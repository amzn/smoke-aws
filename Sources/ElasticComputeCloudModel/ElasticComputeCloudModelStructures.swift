// Copyright 2018-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License").
// You may not use this file except in compliance with the License.
// A copy of the License is located at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.
//
// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length line_length identifier_name type_name vertical_parameter_alignment
// -- Generated Code; do not edit --
//
// ElasticComputeCloudModelStructures.swift
// ElasticComputeCloudModel
//

import Foundation

public struct AcceptReservedInstancesExchangeQuoteRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var reservedInstanceIds: ReservedInstanceIdSet
    public var targetConfigurations: TargetConfigurationRequestSet?

    public init(dryRun: Boolean? = nil,
                reservedInstanceIds: ReservedInstanceIdSet,
                targetConfigurations: TargetConfigurationRequestSet? = nil) {
        self.dryRun = dryRun
        self.reservedInstanceIds = reservedInstanceIds
        self.targetConfigurations = targetConfigurations
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case reservedInstanceIds = "ReservedInstanceId"
        case targetConfigurations = "TargetConfiguration"
    }

    public func validate() throws {
    }
}

public struct AcceptReservedInstancesExchangeQuoteResult: Codable, Equatable {
    public var exchangeId: String?

    public init(exchangeId: String? = nil) {
        self.exchangeId = exchangeId
    }

    enum CodingKeys: String, CodingKey {
        case exchangeId
    }

    public func validate() throws {
    }
}

public struct AcceptTransitGatewayMulticastDomainAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetIds: ValueStringList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                subnetIds: ValueStringList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.subnetIds = subnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case subnetIds = "SubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct AcceptTransitGatewayMulticastDomainAssociationsResult: Codable, Equatable {
    public var associations: TransitGatewayMulticastDomainAssociations?

    public init(associations: TransitGatewayMulticastDomainAssociations? = nil) {
        self.associations = associations
    }

    enum CodingKeys: String, CodingKey {
        case associations
    }

    public func validate() throws {
        try associations?.validate()
    }
}

public struct AcceptTransitGatewayPeeringAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct AcceptTransitGatewayPeeringAttachmentResult: Codable, Equatable {
    public var transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment?

    public init(transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment? = nil) {
        self.transitGatewayPeeringAttachment = transitGatewayPeeringAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPeeringAttachment
    }

    public func validate() throws {
        try transitGatewayPeeringAttachment?.validate()
    }
}

public struct AcceptTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct AcceptTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct AcceptVpcEndpointConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var serviceId: VpcEndpointServiceId
    public var vpcEndpointIds: VpcEndpointIdList

    public init(dryRun: Boolean? = nil,
                serviceId: VpcEndpointServiceId,
                vpcEndpointIds: VpcEndpointIdList) {
        self.dryRun = dryRun
        self.serviceId = serviceId
        self.vpcEndpointIds = vpcEndpointIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case serviceId = "ServiceId"
        case vpcEndpointIds = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct AcceptVpcEndpointConnectionsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct AcceptVpcPeeringConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId?

    public init(dryRun: Boolean? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId? = nil) {
        self.dryRun = dryRun
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct AcceptVpcPeeringConnectionResult: Codable, Equatable {
    public var vpcPeeringConnection: VpcPeeringConnection?

    public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
        self.vpcPeeringConnection = vpcPeeringConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpcPeeringConnection
    }

    public func validate() throws {
        try vpcPeeringConnection?.validate()
    }
}

public struct AccountAttribute: Codable, Equatable {
    public var attributeName: String?
    public var attributeValues: AccountAttributeValueList?

    public init(attributeName: String? = nil,
                attributeValues: AccountAttributeValueList? = nil) {
        self.attributeName = attributeName
        self.attributeValues = attributeValues
    }

    enum CodingKeys: String, CodingKey {
        case attributeName
        case attributeValues = "attributeValueSet"
    }

    public func validate() throws {
    }
}

public struct AccountAttributeValue: Codable, Equatable {
    public var attributeValue: String?

    public init(attributeValue: String? = nil) {
        self.attributeValue = attributeValue
    }

    enum CodingKeys: String, CodingKey {
        case attributeValue
    }

    public func validate() throws {
    }
}

public struct ActiveInstance: Codable, Equatable {
    public var instanceHealth: InstanceHealthStatus?
    public var instanceId: String?
    public var instanceType: String?
    public var spotInstanceRequestId: String?

    public init(instanceHealth: InstanceHealthStatus? = nil,
                instanceId: String? = nil,
                instanceType: String? = nil,
                spotInstanceRequestId: String? = nil) {
        self.instanceHealth = instanceHealth
        self.instanceId = instanceId
        self.instanceType = instanceType
        self.spotInstanceRequestId = spotInstanceRequestId
    }

    enum CodingKeys: String, CodingKey {
        case instanceHealth
        case instanceId
        case instanceType
        case spotInstanceRequestId
    }

    public func validate() throws {
    }
}

public struct AddPrefixListEntry: Codable, Equatable {
    public var cidr: String
    public var description: String?

    public init(cidr: String,
                description: String? = nil) {
        self.cidr = cidr
        self.description = description
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case description = "Description"
    }

    public func validate() throws {
    }
}

public struct Address: Codable, Equatable {
    public var allocationId: String?
    public var associationId: String?
    public var carrierIp: String?
    public var customerOwnedIp: String?
    public var customerOwnedIpv4Pool: String?
    public var domain: DomainType?
    public var instanceId: String?
    public var networkBorderGroup: String?
    public var networkInterfaceId: String?
    public var networkInterfaceOwnerId: String?
    public var privateIpAddress: String?
    public var publicIp: String?
    public var publicIpv4Pool: String?
    public var tags: TagList?

    public init(allocationId: String? = nil,
                associationId: String? = nil,
                carrierIp: String? = nil,
                customerOwnedIp: String? = nil,
                customerOwnedIpv4Pool: String? = nil,
                domain: DomainType? = nil,
                instanceId: String? = nil,
                networkBorderGroup: String? = nil,
                networkInterfaceId: String? = nil,
                networkInterfaceOwnerId: String? = nil,
                privateIpAddress: String? = nil,
                publicIp: String? = nil,
                publicIpv4Pool: String? = nil,
                tags: TagList? = nil) {
        self.allocationId = allocationId
        self.associationId = associationId
        self.carrierIp = carrierIp
        self.customerOwnedIp = customerOwnedIp
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.domain = domain
        self.instanceId = instanceId
        self.networkBorderGroup = networkBorderGroup
        self.networkInterfaceId = networkInterfaceId
        self.networkInterfaceOwnerId = networkInterfaceOwnerId
        self.privateIpAddress = privateIpAddress
        self.publicIp = publicIp
        self.publicIpv4Pool = publicIpv4Pool
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case associationId
        case carrierIp
        case customerOwnedIp
        case customerOwnedIpv4Pool
        case domain
        case instanceId
        case networkBorderGroup
        case networkInterfaceId
        case networkInterfaceOwnerId
        case privateIpAddress
        case publicIp
        case publicIpv4Pool
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct AdvertiseByoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?

    public init(cidr: String,
                dryRun: Boolean? = nil) {
        self.cidr = cidr
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct AdvertiseByoipCidrResult: Codable, Equatable {
    public var byoipCidr: ByoipCidr?

    public init(byoipCidr: ByoipCidr? = nil) {
        self.byoipCidr = byoipCidr
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidr
    }

    public func validate() throws {
        try byoipCidr?.validate()
    }
}

public struct AllocateAddressRequest: Codable, Equatable {
    public var address: PublicIpAddress?
    public var customerOwnedIpv4Pool: String?
    public var domain: DomainType?
    public var dryRun: Boolean?
    public var networkBorderGroup: String?
    public var publicIpv4Pool: Ipv4PoolEc2Id?

    public init(address: PublicIpAddress? = nil,
                customerOwnedIpv4Pool: String? = nil,
                domain: DomainType? = nil,
                dryRun: Boolean? = nil,
                networkBorderGroup: String? = nil,
                publicIpv4Pool: Ipv4PoolEc2Id? = nil) {
        self.address = address
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.domain = domain
        self.dryRun = dryRun
        self.networkBorderGroup = networkBorderGroup
        self.publicIpv4Pool = publicIpv4Pool
    }

    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case domain = "Domain"
        case dryRun
        case networkBorderGroup = "NetworkBorderGroup"
        case publicIpv4Pool = "PublicIpv4Pool"
    }

    public func validate() throws {
    }
}

public struct AllocateAddressResult: Codable, Equatable {
    public var allocationId: String?
    public var carrierIp: String?
    public var customerOwnedIp: String?
    public var customerOwnedIpv4Pool: String?
    public var domain: DomainType?
    public var networkBorderGroup: String?
    public var publicIp: String?
    public var publicIpv4Pool: String?

    public init(allocationId: String? = nil,
                carrierIp: String? = nil,
                customerOwnedIp: String? = nil,
                customerOwnedIpv4Pool: String? = nil,
                domain: DomainType? = nil,
                networkBorderGroup: String? = nil,
                publicIp: String? = nil,
                publicIpv4Pool: String? = nil) {
        self.allocationId = allocationId
        self.carrierIp = carrierIp
        self.customerOwnedIp = customerOwnedIp
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.domain = domain
        self.networkBorderGroup = networkBorderGroup
        self.publicIp = publicIp
        self.publicIpv4Pool = publicIpv4Pool
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case carrierIp
        case customerOwnedIp
        case customerOwnedIpv4Pool
        case domain
        case networkBorderGroup
        case publicIp
        case publicIpv4Pool
    }

    public func validate() throws {
    }
}

public struct AllocateHostsRequest: Codable, Equatable {
    public var autoPlacement: AutoPlacement?
    public var availabilityZone: String
    public var clientToken: String?
    public var hostRecovery: HostRecovery?
    public var instanceFamily: String?
    public var instanceType: String?
    public var quantity: Integer
    public var tagSpecifications: TagSpecificationList?

    public init(autoPlacement: AutoPlacement? = nil,
                availabilityZone: String,
                clientToken: String? = nil,
                hostRecovery: HostRecovery? = nil,
                instanceFamily: String? = nil,
                instanceType: String? = nil,
                quantity: Integer,
                tagSpecifications: TagSpecificationList? = nil) {
        self.autoPlacement = autoPlacement
        self.availabilityZone = availabilityZone
        self.clientToken = clientToken
        self.hostRecovery = hostRecovery
        self.instanceFamily = instanceFamily
        self.instanceType = instanceType
        self.quantity = quantity
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case autoPlacement
        case availabilityZone
        case clientToken
        case hostRecovery = "HostRecovery"
        case instanceFamily = "InstanceFamily"
        case instanceType
        case quantity
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct AllocateHostsResult: Codable, Equatable {
    public var hostIds: ResponseHostIdList?

    public init(hostIds: ResponseHostIdList? = nil) {
        self.hostIds = hostIds
    }

    enum CodingKeys: String, CodingKey {
        case hostIds = "hostIdSet"
    }

    public func validate() throws {
    }
}

public struct AllowedPrincipal: Codable, Equatable {
    public var principal: String?
    public var principalType: PrincipalType?

    public init(principal: String? = nil,
                principalType: PrincipalType? = nil) {
        self.principal = principal
        self.principalType = principalType
    }

    enum CodingKeys: String, CodingKey {
        case principal
        case principalType
    }

    public func validate() throws {
    }
}

public struct AlternatePathHint: Codable, Equatable {
    public var componentArn: String?
    public var componentId: String?

    public init(componentArn: String? = nil,
                componentId: String? = nil) {
        self.componentArn = componentArn
        self.componentId = componentId
    }

    enum CodingKeys: String, CodingKey {
        case componentArn
        case componentId
    }

    public func validate() throws {
    }
}

public struct AnalysisAclRule: Codable, Equatable {
    public var cidr: String?
    public var egress: Boolean?
    public var portRange: PortRange?
    public var `protocol`: String?
    public var ruleAction: String?
    public var ruleNumber: Integer?

    public init(cidr: String? = nil,
                egress: Boolean? = nil,
                portRange: PortRange? = nil,
                `protocol`: String? = nil,
                ruleAction: String? = nil,
                ruleNumber: Integer? = nil) {
        self.cidr = cidr
        self.egress = egress
        self.portRange = portRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case egress
        case portRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
    }

    public func validate() throws {
        try portRange?.validate()
    }
}

public struct AnalysisComponent: Codable, Equatable {
    public var arn: String?
    public var id: String?

    public init(arn: String? = nil,
                id: String? = nil) {
        self.arn = arn
        self.id = id
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case id
    }

    public func validate() throws {
    }
}

public struct AnalysisLoadBalancerListener: Codable, Equatable {
    public var instancePort: Port?
    public var loadBalancerPort: Port?

    public init(instancePort: Port? = nil,
                loadBalancerPort: Port? = nil) {
        self.instancePort = instancePort
        self.loadBalancerPort = loadBalancerPort
    }

    enum CodingKeys: String, CodingKey {
        case instancePort
        case loadBalancerPort
    }

    public func validate() throws {
        try instancePort?.validateAsPort()
        try loadBalancerPort?.validateAsPort()
    }
}

public struct AnalysisLoadBalancerTarget: Codable, Equatable {
    public var address: IpAddress?
    public var availabilityZone: String?
    public var instance: AnalysisComponent?
    public var port: Port?

    public init(address: IpAddress? = nil,
                availabilityZone: String? = nil,
                instance: AnalysisComponent? = nil,
                port: Port? = nil) {
        self.address = address
        self.availabilityZone = availabilityZone
        self.instance = instance
        self.port = port
    }

    enum CodingKeys: String, CodingKey {
        case address
        case availabilityZone
        case instance
        case port
    }

    public func validate() throws {
        try address?.validateAsIpAddress()
        try instance?.validate()
        try port?.validateAsPort()
    }
}

public struct AnalysisPacketHeader: Codable, Equatable {
    public var destinationAddresses: IpAddressList?
    public var destinationPortRanges: PortRangeList?
    public var `protocol`: String?
    public var sourceAddresses: IpAddressList?
    public var sourcePortRanges: PortRangeList?

    public init(destinationAddresses: IpAddressList? = nil,
                destinationPortRanges: PortRangeList? = nil,
                `protocol`: String? = nil,
                sourceAddresses: IpAddressList? = nil,
                sourcePortRanges: PortRangeList? = nil) {
        self.destinationAddresses = destinationAddresses
        self.destinationPortRanges = destinationPortRanges
        self.`protocol` = `protocol`
        self.sourceAddresses = sourceAddresses
        self.sourcePortRanges = sourcePortRanges
    }

    enum CodingKeys: String, CodingKey {
        case destinationAddresses = "destinationAddressSet"
        case destinationPortRanges = "destinationPortRangeSet"
        case `protocol` = "protocol"
        case sourceAddresses = "sourceAddressSet"
        case sourcePortRanges = "sourcePortRangeSet"
    }

    public func validate() throws {
    }
}

public struct AnalysisRouteTableRoute: Codable, Equatable {
    public var destinationCidr: String?
    public var destinationPrefixListId: String?
    public var egressOnlyInternetGatewayId: String?
    public var gatewayId: String?
    public var instanceId: String?
    public var natGatewayId: String?
    public var networkInterfaceId: String?
    public var origin: String?
    public var transitGatewayId: String?
    public var vpcPeeringConnectionId: String?

    public init(destinationCidr: String? = nil,
                destinationPrefixListId: String? = nil,
                egressOnlyInternetGatewayId: String? = nil,
                gatewayId: String? = nil,
                instanceId: String? = nil,
                natGatewayId: String? = nil,
                networkInterfaceId: String? = nil,
                origin: String? = nil,
                transitGatewayId: String? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.destinationCidr = destinationCidr
        self.destinationPrefixListId = destinationPrefixListId
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.gatewayId = gatewayId
        self.instanceId = instanceId
        self.natGatewayId = natGatewayId
        self.networkInterfaceId = networkInterfaceId
        self.origin = origin
        self.transitGatewayId = transitGatewayId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidr
        case destinationPrefixListId
        case egressOnlyInternetGatewayId
        case gatewayId
        case instanceId
        case natGatewayId
        case networkInterfaceId
        case origin
        case transitGatewayId
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct AnalysisSecurityGroupRule: Codable, Equatable {
    public var cidr: String?
    public var direction: String?
    public var portRange: PortRange?
    public var prefixListId: String?
    public var `protocol`: String?
    public var securityGroupId: String?

    public init(cidr: String? = nil,
                direction: String? = nil,
                portRange: PortRange? = nil,
                prefixListId: String? = nil,
                `protocol`: String? = nil,
                securityGroupId: String? = nil) {
        self.cidr = cidr
        self.direction = direction
        self.portRange = portRange
        self.prefixListId = prefixListId
        self.`protocol` = `protocol`
        self.securityGroupId = securityGroupId
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case direction
        case portRange
        case prefixListId
        case `protocol` = "protocol"
        case securityGroupId
    }

    public func validate() throws {
        try portRange?.validate()
    }
}

public struct ApplySecurityGroupsToClientVpnTargetNetworkRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var securityGroupIds: ClientVpnSecurityGroupIdSet
    public var vpcId: VpcId

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                securityGroupIds: ClientVpnSecurityGroupIdSet,
                vpcId: VpcId) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.securityGroupIds = securityGroupIds
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case securityGroupIds = "SecurityGroupId"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct ApplySecurityGroupsToClientVpnTargetNetworkResult: Codable, Equatable {
    public var securityGroupIds: ClientVpnSecurityGroupIdSet?

    public init(securityGroupIds: ClientVpnSecurityGroupIdSet? = nil) {
        self.securityGroupIds = securityGroupIds
    }

    enum CodingKeys: String, CodingKey {
        case securityGroupIds
    }

    public func validate() throws {
    }
}

public struct AssignIpv6AddressesRequest: Codable, Equatable {
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: Ipv6AddressList?
    public var networkInterfaceId: NetworkInterfaceId

    public init(ipv6AddressCount: Integer? = nil,
                ipv6Addresses: Ipv6AddressList? = nil,
                networkInterfaceId: NetworkInterfaceId) {
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6AddressCount
        case ipv6Addresses
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct AssignIpv6AddressesResult: Codable, Equatable {
    public var assignedIpv6Addresses: Ipv6AddressList?
    public var networkInterfaceId: String?

    public init(assignedIpv6Addresses: Ipv6AddressList? = nil,
                networkInterfaceId: String? = nil) {
        self.assignedIpv6Addresses = assignedIpv6Addresses
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case assignedIpv6Addresses
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct AssignPrivateIpAddressesRequest: Codable, Equatable {
    public var allowReassignment: Boolean?
    public var networkInterfaceId: NetworkInterfaceId
    public var privateIpAddresses: PrivateIpAddressStringList?
    public var secondaryPrivateIpAddressCount: Integer?

    public init(allowReassignment: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId,
                privateIpAddresses: PrivateIpAddressStringList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil) {
        self.allowReassignment = allowReassignment
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
    }

    enum CodingKeys: String, CodingKey {
        case allowReassignment
        case networkInterfaceId
        case privateIpAddresses = "privateIpAddress"
        case secondaryPrivateIpAddressCount
    }

    public func validate() throws {
    }
}

public struct AssignPrivateIpAddressesResult: Codable, Equatable {
    public var assignedPrivateIpAddresses: AssignedPrivateIpAddressList?
    public var networkInterfaceId: String?

    public init(assignedPrivateIpAddresses: AssignedPrivateIpAddressList? = nil,
                networkInterfaceId: String? = nil) {
        self.assignedPrivateIpAddresses = assignedPrivateIpAddresses
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case assignedPrivateIpAddresses = "assignedPrivateIpAddressesSet"
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct AssignedPrivateIpAddress: Codable, Equatable {
    public var privateIpAddress: String?

    public init(privateIpAddress: String? = nil) {
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case privateIpAddress
    }

    public func validate() throws {
    }
}

public struct AssociateAddressRequest: Codable, Equatable {
    public var allocationId: AllocationId?
    public var allowReassociation: Boolean?
    public var dryRun: Boolean?
    public var instanceId: InstanceId?
    public var networkInterfaceId: NetworkInterfaceId?
    public var privateIpAddress: String?
    public var publicIp: String?

    public init(allocationId: AllocationId? = nil,
                allowReassociation: Boolean? = nil,
                dryRun: Boolean? = nil,
                instanceId: InstanceId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                privateIpAddress: String? = nil,
                publicIp: String? = nil) {
        self.allocationId = allocationId
        self.allowReassociation = allowReassociation
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case allowReassociation
        case dryRun
        case instanceId = "InstanceId"
        case networkInterfaceId
        case privateIpAddress
        case publicIp = "PublicIp"
    }

    public func validate() throws {
    }
}

public struct AssociateAddressResult: Codable, Equatable {
    public var associationId: String?

    public init(associationId: String? = nil) {
        self.associationId = associationId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
    }

    public func validate() throws {
    }
}

public struct AssociateClientVpnTargetNetworkRequest: Codable, Equatable {
    public var clientToken: String?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var subnetId: SubnetId

    public init(clientToken: String? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                subnetId: SubnetId) {
        self.clientToken = clientToken
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case subnetId = "SubnetId"
    }

    public func validate() throws {
    }
}

public struct AssociateClientVpnTargetNetworkResult: Codable, Equatable {
    public var associationId: String?
    public var status: AssociationStatus?

    public init(associationId: String? = nil,
                status: AssociationStatus? = nil) {
        self.associationId = associationId
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct AssociateDhcpOptionsRequest: Codable, Equatable {
    public var dhcpOptionsId: DefaultingDhcpOptionsId
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(dhcpOptionsId: DefaultingDhcpOptionsId,
                dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.dhcpOptionsId = dhcpOptionsId
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptionsId = "DhcpOptionsId"
        case dryRun
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct AssociateEnclaveCertificateIamRoleRequest: Codable, Equatable {
    public var certificateArn: ResourceArn?
    public var dryRun: Boolean?
    public var roleArn: ResourceArn?

    public init(certificateArn: ResourceArn? = nil,
                dryRun: Boolean? = nil,
                roleArn: ResourceArn? = nil) {
        self.certificateArn = certificateArn
        self.dryRun = dryRun
        self.roleArn = roleArn
    }

    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case dryRun = "DryRun"
        case roleArn = "RoleArn"
    }

    public func validate() throws {
        try certificateArn?.validateAsResourceArn()
        try roleArn?.validateAsResourceArn()
    }
}

public struct AssociateEnclaveCertificateIamRoleResult: Codable, Equatable {
    public var certificateS3BucketName: String?
    public var certificateS3ObjectKey: String?
    public var encryptionKmsKeyId: String?

    public init(certificateS3BucketName: String? = nil,
                certificateS3ObjectKey: String? = nil,
                encryptionKmsKeyId: String? = nil) {
        self.certificateS3BucketName = certificateS3BucketName
        self.certificateS3ObjectKey = certificateS3ObjectKey
        self.encryptionKmsKeyId = encryptionKmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case certificateS3BucketName
        case certificateS3ObjectKey
        case encryptionKmsKeyId
    }

    public func validate() throws {
    }
}

public struct AssociateIamInstanceProfileRequest: Codable, Equatable {
    public var iamInstanceProfile: IamInstanceProfileSpecification
    public var instanceId: InstanceId

    public init(iamInstanceProfile: IamInstanceProfileSpecification,
                instanceId: InstanceId) {
        self.iamInstanceProfile = iamInstanceProfile
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfile = "IamInstanceProfile"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
        try iamInstanceProfile.validate()
    }
}

public struct AssociateIamInstanceProfileResult: Codable, Equatable {
    public var iamInstanceProfileAssociation: IamInstanceProfileAssociation?

    public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
        self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfileAssociation
    }

    public func validate() throws {
        try iamInstanceProfileAssociation?.validate()
    }
}

public struct AssociateRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var gatewayId: RouteGatewayId?
    public var routeTableId: RouteTableId
    public var subnetId: SubnetId?

    public init(dryRun: Boolean? = nil,
                gatewayId: RouteGatewayId? = nil,
                routeTableId: RouteTableId,
                subnetId: SubnetId? = nil) {
        self.dryRun = dryRun
        self.gatewayId = gatewayId
        self.routeTableId = routeTableId
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case gatewayId = "GatewayId"
        case routeTableId
        case subnetId
    }

    public func validate() throws {
    }
}

public struct AssociateRouteTableResult: Codable, Equatable {
    public var associationId: String?
    public var associationState: RouteTableAssociationState?

    public init(associationId: String? = nil,
                associationState: RouteTableAssociationState? = nil) {
        self.associationId = associationId
        self.associationState = associationState
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case associationState
    }

    public func validate() throws {
        try associationState?.validate()
    }
}

public struct AssociateSubnetCidrBlockRequest: Codable, Equatable {
    public var ipv6CidrBlock: String
    public var subnetId: SubnetId

    public init(ipv6CidrBlock: String,
                subnetId: SubnetId) {
        self.ipv6CidrBlock = ipv6CidrBlock
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrBlock
        case subnetId
    }

    public func validate() throws {
    }
}

public struct AssociateSubnetCidrBlockResult: Codable, Equatable {
    public var ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation?
    public var subnetId: String?

    public init(ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil,
                subnetId: String? = nil) {
        self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrBlockAssociation
        case subnetId
    }

    public func validate() throws {
        try ipv6CidrBlockAssociation?.validate()
    }
}

public struct AssociateTransitGatewayMulticastDomainRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetIds: TransitGatewaySubnetIdList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                subnetIds: TransitGatewaySubnetIdList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.subnetIds = subnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case subnetIds = "SubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct AssociateTransitGatewayMulticastDomainResult: Codable, Equatable {
    public var associations: TransitGatewayMulticastDomainAssociations?

    public init(associations: TransitGatewayMulticastDomainAssociations? = nil) {
        self.associations = associations
    }

    enum CodingKeys: String, CodingKey {
        case associations
    }

    public func validate() throws {
        try associations?.validate()
    }
}

public struct AssociateTransitGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct AssociateTransitGatewayRouteTableResult: Codable, Equatable {
    public var association: TransitGatewayAssociation?

    public init(association: TransitGatewayAssociation? = nil) {
        self.association = association
    }

    enum CodingKeys: String, CodingKey {
        case association
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct AssociateVpcCidrBlockRequest: Codable, Equatable {
    public var amazonProvidedIpv6CidrBlock: Boolean?
    public var cidrBlock: String?
    public var ipv6CidrBlock: String?
    public var ipv6CidrBlockNetworkBorderGroup: String?
    public var ipv6Pool: Ipv6PoolEc2Id?
    public var vpcId: VpcId

    public init(amazonProvidedIpv6CidrBlock: Boolean? = nil,
                cidrBlock: String? = nil,
                ipv6CidrBlock: String? = nil,
                ipv6CidrBlockNetworkBorderGroup: String? = nil,
                ipv6Pool: Ipv6PoolEc2Id? = nil,
                vpcId: VpcId) {
        self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
        self.cidrBlock = cidrBlock
        self.ipv6CidrBlock = ipv6CidrBlock
        self.ipv6CidrBlockNetworkBorderGroup = ipv6CidrBlockNetworkBorderGroup
        self.ipv6Pool = ipv6Pool
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case amazonProvidedIpv6CidrBlock
        case cidrBlock = "CidrBlock"
        case ipv6CidrBlock = "Ipv6CidrBlock"
        case ipv6CidrBlockNetworkBorderGroup = "Ipv6CidrBlockNetworkBorderGroup"
        case ipv6Pool = "Ipv6Pool"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct AssociateVpcCidrBlockResult: Codable, Equatable {
    public var cidrBlockAssociation: VpcCidrBlockAssociation?
    public var ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation?
    public var vpcId: String?

    public init(cidrBlockAssociation: VpcCidrBlockAssociation? = nil,
                ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil,
                vpcId: String? = nil) {
        self.cidrBlockAssociation = cidrBlockAssociation
        self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlockAssociation
        case ipv6CidrBlockAssociation
        case vpcId
    }

    public func validate() throws {
        try cidrBlockAssociation?.validate()
        try ipv6CidrBlockAssociation?.validate()
    }
}

public struct AssociatedRole: Codable, Equatable {
    public var associatedRoleArn: ResourceArn?
    public var certificateS3BucketName: String?
    public var certificateS3ObjectKey: String?
    public var encryptionKmsKeyId: String?

    public init(associatedRoleArn: ResourceArn? = nil,
                certificateS3BucketName: String? = nil,
                certificateS3ObjectKey: String? = nil,
                encryptionKmsKeyId: String? = nil) {
        self.associatedRoleArn = associatedRoleArn
        self.certificateS3BucketName = certificateS3BucketName
        self.certificateS3ObjectKey = certificateS3ObjectKey
        self.encryptionKmsKeyId = encryptionKmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case associatedRoleArn
        case certificateS3BucketName
        case certificateS3ObjectKey
        case encryptionKmsKeyId
    }

    public func validate() throws {
        try associatedRoleArn?.validateAsResourceArn()
    }
}

public struct AssociatedTargetNetwork: Codable, Equatable {
    public var networkId: String?
    public var networkType: AssociatedNetworkType?

    public init(networkId: String? = nil,
                networkType: AssociatedNetworkType? = nil) {
        self.networkId = networkId
        self.networkType = networkType
    }

    enum CodingKeys: String, CodingKey {
        case networkId
        case networkType
    }

    public func validate() throws {
    }
}

public struct AssociationStatus: Codable, Equatable {
    public var code: AssociationStatusCode?
    public var message: String?

    public init(code: AssociationStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct AttachClassicLinkVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groups: GroupIdStringList
    public var instanceId: InstanceId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                groups: GroupIdStringList,
                instanceId: InstanceId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.groups = groups
        self.instanceId = instanceId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case groups = "SecurityGroupId"
        case instanceId
        case vpcId
    }

    public func validate() throws {
    }
}

public struct AttachClassicLinkVpcResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct AttachInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var internetGatewayId: InternetGatewayId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                internetGatewayId: InternetGatewayId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.internetGatewayId = internetGatewayId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case internetGatewayId
        case vpcId
    }

    public func validate() throws {
    }
}

public struct AttachNetworkInterfaceRequest: Codable, Equatable {
    public var deviceIndex: Integer
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var networkCardIndex: Integer?
    public var networkInterfaceId: NetworkInterfaceId

    public init(deviceIndex: Integer,
                dryRun: Boolean? = nil,
                instanceId: InstanceId,
                networkCardIndex: Integer? = nil,
                networkInterfaceId: NetworkInterfaceId) {
        self.deviceIndex = deviceIndex
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.networkCardIndex = networkCardIndex
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case deviceIndex
        case dryRun
        case instanceId
        case networkCardIndex = "NetworkCardIndex"
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct AttachNetworkInterfaceResult: Codable, Equatable {
    public var attachmentId: String?
    public var networkCardIndex: Integer?

    public init(attachmentId: String? = nil,
                networkCardIndex: Integer? = nil) {
        self.attachmentId = attachmentId
        self.networkCardIndex = networkCardIndex
    }

    enum CodingKeys: String, CodingKey {
        case attachmentId
        case networkCardIndex
    }

    public func validate() throws {
    }
}

public struct AttachVolumeRequest: Codable, Equatable {
    public var device: String
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var volumeId: VolumeId

    public init(device: String,
                dryRun: Boolean? = nil,
                instanceId: InstanceId,
                volumeId: VolumeId) {
        self.device = device
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case device = "Device"
        case dryRun
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct AttachVpnGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId
    public var vpnGatewayId: VpnGatewayId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId,
                vpnGatewayId: VpnGatewayId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId = "VpcId"
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct AttachVpnGatewayResult: Codable, Equatable {
    public var vpcAttachment: VpcAttachment?

    public init(vpcAttachment: VpcAttachment? = nil) {
        self.vpcAttachment = vpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case vpcAttachment = "attachment"
    }

    public func validate() throws {
        try vpcAttachment?.validate()
    }
}

public struct AttributeBooleanValue: Codable, Equatable {
    public var value: Boolean?

    public init(value: Boolean? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct AttributeValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct AuthorizationRule: Codable, Equatable {
    public var accessAll: Boolean?
    public var clientVpnEndpointId: String?
    public var description: String?
    public var destinationCidr: String?
    public var groupId: String?
    public var status: ClientVpnAuthorizationRuleStatus?

    public init(accessAll: Boolean? = nil,
                clientVpnEndpointId: String? = nil,
                description: String? = nil,
                destinationCidr: String? = nil,
                groupId: String? = nil,
                status: ClientVpnAuthorizationRuleStatus? = nil) {
        self.accessAll = accessAll
        self.clientVpnEndpointId = clientVpnEndpointId
        self.description = description
        self.destinationCidr = destinationCidr
        self.groupId = groupId
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case accessAll
        case clientVpnEndpointId
        case description
        case destinationCidr
        case groupId
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct AuthorizeClientVpnIngressRequest: Codable, Equatable {
    public var accessGroupId: String?
    public var authorizeAllGroups: Boolean?
    public var clientToken: String?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var description: String?
    public var dryRun: Boolean?
    public var targetNetworkCidr: String

    public init(accessGroupId: String? = nil,
                authorizeAllGroups: Boolean? = nil,
                clientToken: String? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                description: String? = nil,
                dryRun: Boolean? = nil,
                targetNetworkCidr: String) {
        self.accessGroupId = accessGroupId
        self.authorizeAllGroups = authorizeAllGroups
        self.clientToken = clientToken
        self.clientVpnEndpointId = clientVpnEndpointId
        self.description = description
        self.dryRun = dryRun
        self.targetNetworkCidr = targetNetworkCidr
    }

    enum CodingKeys: String, CodingKey {
        case accessGroupId = "AccessGroupId"
        case authorizeAllGroups = "AuthorizeAllGroups"
        case clientToken = "ClientToken"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case description = "Description"
        case dryRun = "DryRun"
        case targetNetworkCidr = "TargetNetworkCidr"
    }

    public func validate() throws {
    }
}

public struct AuthorizeClientVpnIngressResult: Codable, Equatable {
    public var status: ClientVpnAuthorizationRuleStatus?

    public init(status: ClientVpnAuthorizationRuleStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct AuthorizeSecurityGroupEgressRequest: Codable, Equatable {
    public var cidrIp: String?
    public var dryRun: Boolean?
    public var fromPort: Integer?
    public var groupId: SecurityGroupId
    public var ipPermissions: IpPermissionList?
    public var ipProtocol: String?
    public var sourceSecurityGroupName: String?
    public var sourceSecurityGroupOwnerId: String?
    public var toPort: Integer?

    public init(cidrIp: String? = nil,
                dryRun: Boolean? = nil,
                fromPort: Integer? = nil,
                groupId: SecurityGroupId,
                ipPermissions: IpPermissionList? = nil,
                ipProtocol: String? = nil,
                sourceSecurityGroupName: String? = nil,
                sourceSecurityGroupOwnerId: String? = nil,
                toPort: Integer? = nil) {
        self.cidrIp = cidrIp
        self.dryRun = dryRun
        self.fromPort = fromPort
        self.groupId = groupId
        self.ipPermissions = ipPermissions
        self.ipProtocol = ipProtocol
        self.sourceSecurityGroupName = sourceSecurityGroupName
        self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp
        case dryRun
        case fromPort
        case groupId
        case ipPermissions
        case ipProtocol
        case sourceSecurityGroupName
        case sourceSecurityGroupOwnerId
        case toPort
    }

    public func validate() throws {
    }
}

public struct AuthorizeSecurityGroupIngressRequest: Codable, Equatable {
    public var cidrIp: String?
    public var dryRun: Boolean?
    public var fromPort: Integer?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?
    public var ipPermissions: IpPermissionList?
    public var ipProtocol: String?
    public var sourceSecurityGroupName: String?
    public var sourceSecurityGroupOwnerId: String?
    public var toPort: Integer?

    public init(cidrIp: String? = nil,
                dryRun: Boolean? = nil,
                fromPort: Integer? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil,
                ipPermissions: IpPermissionList? = nil,
                ipProtocol: String? = nil,
                sourceSecurityGroupName: String? = nil,
                sourceSecurityGroupOwnerId: String? = nil,
                toPort: Integer? = nil) {
        self.cidrIp = cidrIp
        self.dryRun = dryRun
        self.fromPort = fromPort
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
        self.ipProtocol = ipProtocol
        self.sourceSecurityGroupName = sourceSecurityGroupName
        self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp = "CidrIp"
        case dryRun
        case fromPort = "FromPort"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
        case ipProtocol = "IpProtocol"
        case sourceSecurityGroupName = "SourceSecurityGroupName"
        case sourceSecurityGroupOwnerId = "SourceSecurityGroupOwnerId"
        case toPort = "ToPort"
    }

    public func validate() throws {
    }
}

public struct AvailabilityZone: Codable, Equatable {
    public var groupName: String?
    public var messages: AvailabilityZoneMessageList?
    public var networkBorderGroup: String?
    public var optInStatus: AvailabilityZoneOptInStatus?
    public var parentZoneId: String?
    public var parentZoneName: String?
    public var regionName: String?
    public var state: AvailabilityZoneState?
    public var zoneId: String?
    public var zoneName: String?
    public var zoneType: String?

    public init(groupName: String? = nil,
                messages: AvailabilityZoneMessageList? = nil,
                networkBorderGroup: String? = nil,
                optInStatus: AvailabilityZoneOptInStatus? = nil,
                parentZoneId: String? = nil,
                parentZoneName: String? = nil,
                regionName: String? = nil,
                state: AvailabilityZoneState? = nil,
                zoneId: String? = nil,
                zoneName: String? = nil,
                zoneType: String? = nil) {
        self.groupName = groupName
        self.messages = messages
        self.networkBorderGroup = networkBorderGroup
        self.optInStatus = optInStatus
        self.parentZoneId = parentZoneId
        self.parentZoneName = parentZoneName
        self.regionName = regionName
        self.state = state
        self.zoneId = zoneId
        self.zoneName = zoneName
        self.zoneType = zoneType
    }

    enum CodingKeys: String, CodingKey {
        case groupName
        case messages = "messageSet"
        case networkBorderGroup
        case optInStatus
        case parentZoneId
        case parentZoneName
        case regionName
        case state = "zoneState"
        case zoneId
        case zoneName
        case zoneType
    }

    public func validate() throws {
    }
}

public struct AvailabilityZoneMessage: Codable, Equatable {
    public var message: String?

    public init(message: String? = nil) {
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case message
    }

    public func validate() throws {
    }
}

public struct AvailableCapacity: Codable, Equatable {
    public var availableInstanceCapacity: AvailableInstanceCapacityList?
    public var availableVCpus: Integer?

    public init(availableInstanceCapacity: AvailableInstanceCapacityList? = nil,
                availableVCpus: Integer? = nil) {
        self.availableInstanceCapacity = availableInstanceCapacity
        self.availableVCpus = availableVCpus
    }

    enum CodingKeys: String, CodingKey {
        case availableInstanceCapacity
        case availableVCpus
    }

    public func validate() throws {
    }
}

public struct BlobAttributeValue: Codable, Equatable {
    public var value: Blob?

    public init(value: Blob? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct BlockDeviceMapping: Codable, Equatable {
    public var deviceName: String?
    public var ebs: EbsBlockDevice?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: EbsBlockDevice? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct BundleInstanceRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var storage: Storage

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                storage: Storage) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.storage = storage
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId = "InstanceId"
        case storage = "Storage"
    }

    public func validate() throws {
        try storage.validate()
    }
}

public struct BundleInstanceResult: Codable, Equatable {
    public var bundleTask: BundleTask?

    public init(bundleTask: BundleTask? = nil) {
        self.bundleTask = bundleTask
    }

    enum CodingKeys: String, CodingKey {
        case bundleTask = "bundleInstanceTask"
    }

    public func validate() throws {
        try bundleTask?.validate()
    }
}

public struct BundleTask: Codable, Equatable {
    public var bundleId: String?
    public var bundleTaskError: BundleTaskError?
    public var instanceId: String?
    public var progress: String?
    public var startTime: DateTime?
    public var state: BundleTaskState?
    public var storage: Storage?
    public var updateTime: DateTime?

    public init(bundleId: String? = nil,
                bundleTaskError: BundleTaskError? = nil,
                instanceId: String? = nil,
                progress: String? = nil,
                startTime: DateTime? = nil,
                state: BundleTaskState? = nil,
                storage: Storage? = nil,
                updateTime: DateTime? = nil) {
        self.bundleId = bundleId
        self.bundleTaskError = bundleTaskError
        self.instanceId = instanceId
        self.progress = progress
        self.startTime = startTime
        self.state = state
        self.storage = storage
        self.updateTime = updateTime
    }

    enum CodingKeys: String, CodingKey {
        case bundleId
        case bundleTaskError = "error"
        case instanceId
        case progress
        case startTime
        case state
        case storage
        case updateTime
    }

    public func validate() throws {
        try bundleTaskError?.validate()
        try storage?.validate()
    }
}

public struct BundleTaskError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ByoipCidr: Codable, Equatable {
    public var cidr: String?
    public var description: String?
    public var state: ByoipCidrState?
    public var statusMessage: String?

    public init(cidr: String? = nil,
                description: String? = nil,
                state: ByoipCidrState? = nil,
                statusMessage: String? = nil) {
        self.cidr = cidr
        self.description = description
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case description
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct CancelBundleTaskRequest: Codable, Equatable {
    public var bundleId: BundleId
    public var dryRun: Boolean?

    public init(bundleId: BundleId,
                dryRun: Boolean? = nil) {
        self.bundleId = bundleId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct CancelBundleTaskResult: Codable, Equatable {
    public var bundleTask: BundleTask?

    public init(bundleTask: BundleTask? = nil) {
        self.bundleTask = bundleTask
    }

    enum CodingKeys: String, CodingKey {
        case bundleTask = "bundleInstanceTask"
    }

    public func validate() throws {
        try bundleTask?.validate()
    }
}

public struct CancelCapacityReservationRequest: Codable, Equatable {
    public var capacityReservationId: CapacityReservationId
    public var dryRun: Boolean?

    public init(capacityReservationId: CapacityReservationId,
                dryRun: Boolean? = nil) {
        self.capacityReservationId = capacityReservationId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct CancelCapacityReservationResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct CancelConversionRequest: Codable, Equatable {
    public var conversionTaskId: ConversionTaskId
    public var dryRun: Boolean?
    public var reasonMessage: String?

    public init(conversionTaskId: ConversionTaskId,
                dryRun: Boolean? = nil,
                reasonMessage: String? = nil) {
        self.conversionTaskId = conversionTaskId
        self.dryRun = dryRun
        self.reasonMessage = reasonMessage
    }

    enum CodingKeys: String, CodingKey {
        case conversionTaskId
        case dryRun
        case reasonMessage
    }

    public func validate() throws {
    }
}

public struct CancelExportTaskRequest: Codable, Equatable {
    public var exportTaskId: ExportVmTaskId

    public init(exportTaskId: ExportVmTaskId) {
        self.exportTaskId = exportTaskId
    }

    enum CodingKeys: String, CodingKey {
        case exportTaskId
    }

    public func validate() throws {
    }
}

public struct CancelImportTaskRequest: Codable, Equatable {
    public var cancelReason: String?
    public var dryRun: Boolean?
    public var importTaskId: ImportTaskId?

    public init(cancelReason: String? = nil,
                dryRun: Boolean? = nil,
                importTaskId: ImportTaskId? = nil) {
        self.cancelReason = cancelReason
        self.dryRun = dryRun
        self.importTaskId = importTaskId
    }

    enum CodingKeys: String, CodingKey {
        case cancelReason = "CancelReason"
        case dryRun = "DryRun"
        case importTaskId = "ImportTaskId"
    }

    public func validate() throws {
    }
}

public struct CancelImportTaskResult: Codable, Equatable {
    public var importTaskId: String?
    public var previousState: String?
    public var state: String?

    public init(importTaskId: String? = nil,
                previousState: String? = nil,
                state: String? = nil) {
        self.importTaskId = importTaskId
        self.previousState = previousState
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case importTaskId
        case previousState
        case state
    }

    public func validate() throws {
    }
}

public struct CancelReservedInstancesListingRequest: Codable, Equatable {
    public var reservedInstancesListingId: ReservedInstancesListingId

    public init(reservedInstancesListingId: ReservedInstancesListingId) {
        self.reservedInstancesListingId = reservedInstancesListingId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesListingId
    }

    public func validate() throws {
    }
}

public struct CancelReservedInstancesListingResult: Codable, Equatable {
    public var reservedInstancesListings: ReservedInstancesListingList?

    public init(reservedInstancesListings: ReservedInstancesListingList? = nil) {
        self.reservedInstancesListings = reservedInstancesListings
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesListings = "reservedInstancesListingsSet"
    }

    public func validate() throws {
    }
}

public struct CancelSpotFleetRequestsError: Codable, Equatable {
    public var code: CancelBatchErrorCode?
    public var message: String?

    public init(code: CancelBatchErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct CancelSpotFleetRequestsErrorItem: Codable, Equatable {
    public var error: CancelSpotFleetRequestsError?
    public var spotFleetRequestId: String?

    public init(error: CancelSpotFleetRequestsError? = nil,
                spotFleetRequestId: String? = nil) {
        self.error = error
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case spotFleetRequestId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct CancelSpotFleetRequestsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var spotFleetRequestIds: SpotFleetRequestIdList
    public var terminateInstances: Boolean

    public init(dryRun: Boolean? = nil,
                spotFleetRequestIds: SpotFleetRequestIdList,
                terminateInstances: Boolean) {
        self.dryRun = dryRun
        self.spotFleetRequestIds = spotFleetRequestIds
        self.terminateInstances = terminateInstances
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case spotFleetRequestIds = "spotFleetRequestId"
        case terminateInstances
    }

    public func validate() throws {
    }
}

public struct CancelSpotFleetRequestsResponse: Codable, Equatable {
    public var successfulFleetRequests: CancelSpotFleetRequestsSuccessSet?
    public var unsuccessfulFleetRequests: CancelSpotFleetRequestsErrorSet?

    public init(successfulFleetRequests: CancelSpotFleetRequestsSuccessSet? = nil,
                unsuccessfulFleetRequests: CancelSpotFleetRequestsErrorSet? = nil) {
        self.successfulFleetRequests = successfulFleetRequests
        self.unsuccessfulFleetRequests = unsuccessfulFleetRequests
    }

    enum CodingKeys: String, CodingKey {
        case successfulFleetRequests = "successfulFleetRequestSet"
        case unsuccessfulFleetRequests = "unsuccessfulFleetRequestSet"
    }

    public func validate() throws {
    }
}

public struct CancelSpotFleetRequestsSuccessItem: Codable, Equatable {
    public var currentSpotFleetRequestState: BatchState?
    public var previousSpotFleetRequestState: BatchState?
    public var spotFleetRequestId: String?

    public init(currentSpotFleetRequestState: BatchState? = nil,
                previousSpotFleetRequestState: BatchState? = nil,
                spotFleetRequestId: String? = nil) {
        self.currentSpotFleetRequestState = currentSpotFleetRequestState
        self.previousSpotFleetRequestState = previousSpotFleetRequestState
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case currentSpotFleetRequestState
        case previousSpotFleetRequestState
        case spotFleetRequestId
    }

    public func validate() throws {
    }
}

public struct CancelSpotInstanceRequestsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var spotInstanceRequestIds: SpotInstanceRequestIdList

    public init(dryRun: Boolean? = nil,
                spotInstanceRequestIds: SpotInstanceRequestIdList) {
        self.dryRun = dryRun
        self.spotInstanceRequestIds = spotInstanceRequestIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case spotInstanceRequestIds = "SpotInstanceRequestId"
    }

    public func validate() throws {
    }
}

public struct CancelSpotInstanceRequestsResult: Codable, Equatable {
    public var cancelledSpotInstanceRequests: CancelledSpotInstanceRequestList?

    public init(cancelledSpotInstanceRequests: CancelledSpotInstanceRequestList? = nil) {
        self.cancelledSpotInstanceRequests = cancelledSpotInstanceRequests
    }

    enum CodingKeys: String, CodingKey {
        case cancelledSpotInstanceRequests = "spotInstanceRequestSet"
    }

    public func validate() throws {
    }
}

public struct CancelledSpotInstanceRequest: Codable, Equatable {
    public var spotInstanceRequestId: String?
    public var state: CancelSpotInstanceRequestState?

    public init(spotInstanceRequestId: String? = nil,
                state: CancelSpotInstanceRequestState? = nil) {
        self.spotInstanceRequestId = spotInstanceRequestId
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case spotInstanceRequestId
        case state
    }

    public func validate() throws {
    }
}

public struct CapacityReservation: Codable, Equatable {
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var availableInstanceCount: Integer?
    public var capacityReservationArn: String?
    public var capacityReservationId: String?
    public var createDate: DateTime?
    public var ebsOptimized: Boolean?
    public var endDate: DateTime?
    public var endDateType: EndDateType?
    public var ephemeralStorage: Boolean?
    public var instanceMatchCriteria: InstanceMatchCriteria?
    public var instancePlatform: CapacityReservationInstancePlatform?
    public var instanceType: String?
    public var ownerId: String?
    public var state: CapacityReservationState?
    public var tags: TagList?
    public var tenancy: CapacityReservationTenancy?
    public var totalInstanceCount: Integer?

    public init(availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                availableInstanceCount: Integer? = nil,
                capacityReservationArn: String? = nil,
                capacityReservationId: String? = nil,
                createDate: DateTime? = nil,
                ebsOptimized: Boolean? = nil,
                endDate: DateTime? = nil,
                endDateType: EndDateType? = nil,
                ephemeralStorage: Boolean? = nil,
                instanceMatchCriteria: InstanceMatchCriteria? = nil,
                instancePlatform: CapacityReservationInstancePlatform? = nil,
                instanceType: String? = nil,
                ownerId: String? = nil,
                state: CapacityReservationState? = nil,
                tags: TagList? = nil,
                tenancy: CapacityReservationTenancy? = nil,
                totalInstanceCount: Integer? = nil) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.availableInstanceCount = availableInstanceCount
        self.capacityReservationArn = capacityReservationArn
        self.capacityReservationId = capacityReservationId
        self.createDate = createDate
        self.ebsOptimized = ebsOptimized
        self.endDate = endDate
        self.endDateType = endDateType
        self.ephemeralStorage = ephemeralStorage
        self.instanceMatchCriteria = instanceMatchCriteria
        self.instancePlatform = instancePlatform
        self.instanceType = instanceType
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.tenancy = tenancy
        self.totalInstanceCount = totalInstanceCount
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case availabilityZoneId
        case availableInstanceCount
        case capacityReservationArn
        case capacityReservationId
        case createDate
        case ebsOptimized
        case endDate
        case endDateType
        case ephemeralStorage
        case instanceMatchCriteria
        case instancePlatform
        case instanceType
        case ownerId
        case state
        case tags = "tagSet"
        case tenancy
        case totalInstanceCount
    }

    public func validate() throws {
    }
}

public struct CapacityReservationGroup: Codable, Equatable {
    public var groupArn: String?
    public var ownerId: String?

    public init(groupArn: String? = nil,
                ownerId: String? = nil) {
        self.groupArn = groupArn
        self.ownerId = ownerId
    }

    enum CodingKeys: String, CodingKey {
        case groupArn
        case ownerId
    }

    public func validate() throws {
    }
}

public struct CapacityReservationOptions: Codable, Equatable {
    public var usageStrategy: FleetCapacityReservationUsageStrategy?

    public init(usageStrategy: FleetCapacityReservationUsageStrategy? = nil) {
        self.usageStrategy = usageStrategy
    }

    enum CodingKeys: String, CodingKey {
        case usageStrategy
    }

    public func validate() throws {
    }
}

public struct CapacityReservationOptionsRequest: Codable, Equatable {
    public var usageStrategy: FleetCapacityReservationUsageStrategy?

    public init(usageStrategy: FleetCapacityReservationUsageStrategy? = nil) {
        self.usageStrategy = usageStrategy
    }

    enum CodingKeys: String, CodingKey {
        case usageStrategy = "UsageStrategy"
    }

    public func validate() throws {
    }
}

public struct CapacityReservationSpecification: Codable, Equatable {
    public var capacityReservationPreference: CapacityReservationPreference?
    public var capacityReservationTarget: CapacityReservationTarget?

    public init(capacityReservationPreference: CapacityReservationPreference? = nil,
                capacityReservationTarget: CapacityReservationTarget? = nil) {
        self.capacityReservationPreference = capacityReservationPreference
        self.capacityReservationTarget = capacityReservationTarget
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationPreference = "CapacityReservationPreference"
        case capacityReservationTarget = "CapacityReservationTarget"
    }

    public func validate() throws {
        try capacityReservationTarget?.validate()
    }
}

public struct CapacityReservationSpecificationResponse: Codable, Equatable {
    public var capacityReservationPreference: CapacityReservationPreference?
    public var capacityReservationTarget: CapacityReservationTargetResponse?

    public init(capacityReservationPreference: CapacityReservationPreference? = nil,
                capacityReservationTarget: CapacityReservationTargetResponse? = nil) {
        self.capacityReservationPreference = capacityReservationPreference
        self.capacityReservationTarget = capacityReservationTarget
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationPreference
        case capacityReservationTarget
    }

    public func validate() throws {
        try capacityReservationTarget?.validate()
    }
}

public struct CapacityReservationTarget: Codable, Equatable {
    public var capacityReservationId: CapacityReservationId?
    public var capacityReservationResourceGroupArn: String?

    public init(capacityReservationId: CapacityReservationId? = nil,
                capacityReservationResourceGroupArn: String? = nil) {
        self.capacityReservationId = capacityReservationId
        self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case capacityReservationResourceGroupArn = "CapacityReservationResourceGroupArn"
    }

    public func validate() throws {
    }
}

public struct CapacityReservationTargetResponse: Codable, Equatable {
    public var capacityReservationId: String?
    public var capacityReservationResourceGroupArn: String?

    public init(capacityReservationId: String? = nil,
                capacityReservationResourceGroupArn: String? = nil) {
        self.capacityReservationId = capacityReservationId
        self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId
        case capacityReservationResourceGroupArn
    }

    public func validate() throws {
    }
}

public struct CarrierGateway: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId?
    public var ownerId: String?
    public var state: CarrierGatewayState?
    public var tags: TagList?
    public var vpcId: VpcId?

    public init(carrierGatewayId: CarrierGatewayId? = nil,
                ownerId: String? = nil,
                state: CarrierGatewayState? = nil,
                tags: TagList? = nil,
                vpcId: VpcId? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId
        case ownerId
        case state
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct CertificateAuthentication: Codable, Equatable {
    public var clientRootCertificateChain: String?

    public init(clientRootCertificateChain: String? = nil) {
        self.clientRootCertificateChain = clientRootCertificateChain
    }

    enum CodingKeys: String, CodingKey {
        case clientRootCertificateChain
    }

    public func validate() throws {
    }
}

public struct CertificateAuthenticationRequest: Codable, Equatable {
    public var clientRootCertificateChainArn: String?

    public init(clientRootCertificateChainArn: String? = nil) {
        self.clientRootCertificateChainArn = clientRootCertificateChainArn
    }

    enum CodingKeys: String, CodingKey {
        case clientRootCertificateChainArn = "ClientRootCertificateChainArn"
    }

    public func validate() throws {
    }
}

public struct CidrAuthorizationContext: Codable, Equatable {
    public var message: String
    public var signature: String

    public init(message: String,
                signature: String) {
        self.message = message
        self.signature = signature
    }

    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case signature = "Signature"
    }

    public func validate() throws {
    }
}

public struct CidrBlock: Codable, Equatable {
    public var cidrBlock: String?

    public init(cidrBlock: String? = nil) {
        self.cidrBlock = cidrBlock
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
    }

    public func validate() throws {
    }
}

public struct ClassicLinkDnsSupport: Codable, Equatable {
    public var classicLinkDnsSupported: Boolean?
    public var vpcId: String?

    public init(classicLinkDnsSupported: Boolean? = nil,
                vpcId: String? = nil) {
        self.classicLinkDnsSupported = classicLinkDnsSupported
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case classicLinkDnsSupported
        case vpcId
    }

    public func validate() throws {
    }
}

public struct ClassicLinkInstance: Codable, Equatable {
    public var groups: GroupIdentifierList?
    public var instanceId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(groups: GroupIdentifierList? = nil,
                instanceId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.groups = groups
        self.instanceId = instanceId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case groups = "groupSet"
        case instanceId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct ClassicLoadBalancer: Codable, Equatable {
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case name
    }

    public func validate() throws {
    }
}

public struct ClassicLoadBalancersConfig: Codable, Equatable {
    public var classicLoadBalancers: ClassicLoadBalancers?

    public init(classicLoadBalancers: ClassicLoadBalancers? = nil) {
        self.classicLoadBalancers = classicLoadBalancers
    }

    enum CodingKeys: String, CodingKey {
        case classicLoadBalancers
    }

    public func validate() throws {
        try classicLoadBalancers?.validateAsClassicLoadBalancers()
    }
}

public struct ClientCertificateRevocationListStatus: Codable, Equatable {
    public var code: ClientCertificateRevocationListStatusCode?
    public var message: String?

    public init(code: ClientCertificateRevocationListStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientConnectOptions: Codable, Equatable {
    public var enabled: Boolean?
    public var lambdaFunctionArn: String?

    public init(enabled: Boolean? = nil,
                lambdaFunctionArn: String? = nil) {
        self.enabled = enabled
        self.lambdaFunctionArn = lambdaFunctionArn
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case lambdaFunctionArn = "LambdaFunctionArn"
    }

    public func validate() throws {
    }
}

public struct ClientConnectResponseOptions: Codable, Equatable {
    public var enabled: Boolean?
    public var lambdaFunctionArn: String?
    public var status: ClientVpnEndpointAttributeStatus?

    public init(enabled: Boolean? = nil,
                lambdaFunctionArn: String? = nil,
                status: ClientVpnEndpointAttributeStatus? = nil) {
        self.enabled = enabled
        self.lambdaFunctionArn = lambdaFunctionArn
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case enabled
        case lambdaFunctionArn
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct ClientData: Codable, Equatable {
    public var comment: String?
    public var uploadEnd: DateTime?
    public var uploadSize: Double?
    public var uploadStart: DateTime?

    public init(comment: String? = nil,
                uploadEnd: DateTime? = nil,
                uploadSize: Double? = nil,
                uploadStart: DateTime? = nil) {
        self.comment = comment
        self.uploadEnd = uploadEnd
        self.uploadSize = uploadSize
        self.uploadStart = uploadStart
    }

    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case uploadEnd = "UploadEnd"
        case uploadSize = "UploadSize"
        case uploadStart = "UploadStart"
    }

    public func validate() throws {
    }
}

public struct ClientVpnAuthentication: Codable, Equatable {
    public var activeDirectory: DirectoryServiceAuthentication?
    public var federatedAuthentication: FederatedAuthentication?
    public var mutualAuthentication: CertificateAuthentication?
    public var type: ClientVpnAuthenticationType?

    public init(activeDirectory: DirectoryServiceAuthentication? = nil,
                federatedAuthentication: FederatedAuthentication? = nil,
                mutualAuthentication: CertificateAuthentication? = nil,
                type: ClientVpnAuthenticationType? = nil) {
        self.activeDirectory = activeDirectory
        self.federatedAuthentication = federatedAuthentication
        self.mutualAuthentication = mutualAuthentication
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case activeDirectory
        case federatedAuthentication
        case mutualAuthentication
        case type
    }

    public func validate() throws {
        try activeDirectory?.validate()
        try federatedAuthentication?.validate()
        try mutualAuthentication?.validate()
    }
}

public struct ClientVpnAuthenticationRequest: Codable, Equatable {
    public var activeDirectory: DirectoryServiceAuthenticationRequest?
    public var federatedAuthentication: FederatedAuthenticationRequest?
    public var mutualAuthentication: CertificateAuthenticationRequest?
    public var type: ClientVpnAuthenticationType?

    public init(activeDirectory: DirectoryServiceAuthenticationRequest? = nil,
                federatedAuthentication: FederatedAuthenticationRequest? = nil,
                mutualAuthentication: CertificateAuthenticationRequest? = nil,
                type: ClientVpnAuthenticationType? = nil) {
        self.activeDirectory = activeDirectory
        self.federatedAuthentication = federatedAuthentication
        self.mutualAuthentication = mutualAuthentication
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case activeDirectory = "ActiveDirectory"
        case federatedAuthentication = "FederatedAuthentication"
        case mutualAuthentication = "MutualAuthentication"
        case type = "Type"
    }

    public func validate() throws {
        try activeDirectory?.validate()
        try federatedAuthentication?.validate()
        try mutualAuthentication?.validate()
    }
}

public struct ClientVpnAuthorizationRuleStatus: Codable, Equatable {
    public var code: ClientVpnAuthorizationRuleStatusCode?
    public var message: String?

    public init(code: ClientVpnAuthorizationRuleStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientVpnConnection: Codable, Equatable {
    public var clientIp: String?
    public var clientVpnEndpointId: String?
    public var commonName: String?
    public var connectionEndTime: String?
    public var connectionEstablishedTime: String?
    public var connectionId: String?
    public var egressBytes: String?
    public var egressPackets: String?
    public var ingressBytes: String?
    public var ingressPackets: String?
    public var postureComplianceStatuses: ValueStringList?
    public var status: ClientVpnConnectionStatus?
    public var timestamp: String?
    public var username: String?

    public init(clientIp: String? = nil,
                clientVpnEndpointId: String? = nil,
                commonName: String? = nil,
                connectionEndTime: String? = nil,
                connectionEstablishedTime: String? = nil,
                connectionId: String? = nil,
                egressBytes: String? = nil,
                egressPackets: String? = nil,
                ingressBytes: String? = nil,
                ingressPackets: String? = nil,
                postureComplianceStatuses: ValueStringList? = nil,
                status: ClientVpnConnectionStatus? = nil,
                timestamp: String? = nil,
                username: String? = nil) {
        self.clientIp = clientIp
        self.clientVpnEndpointId = clientVpnEndpointId
        self.commonName = commonName
        self.connectionEndTime = connectionEndTime
        self.connectionEstablishedTime = connectionEstablishedTime
        self.connectionId = connectionId
        self.egressBytes = egressBytes
        self.egressPackets = egressPackets
        self.ingressBytes = ingressBytes
        self.ingressPackets = ingressPackets
        self.postureComplianceStatuses = postureComplianceStatuses
        self.status = status
        self.timestamp = timestamp
        self.username = username
    }

    enum CodingKeys: String, CodingKey {
        case clientIp
        case clientVpnEndpointId
        case commonName
        case connectionEndTime
        case connectionEstablishedTime
        case connectionId
        case egressBytes
        case egressPackets
        case ingressBytes
        case ingressPackets
        case postureComplianceStatuses = "postureComplianceStatusSet"
        case status
        case timestamp
        case username
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct ClientVpnConnectionStatus: Codable, Equatable {
    public var code: ClientVpnConnectionStatusCode?
    public var message: String?

    public init(code: ClientVpnConnectionStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientVpnEndpoint: Codable, Equatable {
    public var authenticationOptions: ClientVpnAuthenticationList?
    public var clientCidrBlock: String?
    public var clientConnectOptions: ClientConnectResponseOptions?
    public var clientVpnEndpointId: String?
    public var connectionLogOptions: ConnectionLogResponseOptions?
    public var creationTime: String?
    public var deletionTime: String?
    public var description: String?
    public var dnsName: String?
    public var dnsServers: ValueStringList?
    public var securityGroupIds: ClientVpnSecurityGroupIdSet?
    public var selfServicePortalUrl: String?
    public var serverCertificateArn: String?
    public var splitTunnel: Boolean?
    public var status: ClientVpnEndpointStatus?
    public var tags: TagList?
    public var transportProtocol: TransportProtocol?
    public var vpcId: VpcId?
    public var vpnPort: Integer?
    public var vpnProtocol: VpnProtocol?

    public init(authenticationOptions: ClientVpnAuthenticationList? = nil,
                clientCidrBlock: String? = nil,
                clientConnectOptions: ClientConnectResponseOptions? = nil,
                clientVpnEndpointId: String? = nil,
                connectionLogOptions: ConnectionLogResponseOptions? = nil,
                creationTime: String? = nil,
                deletionTime: String? = nil,
                description: String? = nil,
                dnsName: String? = nil,
                dnsServers: ValueStringList? = nil,
                securityGroupIds: ClientVpnSecurityGroupIdSet? = nil,
                selfServicePortalUrl: String? = nil,
                serverCertificateArn: String? = nil,
                splitTunnel: Boolean? = nil,
                status: ClientVpnEndpointStatus? = nil,
                tags: TagList? = nil,
                transportProtocol: TransportProtocol? = nil,
                vpcId: VpcId? = nil,
                vpnPort: Integer? = nil,
                vpnProtocol: VpnProtocol? = nil) {
        self.authenticationOptions = authenticationOptions
        self.clientCidrBlock = clientCidrBlock
        self.clientConnectOptions = clientConnectOptions
        self.clientVpnEndpointId = clientVpnEndpointId
        self.connectionLogOptions = connectionLogOptions
        self.creationTime = creationTime
        self.deletionTime = deletionTime
        self.description = description
        self.dnsName = dnsName
        self.dnsServers = dnsServers
        self.securityGroupIds = securityGroupIds
        self.selfServicePortalUrl = selfServicePortalUrl
        self.serverCertificateArn = serverCertificateArn
        self.splitTunnel = splitTunnel
        self.status = status
        self.tags = tags
        self.transportProtocol = transportProtocol
        self.vpcId = vpcId
        self.vpnPort = vpnPort
        self.vpnProtocol = vpnProtocol
    }

    enum CodingKeys: String, CodingKey {
        case authenticationOptions
        case clientCidrBlock
        case clientConnectOptions
        case clientVpnEndpointId
        case connectionLogOptions
        case creationTime
        case deletionTime
        case description
        case dnsName
        case dnsServers = "dnsServer"
        case securityGroupIds = "securityGroupIdSet"
        case selfServicePortalUrl
        case serverCertificateArn
        case splitTunnel
        case status
        case tags = "tagSet"
        case transportProtocol
        case vpcId
        case vpnPort
        case vpnProtocol
    }

    public func validate() throws {
        try clientConnectOptions?.validate()
        try connectionLogOptions?.validate()
        try status?.validate()
    }
}

public struct ClientVpnEndpointAttributeStatus: Codable, Equatable {
    public var code: ClientVpnEndpointAttributeStatusCode?
    public var message: String?

    public init(code: ClientVpnEndpointAttributeStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientVpnEndpointStatus: Codable, Equatable {
    public var code: ClientVpnEndpointStatusCode?
    public var message: String?

    public init(code: ClientVpnEndpointStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientVpnRoute: Codable, Equatable {
    public var clientVpnEndpointId: String?
    public var description: String?
    public var destinationCidr: String?
    public var origin: String?
    public var status: ClientVpnRouteStatus?
    public var targetSubnet: String?
    public var type: String?

    public init(clientVpnEndpointId: String? = nil,
                description: String? = nil,
                destinationCidr: String? = nil,
                origin: String? = nil,
                status: ClientVpnRouteStatus? = nil,
                targetSubnet: String? = nil,
                type: String? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.description = description
        self.destinationCidr = destinationCidr
        self.origin = origin
        self.status = status
        self.targetSubnet = targetSubnet
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId
        case description
        case destinationCidr
        case origin
        case status
        case targetSubnet
        case type
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct ClientVpnRouteStatus: Codable, Equatable {
    public var code: ClientVpnRouteStatusCode?
    public var message: String?

    public init(code: ClientVpnRouteStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct CoipAddressUsage: Codable, Equatable {
    public var allocationId: String?
    public var awsAccountId: String?
    public var awsService: String?
    public var coIp: String?

    public init(allocationId: String? = nil,
                awsAccountId: String? = nil,
                awsService: String? = nil,
                coIp: String? = nil) {
        self.allocationId = allocationId
        self.awsAccountId = awsAccountId
        self.awsService = awsService
        self.coIp = coIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case awsAccountId
        case awsService
        case coIp
    }

    public func validate() throws {
    }
}

public struct CoipPool: Codable, Equatable {
    public var localGatewayRouteTableId: LocalGatewayRoutetableId?
    public var poolArn: ResourceArn?
    public var poolCidrs: ValueStringList?
    public var poolId: CoipPoolId?
    public var tags: TagList?

    public init(localGatewayRouteTableId: LocalGatewayRoutetableId? = nil,
                poolArn: ResourceArn? = nil,
                poolCidrs: ValueStringList? = nil,
                poolId: CoipPoolId? = nil,
                tags: TagList? = nil) {
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.poolArn = poolArn
        self.poolCidrs = poolCidrs
        self.poolId = poolId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableId
        case poolArn
        case poolCidrs = "poolCidrSet"
        case poolId
        case tags = "tagSet"
    }

    public func validate() throws {
        try poolArn?.validateAsResourceArn()
    }
}

public struct ConfirmProductInstanceRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var productCode: String

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                productCode: String) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.productCode = productCode
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId = "InstanceId"
        case productCode = "ProductCode"
    }

    public func validate() throws {
    }
}

public struct ConfirmProductInstanceResult: Codable, Equatable {
    public var ownerId: String?
    public var `return`: Boolean?

    public init(ownerId: String? = nil,
                `return`: Boolean? = nil) {
        self.ownerId = ownerId
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case ownerId
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ConnectionLogOptions: Codable, Equatable {
    public var cloudwatchLogGroup: String?
    public var cloudwatchLogStream: String?
    public var enabled: Boolean?

    public init(cloudwatchLogGroup: String? = nil,
                cloudwatchLogStream: String? = nil,
                enabled: Boolean? = nil) {
        self.cloudwatchLogGroup = cloudwatchLogGroup
        self.cloudwatchLogStream = cloudwatchLogStream
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case cloudwatchLogGroup = "CloudwatchLogGroup"
        case cloudwatchLogStream = "CloudwatchLogStream"
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct ConnectionLogResponseOptions: Codable, Equatable {
    public var cloudwatchLogGroup: String?
    public var cloudwatchLogStream: String?
    public var enabled: Boolean?

    public init(cloudwatchLogGroup: String? = nil,
                cloudwatchLogStream: String? = nil,
                enabled: Boolean? = nil) {
        self.cloudwatchLogGroup = cloudwatchLogGroup
        self.cloudwatchLogStream = cloudwatchLogStream
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case cloudwatchLogGroup = "CloudwatchLogGroup"
        case cloudwatchLogStream = "CloudwatchLogStream"
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct ConnectionNotification: Codable, Equatable {
    public var connectionEvents: ValueStringList?
    public var connectionNotificationArn: String?
    public var connectionNotificationId: String?
    public var connectionNotificationState: ConnectionNotificationState?
    public var connectionNotificationType: ConnectionNotificationType?
    public var serviceId: String?
    public var vpcEndpointId: String?

    public init(connectionEvents: ValueStringList? = nil,
                connectionNotificationArn: String? = nil,
                connectionNotificationId: String? = nil,
                connectionNotificationState: ConnectionNotificationState? = nil,
                connectionNotificationType: ConnectionNotificationType? = nil,
                serviceId: String? = nil,
                vpcEndpointId: String? = nil) {
        self.connectionEvents = connectionEvents
        self.connectionNotificationArn = connectionNotificationArn
        self.connectionNotificationId = connectionNotificationId
        self.connectionNotificationState = connectionNotificationState
        self.connectionNotificationType = connectionNotificationType
        self.serviceId = serviceId
        self.vpcEndpointId = vpcEndpointId
    }

    enum CodingKeys: String, CodingKey {
        case connectionEvents
        case connectionNotificationArn
        case connectionNotificationId
        case connectionNotificationState
        case connectionNotificationType
        case serviceId
        case vpcEndpointId
    }

    public func validate() throws {
    }
}

public struct ConversionTask: Codable, Equatable {
    public var conversionTaskId: String?
    public var expirationTime: String?
    public var importInstance: ImportInstanceTaskDetails?
    public var importVolume: ImportVolumeTaskDetails?
    public var state: ConversionTaskState?
    public var statusMessage: String?
    public var tags: TagList?

    public init(conversionTaskId: String? = nil,
                expirationTime: String? = nil,
                importInstance: ImportInstanceTaskDetails? = nil,
                importVolume: ImportVolumeTaskDetails? = nil,
                state: ConversionTaskState? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.conversionTaskId = conversionTaskId
        self.expirationTime = expirationTime
        self.importInstance = importInstance
        self.importVolume = importVolume
        self.state = state
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case conversionTaskId
        case expirationTime
        case importInstance
        case importVolume
        case state
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try importInstance?.validate()
        try importVolume?.validate()
    }
}

public struct CopyFpgaImageRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var name: String?
    public var sourceFpgaImageId: String
    public var sourceRegion: String

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                name: String? = nil,
                sourceFpgaImageId: String,
                sourceRegion: String) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.name = name
        self.sourceFpgaImageId = sourceFpgaImageId
        self.sourceRegion = sourceRegion
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case name = "Name"
        case sourceFpgaImageId = "SourceFpgaImageId"
        case sourceRegion = "SourceRegion"
    }

    public func validate() throws {
    }
}

public struct CopyFpgaImageResult: Codable, Equatable {
    public var fpgaImageId: String?

    public init(fpgaImageId: String? = nil) {
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImageId
    }

    public func validate() throws {
    }
}

public struct CopyImageRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var kmsKeyId: KmsKeyId?
    public var name: String
    public var sourceImageId: String
    public var sourceRegion: String

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                kmsKeyId: KmsKeyId? = nil,
                name: String,
                sourceImageId: String,
                sourceRegion: String) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sourceImageId = sourceImageId
        self.sourceRegion = sourceRegion
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun
        case encrypted
        case kmsKeyId
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
    }

    public func validate() throws {
    }
}

public struct CopyImageResult: Codable, Equatable {
    public var imageId: String?

    public init(imageId: String? = nil) {
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case imageId
    }

    public func validate() throws {
    }
}

public struct CopySnapshotRequest: Codable, Equatable {
    public var description: String?
    public var destinationRegion: String?
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var kmsKeyId: KmsKeyId?
    public var presignedUrl: String?
    public var sourceRegion: String
    public var sourceSnapshotId: String
    public var tagSpecifications: TagSpecificationList?

    public init(description: String? = nil,
                destinationRegion: String? = nil,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                kmsKeyId: KmsKeyId? = nil,
                presignedUrl: String? = nil,
                sourceRegion: String,
                sourceSnapshotId: String,
                tagSpecifications: TagSpecificationList? = nil) {
        self.description = description
        self.destinationRegion = destinationRegion
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.presignedUrl = presignedUrl
        self.sourceRegion = sourceRegion
        self.sourceSnapshotId = sourceSnapshotId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case destinationRegion
        case dryRun
        case encrypted
        case kmsKeyId
        case presignedUrl
        case sourceRegion = "SourceRegion"
        case sourceSnapshotId = "SourceSnapshotId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CopySnapshotResult: Codable, Equatable {
    public var snapshotId: String?
    public var tags: TagList?

    public init(snapshotId: String? = nil,
                tags: TagList? = nil) {
        self.snapshotId = snapshotId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case snapshotId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct CpuOptions: Codable, Equatable {
    public var coreCount: Integer?
    public var threadsPerCore: Integer?

    public init(coreCount: Integer? = nil,
                threadsPerCore: Integer? = nil) {
        self.coreCount = coreCount
        self.threadsPerCore = threadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case coreCount
        case threadsPerCore
    }

    public func validate() throws {
    }
}

public struct CpuOptionsRequest: Codable, Equatable {
    public var coreCount: Integer?
    public var threadsPerCore: Integer?

    public init(coreCount: Integer? = nil,
                threadsPerCore: Integer? = nil) {
        self.coreCount = coreCount
        self.threadsPerCore = threadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case coreCount = "CoreCount"
        case threadsPerCore = "ThreadsPerCore"
    }

    public func validate() throws {
    }
}

public struct CreateCapacityReservationRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var clientToken: String?
    public var dryRun: Boolean?
    public var ebsOptimized: Boolean?
    public var endDate: DateTime?
    public var endDateType: EndDateType?
    public var ephemeralStorage: Boolean?
    public var instanceCount: Integer
    public var instanceMatchCriteria: InstanceMatchCriteria?
    public var instancePlatform: CapacityReservationInstancePlatform
    public var instanceType: String
    public var tagSpecifications: TagSpecificationList?
    public var tenancy: CapacityReservationTenancy?

    public init(availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                ebsOptimized: Boolean? = nil,
                endDate: DateTime? = nil,
                endDateType: EndDateType? = nil,
                ephemeralStorage: Boolean? = nil,
                instanceCount: Integer,
                instanceMatchCriteria: InstanceMatchCriteria? = nil,
                instancePlatform: CapacityReservationInstancePlatform,
                instanceType: String,
                tagSpecifications: TagSpecificationList? = nil,
                tenancy: CapacityReservationTenancy? = nil) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.ebsOptimized = ebsOptimized
        self.endDate = endDate
        self.endDateType = endDateType
        self.ephemeralStorage = ephemeralStorage
        self.instanceCount = instanceCount
        self.instanceMatchCriteria = instanceMatchCriteria
        self.instancePlatform = instancePlatform
        self.instanceType = instanceType
        self.tagSpecifications = tagSpecifications
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case ebsOptimized = "EbsOptimized"
        case endDate = "EndDate"
        case endDateType = "EndDateType"
        case ephemeralStorage = "EphemeralStorage"
        case instanceCount = "InstanceCount"
        case instanceMatchCriteria = "InstanceMatchCriteria"
        case instancePlatform = "InstancePlatform"
        case instanceType = "InstanceType"
        case tagSpecifications = "TagSpecifications"
        case tenancy = "Tenancy"
    }

    public func validate() throws {
    }
}

public struct CreateCapacityReservationResult: Codable, Equatable {
    public var capacityReservation: CapacityReservation?

    public init(capacityReservation: CapacityReservation? = nil) {
        self.capacityReservation = capacityReservation
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservation
    }

    public func validate() throws {
        try capacityReservation?.validate()
    }
}

public struct CreateCarrierGatewayRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateCarrierGatewayResult: Codable, Equatable {
    public var carrierGateway: CarrierGateway?

    public init(carrierGateway: CarrierGateway? = nil) {
        self.carrierGateway = carrierGateway
    }

    enum CodingKeys: String, CodingKey {
        case carrierGateway
    }

    public func validate() throws {
        try carrierGateway?.validate()
    }
}

public struct CreateClientVpnEndpointRequest: Codable, Equatable {
    public var authenticationOptions: ClientVpnAuthenticationRequestList
    public var clientCidrBlock: String
    public var clientConnectOptions: ClientConnectOptions?
    public var clientToken: String?
    public var connectionLogOptions: ConnectionLogOptions
    public var description: String?
    public var dnsServers: ValueStringList?
    public var dryRun: Boolean?
    public var securityGroupIds: ClientVpnSecurityGroupIdSet?
    public var selfServicePortal: SelfServicePortal?
    public var serverCertificateArn: String
    public var splitTunnel: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var transportProtocol: TransportProtocol?
    public var vpcId: VpcId?
    public var vpnPort: Integer?

    public init(authenticationOptions: ClientVpnAuthenticationRequestList,
                clientCidrBlock: String,
                clientConnectOptions: ClientConnectOptions? = nil,
                clientToken: String? = nil,
                connectionLogOptions: ConnectionLogOptions,
                description: String? = nil,
                dnsServers: ValueStringList? = nil,
                dryRun: Boolean? = nil,
                securityGroupIds: ClientVpnSecurityGroupIdSet? = nil,
                selfServicePortal: SelfServicePortal? = nil,
                serverCertificateArn: String,
                splitTunnel: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                transportProtocol: TransportProtocol? = nil,
                vpcId: VpcId? = nil,
                vpnPort: Integer? = nil) {
        self.authenticationOptions = authenticationOptions
        self.clientCidrBlock = clientCidrBlock
        self.clientConnectOptions = clientConnectOptions
        self.clientToken = clientToken
        self.connectionLogOptions = connectionLogOptions
        self.description = description
        self.dnsServers = dnsServers
        self.dryRun = dryRun
        self.securityGroupIds = securityGroupIds
        self.selfServicePortal = selfServicePortal
        self.serverCertificateArn = serverCertificateArn
        self.splitTunnel = splitTunnel
        self.tagSpecifications = tagSpecifications
        self.transportProtocol = transportProtocol
        self.vpcId = vpcId
        self.vpnPort = vpnPort
    }

    enum CodingKeys: String, CodingKey {
        case authenticationOptions = "Authentication"
        case clientCidrBlock = "ClientCidrBlock"
        case clientConnectOptions = "ClientConnectOptions"
        case clientToken = "ClientToken"
        case connectionLogOptions = "ConnectionLogOptions"
        case description = "Description"
        case dnsServers = "DnsServers"
        case dryRun = "DryRun"
        case securityGroupIds = "SecurityGroupId"
        case selfServicePortal = "SelfServicePortal"
        case serverCertificateArn = "ServerCertificateArn"
        case splitTunnel = "SplitTunnel"
        case tagSpecifications = "TagSpecification"
        case transportProtocol = "TransportProtocol"
        case vpcId = "VpcId"
        case vpnPort = "VpnPort"
    }

    public func validate() throws {
        try clientConnectOptions?.validate()
        try connectionLogOptions.validate()
    }
}

public struct CreateClientVpnEndpointResult: Codable, Equatable {
    public var clientVpnEndpointId: String?
    public var dnsName: String?
    public var status: ClientVpnEndpointStatus?

    public init(clientVpnEndpointId: String? = nil,
                dnsName: String? = nil,
                status: ClientVpnEndpointStatus? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dnsName = dnsName
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId
        case dnsName
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct CreateClientVpnRouteRequest: Codable, Equatable {
    public var clientToken: String?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var description: String?
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var targetVpcSubnetId: SubnetId

    public init(clientToken: String? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                description: String? = nil,
                destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                targetVpcSubnetId: SubnetId) {
        self.clientToken = clientToken
        self.clientVpnEndpointId = clientVpnEndpointId
        self.description = description
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.targetVpcSubnetId = targetVpcSubnetId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case targetVpcSubnetId = "TargetVpcSubnetId"
    }

    public func validate() throws {
    }
}

public struct CreateClientVpnRouteResult: Codable, Equatable {
    public var status: ClientVpnRouteStatus?

    public init(status: ClientVpnRouteStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct CreateCustomerGatewayRequest: Codable, Equatable {
    public var bgpAsn: Integer
    public var certificateArn: String?
    public var deviceName: String?
    public var dryRun: Boolean?
    public var publicIp: String?
    public var tagSpecifications: TagSpecificationList?
    public var type: GatewayType

    public init(bgpAsn: Integer,
                certificateArn: String? = nil,
                deviceName: String? = nil,
                dryRun: Boolean? = nil,
                publicIp: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                type: GatewayType) {
        self.bgpAsn = bgpAsn
        self.certificateArn = certificateArn
        self.deviceName = deviceName
        self.dryRun = dryRun
        self.publicIp = publicIp
        self.tagSpecifications = tagSpecifications
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case bgpAsn = "BgpAsn"
        case certificateArn = "CertificateArn"
        case deviceName = "DeviceName"
        case dryRun
        case publicIp = "IpAddress"
        case tagSpecifications = "TagSpecification"
        case type = "Type"
    }

    public func validate() throws {
    }
}

public struct CreateCustomerGatewayResult: Codable, Equatable {
    public var customerGateway: CustomerGateway?

    public init(customerGateway: CustomerGateway? = nil) {
        self.customerGateway = customerGateway
    }

    enum CodingKeys: String, CodingKey {
        case customerGateway
    }

    public func validate() throws {
        try customerGateway?.validate()
    }
}

public struct CreateDefaultSubnetRequest: Codable, Equatable {
    public var availabilityZone: String
    public var dryRun: Boolean?

    public init(availabilityZone: String,
                dryRun: Boolean? = nil) {
        self.availabilityZone = availabilityZone
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct CreateDefaultSubnetResult: Codable, Equatable {
    public var subnet: Subnet?

    public init(subnet: Subnet? = nil) {
        self.subnet = subnet
    }

    enum CodingKeys: String, CodingKey {
        case subnet
    }

    public func validate() throws {
        try subnet?.validate()
    }
}

public struct CreateDefaultVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct CreateDefaultVpcResult: Codable, Equatable {
    public var vpc: Vpc?

    public init(vpc: Vpc? = nil) {
        self.vpc = vpc
    }

    enum CodingKeys: String, CodingKey {
        case vpc
    }

    public func validate() throws {
        try vpc?.validate()
    }
}

public struct CreateDhcpOptionsRequest: Codable, Equatable {
    public var dhcpConfigurations: NewDhcpConfigurationList
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(dhcpConfigurations: NewDhcpConfigurationList,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dhcpConfigurations = dhcpConfigurations
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dhcpConfigurations = "dhcpConfiguration"
        case dryRun
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateDhcpOptionsResult: Codable, Equatable {
    public var dhcpOptions: DhcpOptions?

    public init(dhcpOptions: DhcpOptions? = nil) {
        self.dhcpOptions = dhcpOptions
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptions
    }

    public func validate() throws {
        try dhcpOptions?.validate()
    }
}

public struct CreateEgressOnlyInternetGatewayRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateEgressOnlyInternetGatewayResult: Codable, Equatable {
    public var clientToken: String?
    public var egressOnlyInternetGateway: EgressOnlyInternetGateway?

    public init(clientToken: String? = nil,
                egressOnlyInternetGateway: EgressOnlyInternetGateway? = nil) {
        self.clientToken = clientToken
        self.egressOnlyInternetGateway = egressOnlyInternetGateway
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case egressOnlyInternetGateway
    }

    public func validate() throws {
        try egressOnlyInternetGateway?.validate()
    }
}

public struct CreateFleetError: Codable, Equatable {
    public var errorCode: String?
    public var errorMessage: String?
    public var launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse?
    public var lifecycle: InstanceLifecycle?

    public init(errorCode: String? = nil,
                errorMessage: String? = nil,
                launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse? = nil,
                lifecycle: InstanceLifecycle? = nil) {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.launchTemplateAndOverrides = launchTemplateAndOverrides
        self.lifecycle = lifecycle
    }

    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case launchTemplateAndOverrides
        case lifecycle
    }

    public func validate() throws {
        try launchTemplateAndOverrides?.validate()
    }
}

public struct CreateFleetInstance: Codable, Equatable {
    public var instanceIds: InstanceIdsSet?
    public var instanceType: InstanceType?
    public var launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse?
    public var lifecycle: InstanceLifecycle?
    public var platform: PlatformValues?

    public init(instanceIds: InstanceIdsSet? = nil,
                instanceType: InstanceType? = nil,
                launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse? = nil,
                lifecycle: InstanceLifecycle? = nil,
                platform: PlatformValues? = nil) {
        self.instanceIds = instanceIds
        self.instanceType = instanceType
        self.launchTemplateAndOverrides = launchTemplateAndOverrides
        self.lifecycle = lifecycle
        self.platform = platform
    }

    enum CodingKeys: String, CodingKey {
        case instanceIds
        case instanceType
        case launchTemplateAndOverrides
        case lifecycle
        case platform
    }

    public func validate() throws {
        try launchTemplateAndOverrides?.validate()
    }
}

public struct CreateFleetRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy?
    public var launchTemplateConfigs: FleetLaunchTemplateConfigListRequest
    public var onDemandOptions: OnDemandOptionsRequest?
    public var replaceUnhealthyInstances: Boolean?
    public var spotOptions: SpotOptionsRequest?
    public var tagSpecifications: TagSpecificationList?
    public var targetCapacitySpecification: TargetCapacitySpecificationRequest
    public var terminateInstancesWithExpiration: Boolean?
    public var type: FleetType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy? = nil,
                launchTemplateConfigs: FleetLaunchTemplateConfigListRequest,
                onDemandOptions: OnDemandOptionsRequest? = nil,
                replaceUnhealthyInstances: Boolean? = nil,
                spotOptions: SpotOptionsRequest? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                targetCapacitySpecification: TargetCapacitySpecificationRequest,
                terminateInstancesWithExpiration: Boolean? = nil,
                type: FleetType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.launchTemplateConfigs = launchTemplateConfigs
        self.onDemandOptions = onDemandOptions
        self.replaceUnhealthyInstances = replaceUnhealthyInstances
        self.spotOptions = spotOptions
        self.tagSpecifications = tagSpecifications
        self.targetCapacitySpecification = targetCapacitySpecification
        self.terminateInstancesWithExpiration = terminateInstancesWithExpiration
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case excessCapacityTerminationPolicy = "ExcessCapacityTerminationPolicy"
        case launchTemplateConfigs = "LaunchTemplateConfigs"
        case onDemandOptions = "OnDemandOptions"
        case replaceUnhealthyInstances = "ReplaceUnhealthyInstances"
        case spotOptions = "SpotOptions"
        case tagSpecifications = "TagSpecification"
        case targetCapacitySpecification = "TargetCapacitySpecification"
        case terminateInstancesWithExpiration = "TerminateInstancesWithExpiration"
        case type = "Type"
        case validFrom = "ValidFrom"
        case validUntil = "ValidUntil"
    }

    public func validate() throws {
        try launchTemplateConfigs.validateAsFleetLaunchTemplateConfigListRequest()
        try onDemandOptions?.validate()
        try spotOptions?.validate()
        try targetCapacitySpecification.validate()
    }
}

public struct CreateFleetResult: Codable, Equatable {
    public var errors: CreateFleetErrorsSet?
    public var fleetId: FleetId?
    public var instances: CreateFleetInstancesSet?

    public init(errors: CreateFleetErrorsSet? = nil,
                fleetId: FleetId? = nil,
                instances: CreateFleetInstancesSet? = nil) {
        self.errors = errors
        self.fleetId = fleetId
        self.instances = instances
    }

    enum CodingKeys: String, CodingKey {
        case errors = "errorSet"
        case fleetId
        case instances = "fleetInstanceSet"
    }

    public func validate() throws {
    }
}

public struct CreateFlowLogsRequest: Codable, Equatable {
    public var clientToken: String?
    public var deliverLogsPermissionArn: String?
    public var dryRun: Boolean?
    public var logDestination: String?
    public var logDestinationType: LogDestinationType?
    public var logFormat: String?
    public var logGroupName: String?
    public var maxAggregationInterval: Integer?
    public var resourceIds: FlowLogResourceIds
    public var resourceType: FlowLogsResourceType
    public var tagSpecifications: TagSpecificationList?
    public var trafficType: TrafficType

    public init(clientToken: String? = nil,
                deliverLogsPermissionArn: String? = nil,
                dryRun: Boolean? = nil,
                logDestination: String? = nil,
                logDestinationType: LogDestinationType? = nil,
                logFormat: String? = nil,
                logGroupName: String? = nil,
                maxAggregationInterval: Integer? = nil,
                resourceIds: FlowLogResourceIds,
                resourceType: FlowLogsResourceType,
                tagSpecifications: TagSpecificationList? = nil,
                trafficType: TrafficType) {
        self.clientToken = clientToken
        self.deliverLogsPermissionArn = deliverLogsPermissionArn
        self.dryRun = dryRun
        self.logDestination = logDestination
        self.logDestinationType = logDestinationType
        self.logFormat = logFormat
        self.logGroupName = logGroupName
        self.maxAggregationInterval = maxAggregationInterval
        self.resourceIds = resourceIds
        self.resourceType = resourceType
        self.tagSpecifications = tagSpecifications
        self.trafficType = trafficType
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case deliverLogsPermissionArn = "DeliverLogsPermissionArn"
        case dryRun = "DryRun"
        case logDestination = "LogDestination"
        case logDestinationType = "LogDestinationType"
        case logFormat = "LogFormat"
        case logGroupName = "LogGroupName"
        case maxAggregationInterval = "MaxAggregationInterval"
        case resourceIds = "ResourceId"
        case resourceType = "ResourceType"
        case tagSpecifications = "TagSpecification"
        case trafficType = "TrafficType"
    }

    public func validate() throws {
    }
}

public struct CreateFlowLogsResult: Codable, Equatable {
    public var clientToken: String?
    public var flowLogIds: ValueStringList?
    public var unsuccessful: UnsuccessfulItemSet?

    public init(clientToken: String? = nil,
                flowLogIds: ValueStringList? = nil,
                unsuccessful: UnsuccessfulItemSet? = nil) {
        self.clientToken = clientToken
        self.flowLogIds = flowLogIds
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case flowLogIds = "flowLogIdSet"
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct CreateFpgaImageRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var inputStorageLocation: StorageLocation
    public var logsStorageLocation: StorageLocation?
    public var name: String?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                inputStorageLocation: StorageLocation,
                logsStorageLocation: StorageLocation? = nil,
                name: String? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.inputStorageLocation = inputStorageLocation
        self.logsStorageLocation = logsStorageLocation
        self.name = name
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case inputStorageLocation = "InputStorageLocation"
        case logsStorageLocation = "LogsStorageLocation"
        case name = "Name"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try inputStorageLocation.validate()
        try logsStorageLocation?.validate()
    }
}

public struct CreateFpgaImageResult: Codable, Equatable {
    public var fpgaImageGlobalId: String?
    public var fpgaImageId: String?

    public init(fpgaImageGlobalId: String? = nil,
                fpgaImageId: String? = nil) {
        self.fpgaImageGlobalId = fpgaImageGlobalId
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImageGlobalId
        case fpgaImageId
    }

    public func validate() throws {
    }
}

public struct CreateImageRequest: Codable, Equatable {
    public var blockDeviceMappings: BlockDeviceMappingRequestList?
    public var description: String?
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var name: String
    public var noReboot: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(blockDeviceMappings: BlockDeviceMappingRequestList? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                instanceId: InstanceId,
                name: String,
                noReboot: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.description = description
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.name = name
        self.noReboot = noReboot
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "blockDeviceMapping"
        case description
        case dryRun
        case instanceId
        case name
        case noReboot
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateImageResult: Codable, Equatable {
    public var imageId: String?

    public init(imageId: String? = nil) {
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case imageId
    }

    public func validate() throws {
    }
}

public struct CreateInstanceExportTaskRequest: Codable, Equatable {
    public var description: String?
    public var exportToS3Task: ExportToS3TaskSpecification
    public var instanceId: InstanceId
    public var tagSpecifications: TagSpecificationList?
    public var targetEnvironment: ExportEnvironment

    public init(description: String? = nil,
                exportToS3Task: ExportToS3TaskSpecification,
                instanceId: InstanceId,
                tagSpecifications: TagSpecificationList? = nil,
                targetEnvironment: ExportEnvironment) {
        self.description = description
        self.exportToS3Task = exportToS3Task
        self.instanceId = instanceId
        self.tagSpecifications = tagSpecifications
        self.targetEnvironment = targetEnvironment
    }

    enum CodingKeys: String, CodingKey {
        case description
        case exportToS3Task = "exportToS3"
        case instanceId
        case tagSpecifications = "TagSpecification"
        case targetEnvironment
    }

    public func validate() throws {
        try exportToS3Task.validate()
    }
}

public struct CreateInstanceExportTaskResult: Codable, Equatable {
    public var exportTask: ExportTask?

    public init(exportTask: ExportTask? = nil) {
        self.exportTask = exportTask
    }

    enum CodingKeys: String, CodingKey {
        case exportTask
    }

    public func validate() throws {
        try exportTask?.validate()
    }
}

public struct CreateInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateInternetGatewayResult: Codable, Equatable {
    public var internetGateway: InternetGateway?

    public init(internetGateway: InternetGateway? = nil) {
        self.internetGateway = internetGateway
    }

    enum CodingKeys: String, CodingKey {
        case internetGateway
    }

    public func validate() throws {
        try internetGateway?.validate()
    }
}

public struct CreateKeyPairRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var keyName: String
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                keyName: String,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.keyName = keyName
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case keyName = "KeyName"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateLaunchTemplateRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var launchTemplateData: RequestLaunchTemplateData
    public var launchTemplateName: LaunchTemplateName
    public var tagSpecifications: TagSpecificationList?
    public var versionDescription: VersionDescription?

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                launchTemplateData: RequestLaunchTemplateData,
                launchTemplateName: LaunchTemplateName,
                tagSpecifications: TagSpecificationList? = nil,
                versionDescription: VersionDescription? = nil) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.launchTemplateData = launchTemplateData
        self.launchTemplateName = launchTemplateName
        self.tagSpecifications = tagSpecifications
        self.versionDescription = versionDescription
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case launchTemplateData = "LaunchTemplateData"
        case launchTemplateName = "LaunchTemplateName"
        case tagSpecifications = "TagSpecification"
        case versionDescription = "VersionDescription"
    }

    public func validate() throws {
        try launchTemplateData.validate()
        try launchTemplateName.validateAsLaunchTemplateName()
        try versionDescription?.validateAsVersionDescription()
    }
}

public struct CreateLaunchTemplateResult: Codable, Equatable {
    public var launchTemplate: LaunchTemplate?
    public var warning: ValidationWarning?

    public init(launchTemplate: LaunchTemplate? = nil,
                warning: ValidationWarning? = nil) {
        self.launchTemplate = launchTemplate
        self.warning = warning
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplate
        case warning
    }

    public func validate() throws {
        try launchTemplate?.validate()
        try warning?.validate()
    }
}

public struct CreateLaunchTemplateVersionRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var launchTemplateData: RequestLaunchTemplateData
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?
    public var sourceVersion: String?
    public var versionDescription: VersionDescription?

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                launchTemplateData: RequestLaunchTemplateData,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                sourceVersion: String? = nil,
                versionDescription: VersionDescription? = nil) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.launchTemplateData = launchTemplateData
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.sourceVersion = sourceVersion
        self.versionDescription = versionDescription
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case launchTemplateData = "LaunchTemplateData"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case sourceVersion = "SourceVersion"
        case versionDescription = "VersionDescription"
    }

    public func validate() throws {
        try launchTemplateData.validate()
        try launchTemplateName?.validateAsLaunchTemplateName()
        try versionDescription?.validateAsVersionDescription()
    }
}

public struct CreateLaunchTemplateVersionResult: Codable, Equatable {
    public var launchTemplateVersion: LaunchTemplateVersion?
    public var warning: ValidationWarning?

    public init(launchTemplateVersion: LaunchTemplateVersion? = nil,
                warning: ValidationWarning? = nil) {
        self.launchTemplateVersion = launchTemplateVersion
        self.warning = warning
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateVersion
        case warning
    }

    public func validate() throws {
        try launchTemplateVersion?.validate()
        try warning?.validate()
    }
}

public struct CreateLocalGatewayRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId

    public init(destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
        case localGatewayVirtualInterfaceGroupId = "LocalGatewayVirtualInterfaceGroupId"
    }

    public func validate() throws {
    }
}

public struct CreateLocalGatewayRouteResult: Codable, Equatable {
    public var route: LocalGatewayRoute?

    public init(route: LocalGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct CreateLocalGatewayRouteTableVpcAssociationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateLocalGatewayRouteTableVpcAssociationResult: Codable, Equatable {
    public var localGatewayRouteTableVpcAssociation: LocalGatewayRouteTableVpcAssociation?

    public init(localGatewayRouteTableVpcAssociation: LocalGatewayRouteTableVpcAssociation? = nil) {
        self.localGatewayRouteTableVpcAssociation = localGatewayRouteTableVpcAssociation
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVpcAssociation
    }

    public func validate() throws {
        try localGatewayRouteTableVpcAssociation?.validate()
    }
}

public struct CreateManagedPrefixListRequest: Codable, Equatable {
    public var addressFamily: String
    public var clientToken: String?
    public var dryRun: Boolean?
    public var entries: AddPrefixListEntries?
    public var maxEntries: Integer
    public var prefixListName: String
    public var tagSpecifications: TagSpecificationList?

    public init(addressFamily: String,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                entries: AddPrefixListEntries? = nil,
                maxEntries: Integer,
                prefixListName: String,
                tagSpecifications: TagSpecificationList? = nil) {
        self.addressFamily = addressFamily
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.entries = entries
        self.maxEntries = maxEntries
        self.prefixListName = prefixListName
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case addressFamily = "AddressFamily"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case entries = "Entry"
        case maxEntries = "MaxEntries"
        case prefixListName = "PrefixListName"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try entries?.validateAsAddPrefixListEntries()
    }
}

public struct CreateManagedPrefixListResult: Codable, Equatable {
    public var prefixList: ManagedPrefixList?

    public init(prefixList: ManagedPrefixList? = nil) {
        self.prefixList = prefixList
    }

    enum CodingKeys: String, CodingKey {
        case prefixList
    }

    public func validate() throws {
        try prefixList?.validate()
    }
}

public struct CreateNatGatewayRequest: Codable, Equatable {
    public var allocationId: AllocationId
    public var clientToken: String?
    public var dryRun: Boolean?
    public var subnetId: SubnetId
    public var tagSpecifications: TagSpecificationList?

    public init(allocationId: AllocationId,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                subnetId: SubnetId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.allocationId = allocationId
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.subnetId = subnetId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case subnetId = "SubnetId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateNatGatewayResult: Codable, Equatable {
    public var clientToken: String?
    public var natGateway: NatGateway?

    public init(clientToken: String? = nil,
                natGateway: NatGateway? = nil) {
        self.clientToken = clientToken
        self.natGateway = natGateway
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case natGateway
    }

    public func validate() throws {
        try natGateway?.validate()
    }
}

public struct CreateNetworkAclEntryRequest: Codable, Equatable {
    public var cidrBlock: String?
    public var dryRun: Boolean?
    public var egress: Boolean
    public var icmpTypeCode: IcmpTypeCode?
    public var ipv6CidrBlock: String?
    public var networkAclId: NetworkAclId
    public var portRange: PortRange?
    public var `protocol`: String
    public var ruleAction: RuleAction
    public var ruleNumber: Integer

    public init(cidrBlock: String? = nil,
                dryRun: Boolean? = nil,
                egress: Boolean,
                icmpTypeCode: IcmpTypeCode? = nil,
                ipv6CidrBlock: String? = nil,
                networkAclId: NetworkAclId,
                portRange: PortRange? = nil,
                `protocol`: String,
                ruleAction: RuleAction,
                ruleNumber: Integer) {
        self.cidrBlock = cidrBlock
        self.dryRun = dryRun
        self.egress = egress
        self.icmpTypeCode = icmpTypeCode
        self.ipv6CidrBlock = ipv6CidrBlock
        self.networkAclId = networkAclId
        self.portRange = portRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case dryRun
        case egress
        case icmpTypeCode = "Icmp"
        case ipv6CidrBlock
        case networkAclId
        case portRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
    }

    public func validate() throws {
        try icmpTypeCode?.validate()
        try portRange?.validate()
    }
}

public struct CreateNetworkAclRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case tagSpecifications = "TagSpecification"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct CreateNetworkAclResult: Codable, Equatable {
    public var networkAcl: NetworkAcl?

    public init(networkAcl: NetworkAcl? = nil) {
        self.networkAcl = networkAcl
    }

    enum CodingKeys: String, CodingKey {
        case networkAcl
    }

    public func validate() throws {
        try networkAcl?.validate()
    }
}

public struct CreateNetworkInsightsPathRequest: Codable, Equatable {
    public var clientToken: String
    public var destination: String
    public var destinationIp: IpAddress?
    public var destinationPort: Port?
    public var dryRun: Boolean?
    public var `protocol`: Protocol
    public var source: String
    public var sourceIp: IpAddress?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String,
                destination: String,
                destinationIp: IpAddress? = nil,
                destinationPort: Port? = nil,
                dryRun: Boolean? = nil,
                `protocol`: Protocol,
                source: String,
                sourceIp: IpAddress? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.destination = destination
        self.destinationIp = destinationIp
        self.destinationPort = destinationPort
        self.dryRun = dryRun
        self.`protocol` = `protocol`
        self.source = source
        self.sourceIp = sourceIp
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case destination = "Destination"
        case destinationIp = "DestinationIp"
        case destinationPort = "DestinationPort"
        case dryRun = "DryRun"
        case `protocol` = "Protocol"
        case source = "Source"
        case sourceIp = "SourceIp"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try destinationIp?.validateAsIpAddress()
        try destinationPort?.validateAsPort()
        try sourceIp?.validateAsIpAddress()
    }
}

public struct CreateNetworkInsightsPathResult: Codable, Equatable {
    public var networkInsightsPath: NetworkInsightsPath?

    public init(networkInsightsPath: NetworkInsightsPath? = nil) {
        self.networkInsightsPath = networkInsightsPath
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsPath
    }

    public func validate() throws {
        try networkInsightsPath?.validate()
    }
}

public struct CreateNetworkInterfacePermissionRequest: Codable, Equatable {
    public var awsAccountId: String?
    public var awsService: String?
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId
    public var permission: InterfacePermissionType

    public init(awsAccountId: String? = nil,
                awsService: String? = nil,
                dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId,
                permission: InterfacePermissionType) {
        self.awsAccountId = awsAccountId
        self.awsService = awsService
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
        self.permission = permission
    }

    enum CodingKeys: String, CodingKey {
        case awsAccountId = "AwsAccountId"
        case awsService = "AwsService"
        case dryRun = "DryRun"
        case networkInterfaceId = "NetworkInterfaceId"
        case permission = "Permission"
    }

    public func validate() throws {
    }
}

public struct CreateNetworkInterfacePermissionResult: Codable, Equatable {
    public var interfacePermission: NetworkInterfacePermission?

    public init(interfacePermission: NetworkInterfacePermission? = nil) {
        self.interfacePermission = interfacePermission
    }

    enum CodingKeys: String, CodingKey {
        case interfacePermission
    }

    public func validate() throws {
        try interfacePermission?.validate()
    }
}

public struct CreateNetworkInterfaceRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var groups: SecurityGroupIdStringList?
    public var interfaceType: NetworkInterfaceCreationType?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var privateIpAddress: String?
    public var privateIpAddresses: PrivateIpAddressSpecificationList?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: SubnetId
    public var tagSpecifications: TagSpecificationList?

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                groups: SecurityGroupIdStringList? = nil,
                interfaceType: NetworkInterfaceCreationType? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: PrivateIpAddressSpecificationList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: SubnetId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.description = description
        self.dryRun = dryRun
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case description
        case dryRun
        case groups = "SecurityGroupId"
        case interfaceType = "InterfaceType"
        case ipv6AddressCount
        case ipv6Addresses
        case privateIpAddress
        case privateIpAddresses
        case secondaryPrivateIpAddressCount
        case subnetId
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateNetworkInterfaceResult: Codable, Equatable {
    public var networkInterface: NetworkInterface?

    public init(networkInterface: NetworkInterface? = nil) {
        self.networkInterface = networkInterface
    }

    enum CodingKeys: String, CodingKey {
        case networkInterface
    }

    public func validate() throws {
        try networkInterface?.validate()
    }
}

public struct CreatePlacementGroupRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupName: String?
    public var partitionCount: Integer?
    public var strategy: PlacementStrategy?
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                groupName: String? = nil,
                partitionCount: Integer? = nil,
                strategy: PlacementStrategy? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.groupName = groupName
        self.partitionCount = partitionCount
        self.strategy = strategy
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case groupName
        case partitionCount = "PartitionCount"
        case strategy
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreatePlacementGroupResult: Codable, Equatable {
    public var placementGroup: PlacementGroup?

    public init(placementGroup: PlacementGroup? = nil) {
        self.placementGroup = placementGroup
    }

    enum CodingKeys: String, CodingKey {
        case placementGroup
    }

    public func validate() throws {
        try placementGroup?.validate()
    }
}

public struct CreateReservedInstancesListingRequest: Codable, Equatable {
    public var clientToken: String
    public var instanceCount: Integer
    public var priceSchedules: PriceScheduleSpecificationList
    public var reservedInstancesId: ReservationId

    public init(clientToken: String,
                instanceCount: Integer,
                priceSchedules: PriceScheduleSpecificationList,
                reservedInstancesId: ReservationId) {
        self.clientToken = clientToken
        self.instanceCount = instanceCount
        self.priceSchedules = priceSchedules
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case instanceCount
        case priceSchedules
        case reservedInstancesId
    }

    public func validate() throws {
    }
}

public struct CreateReservedInstancesListingResult: Codable, Equatable {
    public var reservedInstancesListings: ReservedInstancesListingList?

    public init(reservedInstancesListings: ReservedInstancesListingList? = nil) {
        self.reservedInstancesListings = reservedInstancesListings
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesListings = "reservedInstancesListingsSet"
    }

    public func validate() throws {
    }
}

public struct CreateRouteRequest: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId?
    public var destinationCidrBlock: String?
    public var destinationIpv6CidrBlock: String?
    public var destinationPrefixListId: PrefixListResourceId?
    public var dryRun: Boolean?
    public var egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId?
    public var gatewayId: RouteGatewayId?
    public var instanceId: InstanceId?
    public var localGatewayId: LocalGatewayId?
    public var natGatewayId: NatGatewayId?
    public var networkInterfaceId: NetworkInterfaceId?
    public var routeTableId: RouteTableId
    public var transitGatewayId: TransitGatewayId?
    public var vpcEndpointId: VpcEndpointId?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId?

    public init(carrierGatewayId: CarrierGatewayId? = nil,
                destinationCidrBlock: String? = nil,
                destinationIpv6CidrBlock: String? = nil,
                destinationPrefixListId: PrefixListResourceId? = nil,
                dryRun: Boolean? = nil,
                egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId? = nil,
                gatewayId: RouteGatewayId? = nil,
                instanceId: InstanceId? = nil,
                localGatewayId: LocalGatewayId? = nil,
                natGatewayId: NatGatewayId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                routeTableId: RouteTableId,
                transitGatewayId: TransitGatewayId? = nil,
                vpcEndpointId: VpcEndpointId? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        self.destinationPrefixListId = destinationPrefixListId
        self.dryRun = dryRun
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.gatewayId = gatewayId
        self.instanceId = instanceId
        self.localGatewayId = localGatewayId
        self.natGatewayId = natGatewayId
        self.networkInterfaceId = networkInterfaceId
        self.routeTableId = routeTableId
        self.transitGatewayId = transitGatewayId
        self.vpcEndpointId = vpcEndpointId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId = "CarrierGatewayId"
        case destinationCidrBlock
        case destinationIpv6CidrBlock
        case destinationPrefixListId = "DestinationPrefixListId"
        case dryRun
        case egressOnlyInternetGatewayId
        case gatewayId
        case instanceId
        case localGatewayId = "LocalGatewayId"
        case natGatewayId
        case networkInterfaceId
        case routeTableId
        case transitGatewayId = "TransitGatewayId"
        case vpcEndpointId = "VpcEndpointId"
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct CreateRouteResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct CreateRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case tagSpecifications = "TagSpecification"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct CreateRouteTableResult: Codable, Equatable {
    public var routeTable: RouteTable?

    public init(routeTable: RouteTable? = nil) {
        self.routeTable = routeTable
    }

    enum CodingKeys: String, CodingKey {
        case routeTable
    }

    public func validate() throws {
        try routeTable?.validate()
    }
}

public struct CreateSecurityGroupRequest: Codable, Equatable {
    public var description: String
    public var dryRun: Boolean?
    public var groupName: String
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId?

    public init(description: String,
                dryRun: Boolean? = nil,
                groupName: String,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId? = nil) {
        self.description = description
        self.dryRun = dryRun
        self.groupName = groupName
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case description = "GroupDescription"
        case dryRun
        case groupName = "GroupName"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateSecurityGroupResult: Codable, Equatable {
    public var groupId: String?
    public var tags: TagList?

    public init(groupId: String? = nil,
                tags: TagList? = nil) {
        self.groupId = groupId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct CreateSnapshotRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var volumeId: VolumeId

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                volumeId: VolumeId) {
        self.description = description
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun
        case tagSpecifications = "TagSpecification"
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct CreateSnapshotsRequest: Codable, Equatable {
    public var copyTagsFromSource: CopyTagsFromSource?
    public var description: String?
    public var dryRun: Boolean?
    public var instanceSpecification: InstanceSpecification
    public var tagSpecifications: TagSpecificationList?

    public init(copyTagsFromSource: CopyTagsFromSource? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                instanceSpecification: InstanceSpecification,
                tagSpecifications: TagSpecificationList? = nil) {
        self.copyTagsFromSource = copyTagsFromSource
        self.description = description
        self.dryRun = dryRun
        self.instanceSpecification = instanceSpecification
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case copyTagsFromSource = "CopyTagsFromSource"
        case description = "Description"
        case dryRun = "DryRun"
        case instanceSpecification = "InstanceSpecification"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try instanceSpecification.validate()
    }
}

public struct CreateSnapshotsResult: Codable, Equatable {
    public var snapshots: SnapshotSet?

    public init(snapshots: SnapshotSet? = nil) {
        self.snapshots = snapshots
    }

    enum CodingKeys: String, CodingKey {
        case snapshots = "snapshotSet"
    }

    public func validate() throws {
    }
}

public struct CreateSpotDatafeedSubscriptionRequest: Codable, Equatable {
    public var bucket: String
    public var dryRun: Boolean?
    public var prefix: String?

    public init(bucket: String,
                dryRun: Boolean? = nil,
                prefix: String? = nil) {
        self.bucket = bucket
        self.dryRun = dryRun
        self.prefix = prefix
    }

    enum CodingKeys: String, CodingKey {
        case bucket
        case dryRun
        case prefix
    }

    public func validate() throws {
    }
}

public struct CreateSpotDatafeedSubscriptionResult: Codable, Equatable {
    public var spotDatafeedSubscription: SpotDatafeedSubscription?

    public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
        self.spotDatafeedSubscription = spotDatafeedSubscription
    }

    enum CodingKeys: String, CodingKey {
        case spotDatafeedSubscription
    }

    public func validate() throws {
        try spotDatafeedSubscription?.validate()
    }
}

public struct CreateSubnetRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var cidrBlock: String
    public var dryRun: Boolean?
    public var ipv6CidrBlock: String?
    public var outpostArn: String?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                cidrBlock: String,
                dryRun: Boolean? = nil,
                ipv6CidrBlock: String? = nil,
                outpostArn: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.cidrBlock = cidrBlock
        self.dryRun = dryRun
        self.ipv6CidrBlock = ipv6CidrBlock
        self.outpostArn = outpostArn
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case cidrBlock = "CidrBlock"
        case dryRun
        case ipv6CidrBlock = "Ipv6CidrBlock"
        case outpostArn = "OutpostArn"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateSubnetResult: Codable, Equatable {
    public var subnet: Subnet?

    public init(subnet: Subnet? = nil) {
        self.subnet = subnet
    }

    enum CodingKeys: String, CodingKey {
        case subnet
    }

    public func validate() throws {
        try subnet?.validate()
    }
}

public struct CreateTagsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var resources: ResourceIdList
    public var tags: TagList

    public init(dryRun: Boolean? = nil,
                resources: ResourceIdList,
                tags: TagList) {
        self.dryRun = dryRun
        self.resources = resources
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case resources = "ResourceId"
        case tags = "Tag"
    }

    public func validate() throws {
    }
}

public struct CreateTrafficMirrorFilterRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateTrafficMirrorFilterResult: Codable, Equatable {
    public var clientToken: String?
    public var trafficMirrorFilter: TrafficMirrorFilter?

    public init(clientToken: String? = nil,
                trafficMirrorFilter: TrafficMirrorFilter? = nil) {
        self.clientToken = clientToken
        self.trafficMirrorFilter = trafficMirrorFilter
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case trafficMirrorFilter
    }

    public func validate() throws {
        try trafficMirrorFilter?.validate()
    }
}

public struct CreateTrafficMirrorFilterRuleRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var destinationCidrBlock: String
    public var destinationPortRange: TrafficMirrorPortRangeRequest?
    public var dryRun: Boolean?
    public var `protocol`: Integer?
    public var ruleAction: TrafficMirrorRuleAction
    public var ruleNumber: Integer
    public var sourceCidrBlock: String
    public var sourcePortRange: TrafficMirrorPortRangeRequest?
    public var trafficDirection: TrafficDirection
    public var trafficMirrorFilterId: TrafficMirrorFilterId

    public init(clientToken: String? = nil,
                description: String? = nil,
                destinationCidrBlock: String,
                destinationPortRange: TrafficMirrorPortRangeRequest? = nil,
                dryRun: Boolean? = nil,
                `protocol`: Integer? = nil,
                ruleAction: TrafficMirrorRuleAction,
                ruleNumber: Integer,
                sourceCidrBlock: String,
                sourcePortRange: TrafficMirrorPortRangeRequest? = nil,
                trafficDirection: TrafficDirection,
                trafficMirrorFilterId: TrafficMirrorFilterId) {
        self.clientToken = clientToken
        self.description = description
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationPortRange = destinationPortRange
        self.dryRun = dryRun
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
        self.sourceCidrBlock = sourceCidrBlock
        self.sourcePortRange = sourcePortRange
        self.trafficDirection = trafficDirection
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationPortRange = "DestinationPortRange"
        case dryRun = "DryRun"
        case `protocol` = "Protocol"
        case ruleAction = "RuleAction"
        case ruleNumber = "RuleNumber"
        case sourceCidrBlock = "SourceCidrBlock"
        case sourcePortRange = "SourcePortRange"
        case trafficDirection = "TrafficDirection"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
    }

    public func validate() throws {
        try destinationPortRange?.validate()
        try sourcePortRange?.validate()
    }
}

public struct CreateTrafficMirrorFilterRuleResult: Codable, Equatable {
    public var clientToken: String?
    public var trafficMirrorFilterRule: TrafficMirrorFilterRule?

    public init(clientToken: String? = nil,
                trafficMirrorFilterRule: TrafficMirrorFilterRule? = nil) {
        self.clientToken = clientToken
        self.trafficMirrorFilterRule = trafficMirrorFilterRule
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case trafficMirrorFilterRule
    }

    public func validate() throws {
        try trafficMirrorFilterRule?.validate()
    }
}

public struct CreateTrafficMirrorSessionRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId
    public var packetLength: Integer?
    public var sessionNumber: Integer
    public var tagSpecifications: TagSpecificationList?
    public var trafficMirrorFilterId: TrafficMirrorFilterId
    public var trafficMirrorTargetId: TrafficMirrorTargetId
    public var virtualNetworkId: Integer?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId,
                packetLength: Integer? = nil,
                sessionNumber: Integer,
                tagSpecifications: TagSpecificationList? = nil,
                trafficMirrorFilterId: TrafficMirrorFilterId,
                trafficMirrorTargetId: TrafficMirrorTargetId,
                virtualNetworkId: Integer? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
        self.packetLength = packetLength
        self.sessionNumber = sessionNumber
        self.tagSpecifications = tagSpecifications
        self.trafficMirrorFilterId = trafficMirrorFilterId
        self.trafficMirrorTargetId = trafficMirrorTargetId
        self.virtualNetworkId = virtualNetworkId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case networkInterfaceId = "NetworkInterfaceId"
        case packetLength = "PacketLength"
        case sessionNumber = "SessionNumber"
        case tagSpecifications = "TagSpecification"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
        case trafficMirrorTargetId = "TrafficMirrorTargetId"
        case virtualNetworkId = "VirtualNetworkId"
    }

    public func validate() throws {
    }
}

public struct CreateTrafficMirrorSessionResult: Codable, Equatable {
    public var clientToken: String?
    public var trafficMirrorSession: TrafficMirrorSession?

    public init(clientToken: String? = nil,
                trafficMirrorSession: TrafficMirrorSession? = nil) {
        self.clientToken = clientToken
        self.trafficMirrorSession = trafficMirrorSession
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case trafficMirrorSession
    }

    public func validate() throws {
        try trafficMirrorSession?.validate()
    }
}

public struct CreateTrafficMirrorTargetRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId?
    public var networkLoadBalancerArn: String?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                networkLoadBalancerArn: String? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
        self.networkLoadBalancerArn = networkLoadBalancerArn
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkLoadBalancerArn = "NetworkLoadBalancerArn"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateTrafficMirrorTargetResult: Codable, Equatable {
    public var clientToken: String?
    public var trafficMirrorTarget: TrafficMirrorTarget?

    public init(clientToken: String? = nil,
                trafficMirrorTarget: TrafficMirrorTarget? = nil) {
        self.clientToken = clientToken
        self.trafficMirrorTarget = trafficMirrorTarget
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case trafficMirrorTarget
    }

    public func validate() throws {
        try trafficMirrorTarget?.validate()
    }
}

public struct CreateTransitGatewayConnectPeerRequest: Codable, Equatable {
    public var bgpOptions: TransitGatewayConnectRequestBgpOptions?
    public var dryRun: Boolean?
    public var insideCidrBlocks: InsideCidrBlocksStringList
    public var peerAddress: String
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayAddress: String?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(bgpOptions: TransitGatewayConnectRequestBgpOptions? = nil,
                dryRun: Boolean? = nil,
                insideCidrBlocks: InsideCidrBlocksStringList,
                peerAddress: String,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayAddress: String? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.bgpOptions = bgpOptions
        self.dryRun = dryRun
        self.insideCidrBlocks = insideCidrBlocks
        self.peerAddress = peerAddress
        self.tagSpecifications = tagSpecifications
        self.transitGatewayAddress = transitGatewayAddress
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case bgpOptions = "BgpOptions"
        case dryRun = "DryRun"
        case insideCidrBlocks = "InsideCidrBlocks"
        case peerAddress = "PeerAddress"
        case tagSpecifications = "TagSpecification"
        case transitGatewayAddress = "TransitGatewayAddress"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
        try bgpOptions?.validate()
    }
}

public struct CreateTransitGatewayConnectPeerResult: Codable, Equatable {
    public var transitGatewayConnectPeer: TransitGatewayConnectPeer?

    public init(transitGatewayConnectPeer: TransitGatewayConnectPeer? = nil) {
        self.transitGatewayConnectPeer = transitGatewayConnectPeer
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayConnectPeer
    }

    public func validate() throws {
        try transitGatewayConnectPeer?.validate()
    }
}

public struct CreateTransitGatewayConnectRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var options: CreateTransitGatewayConnectRequestOptions
    public var tagSpecifications: TagSpecificationList?
    public var transportTransitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                options: CreateTransitGatewayConnectRequestOptions,
                tagSpecifications: TagSpecificationList? = nil,
                transportTransitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.options = options
        self.tagSpecifications = tagSpecifications
        self.transportTransitGatewayAttachmentId = transportTransitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case options = "Options"
        case tagSpecifications = "TagSpecification"
        case transportTransitGatewayAttachmentId = "TransportTransitGatewayAttachmentId"
    }

    public func validate() throws {
        try options.validate()
    }
}

public struct CreateTransitGatewayConnectRequestOptions: Codable, Equatable {
    public var `protocol`: ProtocolValue

    public init(`protocol`: ProtocolValue) {
        self.`protocol` = `protocol`
    }

    enum CodingKeys: String, CodingKey {
        case `protocol` = "Protocol"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayConnectResult: Codable, Equatable {
    public var transitGatewayConnect: TransitGatewayConnect?

    public init(transitGatewayConnect: TransitGatewayConnect? = nil) {
        self.transitGatewayConnect = transitGatewayConnect
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayConnect
    }

    public func validate() throws {
        try transitGatewayConnect?.validate()
    }
}

public struct CreateTransitGatewayMulticastDomainRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var options: CreateTransitGatewayMulticastDomainRequestOptions?
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId

    public init(dryRun: Boolean? = nil,
                options: CreateTransitGatewayMulticastDomainRequestOptions? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId) {
        self.dryRun = dryRun
        self.options = options
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case options = "Options"
        case tagSpecifications = "TagSpecification"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct CreateTransitGatewayMulticastDomainRequestOptions: Codable, Equatable {
    public var autoAcceptSharedAssociations: AutoAcceptSharedAssociationsValue?
    public var igmpv2Support: Igmpv2SupportValue?
    public var staticSourcesSupport: StaticSourcesSupportValue?

    public init(autoAcceptSharedAssociations: AutoAcceptSharedAssociationsValue? = nil,
                igmpv2Support: Igmpv2SupportValue? = nil,
                staticSourcesSupport: StaticSourcesSupportValue? = nil) {
        self.autoAcceptSharedAssociations = autoAcceptSharedAssociations
        self.igmpv2Support = igmpv2Support
        self.staticSourcesSupport = staticSourcesSupport
    }

    enum CodingKeys: String, CodingKey {
        case autoAcceptSharedAssociations = "AutoAcceptSharedAssociations"
        case igmpv2Support = "Igmpv2Support"
        case staticSourcesSupport = "StaticSourcesSupport"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayMulticastDomainResult: Codable, Equatable {
    public var transitGatewayMulticastDomain: TransitGatewayMulticastDomain?

    public init(transitGatewayMulticastDomain: TransitGatewayMulticastDomain? = nil) {
        self.transitGatewayMulticastDomain = transitGatewayMulticastDomain
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayMulticastDomain
    }

    public func validate() throws {
        try transitGatewayMulticastDomain?.validate()
    }
}

public struct CreateTransitGatewayPeeringAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var peerAccountId: String
    public var peerRegion: String
    public var peerTransitGatewayId: TransitAssociationGatewayId
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId

    public init(dryRun: Boolean? = nil,
                peerAccountId: String,
                peerRegion: String,
                peerTransitGatewayId: TransitAssociationGatewayId,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId) {
        self.dryRun = dryRun
        self.peerAccountId = peerAccountId
        self.peerRegion = peerRegion
        self.peerTransitGatewayId = peerTransitGatewayId
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case peerAccountId = "PeerAccountId"
        case peerRegion = "PeerRegion"
        case peerTransitGatewayId = "PeerTransitGatewayId"
        case tagSpecifications = "TagSpecification"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayPeeringAttachmentResult: Codable, Equatable {
    public var transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment?

    public init(transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment? = nil) {
        self.transitGatewayPeeringAttachment = transitGatewayPeeringAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPeeringAttachment
    }

    public func validate() throws {
        try transitGatewayPeeringAttachment?.validate()
    }
}

public struct CreateTransitGatewayPrefixListReferenceRequest: Codable, Equatable {
    public var blackhole: Boolean?
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(blackhole: Boolean? = nil,
                dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.blackhole = blackhole
        self.dryRun = dryRun
        self.prefixListId = prefixListId
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole = "Blackhole"
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayPrefixListReferenceResult: Codable, Equatable {
    public var transitGatewayPrefixListReference: TransitGatewayPrefixListReference?

    public init(transitGatewayPrefixListReference: TransitGatewayPrefixListReference? = nil) {
        self.transitGatewayPrefixListReference = transitGatewayPrefixListReference
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPrefixListReference
    }

    public func validate() throws {
        try transitGatewayPrefixListReference?.validate()
    }
}

public struct CreateTransitGatewayRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var options: TransitGatewayRequestOptions?
    public var tagSpecifications: TagSpecificationList?

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                options: TransitGatewayRequestOptions? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.description = description
        self.dryRun = dryRun
        self.options = options
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case options = "Options"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct CreateTransitGatewayResult: Codable, Equatable {
    public var transitGateway: TransitGateway?

    public init(transitGateway: TransitGateway? = nil) {
        self.transitGateway = transitGateway
    }

    enum CodingKeys: String, CodingKey {
        case transitGateway
    }

    public func validate() throws {
        try transitGateway?.validate()
    }
}

public struct CreateTransitGatewayRouteRequest: Codable, Equatable {
    public var blackhole: Boolean?
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(blackhole: Boolean? = nil,
                destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.blackhole = blackhole
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole = "Blackhole"
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayRouteResult: Codable, Equatable {
    public var route: TransitGatewayRoute?

    public init(route: TransitGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct CreateTransitGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecifications"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayRouteTableResult: Codable, Equatable {
    public var transitGatewayRouteTable: TransitGatewayRouteTable?

    public init(transitGatewayRouteTable: TransitGatewayRouteTable? = nil) {
        self.transitGatewayRouteTable = transitGatewayRouteTable
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayRouteTable
    }

    public func validate() throws {
        try transitGatewayRouteTable?.validate()
    }
}

public struct CreateTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var options: CreateTransitGatewayVpcAttachmentRequestOptions?
    public var subnetIds: TransitGatewaySubnetIdList
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                options: CreateTransitGatewayVpcAttachmentRequestOptions? = nil,
                subnetIds: TransitGatewaySubnetIdList,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.options = options
        self.subnetIds = subnetIds
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case options = "Options"
        case subnetIds = "SubnetIds"
        case tagSpecifications = "TagSpecifications"
        case transitGatewayId = "TransitGatewayId"
        case vpcId = "VpcId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct CreateTransitGatewayVpcAttachmentRequestOptions: Codable, Equatable {
    public var applianceModeSupport: ApplianceModeSupportValue?
    public var dnsSupport: DnsSupportValue?
    public var ipv6Support: Ipv6SupportValue?

    public init(applianceModeSupport: ApplianceModeSupportValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                ipv6Support: Ipv6SupportValue? = nil) {
        self.applianceModeSupport = applianceModeSupport
        self.dnsSupport = dnsSupport
        self.ipv6Support = ipv6Support
    }

    enum CodingKeys: String, CodingKey {
        case applianceModeSupport = "ApplianceModeSupport"
        case dnsSupport = "DnsSupport"
        case ipv6Support = "Ipv6Support"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct CreateVolumePermission: Codable, Equatable {
    public var group: PermissionGroup?
    public var userId: String?

    public init(group: PermissionGroup? = nil,
                userId: String? = nil) {
        self.group = group
        self.userId = userId
    }

    enum CodingKeys: String, CodingKey {
        case group
        case userId
    }

    public func validate() throws {
    }
}

public struct CreateVolumePermissionModifications: Codable, Equatable {
    public var add: CreateVolumePermissionList?
    public var remove: CreateVolumePermissionList?

    public init(add: CreateVolumePermissionList? = nil,
                remove: CreateVolumePermissionList? = nil) {
        self.add = add
        self.remove = remove
    }

    enum CodingKeys: String, CodingKey {
        case add = "Add"
        case remove = "Remove"
    }

    public func validate() throws {
    }
}

public struct CreateVolumeRequest: Codable, Equatable {
    public var availabilityZone: String
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var kmsKeyId: KmsKeyId?
    public var multiAttachEnabled: Boolean?
    public var outpostArn: String?
    public var size: Integer?
    public var snapshotId: SnapshotId?
    public var tagSpecifications: TagSpecificationList?
    public var throughput: Integer?
    public var volumeType: VolumeType?

    public init(availabilityZone: String,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: KmsKeyId? = nil,
                multiAttachEnabled: Boolean? = nil,
                outpostArn: String? = nil,
                size: Integer? = nil,
                snapshotId: SnapshotId? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                throughput: Integer? = nil,
                volumeType: VolumeType? = nil) {
        self.availabilityZone = availabilityZone
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.multiAttachEnabled = multiAttachEnabled
        self.outpostArn = outpostArn
        self.size = size
        self.snapshotId = snapshotId
        self.tagSpecifications = tagSpecifications
        self.throughput = throughput
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case dryRun
        case encrypted
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case multiAttachEnabled = "MultiAttachEnabled"
        case outpostArn = "OutpostArn"
        case size = "Size"
        case snapshotId = "SnapshotId"
        case tagSpecifications = "TagSpecification"
        case throughput = "Throughput"
        case volumeType = "VolumeType"
    }

    public func validate() throws {
    }
}

public struct CreateVpcEndpointConnectionNotificationRequest: Codable, Equatable {
    public var clientToken: String?
    public var connectionEvents: ValueStringList
    public var connectionNotificationArn: String
    public var dryRun: Boolean?
    public var serviceId: VpcEndpointServiceId?
    public var vpcEndpointId: VpcEndpointId?

    public init(clientToken: String? = nil,
                connectionEvents: ValueStringList,
                connectionNotificationArn: String,
                dryRun: Boolean? = nil,
                serviceId: VpcEndpointServiceId? = nil,
                vpcEndpointId: VpcEndpointId? = nil) {
        self.clientToken = clientToken
        self.connectionEvents = connectionEvents
        self.connectionNotificationArn = connectionNotificationArn
        self.dryRun = dryRun
        self.serviceId = serviceId
        self.vpcEndpointId = vpcEndpointId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case connectionEvents = "ConnectionEvents"
        case connectionNotificationArn = "ConnectionNotificationArn"
        case dryRun = "DryRun"
        case serviceId = "ServiceId"
        case vpcEndpointId = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct CreateVpcEndpointConnectionNotificationResult: Codable, Equatable {
    public var clientToken: String?
    public var connectionNotification: ConnectionNotification?

    public init(clientToken: String? = nil,
                connectionNotification: ConnectionNotification? = nil) {
        self.clientToken = clientToken
        self.connectionNotification = connectionNotification
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case connectionNotification
    }

    public func validate() throws {
        try connectionNotification?.validate()
    }
}

public struct CreateVpcEndpointRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var policyDocument: String?
    public var privateDnsEnabled: Boolean?
    public var routeTableIds: VpcEndpointRouteTableIdList?
    public var securityGroupIds: VpcEndpointSecurityGroupIdList?
    public var serviceName: String
    public var subnetIds: VpcEndpointSubnetIdList?
    public var tagSpecifications: TagSpecificationList?
    public var vpcEndpointType: VpcEndpointType?
    public var vpcId: VpcId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                policyDocument: String? = nil,
                privateDnsEnabled: Boolean? = nil,
                routeTableIds: VpcEndpointRouteTableIdList? = nil,
                securityGroupIds: VpcEndpointSecurityGroupIdList? = nil,
                serviceName: String,
                subnetIds: VpcEndpointSubnetIdList? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcEndpointType: VpcEndpointType? = nil,
                vpcId: VpcId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.policyDocument = policyDocument
        self.privateDnsEnabled = privateDnsEnabled
        self.routeTableIds = routeTableIds
        self.securityGroupIds = securityGroupIds
        self.serviceName = serviceName
        self.subnetIds = subnetIds
        self.tagSpecifications = tagSpecifications
        self.vpcEndpointType = vpcEndpointType
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case policyDocument = "PolicyDocument"
        case privateDnsEnabled = "PrivateDnsEnabled"
        case routeTableIds = "RouteTableId"
        case securityGroupIds = "SecurityGroupId"
        case serviceName = "ServiceName"
        case subnetIds = "SubnetId"
        case tagSpecifications = "TagSpecification"
        case vpcEndpointType = "VpcEndpointType"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateVpcEndpointResult: Codable, Equatable {
    public var clientToken: String?
    public var vpcEndpoint: VpcEndpoint?

    public init(clientToken: String? = nil,
                vpcEndpoint: VpcEndpoint? = nil) {
        self.clientToken = clientToken
        self.vpcEndpoint = vpcEndpoint
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case vpcEndpoint
    }

    public func validate() throws {
        try vpcEndpoint?.validate()
    }
}

public struct CreateVpcEndpointServiceConfigurationRequest: Codable, Equatable {
    public var acceptanceRequired: Boolean?
    public var clientToken: String?
    public var dryRun: Boolean?
    public var gatewayLoadBalancerArns: ValueStringList?
    public var networkLoadBalancerArns: ValueStringList?
    public var privateDnsName: String?
    public var tagSpecifications: TagSpecificationList?

    public init(acceptanceRequired: Boolean? = nil,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                gatewayLoadBalancerArns: ValueStringList? = nil,
                networkLoadBalancerArns: ValueStringList? = nil,
                privateDnsName: String? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.acceptanceRequired = acceptanceRequired
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
        self.networkLoadBalancerArns = networkLoadBalancerArns
        self.privateDnsName = privateDnsName
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case acceptanceRequired = "AcceptanceRequired"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case gatewayLoadBalancerArns = "GatewayLoadBalancerArn"
        case networkLoadBalancerArns = "NetworkLoadBalancerArn"
        case privateDnsName = "PrivateDnsName"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateVpcEndpointServiceConfigurationResult: Codable, Equatable {
    public var clientToken: String?
    public var serviceConfiguration: ServiceConfiguration?

    public init(clientToken: String? = nil,
                serviceConfiguration: ServiceConfiguration? = nil) {
        self.clientToken = clientToken
        self.serviceConfiguration = serviceConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case serviceConfiguration
    }

    public func validate() throws {
        try serviceConfiguration?.validate()
    }
}

public struct CreateVpcPeeringConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var peerOwnerId: String?
    public var peerRegion: String?
    public var peerVpcId: String?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId?

    public init(dryRun: Boolean? = nil,
                peerOwnerId: String? = nil,
                peerRegion: String? = nil,
                peerVpcId: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId? = nil) {
        self.dryRun = dryRun
        self.peerOwnerId = peerOwnerId
        self.peerRegion = peerRegion
        self.peerVpcId = peerVpcId
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case peerOwnerId
        case peerRegion = "PeerRegion"
        case peerVpcId
        case tagSpecifications = "TagSpecification"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct CreateVpcPeeringConnectionResult: Codable, Equatable {
    public var vpcPeeringConnection: VpcPeeringConnection?

    public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
        self.vpcPeeringConnection = vpcPeeringConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpcPeeringConnection
    }

    public func validate() throws {
        try vpcPeeringConnection?.validate()
    }
}

public struct CreateVpcRequest: Codable, Equatable {
    public var amazonProvidedIpv6CidrBlock: Boolean?
    public var cidrBlock: String
    public var dryRun: Boolean?
    public var instanceTenancy: Tenancy?
    public var ipv6CidrBlock: String?
    public var ipv6CidrBlockNetworkBorderGroup: String?
    public var ipv6Pool: Ipv6PoolEc2Id?
    public var tagSpecifications: TagSpecificationList?

    public init(amazonProvidedIpv6CidrBlock: Boolean? = nil,
                cidrBlock: String,
                dryRun: Boolean? = nil,
                instanceTenancy: Tenancy? = nil,
                ipv6CidrBlock: String? = nil,
                ipv6CidrBlockNetworkBorderGroup: String? = nil,
                ipv6Pool: Ipv6PoolEc2Id? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
        self.cidrBlock = cidrBlock
        self.dryRun = dryRun
        self.instanceTenancy = instanceTenancy
        self.ipv6CidrBlock = ipv6CidrBlock
        self.ipv6CidrBlockNetworkBorderGroup = ipv6CidrBlockNetworkBorderGroup
        self.ipv6Pool = ipv6Pool
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case amazonProvidedIpv6CidrBlock
        case cidrBlock = "CidrBlock"
        case dryRun
        case instanceTenancy
        case ipv6CidrBlock = "Ipv6CidrBlock"
        case ipv6CidrBlockNetworkBorderGroup = "Ipv6CidrBlockNetworkBorderGroup"
        case ipv6Pool = "Ipv6Pool"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateVpcResult: Codable, Equatable {
    public var vpc: Vpc?

    public init(vpc: Vpc? = nil) {
        self.vpc = vpc
    }

    enum CodingKeys: String, CodingKey {
        case vpc
    }

    public func validate() throws {
        try vpc?.validate()
    }
}

public struct CreateVpnConnectionRequest: Codable, Equatable {
    public var customerGatewayId: CustomerGatewayId
    public var dryRun: Boolean?
    public var options: VpnConnectionOptionsSpecification?
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId?
    public var type: String
    public var vpnGatewayId: VpnGatewayId?

    public init(customerGatewayId: CustomerGatewayId,
                dryRun: Boolean? = nil,
                options: VpnConnectionOptionsSpecification? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId? = nil,
                type: String,
                vpnGatewayId: VpnGatewayId? = nil) {
        self.customerGatewayId = customerGatewayId
        self.dryRun = dryRun
        self.options = options
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
        self.type = type
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case customerGatewayId = "CustomerGatewayId"
        case dryRun
        case options
        case tagSpecifications = "TagSpecification"
        case transitGatewayId = "TransitGatewayId"
        case type = "Type"
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct CreateVpnConnectionResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct CreateVpnConnectionRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var vpnConnectionId: VpnConnectionId

    public init(destinationCidrBlock: String,
                vpnConnectionId: VpnConnectionId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.vpnConnectionId = vpnConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case vpnConnectionId = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct CreateVpnGatewayRequest: Codable, Equatable {
    public var amazonSideAsn: Long?
    public var availabilityZone: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var type: GatewayType

    public init(amazonSideAsn: Long? = nil,
                availabilityZone: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                type: GatewayType) {
        self.amazonSideAsn = amazonSideAsn
        self.availabilityZone = availabilityZone
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case amazonSideAsn = "AmazonSideAsn"
        case availabilityZone = "AvailabilityZone"
        case dryRun
        case tagSpecifications = "TagSpecification"
        case type = "Type"
    }

    public func validate() throws {
    }
}

public struct CreateVpnGatewayResult: Codable, Equatable {
    public var vpnGateway: VpnGateway?

    public init(vpnGateway: VpnGateway? = nil) {
        self.vpnGateway = vpnGateway
    }

    enum CodingKeys: String, CodingKey {
        case vpnGateway
    }

    public func validate() throws {
        try vpnGateway?.validate()
    }
}

public struct CreditSpecification: Codable, Equatable {
    public var cpuCredits: String?

    public init(cpuCredits: String? = nil) {
        self.cpuCredits = cpuCredits
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits
    }

    public func validate() throws {
    }
}

public struct CreditSpecificationRequest: Codable, Equatable {
    public var cpuCredits: String

    public init(cpuCredits: String) {
        self.cpuCredits = cpuCredits
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits = "CpuCredits"
    }

    public func validate() throws {
    }
}

public struct CustomerGateway: Codable, Equatable {
    public var bgpAsn: String?
    public var certificateArn: String?
    public var customerGatewayId: String?
    public var deviceName: String?
    public var ipAddress: String?
    public var state: String?
    public var tags: TagList?
    public var type: String?

    public init(bgpAsn: String? = nil,
                certificateArn: String? = nil,
                customerGatewayId: String? = nil,
                deviceName: String? = nil,
                ipAddress: String? = nil,
                state: String? = nil,
                tags: TagList? = nil,
                type: String? = nil) {
        self.bgpAsn = bgpAsn
        self.certificateArn = certificateArn
        self.customerGatewayId = customerGatewayId
        self.deviceName = deviceName
        self.ipAddress = ipAddress
        self.state = state
        self.tags = tags
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case bgpAsn
        case certificateArn
        case customerGatewayId
        case deviceName
        case ipAddress
        case state
        case tags = "tagSet"
        case type
    }

    public func validate() throws {
    }
}

public struct DeleteCarrierGatewayRequest: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId
    public var dryRun: Boolean?

    public init(carrierGatewayId: CarrierGatewayId,
                dryRun: Boolean? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId = "CarrierGatewayId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeleteCarrierGatewayResult: Codable, Equatable {
    public var carrierGateway: CarrierGateway?

    public init(carrierGateway: CarrierGateway? = nil) {
        self.carrierGateway = carrierGateway
    }

    enum CodingKeys: String, CodingKey {
        case carrierGateway
    }

    public func validate() throws {
        try carrierGateway?.validate()
    }
}

public struct DeleteClientVpnEndpointRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeleteClientVpnEndpointResult: Codable, Equatable {
    public var status: ClientVpnEndpointStatus?

    public init(status: ClientVpnEndpointStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct DeleteClientVpnRouteRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var targetVpcSubnetId: SubnetId?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                targetVpcSubnetId: SubnetId? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.targetVpcSubnetId = targetVpcSubnetId
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case targetVpcSubnetId = "TargetVpcSubnetId"
    }

    public func validate() throws {
    }
}

public struct DeleteClientVpnRouteResult: Codable, Equatable {
    public var status: ClientVpnRouteStatus?

    public init(status: ClientVpnRouteStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct DeleteCustomerGatewayRequest: Codable, Equatable {
    public var customerGatewayId: CustomerGatewayId
    public var dryRun: Boolean?

    public init(customerGatewayId: CustomerGatewayId,
                dryRun: Boolean? = nil) {
        self.customerGatewayId = customerGatewayId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case customerGatewayId = "CustomerGatewayId"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DeleteDhcpOptionsRequest: Codable, Equatable {
    public var dhcpOptionsId: DhcpOptionsId
    public var dryRun: Boolean?

    public init(dhcpOptionsId: DhcpOptionsId,
                dryRun: Boolean? = nil) {
        self.dhcpOptionsId = dhcpOptionsId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptionsId = "DhcpOptionsId"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DeleteEgressOnlyInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId

    public init(dryRun: Boolean? = nil,
                egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId) {
        self.dryRun = dryRun
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case egressOnlyInternetGatewayId = "EgressOnlyInternetGatewayId"
    }

    public func validate() throws {
    }
}

public struct DeleteEgressOnlyInternetGatewayResult: Codable, Equatable {
    public var returnCode: Boolean?

    public init(returnCode: Boolean? = nil) {
        self.returnCode = returnCode
    }

    enum CodingKeys: String, CodingKey {
        case returnCode
    }

    public func validate() throws {
    }
}

public struct DeleteFleetError: Codable, Equatable {
    public var code: DeleteFleetErrorCode?
    public var message: String?

    public init(code: DeleteFleetErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct DeleteFleetErrorItem: Codable, Equatable {
    public var error: DeleteFleetError?
    public var fleetId: FleetId?

    public init(error: DeleteFleetError? = nil,
                fleetId: FleetId? = nil) {
        self.error = error
        self.fleetId = fleetId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case fleetId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct DeleteFleetSuccessItem: Codable, Equatable {
    public var currentFleetState: FleetStateCode?
    public var fleetId: FleetId?
    public var previousFleetState: FleetStateCode?

    public init(currentFleetState: FleetStateCode? = nil,
                fleetId: FleetId? = nil,
                previousFleetState: FleetStateCode? = nil) {
        self.currentFleetState = currentFleetState
        self.fleetId = fleetId
        self.previousFleetState = previousFleetState
    }

    enum CodingKeys: String, CodingKey {
        case currentFleetState
        case fleetId
        case previousFleetState
    }

    public func validate() throws {
    }
}

public struct DeleteFleetsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var fleetIds: FleetIdSet
    public var terminateInstances: Boolean

    public init(dryRun: Boolean? = nil,
                fleetIds: FleetIdSet,
                terminateInstances: Boolean) {
        self.dryRun = dryRun
        self.fleetIds = fleetIds
        self.terminateInstances = terminateInstances
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case fleetIds = "FleetId"
        case terminateInstances = "TerminateInstances"
    }

    public func validate() throws {
    }
}

public struct DeleteFleetsResult: Codable, Equatable {
    public var successfulFleetDeletions: DeleteFleetSuccessSet?
    public var unsuccessfulFleetDeletions: DeleteFleetErrorSet?

    public init(successfulFleetDeletions: DeleteFleetSuccessSet? = nil,
                unsuccessfulFleetDeletions: DeleteFleetErrorSet? = nil) {
        self.successfulFleetDeletions = successfulFleetDeletions
        self.unsuccessfulFleetDeletions = unsuccessfulFleetDeletions
    }

    enum CodingKeys: String, CodingKey {
        case successfulFleetDeletions = "successfulFleetDeletionSet"
        case unsuccessfulFleetDeletions = "unsuccessfulFleetDeletionSet"
    }

    public func validate() throws {
    }
}

public struct DeleteFlowLogsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var flowLogIds: FlowLogIdList

    public init(dryRun: Boolean? = nil,
                flowLogIds: FlowLogIdList) {
        self.dryRun = dryRun
        self.flowLogIds = flowLogIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case flowLogIds = "FlowLogId"
    }

    public func validate() throws {
    }
}

public struct DeleteFlowLogsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DeleteFpgaImageRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var fpgaImageId: FpgaImageId

    public init(dryRun: Boolean? = nil,
                fpgaImageId: FpgaImageId) {
        self.dryRun = dryRun
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case fpgaImageId = "FpgaImageId"
    }

    public func validate() throws {
    }
}

public struct DeleteFpgaImageResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DeleteInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var internetGatewayId: InternetGatewayId

    public init(dryRun: Boolean? = nil,
                internetGatewayId: InternetGatewayId) {
        self.dryRun = dryRun
        self.internetGatewayId = internetGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case internetGatewayId
    }

    public func validate() throws {
    }
}

public struct DeleteKeyPairRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var keyName: KeyPairName?
    public var keyPairId: KeyPairId?

    public init(dryRun: Boolean? = nil,
                keyName: KeyPairName? = nil,
                keyPairId: KeyPairId? = nil) {
        self.dryRun = dryRun
        self.keyName = keyName
        self.keyPairId = keyPairId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case keyName = "KeyName"
        case keyPairId = "KeyPairId"
    }

    public func validate() throws {
    }
}

public struct DeleteLaunchTemplateRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?

    public init(dryRun: Boolean? = nil,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil) {
        self.dryRun = dryRun
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct DeleteLaunchTemplateResult: Codable, Equatable {
    public var launchTemplate: LaunchTemplate?

    public init(launchTemplate: LaunchTemplate? = nil) {
        self.launchTemplate = launchTemplate
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplate
    }

    public func validate() throws {
        try launchTemplate?.validate()
    }
}

public struct DeleteLaunchTemplateVersionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?
    public var versions: VersionStringList

    public init(dryRun: Boolean? = nil,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                versions: VersionStringList) {
        self.dryRun = dryRun
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.versions = versions
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case versions = "LaunchTemplateVersion"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct DeleteLaunchTemplateVersionsResponseErrorItem: Codable, Equatable {
    public var launchTemplateId: String?
    public var launchTemplateName: String?
    public var responseError: ResponseError?
    public var versionNumber: Long?

    public init(launchTemplateId: String? = nil,
                launchTemplateName: String? = nil,
                responseError: ResponseError? = nil,
                versionNumber: Long? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.responseError = responseError
        self.versionNumber = versionNumber
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId
        case launchTemplateName
        case responseError
        case versionNumber
    }

    public func validate() throws {
        try responseError?.validate()
    }
}

public struct DeleteLaunchTemplateVersionsResponseSuccessItem: Codable, Equatable {
    public var launchTemplateId: String?
    public var launchTemplateName: String?
    public var versionNumber: Long?

    public init(launchTemplateId: String? = nil,
                launchTemplateName: String? = nil,
                versionNumber: Long? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.versionNumber = versionNumber
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId
        case launchTemplateName
        case versionNumber
    }

    public func validate() throws {
    }
}

public struct DeleteLaunchTemplateVersionsResult: Codable, Equatable {
    public var successfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseSuccessSet?
    public var unsuccessfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseErrorSet?

    public init(successfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseSuccessSet? = nil,
                unsuccessfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseErrorSet? = nil) {
        self.successfullyDeletedLaunchTemplateVersions = successfullyDeletedLaunchTemplateVersions
        self.unsuccessfullyDeletedLaunchTemplateVersions = unsuccessfullyDeletedLaunchTemplateVersions
    }

    enum CodingKeys: String, CodingKey {
        case successfullyDeletedLaunchTemplateVersions = "successfullyDeletedLaunchTemplateVersionSet"
        case unsuccessfullyDeletedLaunchTemplateVersions = "unsuccessfullyDeletedLaunchTemplateVersionSet"
    }

    public func validate() throws {
    }
}

public struct DeleteLocalGatewayRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId

    public init(destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteLocalGatewayRouteResult: Codable, Equatable {
    public var route: LocalGatewayRoute?

    public init(route: LocalGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct DeleteLocalGatewayRouteTableVpcAssociationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localGatewayRouteTableVpcAssociationId: LocalGatewayRouteTableVpcAssociationId

    public init(dryRun: Boolean? = nil,
                localGatewayRouteTableVpcAssociationId: LocalGatewayRouteTableVpcAssociationId) {
        self.dryRun = dryRun
        self.localGatewayRouteTableVpcAssociationId = localGatewayRouteTableVpcAssociationId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localGatewayRouteTableVpcAssociationId = "LocalGatewayRouteTableVpcAssociationId"
    }

    public func validate() throws {
    }
}

public struct DeleteLocalGatewayRouteTableVpcAssociationResult: Codable, Equatable {
    public var localGatewayRouteTableVpcAssociation: LocalGatewayRouteTableVpcAssociation?

    public init(localGatewayRouteTableVpcAssociation: LocalGatewayRouteTableVpcAssociation? = nil) {
        self.localGatewayRouteTableVpcAssociation = localGatewayRouteTableVpcAssociation
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVpcAssociation
    }

    public func validate() throws {
        try localGatewayRouteTableVpcAssociation?.validate()
    }
}

public struct DeleteManagedPrefixListRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId

    public init(dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId) {
        self.dryRun = dryRun
        self.prefixListId = prefixListId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
    }

    public func validate() throws {
    }
}

public struct DeleteManagedPrefixListResult: Codable, Equatable {
    public var prefixList: ManagedPrefixList?

    public init(prefixList: ManagedPrefixList? = nil) {
        self.prefixList = prefixList
    }

    enum CodingKeys: String, CodingKey {
        case prefixList
    }

    public func validate() throws {
        try prefixList?.validate()
    }
}

public struct DeleteNatGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var natGatewayId: NatGatewayId

    public init(dryRun: Boolean? = nil,
                natGatewayId: NatGatewayId) {
        self.dryRun = dryRun
        self.natGatewayId = natGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case natGatewayId = "NatGatewayId"
    }

    public func validate() throws {
    }
}

public struct DeleteNatGatewayResult: Codable, Equatable {
    public var natGatewayId: String?

    public init(natGatewayId: String? = nil) {
        self.natGatewayId = natGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case natGatewayId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkAclEntryRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var egress: Boolean
    public var networkAclId: NetworkAclId
    public var ruleNumber: Integer

    public init(dryRun: Boolean? = nil,
                egress: Boolean,
                networkAclId: NetworkAclId,
                ruleNumber: Integer) {
        self.dryRun = dryRun
        self.egress = egress
        self.networkAclId = networkAclId
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case egress
        case networkAclId
        case ruleNumber
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkAclRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkAclId: NetworkAclId

    public init(dryRun: Boolean? = nil,
                networkAclId: NetworkAclId) {
        self.dryRun = dryRun
        self.networkAclId = networkAclId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case networkAclId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsAnalysisRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInsightsAnalysisId: NetworkInsightsAnalysisId

    public init(dryRun: Boolean? = nil,
                networkInsightsAnalysisId: NetworkInsightsAnalysisId) {
        self.dryRun = dryRun
        self.networkInsightsAnalysisId = networkInsightsAnalysisId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case networkInsightsAnalysisId = "NetworkInsightsAnalysisId"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsAnalysisResult: Codable, Equatable {
    public var networkInsightsAnalysisId: NetworkInsightsAnalysisId?

    public init(networkInsightsAnalysisId: NetworkInsightsAnalysisId? = nil) {
        self.networkInsightsAnalysisId = networkInsightsAnalysisId
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAnalysisId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsPathRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInsightsPathId: NetworkInsightsPathId

    public init(dryRun: Boolean? = nil,
                networkInsightsPathId: NetworkInsightsPathId) {
        self.dryRun = dryRun
        self.networkInsightsPathId = networkInsightsPathId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case networkInsightsPathId = "NetworkInsightsPathId"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsPathResult: Codable, Equatable {
    public var networkInsightsPathId: NetworkInsightsPathId?

    public init(networkInsightsPathId: NetworkInsightsPathId? = nil) {
        self.networkInsightsPathId = networkInsightsPathId
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsPathId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInterfacePermissionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var force: Boolean?
    public var networkInterfacePermissionId: NetworkInterfacePermissionId

    public init(dryRun: Boolean? = nil,
                force: Boolean? = nil,
                networkInterfacePermissionId: NetworkInterfacePermissionId) {
        self.dryRun = dryRun
        self.force = force
        self.networkInterfacePermissionId = networkInterfacePermissionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case force = "Force"
        case networkInterfacePermissionId = "NetworkInterfacePermissionId"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInterfacePermissionResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInterfaceRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId

    public init(dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId) {
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct DeletePlacementGroupRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupName: PlacementGroupName

    public init(dryRun: Boolean? = nil,
                groupName: PlacementGroupName) {
        self.dryRun = dryRun
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case groupName
    }

    public func validate() throws {
    }
}

public struct DeleteQueuedReservedInstancesError: Codable, Equatable {
    public var code: DeleteQueuedReservedInstancesErrorCode?
    public var message: String?

    public init(code: DeleteQueuedReservedInstancesErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct DeleteQueuedReservedInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var reservedInstancesIds: DeleteQueuedReservedInstancesIdList

    public init(dryRun: Boolean? = nil,
                reservedInstancesIds: DeleteQueuedReservedInstancesIdList) {
        self.dryRun = dryRun
        self.reservedInstancesIds = reservedInstancesIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case reservedInstancesIds = "ReservedInstancesId"
    }

    public func validate() throws {
        try reservedInstancesIds.validateAsDeleteQueuedReservedInstancesIdList()
    }
}

public struct DeleteQueuedReservedInstancesResult: Codable, Equatable {
    public var failedQueuedPurchaseDeletions: FailedQueuedPurchaseDeletionSet?
    public var successfulQueuedPurchaseDeletions: SuccessfulQueuedPurchaseDeletionSet?

    public init(failedQueuedPurchaseDeletions: FailedQueuedPurchaseDeletionSet? = nil,
                successfulQueuedPurchaseDeletions: SuccessfulQueuedPurchaseDeletionSet? = nil) {
        self.failedQueuedPurchaseDeletions = failedQueuedPurchaseDeletions
        self.successfulQueuedPurchaseDeletions = successfulQueuedPurchaseDeletions
    }

    enum CodingKeys: String, CodingKey {
        case failedQueuedPurchaseDeletions = "failedQueuedPurchaseDeletionSet"
        case successfulQueuedPurchaseDeletions = "successfulQueuedPurchaseDeletionSet"
    }

    public func validate() throws {
    }
}

public struct DeleteRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String?
    public var destinationIpv6CidrBlock: String?
    public var destinationPrefixListId: PrefixListResourceId?
    public var dryRun: Boolean?
    public var routeTableId: RouteTableId

    public init(destinationCidrBlock: String? = nil,
                destinationIpv6CidrBlock: String? = nil,
                destinationPrefixListId: PrefixListResourceId? = nil,
                dryRun: Boolean? = nil,
                routeTableId: RouteTableId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        self.destinationPrefixListId = destinationPrefixListId
        self.dryRun = dryRun
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock
        case destinationIpv6CidrBlock
        case destinationPrefixListId = "DestinationPrefixListId"
        case dryRun
        case routeTableId
    }

    public func validate() throws {
    }
}

public struct DeleteRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var routeTableId: RouteTableId

    public init(dryRun: Boolean? = nil,
                routeTableId: RouteTableId) {
        self.dryRun = dryRun
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case routeTableId
    }

    public func validate() throws {
    }
}

public struct DeleteSecurityGroupRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?

    public init(dryRun: Boolean? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil) {
        self.dryRun = dryRun
        self.groupId = groupId
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case groupId = "GroupId"
        case groupName = "GroupName"
    }

    public func validate() throws {
    }
}

public struct DeleteSnapshotRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var snapshotId: SnapshotId

    public init(dryRun: Boolean? = nil,
                snapshotId: SnapshotId) {
        self.dryRun = dryRun
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case snapshotId = "SnapshotId"
    }

    public func validate() throws {
    }
}

public struct DeleteSpotDatafeedSubscriptionRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DeleteSubnetRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetId: SubnetId

    public init(dryRun: Boolean? = nil,
                subnetId: SubnetId) {
        self.dryRun = dryRun
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case subnetId = "SubnetId"
    }

    public func validate() throws {
    }
}

public struct DeleteTagsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var resources: ResourceIdList
    public var tags: TagList?

    public init(dryRun: Boolean? = nil,
                resources: ResourceIdList,
                tags: TagList? = nil) {
        self.dryRun = dryRun
        self.resources = resources
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case resources = "resourceId"
        case tags = "tag"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorFilterRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var trafficMirrorFilterId: TrafficMirrorFilterId

    public init(dryRun: Boolean? = nil,
                trafficMirrorFilterId: TrafficMirrorFilterId) {
        self.dryRun = dryRun
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorFilterResult: Codable, Equatable {
    public var trafficMirrorFilterId: String?

    public init(trafficMirrorFilterId: String? = nil) {
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorFilterId
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorFilterRuleRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var trafficMirrorFilterRuleId: TrafficMirrorFilterRuleId

    public init(dryRun: Boolean? = nil,
                trafficMirrorFilterRuleId: TrafficMirrorFilterRuleId) {
        self.dryRun = dryRun
        self.trafficMirrorFilterRuleId = trafficMirrorFilterRuleId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case trafficMirrorFilterRuleId = "TrafficMirrorFilterRuleId"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorFilterRuleResult: Codable, Equatable {
    public var trafficMirrorFilterRuleId: String?

    public init(trafficMirrorFilterRuleId: String? = nil) {
        self.trafficMirrorFilterRuleId = trafficMirrorFilterRuleId
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorFilterRuleId
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorSessionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var trafficMirrorSessionId: TrafficMirrorSessionId

    public init(dryRun: Boolean? = nil,
                trafficMirrorSessionId: TrafficMirrorSessionId) {
        self.dryRun = dryRun
        self.trafficMirrorSessionId = trafficMirrorSessionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case trafficMirrorSessionId = "TrafficMirrorSessionId"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorSessionResult: Codable, Equatable {
    public var trafficMirrorSessionId: String?

    public init(trafficMirrorSessionId: String? = nil) {
        self.trafficMirrorSessionId = trafficMirrorSessionId
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorSessionId
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorTargetRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var trafficMirrorTargetId: TrafficMirrorTargetId

    public init(dryRun: Boolean? = nil,
                trafficMirrorTargetId: TrafficMirrorTargetId) {
        self.dryRun = dryRun
        self.trafficMirrorTargetId = trafficMirrorTargetId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case trafficMirrorTargetId = "TrafficMirrorTargetId"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorTargetResult: Codable, Equatable {
    public var trafficMirrorTargetId: String?

    public init(trafficMirrorTargetId: String? = nil) {
        self.trafficMirrorTargetId = trafficMirrorTargetId
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorTargetId
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayConnectPeerRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayConnectPeerId: TransitGatewayConnectPeerId

    public init(dryRun: Boolean? = nil,
                transitGatewayConnectPeerId: TransitGatewayConnectPeerId) {
        self.dryRun = dryRun
        self.transitGatewayConnectPeerId = transitGatewayConnectPeerId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayConnectPeerId = "TransitGatewayConnectPeerId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayConnectPeerResult: Codable, Equatable {
    public var transitGatewayConnectPeer: TransitGatewayConnectPeer?

    public init(transitGatewayConnectPeer: TransitGatewayConnectPeer? = nil) {
        self.transitGatewayConnectPeer = transitGatewayConnectPeer
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayConnectPeer
    }

    public func validate() throws {
        try transitGatewayConnectPeer?.validate()
    }
}

public struct DeleteTransitGatewayConnectRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayConnectResult: Codable, Equatable {
    public var transitGatewayConnect: TransitGatewayConnect?

    public init(transitGatewayConnect: TransitGatewayConnect? = nil) {
        self.transitGatewayConnect = transitGatewayConnect
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayConnect
    }

    public func validate() throws {
        try transitGatewayConnect?.validate()
    }
}

public struct DeleteTransitGatewayMulticastDomainRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId

    public init(dryRun: Boolean? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId) {
        self.dryRun = dryRun
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayMulticastDomainResult: Codable, Equatable {
    public var transitGatewayMulticastDomain: TransitGatewayMulticastDomain?

    public init(transitGatewayMulticastDomain: TransitGatewayMulticastDomain? = nil) {
        self.transitGatewayMulticastDomain = transitGatewayMulticastDomain
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayMulticastDomain
    }

    public func validate() throws {
        try transitGatewayMulticastDomain?.validate()
    }
}

public struct DeleteTransitGatewayPeeringAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayPeeringAttachmentResult: Codable, Equatable {
    public var transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment?

    public init(transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment? = nil) {
        self.transitGatewayPeeringAttachment = transitGatewayPeeringAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPeeringAttachment
    }

    public func validate() throws {
        try transitGatewayPeeringAttachment?.validate()
    }
}

public struct DeleteTransitGatewayPrefixListReferenceRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.prefixListId = prefixListId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayPrefixListReferenceResult: Codable, Equatable {
    public var transitGatewayPrefixListReference: TransitGatewayPrefixListReference?

    public init(transitGatewayPrefixListReference: TransitGatewayPrefixListReference? = nil) {
        self.transitGatewayPrefixListReference = transitGatewayPrefixListReference
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPrefixListReference
    }

    public func validate() throws {
        try transitGatewayPrefixListReference?.validate()
    }
}

public struct DeleteTransitGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayId: TransitGatewayId

    public init(dryRun: Boolean? = nil,
                transitGatewayId: TransitGatewayId) {
        self.dryRun = dryRun
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayResult: Codable, Equatable {
    public var transitGateway: TransitGateway?

    public init(transitGateway: TransitGateway? = nil) {
        self.transitGateway = transitGateway
    }

    enum CodingKeys: String, CodingKey {
        case transitGateway
    }

    public func validate() throws {
        try transitGateway?.validate()
    }
}

public struct DeleteTransitGatewayRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayRouteResult: Codable, Equatable {
    public var route: TransitGatewayRoute?

    public init(route: TransitGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct DeleteTransitGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayRouteTableResult: Codable, Equatable {
    public var transitGatewayRouteTable: TransitGatewayRouteTable?

    public init(transitGatewayRouteTable: TransitGatewayRouteTable? = nil) {
        self.transitGatewayRouteTable = transitGatewayRouteTable
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayRouteTable
    }

    public func validate() throws {
        try transitGatewayRouteTable?.validate()
    }
}

public struct DeleteTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct DeleteVolumeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var volumeId: VolumeId

    public init(dryRun: Boolean? = nil,
                volumeId: VolumeId) {
        self.dryRun = dryRun
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointConnectionNotificationsRequest: Codable, Equatable {
    public var connectionNotificationIds: ConnectionNotificationIdsList
    public var dryRun: Boolean?

    public init(connectionNotificationIds: ConnectionNotificationIdsList,
                dryRun: Boolean? = nil) {
        self.connectionNotificationIds = connectionNotificationIds
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case connectionNotificationIds = "ConnectionNotificationId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointConnectionNotificationsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointServiceConfigurationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var serviceIds: VpcEndpointServiceIdList

    public init(dryRun: Boolean? = nil,
                serviceIds: VpcEndpointServiceIdList) {
        self.dryRun = dryRun
        self.serviceIds = serviceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case serviceIds = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointServiceConfigurationsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcEndpointIds: VpcEndpointIdList

    public init(dryRun: Boolean? = nil,
                vpcEndpointIds: VpcEndpointIdList) {
        self.dryRun = dryRun
        self.vpcEndpointIds = vpcEndpointIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case vpcEndpointIds = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DeleteVpcPeeringConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId

    public init(dryRun: Boolean? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId) {
        self.dryRun = dryRun
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct DeleteVpcPeeringConnectionResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpnConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpnConnectionId: VpnConnectionId

    public init(dryRun: Boolean? = nil,
                vpnConnectionId: VpnConnectionId) {
        self.dryRun = dryRun
        self.vpnConnectionId = vpnConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpnConnectionId = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpnConnectionRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var vpnConnectionId: VpnConnectionId

    public init(destinationCidrBlock: String,
                vpnConnectionId: VpnConnectionId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.vpnConnectionId = vpnConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case vpnConnectionId = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpnGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpnGatewayId: VpnGatewayId

    public init(dryRun: Boolean? = nil,
                vpnGatewayId: VpnGatewayId) {
        self.dryRun = dryRun
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct DeprovisionByoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?

    public init(cidr: String,
                dryRun: Boolean? = nil) {
        self.cidr = cidr
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeprovisionByoipCidrResult: Codable, Equatable {
    public var byoipCidr: ByoipCidr?

    public init(byoipCidr: ByoipCidr? = nil) {
        self.byoipCidr = byoipCidr
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidr
    }

    public func validate() throws {
        try byoipCidr?.validate()
    }
}

public struct DeregisterImageRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct DeregisterInstanceEventNotificationAttributesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceTagAttribute: DeregisterInstanceTagAttributeRequest?

    public init(dryRun: Boolean? = nil,
                instanceTagAttribute: DeregisterInstanceTagAttributeRequest? = nil) {
        self.dryRun = dryRun
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceTagAttribute = "InstanceTagAttribute"
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct DeregisterInstanceEventNotificationAttributesResult: Codable, Equatable {
    public var instanceTagAttribute: InstanceTagNotificationAttribute?

    public init(instanceTagAttribute: InstanceTagNotificationAttribute? = nil) {
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case instanceTagAttribute
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct DeregisterInstanceTagAttributeRequest: Codable, Equatable {
    public var includeAllTagsOfInstance: Boolean?
    public var instanceTagKeys: InstanceTagKeySet?

    public init(includeAllTagsOfInstance: Boolean? = nil,
                instanceTagKeys: InstanceTagKeySet? = nil) {
        self.includeAllTagsOfInstance = includeAllTagsOfInstance
        self.instanceTagKeys = instanceTagKeys
    }

    enum CodingKeys: String, CodingKey {
        case includeAllTagsOfInstance = "IncludeAllTagsOfInstance"
        case instanceTagKeys = "InstanceTagKey"
    }

    public func validate() throws {
    }
}

public struct DeregisterTransitGatewayMulticastGroupMembersRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupIpAddress: String?
    public var networkInterfaceIds: TransitGatewayNetworkInterfaceIdList?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                groupIpAddress: String? = nil,
                networkInterfaceIds: TransitGatewayNetworkInterfaceIdList? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.groupIpAddress = groupIpAddress
        self.networkInterfaceIds = networkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupIpAddress = "GroupIpAddress"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct DeregisterTransitGatewayMulticastGroupMembersResult: Codable, Equatable {
    public var deregisteredMulticastGroupMembers: TransitGatewayMulticastDeregisteredGroupMembers?

    public init(deregisteredMulticastGroupMembers: TransitGatewayMulticastDeregisteredGroupMembers? = nil) {
        self.deregisteredMulticastGroupMembers = deregisteredMulticastGroupMembers
    }

    enum CodingKeys: String, CodingKey {
        case deregisteredMulticastGroupMembers
    }

    public func validate() throws {
        try deregisteredMulticastGroupMembers?.validate()
    }
}

public struct DeregisterTransitGatewayMulticastGroupSourcesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupIpAddress: String?
    public var networkInterfaceIds: TransitGatewayNetworkInterfaceIdList?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                groupIpAddress: String? = nil,
                networkInterfaceIds: TransitGatewayNetworkInterfaceIdList? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.groupIpAddress = groupIpAddress
        self.networkInterfaceIds = networkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupIpAddress = "GroupIpAddress"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct DeregisterTransitGatewayMulticastGroupSourcesResult: Codable, Equatable {
    public var deregisteredMulticastGroupSources: TransitGatewayMulticastDeregisteredGroupSources?

    public init(deregisteredMulticastGroupSources: TransitGatewayMulticastDeregisteredGroupSources? = nil) {
        self.deregisteredMulticastGroupSources = deregisteredMulticastGroupSources
    }

    enum CodingKeys: String, CodingKey {
        case deregisteredMulticastGroupSources
    }

    public func validate() throws {
        try deregisteredMulticastGroupSources?.validate()
    }
}

public struct DescribeAccountAttributesRequest: Codable, Equatable {
    public var attributeNames: AccountAttributeNameStringList?
    public var dryRun: Boolean?

    public init(attributeNames: AccountAttributeNameStringList? = nil,
                dryRun: Boolean? = nil) {
        self.attributeNames = attributeNames
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case attributeNames = "attributeName"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DescribeAccountAttributesResult: Codable, Equatable {
    public var accountAttributes: AccountAttributeList?

    public init(accountAttributes: AccountAttributeList? = nil) {
        self.accountAttributes = accountAttributes
    }

    enum CodingKeys: String, CodingKey {
        case accountAttributes = "accountAttributeSet"
    }

    public func validate() throws {
    }
}

public struct DescribeAddressesRequest: Codable, Equatable {
    public var allocationIds: AllocationIdList?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var publicIps: PublicIpStringList?

    public init(allocationIds: AllocationIdList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                publicIps: PublicIpStringList? = nil) {
        self.allocationIds = allocationIds
        self.dryRun = dryRun
        self.filters = filters
        self.publicIps = publicIps
    }

    enum CodingKeys: String, CodingKey {
        case allocationIds = "AllocationId"
        case dryRun
        case filters = "Filter"
        case publicIps = "PublicIp"
    }

    public func validate() throws {
    }
}

public struct DescribeAddressesResult: Codable, Equatable {
    public var addresses: AddressList?

    public init(addresses: AddressList? = nil) {
        self.addresses = addresses
    }

    enum CodingKeys: String, CodingKey {
        case addresses = "addressesSet"
    }

    public func validate() throws {
    }
}

public struct DescribeAggregateIdFormatRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DescribeAggregateIdFormatResult: Codable, Equatable {
    public var statuses: IdFormatList?
    public var useLongIdsAggregated: Boolean?

    public init(statuses: IdFormatList? = nil,
                useLongIdsAggregated: Boolean? = nil) {
        self.statuses = statuses
        self.useLongIdsAggregated = useLongIdsAggregated
    }

    enum CodingKeys: String, CodingKey {
        case statuses = "statusSet"
        case useLongIdsAggregated
    }

    public func validate() throws {
    }
}

public struct DescribeAvailabilityZonesRequest: Codable, Equatable {
    public var allAvailabilityZones: Boolean?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var zoneIds: ZoneIdStringList?
    public var zoneNames: ZoneNameStringList?

    public init(allAvailabilityZones: Boolean? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                zoneIds: ZoneIdStringList? = nil,
                zoneNames: ZoneNameStringList? = nil) {
        self.allAvailabilityZones = allAvailabilityZones
        self.dryRun = dryRun
        self.filters = filters
        self.zoneIds = zoneIds
        self.zoneNames = zoneNames
    }

    enum CodingKeys: String, CodingKey {
        case allAvailabilityZones = "AllAvailabilityZones"
        case dryRun
        case filters = "Filter"
        case zoneIds = "ZoneId"
        case zoneNames = "ZoneName"
    }

    public func validate() throws {
    }
}

public struct DescribeAvailabilityZonesResult: Codable, Equatable {
    public var availabilityZones: AvailabilityZoneList?

    public init(availabilityZones: AvailabilityZoneList? = nil) {
        self.availabilityZones = availabilityZones
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZones = "availabilityZoneInfo"
    }

    public func validate() throws {
    }
}

public struct DescribeBundleTasksRequest: Codable, Equatable {
    public var bundleIds: BundleIdStringList?
    public var dryRun: Boolean?
    public var filters: FilterList?

    public init(bundleIds: BundleIdStringList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil) {
        self.bundleIds = bundleIds
        self.dryRun = dryRun
        self.filters = filters
    }

    enum CodingKeys: String, CodingKey {
        case bundleIds = "BundleId"
        case dryRun
        case filters = "Filter"
    }

    public func validate() throws {
    }
}

public struct DescribeBundleTasksResult: Codable, Equatable {
    public var bundleTasks: BundleTaskList?

    public init(bundleTasks: BundleTaskList? = nil) {
        self.bundleTasks = bundleTasks
    }

    enum CodingKeys: String, CodingKey {
        case bundleTasks = "bundleInstanceTasksSet"
    }

    public func validate() throws {
    }
}

public struct DescribeByoipCidrsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: DescribeByoipCidrsMaxResults
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                maxResults: DescribeByoipCidrsMaxResults,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults.validateAsDescribeByoipCidrsMaxResults()
    }
}

public struct DescribeByoipCidrsResult: Codable, Equatable {
    public var byoipCidrs: ByoipCidrSet?
    public var nextToken: String?

    public init(byoipCidrs: ByoipCidrSet? = nil,
                nextToken: String? = nil) {
        self.byoipCidrs = byoipCidrs
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidrs = "byoipCidrSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeCapacityReservationsRequest: Codable, Equatable {
    public var capacityReservationIds: CapacityReservationIdSet?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeCapacityReservationsMaxResults?
    public var nextToken: String?

    public init(capacityReservationIds: CapacityReservationIdSet? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeCapacityReservationsMaxResults? = nil,
                nextToken: String? = nil) {
        self.capacityReservationIds = capacityReservationIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationIds = "CapacityReservationId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeCapacityReservationsMaxResults()
    }
}

public struct DescribeCapacityReservationsResult: Codable, Equatable {
    public var capacityReservations: CapacityReservationSet?
    public var nextToken: String?

    public init(capacityReservations: CapacityReservationSet? = nil,
                nextToken: String? = nil) {
        self.capacityReservations = capacityReservations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservations = "capacityReservationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeCarrierGatewaysRequest: Codable, Equatable {
    public var carrierGatewayIds: CarrierGatewayIdSet?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: CarrierGatewayMaxResults?
    public var nextToken: String?

    public init(carrierGatewayIds: CarrierGatewayIdSet? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: CarrierGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.carrierGatewayIds = carrierGatewayIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayIds = "CarrierGatewayId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsCarrierGatewayMaxResults()
    }
}

public struct DescribeCarrierGatewaysResult: Codable, Equatable {
    public var carrierGateways: CarrierGatewaySet?
    public var nextToken: String?

    public init(carrierGateways: CarrierGatewaySet? = nil,
                nextToken: String? = nil) {
        self.carrierGateways = carrierGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case carrierGateways = "carrierGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClassicLinkInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var instanceIds: InstanceIdStringList?
    public var maxResults: DescribeClassicLinkInstancesMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                instanceIds: InstanceIdStringList? = nil,
                maxResults: DescribeClassicLinkInstancesMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case instanceIds = "InstanceId"
        case maxResults
        case nextToken
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClassicLinkInstancesMaxResults()
    }
}

public struct DescribeClassicLinkInstancesResult: Codable, Equatable {
    public var instances: ClassicLinkInstanceList?
    public var nextToken: String?

    public init(instances: ClassicLinkInstanceList? = nil,
                nextToken: String? = nil) {
        self.instances = instances
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instances = "instancesSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnAuthorizationRulesRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnAuthorizationRulesMaxResults?
    public var nextToken: NextToken?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnAuthorizationRulesMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnAuthorizationRulesMaxResults()
    }
}

public struct DescribeClientVpnAuthorizationRulesResult: Codable, Equatable {
    public var authorizationRules: AuthorizationRuleSet?
    public var nextToken: NextToken?

    public init(authorizationRules: AuthorizationRuleSet? = nil,
                nextToken: NextToken? = nil) {
        self.authorizationRules = authorizationRules
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case authorizationRules = "authorizationRule"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnConnectionsRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnConnectionsMaxResults?
    public var nextToken: NextToken?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnConnectionsMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnConnectionsMaxResults()
    }
}

public struct DescribeClientVpnConnectionsResult: Codable, Equatable {
    public var connections: ClientVpnConnectionSet?
    public var nextToken: NextToken?

    public init(connections: ClientVpnConnectionSet? = nil,
                nextToken: NextToken? = nil) {
        self.connections = connections
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case connections
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnEndpointsRequest: Codable, Equatable {
    public var clientVpnEndpointIds: ClientVpnEndpointIdList?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnEndpointMaxResults?
    public var nextToken: NextToken?

    public init(clientVpnEndpointIds: ClientVpnEndpointIdList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnEndpointMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpointIds = clientVpnEndpointIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointIds = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnEndpointMaxResults()
    }
}

public struct DescribeClientVpnEndpointsResult: Codable, Equatable {
    public var clientVpnEndpoints: EndpointSet?
    public var nextToken: NextToken?

    public init(clientVpnEndpoints: EndpointSet? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpoints = clientVpnEndpoints
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpoints = "clientVpnEndpoint"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnRoutesRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnRoutesMaxResults?
    public var nextToken: NextToken?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnRoutesMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnRoutesMaxResults()
    }
}

public struct DescribeClientVpnRoutesResult: Codable, Equatable {
    public var nextToken: NextToken?
    public var routes: ClientVpnRouteSet?

    public init(nextToken: NextToken? = nil,
                routes: ClientVpnRouteSet? = nil) {
        self.nextToken = nextToken
        self.routes = routes
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case routes
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnTargetNetworksRequest: Codable, Equatable {
    public var associationIds: ValueStringList?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnTargetNetworksMaxResults?
    public var nextToken: NextToken?

    public init(associationIds: ValueStringList? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnTargetNetworksMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.associationIds = associationIds
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case associationIds = "AssociationIds"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnTargetNetworksMaxResults()
    }
}

public struct DescribeClientVpnTargetNetworksResult: Codable, Equatable {
    public var clientVpnTargetNetworks: TargetNetworkSet?
    public var nextToken: NextToken?

    public init(clientVpnTargetNetworks: TargetNetworkSet? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnTargetNetworks = clientVpnTargetNetworks
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnTargetNetworks
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeCoipPoolsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: CoipPoolMaxResults?
    public var nextToken: String?
    public var poolIds: CoipPoolIdSet?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: CoipPoolMaxResults? = nil,
                nextToken: String? = nil,
                poolIds: CoipPoolIdSet? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolIds = poolIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsCoipPoolMaxResults()
    }
}

public struct DescribeCoipPoolsResult: Codable, Equatable {
    public var coipPools: CoipPoolSet?
    public var nextToken: String?

    public init(coipPools: CoipPoolSet? = nil,
                nextToken: String? = nil) {
        self.coipPools = coipPools
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case coipPools = "coipPoolSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeConversionTasksRequest: Codable, Equatable {
    public var conversionTaskIds: ConversionIdStringList?
    public var dryRun: Boolean?

    public init(conversionTaskIds: ConversionIdStringList? = nil,
                dryRun: Boolean? = nil) {
        self.conversionTaskIds = conversionTaskIds
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case conversionTaskIds = "conversionTaskId"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DescribeConversionTasksResult: Codable, Equatable {
    public var conversionTasks: DescribeConversionTaskList?

    public init(conversionTasks: DescribeConversionTaskList? = nil) {
        self.conversionTasks = conversionTasks
    }

    enum CodingKeys: String, CodingKey {
        case conversionTasks
    }

    public func validate() throws {
    }
}

public struct DescribeCustomerGatewaysRequest: Codable, Equatable {
    public var customerGatewayIds: CustomerGatewayIdStringList?
    public var dryRun: Boolean?
    public var filters: FilterList?

    public init(customerGatewayIds: CustomerGatewayIdStringList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil) {
        self.customerGatewayIds = customerGatewayIds
        self.dryRun = dryRun
        self.filters = filters
    }

    enum CodingKeys: String, CodingKey {
        case customerGatewayIds = "CustomerGatewayId"
        case dryRun
        case filters = "Filter"
    }

    public func validate() throws {
    }
}

public struct DescribeCustomerGatewaysResult: Codable, Equatable {
    public var customerGateways: CustomerGatewayList?

    public init(customerGateways: CustomerGatewayList? = nil) {
        self.customerGateways = customerGateways
    }

    enum CodingKeys: String, CodingKey {
        case customerGateways = "customerGatewaySet"
    }

    public func validate() throws {
    }
}

public struct DescribeDhcpOptionsRequest: Codable, Equatable {
    public var dhcpOptionsIds: DhcpOptionsIdStringList?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeDhcpOptionsMaxResults?
    public var nextToken: String?

    public init(dhcpOptionsIds: DhcpOptionsIdStringList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeDhcpOptionsMaxResults? = nil,
                nextToken: String? = nil) {
        self.dhcpOptionsIds = dhcpOptionsIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptionsIds = "DhcpOptionsId"
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeDhcpOptionsMaxResults()
    }
}

public struct DescribeDhcpOptionsResult: Codable, Equatable {
    public var dhcpOptions: DhcpOptionsList?
    public var nextToken: String?

    public init(dhcpOptions: DhcpOptionsList? = nil,
                nextToken: String? = nil) {
        self.dhcpOptions = dhcpOptions
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptions = "dhcpOptionsSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeEgressOnlyInternetGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var egressOnlyInternetGatewayIds: EgressOnlyInternetGatewayIdList?
    public var filters: FilterList?
    public var maxResults: DescribeEgressOnlyInternetGatewaysMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                egressOnlyInternetGatewayIds: EgressOnlyInternetGatewayIdList? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeEgressOnlyInternetGatewaysMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.egressOnlyInternetGatewayIds = egressOnlyInternetGatewayIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case egressOnlyInternetGatewayIds = "EgressOnlyInternetGatewayId"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeEgressOnlyInternetGatewaysMaxResults()
    }
}

public struct DescribeEgressOnlyInternetGatewaysResult: Codable, Equatable {
    public var egressOnlyInternetGateways: EgressOnlyInternetGatewayList?
    public var nextToken: String?

    public init(egressOnlyInternetGateways: EgressOnlyInternetGatewayList? = nil,
                nextToken: String? = nil) {
        self.egressOnlyInternetGateways = egressOnlyInternetGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case egressOnlyInternetGateways = "egressOnlyInternetGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeElasticGpusRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var elasticGpuIds: ElasticGpuIdSet?
    public var filters: FilterList?
    public var maxResults: DescribeElasticGpusMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                elasticGpuIds: ElasticGpuIdSet? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeElasticGpusMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.elasticGpuIds = elasticGpuIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case elasticGpuIds = "ElasticGpuId"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeElasticGpusMaxResults()
    }
}

public struct DescribeElasticGpusResult: Codable, Equatable {
    public var elasticGpuSet: ElasticGpuSet?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(elasticGpuSet: ElasticGpuSet? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.elasticGpuSet = elasticGpuSet
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case elasticGpuSet
        case maxResults
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeExportImageTasksRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var exportImageTaskIds: ExportImageTaskIdList?
    public var filters: FilterList?
    public var maxResults: DescribeExportImageTasksMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                exportImageTaskIds: ExportImageTaskIdList? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeExportImageTasksMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.exportImageTaskIds = exportImageTaskIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case exportImageTaskIds = "ExportImageTaskId"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeExportImageTasksMaxResults()
    }
}

public struct DescribeExportImageTasksResult: Codable, Equatable {
    public var exportImageTasks: ExportImageTaskList?
    public var nextToken: NextToken?

    public init(exportImageTasks: ExportImageTaskList? = nil,
                nextToken: NextToken? = nil) {
        self.exportImageTasks = exportImageTasks
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case exportImageTasks = "exportImageTaskSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeExportTasksRequest: Codable, Equatable {
    public var exportTaskIds: ExportTaskIdStringList?
    public var filters: FilterList?

    public init(exportTaskIds: ExportTaskIdStringList? = nil,
                filters: FilterList? = nil) {
        self.exportTaskIds = exportTaskIds
        self.filters = filters
    }

    enum CodingKeys: String, CodingKey {
        case exportTaskIds = "exportTaskId"
        case filters = "Filter"
    }

    public func validate() throws {
    }
}

public struct DescribeExportTasksResult: Codable, Equatable {
    public var exportTasks: ExportTaskList?

    public init(exportTasks: ExportTaskList? = nil) {
        self.exportTasks = exportTasks
    }

    enum CodingKeys: String, CodingKey {
        case exportTasks = "exportTaskSet"
    }

    public func validate() throws {
    }
}

public struct DescribeFastSnapshotRestoreSuccessItem: Codable, Equatable {
    public var availabilityZone: String?
    public var disabledTime: MillisecondDateTime?
    public var disablingTime: MillisecondDateTime?
    public var enabledTime: MillisecondDateTime?
    public var enablingTime: MillisecondDateTime?
    public var optimizingTime: MillisecondDateTime?
    public var ownerAlias: String?
    public var ownerId: String?
    public var snapshotId: String?
    public var state: FastSnapshotRestoreStateCode?
    public var stateTransitionReason: String?

    public init(availabilityZone: String? = nil,
                disabledTime: MillisecondDateTime? = nil,
                disablingTime: MillisecondDateTime? = nil,
                enabledTime: MillisecondDateTime? = nil,
                enablingTime: MillisecondDateTime? = nil,
                optimizingTime: MillisecondDateTime? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                snapshotId: String? = nil,
                state: FastSnapshotRestoreStateCode? = nil,
                stateTransitionReason: String? = nil) {
        self.availabilityZone = availabilityZone
        self.disabledTime = disabledTime
        self.disablingTime = disablingTime
        self.enabledTime = enabledTime
        self.enablingTime = enablingTime
        self.optimizingTime = optimizingTime
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.snapshotId = snapshotId
        self.state = state
        self.stateTransitionReason = stateTransitionReason
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case disabledTime
        case disablingTime
        case enabledTime
        case enablingTime
        case optimizingTime
        case ownerAlias
        case ownerId
        case snapshotId
        case state
        case stateTransitionReason
    }

    public func validate() throws {
    }
}

public struct DescribeFastSnapshotRestoresRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeFastSnapshotRestoresMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeFastSnapshotRestoresMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeFastSnapshotRestoresMaxResults()
    }
}

public struct DescribeFastSnapshotRestoresResult: Codable, Equatable {
    public var fastSnapshotRestores: DescribeFastSnapshotRestoreSuccessSet?
    public var nextToken: NextToken?

    public init(fastSnapshotRestores: DescribeFastSnapshotRestoreSuccessSet? = nil,
                nextToken: NextToken? = nil) {
        self.fastSnapshotRestores = fastSnapshotRestores
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case fastSnapshotRestores = "fastSnapshotRestoreSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeFleetError: Codable, Equatable {
    public var errorCode: String?
    public var errorMessage: String?
    public var launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse?
    public var lifecycle: InstanceLifecycle?

    public init(errorCode: String? = nil,
                errorMessage: String? = nil,
                launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse? = nil,
                lifecycle: InstanceLifecycle? = nil) {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.launchTemplateAndOverrides = launchTemplateAndOverrides
        self.lifecycle = lifecycle
    }

    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case launchTemplateAndOverrides
        case lifecycle
    }

    public func validate() throws {
        try launchTemplateAndOverrides?.validate()
    }
}

public struct DescribeFleetHistoryRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var eventType: FleetEventType?
    public var fleetId: FleetId
    public var maxResults: Integer?
    public var nextToken: String?
    public var startTime: DateTime

    public init(dryRun: Boolean? = nil,
                eventType: FleetEventType? = nil,
                fleetId: FleetId,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                startTime: DateTime) {
        self.dryRun = dryRun
        self.eventType = eventType
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case eventType = "EventType"
        case fleetId = "FleetId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func validate() throws {
    }
}

public struct DescribeFleetHistoryResult: Codable, Equatable {
    public var fleetId: FleetId?
    public var historyRecords: HistoryRecordSet?
    public var lastEvaluatedTime: DateTime?
    public var nextToken: String?
    public var startTime: DateTime?

    public init(fleetId: FleetId? = nil,
                historyRecords: HistoryRecordSet? = nil,
                lastEvaluatedTime: DateTime? = nil,
                nextToken: String? = nil,
                startTime: DateTime? = nil) {
        self.fleetId = fleetId
        self.historyRecords = historyRecords
        self.lastEvaluatedTime = lastEvaluatedTime
        self.nextToken = nextToken
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case fleetId
        case historyRecords = "historyRecordSet"
        case lastEvaluatedTime
        case nextToken
        case startTime
    }

    public func validate() throws {
    }
}

public struct DescribeFleetInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var fleetId: FleetId
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                fleetId: FleetId,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case fleetId = "FleetId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeFleetInstancesResult: Codable, Equatable {
    public var activeInstances: ActiveInstanceSet?
    public var fleetId: FleetId?
    public var nextToken: String?

    public init(activeInstances: ActiveInstanceSet? = nil,
                fleetId: FleetId? = nil,
                nextToken: String? = nil) {
        self.activeInstances = activeInstances
        self.fleetId = fleetId
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case activeInstances = "activeInstanceSet"
        case fleetId
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeFleetsInstances: Codable, Equatable {
    public var instanceIds: InstanceIdsSet?
    public var instanceType: InstanceType?
    public var launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse?
    public var lifecycle: InstanceLifecycle?
    public var platform: PlatformValues?

    public init(instanceIds: InstanceIdsSet? = nil,
                instanceType: InstanceType? = nil,
                launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse? = nil,
                lifecycle: InstanceLifecycle? = nil,
                platform: PlatformValues? = nil) {
        self.instanceIds = instanceIds
        self.instanceType = instanceType
        self.launchTemplateAndOverrides = launchTemplateAndOverrides
        self.lifecycle = lifecycle
        self.platform = platform
    }

    enum CodingKeys: String, CodingKey {
        case instanceIds
        case instanceType
        case launchTemplateAndOverrides
        case lifecycle
        case platform
    }

    public func validate() throws {
        try launchTemplateAndOverrides?.validate()
    }
}

public struct DescribeFleetsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var fleetIds: FleetIdSet?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                fleetIds: FleetIdSet? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.fleetIds = fleetIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case fleetIds = "FleetId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeFleetsResult: Codable, Equatable {
    public var fleets: FleetSet?
    public var nextToken: String?

    public init(fleets: FleetSet? = nil,
                nextToken: String? = nil) {
        self.fleets = fleets
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case fleets = "fleetSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeFlowLogsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filter: FilterList?
    public var flowLogIds: FlowLogIdList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filter: FilterList? = nil,
                flowLogIds: FlowLogIdList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filter = filter
        self.flowLogIds = flowLogIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filter = "Filter"
        case flowLogIds = "FlowLogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeFlowLogsResult: Codable, Equatable {
    public var flowLogs: FlowLogSet?
    public var nextToken: String?

    public init(flowLogs: FlowLogSet? = nil,
                nextToken: String? = nil) {
        self.flowLogs = flowLogs
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case flowLogs = "flowLogSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeFpgaImageAttributeRequest: Codable, Equatable {
    public var attribute: FpgaImageAttributeName
    public var dryRun: Boolean?
    public var fpgaImageId: FpgaImageId

    public init(attribute: FpgaImageAttributeName,
                dryRun: Boolean? = nil,
                fpgaImageId: FpgaImageId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun = "DryRun"
        case fpgaImageId = "FpgaImageId"
    }

    public func validate() throws {
    }
}

public struct DescribeFpgaImageAttributeResult: Codable, Equatable {
    public var fpgaImageAttribute: FpgaImageAttribute?

    public init(fpgaImageAttribute: FpgaImageAttribute? = nil) {
        self.fpgaImageAttribute = fpgaImageAttribute
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImageAttribute
    }

    public func validate() throws {
        try fpgaImageAttribute?.validate()
    }
}

public struct DescribeFpgaImagesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var fpgaImageIds: FpgaImageIdList?
    public var maxResults: DescribeFpgaImagesMaxResults?
    public var nextToken: NextToken?
    public var owners: OwnerStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                fpgaImageIds: FpgaImageIdList? = nil,
                maxResults: DescribeFpgaImagesMaxResults? = nil,
                nextToken: NextToken? = nil,
                owners: OwnerStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.fpgaImageIds = fpgaImageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owners = owners
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case fpgaImageIds = "FpgaImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case owners = "Owner"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeFpgaImagesMaxResults()
    }
}

public struct DescribeFpgaImagesResult: Codable, Equatable {
    public var fpgaImages: FpgaImageList?
    public var nextToken: NextToken?

    public init(fpgaImages: FpgaImageList? = nil,
                nextToken: NextToken? = nil) {
        self.fpgaImages = fpgaImages
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImages = "fpgaImageSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeHostReservationOfferingsRequest: Codable, Equatable {
    public var filter: FilterList?
    public var maxDuration: Integer?
    public var maxResults: DescribeHostReservationsMaxResults?
    public var minDuration: Integer?
    public var nextToken: String?
    public var offeringId: OfferingId?

    public init(filter: FilterList? = nil,
                maxDuration: Integer? = nil,
                maxResults: DescribeHostReservationsMaxResults? = nil,
                minDuration: Integer? = nil,
                nextToken: String? = nil,
                offeringId: OfferingId? = nil) {
        self.filter = filter
        self.maxDuration = maxDuration
        self.maxResults = maxResults
        self.minDuration = minDuration
        self.nextToken = nextToken
        self.offeringId = offeringId
    }

    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxDuration = "MaxDuration"
        case maxResults = "MaxResults"
        case minDuration = "MinDuration"
        case nextToken = "NextToken"
        case offeringId = "OfferingId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeHostReservationsMaxResults()
    }
}

public struct DescribeHostReservationOfferingsResult: Codable, Equatable {
    public var nextToken: String?
    public var offeringSet: HostOfferingSet?

    public init(nextToken: String? = nil,
                offeringSet: HostOfferingSet? = nil) {
        self.nextToken = nextToken
        self.offeringSet = offeringSet
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case offeringSet
    }

    public func validate() throws {
    }
}

public struct DescribeHostReservationsRequest: Codable, Equatable {
    public var filter: FilterList?
    public var hostReservationIdSet: HostReservationIdSet?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(filter: FilterList? = nil,
                hostReservationIdSet: HostReservationIdSet? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.filter = filter
        self.hostReservationIdSet = hostReservationIdSet
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case hostReservationIdSet = "HostReservationIdSet"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeHostReservationsResult: Codable, Equatable {
    public var hostReservationSet: HostReservationSet?
    public var nextToken: String?

    public init(hostReservationSet: HostReservationSet? = nil,
                nextToken: String? = nil) {
        self.hostReservationSet = hostReservationSet
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case hostReservationSet
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeHostsRequest: Codable, Equatable {
    public var filter: FilterList?
    public var hostIds: RequestHostIdList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(filter: FilterList? = nil,
                hostIds: RequestHostIdList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.filter = filter
        self.hostIds = hostIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case filter
        case hostIds = "hostId"
        case maxResults
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeHostsResult: Codable, Equatable {
    public var hosts: HostList?
    public var nextToken: String?

    public init(hosts: HostList? = nil,
                nextToken: String? = nil) {
        self.hosts = hosts
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case hosts = "hostSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeIamInstanceProfileAssociationsRequest: Codable, Equatable {
    public var associationIds: AssociationIdList?
    public var filters: FilterList?
    public var maxResults: DescribeIamInstanceProfileAssociationsMaxResults?
    public var nextToken: NextToken?

    public init(associationIds: AssociationIdList? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeIamInstanceProfileAssociationsMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.associationIds = associationIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case associationIds = "AssociationId"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeIamInstanceProfileAssociationsMaxResults()
    }
}

public struct DescribeIamInstanceProfileAssociationsResult: Codable, Equatable {
    public var iamInstanceProfileAssociations: IamInstanceProfileAssociationSet?
    public var nextToken: NextToken?

    public init(iamInstanceProfileAssociations: IamInstanceProfileAssociationSet? = nil,
                nextToken: NextToken? = nil) {
        self.iamInstanceProfileAssociations = iamInstanceProfileAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfileAssociations = "iamInstanceProfileAssociationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeIdFormatRequest: Codable, Equatable {
    public var resource: String?

    public init(resource: String? = nil) {
        self.resource = resource
    }

    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
    }

    public func validate() throws {
    }
}

public struct DescribeIdFormatResult: Codable, Equatable {
    public var statuses: IdFormatList?

    public init(statuses: IdFormatList? = nil) {
        self.statuses = statuses
    }

    enum CodingKeys: String, CodingKey {
        case statuses = "statusSet"
    }

    public func validate() throws {
    }
}

public struct DescribeIdentityIdFormatRequest: Codable, Equatable {
    public var principalArn: String
    public var resource: String?

    public init(principalArn: String,
                resource: String? = nil) {
        self.principalArn = principalArn
        self.resource = resource
    }

    enum CodingKeys: String, CodingKey {
        case principalArn
        case resource
    }

    public func validate() throws {
    }
}

public struct DescribeIdentityIdFormatResult: Codable, Equatable {
    public var statuses: IdFormatList?

    public init(statuses: IdFormatList? = nil) {
        self.statuses = statuses
    }

    enum CodingKeys: String, CodingKey {
        case statuses = "statusSet"
    }

    public func validate() throws {
    }
}

public struct DescribeImageAttributeRequest: Codable, Equatable {
    public var attribute: ImageAttributeName
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(attribute: ImageAttributeName,
                dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct DescribeImagesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var executableUsers: ExecutableByStringList?
    public var filters: FilterList?
    public var imageIds: ImageIdStringList?
    public var owners: OwnerStringList?

    public init(dryRun: Boolean? = nil,
                executableUsers: ExecutableByStringList? = nil,
                filters: FilterList? = nil,
                imageIds: ImageIdStringList? = nil,
                owners: OwnerStringList? = nil) {
        self.dryRun = dryRun
        self.executableUsers = executableUsers
        self.filters = filters
        self.imageIds = imageIds
        self.owners = owners
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case executableUsers = "ExecutableBy"
        case filters = "Filter"
        case imageIds = "ImageId"
        case owners = "Owner"
    }

    public func validate() throws {
    }
}

public struct DescribeImagesResult: Codable, Equatable {
    public var images: ImageList?

    public init(images: ImageList? = nil) {
        self.images = images
    }

    enum CodingKeys: String, CodingKey {
        case images = "imagesSet"
    }

    public func validate() throws {
    }
}

public struct DescribeImportImageTasksRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var importTaskIds: ImportTaskIdList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                importTaskIds: ImportTaskIdList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.importTaskIds = importTaskIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filters"
        case importTaskIds = "ImportTaskId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeImportImageTasksResult: Codable, Equatable {
    public var importImageTasks: ImportImageTaskList?
    public var nextToken: String?

    public init(importImageTasks: ImportImageTaskList? = nil,
                nextToken: String? = nil) {
        self.importImageTasks = importImageTasks
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case importImageTasks = "importImageTaskSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeImportSnapshotTasksRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var importTaskIds: ImportSnapshotTaskIdList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                importTaskIds: ImportSnapshotTaskIdList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.importTaskIds = importTaskIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filters"
        case importTaskIds = "ImportTaskId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeImportSnapshotTasksResult: Codable, Equatable {
    public var importSnapshotTasks: ImportSnapshotTaskList?
    public var nextToken: String?

    public init(importSnapshotTasks: ImportSnapshotTaskList? = nil,
                nextToken: String? = nil) {
        self.importSnapshotTasks = importSnapshotTasks
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case importSnapshotTasks = "importSnapshotTaskSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceAttributeRequest: Codable, Equatable {
    public var attribute: InstanceAttributeName
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(attribute: InstanceAttributeName,
                dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case attribute
        case dryRun
        case instanceId
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceCreditSpecificationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var instanceIds: InstanceIdStringList?
    public var maxResults: DescribeInstanceCreditSpecificationsMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                instanceIds: InstanceIdStringList? = nil,
                maxResults: DescribeInstanceCreditSpecificationsMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case instanceIds = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeInstanceCreditSpecificationsMaxResults()
    }
}

public struct DescribeInstanceCreditSpecificationsResult: Codable, Equatable {
    public var instanceCreditSpecifications: InstanceCreditSpecificationList?
    public var nextToken: String?

    public init(instanceCreditSpecifications: InstanceCreditSpecificationList? = nil,
                nextToken: String? = nil) {
        self.instanceCreditSpecifications = instanceCreditSpecifications
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceCreditSpecifications = "instanceCreditSpecificationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceEventNotificationAttributesRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceEventNotificationAttributesResult: Codable, Equatable {
    public var instanceTagAttribute: InstanceTagNotificationAttribute?

    public init(instanceTagAttribute: InstanceTagNotificationAttribute? = nil) {
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case instanceTagAttribute
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct DescribeInstanceStatusRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var includeAllInstances: Boolean?
    public var instanceIds: InstanceIdStringList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                includeAllInstances: Boolean? = nil,
                instanceIds: InstanceIdStringList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.includeAllInstances = includeAllInstances
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case includeAllInstances
        case instanceIds = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceStatusResult: Codable, Equatable {
    public var instanceStatuses: InstanceStatusList?
    public var nextToken: String?

    public init(instanceStatuses: InstanceStatusList? = nil,
                nextToken: String? = nil) {
        self.instanceStatuses = instanceStatuses
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceStatuses = "instanceStatusSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceTypeOfferingsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var locationType: LocationType?
    public var maxResults: DITOMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                locationType: LocationType? = nil,
                maxResults: DITOMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.locationType = locationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case locationType = "LocationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDITOMaxResults()
    }
}

public struct DescribeInstanceTypeOfferingsResult: Codable, Equatable {
    public var instanceTypeOfferings: InstanceTypeOfferingsList?
    public var nextToken: NextToken?

    public init(instanceTypeOfferings: InstanceTypeOfferingsList? = nil,
                nextToken: NextToken? = nil) {
        self.instanceTypeOfferings = instanceTypeOfferings
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceTypeOfferings = "instanceTypeOfferingSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceTypesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var instanceTypes: RequestInstanceTypeList?
    public var maxResults: DITMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                instanceTypes: RequestInstanceTypeList? = nil,
                maxResults: DITMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.instanceTypes = instanceTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case instanceTypes = "InstanceType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try instanceTypes?.validateAsRequestInstanceTypeList()
        try maxResults?.validateAsDITMaxResults()
    }
}

public struct DescribeInstanceTypesResult: Codable, Equatable {
    public var instanceTypes: InstanceTypeInfoList?
    public var nextToken: NextToken?

    public init(instanceTypes: InstanceTypeInfoList? = nil,
                nextToken: NextToken? = nil) {
        self.instanceTypes = instanceTypes
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceTypes = "instanceTypeSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var instanceIds: InstanceIdStringList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                instanceIds: InstanceIdStringList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case instanceIds = "InstanceId"
        case maxResults
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstancesResult: Codable, Equatable {
    public var nextToken: String?
    public var reservations: ReservationList?

    public init(nextToken: String? = nil,
                reservations: ReservationList? = nil) {
        self.nextToken = nextToken
        self.reservations = reservations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case reservations = "reservationSet"
    }

    public func validate() throws {
    }
}

public struct DescribeInternetGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var internetGatewayIds: InternetGatewayIdList?
    public var maxResults: DescribeInternetGatewaysMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                internetGatewayIds: InternetGatewayIdList? = nil,
                maxResults: DescribeInternetGatewaysMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.internetGatewayIds = internetGatewayIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case internetGatewayIds = "internetGatewayId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeInternetGatewaysMaxResults()
    }
}

public struct DescribeInternetGatewaysResult: Codable, Equatable {
    public var internetGateways: InternetGatewayList?
    public var nextToken: String?

    public init(internetGateways: InternetGatewayList? = nil,
                nextToken: String? = nil) {
        self.internetGateways = internetGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case internetGateways = "internetGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeIpv6PoolsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Ipv6PoolMaxResults?
    public var nextToken: NextToken?
    public var poolIds: Ipv6PoolIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Ipv6PoolMaxResults? = nil,
                nextToken: NextToken? = nil,
                poolIds: Ipv6PoolIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolIds = poolIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsIpv6PoolMaxResults()
    }
}

public struct DescribeIpv6PoolsResult: Codable, Equatable {
    public var ipv6Pools: Ipv6PoolSet?
    public var nextToken: NextToken?

    public init(ipv6Pools: Ipv6PoolSet? = nil,
                nextToken: NextToken? = nil) {
        self.ipv6Pools = ipv6Pools
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Pools = "ipv6PoolSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeKeyPairsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var keyNames: KeyNameStringList?
    public var keyPairIds: KeyPairIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                keyNames: KeyNameStringList? = nil,
                keyPairIds: KeyPairIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.keyNames = keyNames
        self.keyPairIds = keyPairIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case keyNames = "KeyName"
        case keyPairIds = "KeyPairId"
    }

    public func validate() throws {
    }
}

public struct DescribeKeyPairsResult: Codable, Equatable {
    public var keyPairs: KeyPairList?

    public init(keyPairs: KeyPairList? = nil) {
        self.keyPairs = keyPairs
    }

    enum CodingKeys: String, CodingKey {
        case keyPairs = "keySet"
    }

    public func validate() throws {
    }
}

public struct DescribeLaunchTemplateVersionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?
    public var maxResults: Integer?
    public var maxVersion: String?
    public var minVersion: String?
    public var nextToken: String?
    public var versions: VersionStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                maxResults: Integer? = nil,
                maxVersion: String? = nil,
                minVersion: String? = nil,
                nextToken: String? = nil,
                versions: VersionStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.maxResults = maxResults
        self.maxVersion = maxVersion
        self.minVersion = minVersion
        self.nextToken = nextToken
        self.versions = versions
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case maxResults = "MaxResults"
        case maxVersion = "MaxVersion"
        case minVersion = "MinVersion"
        case nextToken = "NextToken"
        case versions = "LaunchTemplateVersion"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct DescribeLaunchTemplateVersionsResult: Codable, Equatable {
    public var launchTemplateVersions: LaunchTemplateVersionSet?
    public var nextToken: String?

    public init(launchTemplateVersions: LaunchTemplateVersionSet? = nil,
                nextToken: String? = nil) {
        self.launchTemplateVersions = launchTemplateVersions
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateVersions = "launchTemplateVersionSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLaunchTemplatesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var launchTemplateIds: LaunchTemplateIdStringList?
    public var launchTemplateNames: LaunchTemplateNameStringList?
    public var maxResults: DescribeLaunchTemplatesMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                launchTemplateIds: LaunchTemplateIdStringList? = nil,
                launchTemplateNames: LaunchTemplateNameStringList? = nil,
                maxResults: DescribeLaunchTemplatesMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.launchTemplateIds = launchTemplateIds
        self.launchTemplateNames = launchTemplateNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case launchTemplateIds = "LaunchTemplateId"
        case launchTemplateNames = "LaunchTemplateName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeLaunchTemplatesMaxResults()
    }
}

public struct DescribeLaunchTemplatesResult: Codable, Equatable {
    public var launchTemplates: LaunchTemplateSet?
    public var nextToken: String?

    public init(launchTemplates: LaunchTemplateSet? = nil,
                nextToken: String? = nil) {
        self.launchTemplates = launchTemplates
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplates
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayRouteTableVirtualInterfaceGroupAssociationIds: LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayRouteTableVirtualInterfaceGroupAssociationIds: LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayRouteTableVirtualInterfaceGroupAssociationIds = localGatewayRouteTableVirtualInterfaceGroupAssociationIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayRouteTableVirtualInterfaceGroupAssociationIds = "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult: Codable, Equatable {
    public var localGatewayRouteTableVirtualInterfaceGroupAssociations: LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet?
    public var nextToken: String?

    public init(localGatewayRouteTableVirtualInterfaceGroupAssociations: LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayRouteTableVirtualInterfaceGroupAssociations = localGatewayRouteTableVirtualInterfaceGroupAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVirtualInterfaceGroupAssociations = "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayRouteTableVpcAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayRouteTableVpcAssociationIds: LocalGatewayRouteTableVpcAssociationIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayRouteTableVpcAssociationIds: LocalGatewayRouteTableVpcAssociationIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayRouteTableVpcAssociationIds = localGatewayRouteTableVpcAssociationIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayRouteTableVpcAssociationIds = "LocalGatewayRouteTableVpcAssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayRouteTableVpcAssociationsResult: Codable, Equatable {
    public var localGatewayRouteTableVpcAssociations: LocalGatewayRouteTableVpcAssociationSet?
    public var nextToken: String?

    public init(localGatewayRouteTableVpcAssociations: LocalGatewayRouteTableVpcAssociationSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayRouteTableVpcAssociations = localGatewayRouteTableVpcAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVpcAssociations = "localGatewayRouteTableVpcAssociationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayRouteTablesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayRouteTableIds: LocalGatewayRouteTableIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayRouteTableIds: LocalGatewayRouteTableIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayRouteTableIds = localGatewayRouteTableIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayRouteTableIds = "LocalGatewayRouteTableId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayRouteTablesResult: Codable, Equatable {
    public var localGatewayRouteTables: LocalGatewayRouteTableSet?
    public var nextToken: String?

    public init(localGatewayRouteTables: LocalGatewayRouteTableSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayRouteTables = localGatewayRouteTables
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTables = "localGatewayRouteTableSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayVirtualInterfaceGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayVirtualInterfaceGroupIds: LocalGatewayVirtualInterfaceGroupIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayVirtualInterfaceGroupIds: LocalGatewayVirtualInterfaceGroupIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayVirtualInterfaceGroupIds = localGatewayVirtualInterfaceGroupIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayVirtualInterfaceGroupIds = "LocalGatewayVirtualInterfaceGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayVirtualInterfaceGroupsResult: Codable, Equatable {
    public var localGatewayVirtualInterfaceGroups: LocalGatewayVirtualInterfaceGroupSet?
    public var nextToken: String?

    public init(localGatewayVirtualInterfaceGroups: LocalGatewayVirtualInterfaceGroupSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayVirtualInterfaceGroups = localGatewayVirtualInterfaceGroups
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayVirtualInterfaceGroups = "localGatewayVirtualInterfaceGroupSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayVirtualInterfacesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayVirtualInterfaceIds: LocalGatewayVirtualInterfaceIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayVirtualInterfaceIds: LocalGatewayVirtualInterfaceIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayVirtualInterfaceIds = localGatewayVirtualInterfaceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayVirtualInterfaceIds = "LocalGatewayVirtualInterfaceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayVirtualInterfacesResult: Codable, Equatable {
    public var localGatewayVirtualInterfaces: LocalGatewayVirtualInterfaceSet?
    public var nextToken: String?

    public init(localGatewayVirtualInterfaces: LocalGatewayVirtualInterfaceSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayVirtualInterfaces = localGatewayVirtualInterfaces
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayVirtualInterfaces = "localGatewayVirtualInterfaceSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayIds: LocalGatewayIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayIds: LocalGatewayIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayIds = localGatewayIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayIds = "LocalGatewayId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewaysResult: Codable, Equatable {
    public var localGateways: LocalGatewaySet?
    public var nextToken: String?

    public init(localGateways: LocalGatewaySet? = nil,
                nextToken: String? = nil) {
        self.localGateways = localGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGateways = "localGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeManagedPrefixListsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: PrefixListMaxResults?
    public var nextToken: NextToken?
    public var prefixListIds: ValueStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: PrefixListMaxResults? = nil,
                nextToken: NextToken? = nil,
                prefixListIds: ValueStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.prefixListIds = prefixListIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case prefixListIds = "PrefixListId"
    }

    public func validate() throws {
        try maxResults?.validateAsPrefixListMaxResults()
    }
}

public struct DescribeManagedPrefixListsResult: Codable, Equatable {
    public var nextToken: NextToken?
    public var prefixLists: ManagedPrefixListSet?

    public init(nextToken: NextToken? = nil,
                prefixLists: ManagedPrefixListSet? = nil) {
        self.nextToken = nextToken
        self.prefixLists = prefixLists
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case prefixLists = "prefixListSet"
    }

    public func validate() throws {
    }
}

public struct DescribeMovingAddressesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeMovingAddressesMaxResults?
    public var nextToken: String?
    public var publicIps: ValueStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeMovingAddressesMaxResults? = nil,
                nextToken: String? = nil,
                publicIps: ValueStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.publicIps = publicIps
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "filter"
        case maxResults
        case nextToken
        case publicIps = "publicIp"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeMovingAddressesMaxResults()
    }
}

public struct DescribeMovingAddressesResult: Codable, Equatable {
    public var movingAddressStatuses: MovingAddressStatusSet?
    public var nextToken: String?

    public init(movingAddressStatuses: MovingAddressStatusSet? = nil,
                nextToken: String? = nil) {
        self.movingAddressStatuses = movingAddressStatuses
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case movingAddressStatuses = "movingAddressStatusSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNatGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filter: FilterList?
    public var maxResults: DescribeNatGatewaysMaxResults?
    public var natGatewayIds: NatGatewayIdStringList?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filter: FilterList? = nil,
                maxResults: DescribeNatGatewaysMaxResults? = nil,
                natGatewayIds: NatGatewayIdStringList? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filter = filter
        self.maxResults = maxResults
        self.natGatewayIds = natGatewayIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case natGatewayIds = "NatGatewayId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeNatGatewaysMaxResults()
    }
}

public struct DescribeNatGatewaysResult: Codable, Equatable {
    public var natGateways: NatGatewayList?
    public var nextToken: String?

    public init(natGateways: NatGatewayList? = nil,
                nextToken: String? = nil) {
        self.natGateways = natGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case natGateways = "natGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkAclsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeNetworkAclsMaxResults?
    public var networkAclIds: NetworkAclIdStringList?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeNetworkAclsMaxResults? = nil,
                networkAclIds: NetworkAclIdStringList? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkAclIds = networkAclIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkAclIds = "NetworkAclId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeNetworkAclsMaxResults()
    }
}

public struct DescribeNetworkAclsResult: Codable, Equatable {
    public var networkAcls: NetworkAclList?
    public var nextToken: String?

    public init(networkAcls: NetworkAclList? = nil,
                nextToken: String? = nil) {
        self.networkAcls = networkAcls
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkAcls = "networkAclSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInsightsAnalysesRequest: Codable, Equatable {
    public var analysisEndTime: MillisecondDateTime?
    public var analysisStartTime: MillisecondDateTime?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: NetworkInsightsMaxResults?
    public var networkInsightsAnalysisIds: NetworkInsightsAnalysisIdList?
    public var networkInsightsPathId: NetworkInsightsPathId?
    public var nextToken: NextToken?

    public init(analysisEndTime: MillisecondDateTime? = nil,
                analysisStartTime: MillisecondDateTime? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: NetworkInsightsMaxResults? = nil,
                networkInsightsAnalysisIds: NetworkInsightsAnalysisIdList? = nil,
                networkInsightsPathId: NetworkInsightsPathId? = nil,
                nextToken: NextToken? = nil) {
        self.analysisEndTime = analysisEndTime
        self.analysisStartTime = analysisStartTime
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkInsightsAnalysisIds = networkInsightsAnalysisIds
        self.networkInsightsPathId = networkInsightsPathId
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case analysisEndTime = "AnalysisEndTime"
        case analysisStartTime = "AnalysisStartTime"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkInsightsAnalysisIds = "NetworkInsightsAnalysisId"
        case networkInsightsPathId = "NetworkInsightsPathId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsNetworkInsightsMaxResults()
    }
}

public struct DescribeNetworkInsightsAnalysesResult: Codable, Equatable {
    public var networkInsightsAnalyses: NetworkInsightsAnalysisList?
    public var nextToken: String?

    public init(networkInsightsAnalyses: NetworkInsightsAnalysisList? = nil,
                nextToken: String? = nil) {
        self.networkInsightsAnalyses = networkInsightsAnalyses
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAnalyses = "networkInsightsAnalysisSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInsightsPathsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: NetworkInsightsMaxResults?
    public var networkInsightsPathIds: NetworkInsightsPathIdList?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: NetworkInsightsMaxResults? = nil,
                networkInsightsPathIds: NetworkInsightsPathIdList? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkInsightsPathIds = networkInsightsPathIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkInsightsPathIds = "NetworkInsightsPathId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsNetworkInsightsMaxResults()
    }
}

public struct DescribeNetworkInsightsPathsResult: Codable, Equatable {
    public var networkInsightsPaths: NetworkInsightsPathList?
    public var nextToken: String?

    public init(networkInsightsPaths: NetworkInsightsPathList? = nil,
                nextToken: String? = nil) {
        self.networkInsightsPaths = networkInsightsPaths
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsPaths = "networkInsightsPathSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInterfaceAttributeRequest: Codable, Equatable {
    public var attribute: NetworkInterfaceAttribute?
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId

    public init(attribute: NetworkInterfaceAttribute? = nil,
                dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case attribute
        case dryRun
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInterfaceAttributeResult: Codable, Equatable {
    public var attachment: NetworkInterfaceAttachment?
    public var description: AttributeValue?
    public var groups: GroupIdentifierList?
    public var networkInterfaceId: String?
    public var sourceDestCheck: AttributeBooleanValue?

    public init(attachment: NetworkInterfaceAttachment? = nil,
                description: AttributeValue? = nil,
                groups: GroupIdentifierList? = nil,
                networkInterfaceId: String? = nil,
                sourceDestCheck: AttributeBooleanValue? = nil) {
        self.attachment = attachment
        self.description = description
        self.groups = groups
        self.networkInterfaceId = networkInterfaceId
        self.sourceDestCheck = sourceDestCheck
    }

    enum CodingKeys: String, CodingKey {
        case attachment
        case description
        case groups = "groupSet"
        case networkInterfaceId
        case sourceDestCheck
    }

    public func validate() throws {
        try attachment?.validate()
        try description?.validate()
        try sourceDestCheck?.validate()
    }
}

public struct DescribeNetworkInterfacePermissionsRequest: Codable, Equatable {
    public var filters: FilterList?
    public var maxResults: DescribeNetworkInterfacePermissionsMaxResults?
    public var networkInterfacePermissionIds: NetworkInterfacePermissionIdList?
    public var nextToken: String?

    public init(filters: FilterList? = nil,
                maxResults: DescribeNetworkInterfacePermissionsMaxResults? = nil,
                networkInterfacePermissionIds: NetworkInterfacePermissionIdList? = nil,
                nextToken: String? = nil) {
        self.filters = filters
        self.maxResults = maxResults
        self.networkInterfacePermissionIds = networkInterfacePermissionIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkInterfacePermissionIds = "NetworkInterfacePermissionId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeNetworkInterfacePermissionsMaxResults()
    }
}

public struct DescribeNetworkInterfacePermissionsResult: Codable, Equatable {
    public var networkInterfacePermissions: NetworkInterfacePermissionList?
    public var nextToken: String?

    public init(networkInterfacePermissions: NetworkInterfacePermissionList? = nil,
                nextToken: String? = nil) {
        self.networkInterfacePermissions = networkInterfacePermissions
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInterfacePermissions
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInterfacesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeNetworkInterfacesMaxResults?
    public var networkInterfaceIds: NetworkInterfaceIdList?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeNetworkInterfacesMaxResults? = nil,
                networkInterfaceIds: NetworkInterfaceIdList? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkInterfaceIds = networkInterfaceIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "filter"
        case maxResults = "MaxResults"
        case networkInterfaceIds = "NetworkInterfaceId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeNetworkInterfacesMaxResults()
    }
}

public struct DescribeNetworkInterfacesResult: Codable, Equatable {
    public var networkInterfaces: NetworkInterfaceList?
    public var nextToken: String?

    public init(networkInterfaces: NetworkInterfaceList? = nil,
                nextToken: String? = nil) {
        self.networkInterfaces = networkInterfaces
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInterfaces = "networkInterfaceSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribePlacementGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var groupIds: PlacementGroupIdStringList?
    public var groupNames: PlacementGroupStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                groupIds: PlacementGroupIdStringList? = nil,
                groupNames: PlacementGroupStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.groupIds = groupIds
        self.groupNames = groupNames
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case groupIds = "GroupId"
        case groupNames = "groupName"
    }

    public func validate() throws {
    }
}

public struct DescribePlacementGroupsResult: Codable, Equatable {
    public var placementGroups: PlacementGroupList?

    public init(placementGroups: PlacementGroupList? = nil) {
        self.placementGroups = placementGroups
    }

    enum CodingKeys: String, CodingKey {
        case placementGroups = "placementGroupSet"
    }

    public func validate() throws {
    }
}

public struct DescribePrefixListsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var prefixListIds: PrefixListResourceIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                prefixListIds: PrefixListResourceIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.prefixListIds = prefixListIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case prefixListIds = "PrefixListId"
    }

    public func validate() throws {
    }
}

public struct DescribePrefixListsResult: Codable, Equatable {
    public var nextToken: String?
    public var prefixLists: PrefixListSet?

    public init(nextToken: String? = nil,
                prefixLists: PrefixListSet? = nil) {
        self.nextToken = nextToken
        self.prefixLists = prefixLists
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case prefixLists = "prefixListSet"
    }

    public func validate() throws {
    }
}

public struct DescribePrincipalIdFormatRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: DescribePrincipalIdFormatMaxResults?
    public var nextToken: String?
    public var resources: ResourceList?

    public init(dryRun: Boolean? = nil,
                maxResults: DescribePrincipalIdFormatMaxResults? = nil,
                nextToken: String? = nil,
                resources: ResourceList? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resources = resources
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resources = "Resource"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribePrincipalIdFormatMaxResults()
    }
}

public struct DescribePrincipalIdFormatResult: Codable, Equatable {
    public var nextToken: String?
    public var principals: PrincipalIdFormatList?

    public init(nextToken: String? = nil,
                principals: PrincipalIdFormatList? = nil) {
        self.nextToken = nextToken
        self.principals = principals
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case principals = "principalSet"
    }

    public func validate() throws {
    }
}

public struct DescribePublicIpv4PoolsRequest: Codable, Equatable {
    public var filters: FilterList?
    public var maxResults: PoolMaxResults?
    public var nextToken: NextToken?
    public var poolIds: PublicIpv4PoolIdStringList?

    public init(filters: FilterList? = nil,
                maxResults: PoolMaxResults? = nil,
                nextToken: NextToken? = nil,
                poolIds: PublicIpv4PoolIdStringList? = nil) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolIds = poolIds
    }

    enum CodingKeys: String, CodingKey {
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsPoolMaxResults()
    }
}

public struct DescribePublicIpv4PoolsResult: Codable, Equatable {
    public var nextToken: String?
    public var publicIpv4Pools: PublicIpv4PoolSet?

    public init(nextToken: String? = nil,
                publicIpv4Pools: PublicIpv4PoolSet? = nil) {
        self.nextToken = nextToken
        self.publicIpv4Pools = publicIpv4Pools
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case publicIpv4Pools = "publicIpv4PoolSet"
    }

    public func validate() throws {
    }
}

public struct DescribeRegionsRequest: Codable, Equatable {
    public var allRegions: Boolean?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var regionNames: RegionNameStringList?

    public init(allRegions: Boolean? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                regionNames: RegionNameStringList? = nil) {
        self.allRegions = allRegions
        self.dryRun = dryRun
        self.filters = filters
        self.regionNames = regionNames
    }

    enum CodingKeys: String, CodingKey {
        case allRegions = "AllRegions"
        case dryRun
        case filters = "Filter"
        case regionNames = "RegionName"
    }

    public func validate() throws {
    }
}

public struct DescribeRegionsResult: Codable, Equatable {
    public var regions: RegionList?

    public init(regions: RegionList? = nil) {
        self.regions = regions
    }

    enum CodingKeys: String, CodingKey {
        case regions = "regionInfo"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesListingsRequest: Codable, Equatable {
    public var filters: FilterList?
    public var reservedInstancesId: ReservationId?
    public var reservedInstancesListingId: ReservedInstancesListingId?

    public init(filters: FilterList? = nil,
                reservedInstancesId: ReservationId? = nil,
                reservedInstancesListingId: ReservedInstancesListingId? = nil) {
        self.filters = filters
        self.reservedInstancesId = reservedInstancesId
        self.reservedInstancesListingId = reservedInstancesListingId
    }

    enum CodingKeys: String, CodingKey {
        case filters = "Filter"
        case reservedInstancesId
        case reservedInstancesListingId
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesListingsResult: Codable, Equatable {
    public var reservedInstancesListings: ReservedInstancesListingList?

    public init(reservedInstancesListings: ReservedInstancesListingList? = nil) {
        self.reservedInstancesListings = reservedInstancesListings
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesListings = "reservedInstancesListingsSet"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesModificationsRequest: Codable, Equatable {
    public var filters: FilterList?
    public var nextToken: String?
    public var reservedInstancesModificationIds: ReservedInstancesModificationIdStringList?

    public init(filters: FilterList? = nil,
                nextToken: String? = nil,
                reservedInstancesModificationIds: ReservedInstancesModificationIdStringList? = nil) {
        self.filters = filters
        self.nextToken = nextToken
        self.reservedInstancesModificationIds = reservedInstancesModificationIds
    }

    enum CodingKeys: String, CodingKey {
        case filters = "Filter"
        case nextToken
        case reservedInstancesModificationIds = "ReservedInstancesModificationId"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesModificationsResult: Codable, Equatable {
    public var nextToken: String?
    public var reservedInstancesModifications: ReservedInstancesModificationList?

    public init(nextToken: String? = nil,
                reservedInstancesModifications: ReservedInstancesModificationList? = nil) {
        self.nextToken = nextToken
        self.reservedInstancesModifications = reservedInstancesModifications
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case reservedInstancesModifications = "reservedInstancesModificationsSet"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesOfferingsRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var includeMarketplace: Boolean?
    public var instanceTenancy: Tenancy?
    public var instanceType: InstanceType?
    public var maxDuration: Long?
    public var maxInstanceCount: Integer?
    public var maxResults: Integer?
    public var minDuration: Long?
    public var nextToken: String?
    public var offeringClass: OfferingClassType?
    public var offeringType: OfferingTypeValues?
    public var productDescription: RIProductDescription?
    public var reservedInstancesOfferingIds: ReservedInstancesOfferingIdStringList?

    public init(availabilityZone: String? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                includeMarketplace: Boolean? = nil,
                instanceTenancy: Tenancy? = nil,
                instanceType: InstanceType? = nil,
                maxDuration: Long? = nil,
                maxInstanceCount: Integer? = nil,
                maxResults: Integer? = nil,
                minDuration: Long? = nil,
                nextToken: String? = nil,
                offeringClass: OfferingClassType? = nil,
                offeringType: OfferingTypeValues? = nil,
                productDescription: RIProductDescription? = nil,
                reservedInstancesOfferingIds: ReservedInstancesOfferingIdStringList? = nil) {
        self.availabilityZone = availabilityZone
        self.dryRun = dryRun
        self.filters = filters
        self.includeMarketplace = includeMarketplace
        self.instanceTenancy = instanceTenancy
        self.instanceType = instanceType
        self.maxDuration = maxDuration
        self.maxInstanceCount = maxInstanceCount
        self.maxResults = maxResults
        self.minDuration = minDuration
        self.nextToken = nextToken
        self.offeringClass = offeringClass
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.reservedInstancesOfferingIds = reservedInstancesOfferingIds
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case dryRun
        case filters = "Filter"
        case includeMarketplace = "IncludeMarketplace"
        case instanceTenancy
        case instanceType = "InstanceType"
        case maxDuration = "MaxDuration"
        case maxInstanceCount = "MaxInstanceCount"
        case maxResults
        case minDuration = "MinDuration"
        case nextToken
        case offeringClass = "OfferingClass"
        case offeringType
        case productDescription = "ProductDescription"
        case reservedInstancesOfferingIds = "ReservedInstancesOfferingId"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesOfferingsResult: Codable, Equatable {
    public var nextToken: String?
    public var reservedInstancesOfferings: ReservedInstancesOfferingList?

    public init(nextToken: String? = nil,
                reservedInstancesOfferings: ReservedInstancesOfferingList? = nil) {
        self.nextToken = nextToken
        self.reservedInstancesOfferings = reservedInstancesOfferings
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case reservedInstancesOfferings = "reservedInstancesOfferingsSet"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var offeringClass: OfferingClassType?
    public var offeringType: OfferingTypeValues?
    public var reservedInstancesIds: ReservedInstancesIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                offeringClass: OfferingClassType? = nil,
                offeringType: OfferingTypeValues? = nil,
                reservedInstancesIds: ReservedInstancesIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.offeringClass = offeringClass
        self.offeringType = offeringType
        self.reservedInstancesIds = reservedInstancesIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case offeringClass = "OfferingClass"
        case offeringType
        case reservedInstancesIds = "ReservedInstancesId"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesResult: Codable, Equatable {
    public var reservedInstances: ReservedInstancesList?

    public init(reservedInstances: ReservedInstancesList? = nil) {
        self.reservedInstances = reservedInstances
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstances = "reservedInstancesSet"
    }

    public func validate() throws {
    }
}

public struct DescribeRouteTablesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeRouteTablesMaxResults?
    public var nextToken: String?
    public var routeTableIds: RouteTableIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeRouteTablesMaxResults? = nil,
                nextToken: String? = nil,
                routeTableIds: RouteTableIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routeTableIds = routeTableIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case routeTableIds = "RouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeRouteTablesMaxResults()
    }
}

public struct DescribeRouteTablesResult: Codable, Equatable {
    public var nextToken: String?
    public var routeTables: RouteTableList?

    public init(nextToken: String? = nil,
                routeTables: RouteTableList? = nil) {
        self.nextToken = nextToken
        self.routeTables = routeTables
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case routeTables = "routeTableSet"
    }

    public func validate() throws {
    }
}

public struct DescribeScheduledInstanceAvailabilityRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var firstSlotStartTimeRange: SlotDateTimeRangeRequest
    public var maxResults: DescribeScheduledInstanceAvailabilityMaxResults?
    public var maxSlotDurationInHours: Integer?
    public var minSlotDurationInHours: Integer?
    public var nextToken: String?
    public var recurrence: ScheduledInstanceRecurrenceRequest

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                firstSlotStartTimeRange: SlotDateTimeRangeRequest,
                maxResults: DescribeScheduledInstanceAvailabilityMaxResults? = nil,
                maxSlotDurationInHours: Integer? = nil,
                minSlotDurationInHours: Integer? = nil,
                nextToken: String? = nil,
                recurrence: ScheduledInstanceRecurrenceRequest) {
        self.dryRun = dryRun
        self.filters = filters
        self.firstSlotStartTimeRange = firstSlotStartTimeRange
        self.maxResults = maxResults
        self.maxSlotDurationInHours = maxSlotDurationInHours
        self.minSlotDurationInHours = minSlotDurationInHours
        self.nextToken = nextToken
        self.recurrence = recurrence
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case firstSlotStartTimeRange = "FirstSlotStartTimeRange"
        case maxResults = "MaxResults"
        case maxSlotDurationInHours = "MaxSlotDurationInHours"
        case minSlotDurationInHours = "MinSlotDurationInHours"
        case nextToken = "NextToken"
        case recurrence = "Recurrence"
    }

    public func validate() throws {
        try firstSlotStartTimeRange.validate()
        try maxResults?.validateAsDescribeScheduledInstanceAvailabilityMaxResults()
        try recurrence.validate()
    }
}

public struct DescribeScheduledInstanceAvailabilityResult: Codable, Equatable {
    public var nextToken: String?
    public var scheduledInstanceAvailabilitySet: ScheduledInstanceAvailabilitySet?

    public init(nextToken: String? = nil,
                scheduledInstanceAvailabilitySet: ScheduledInstanceAvailabilitySet? = nil) {
        self.nextToken = nextToken
        self.scheduledInstanceAvailabilitySet = scheduledInstanceAvailabilitySet
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case scheduledInstanceAvailabilitySet
    }

    public func validate() throws {
    }
}

public struct DescribeScheduledInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var scheduledInstanceIds: ScheduledInstanceIdRequestSet?
    public var slotStartTimeRange: SlotStartTimeRangeRequest?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                scheduledInstanceIds: ScheduledInstanceIdRequestSet? = nil,
                slotStartTimeRange: SlotStartTimeRangeRequest? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scheduledInstanceIds = scheduledInstanceIds
        self.slotStartTimeRange = slotStartTimeRange
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scheduledInstanceIds = "ScheduledInstanceId"
        case slotStartTimeRange = "SlotStartTimeRange"
    }

    public func validate() throws {
        try slotStartTimeRange?.validate()
    }
}

public struct DescribeScheduledInstancesResult: Codable, Equatable {
    public var nextToken: String?
    public var scheduledInstanceSet: ScheduledInstanceSet?

    public init(nextToken: String? = nil,
                scheduledInstanceSet: ScheduledInstanceSet? = nil) {
        self.nextToken = nextToken
        self.scheduledInstanceSet = scheduledInstanceSet
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case scheduledInstanceSet
    }

    public func validate() throws {
    }
}

public struct DescribeSecurityGroupReferencesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupId: GroupIds

    public init(dryRun: Boolean? = nil,
                groupId: GroupIds) {
        self.dryRun = dryRun
        self.groupId = groupId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupId = "GroupId"
    }

    public func validate() throws {
    }
}

public struct DescribeSecurityGroupReferencesResult: Codable, Equatable {
    public var securityGroupReferenceSet: SecurityGroupReferences?

    public init(securityGroupReferenceSet: SecurityGroupReferences? = nil) {
        self.securityGroupReferenceSet = securityGroupReferenceSet
    }

    enum CodingKeys: String, CodingKey {
        case securityGroupReferenceSet
    }

    public func validate() throws {
    }
}

public struct DescribeSecurityGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var groupIds: GroupIdStringList?
    public var groupNames: GroupNameStringList?
    public var maxResults: DescribeSecurityGroupsMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                groupIds: GroupIdStringList? = nil,
                groupNames: GroupNameStringList? = nil,
                maxResults: DescribeSecurityGroupsMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.groupIds = groupIds
        self.groupNames = groupNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case groupIds = "GroupId"
        case groupNames = "GroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeSecurityGroupsMaxResults()
    }
}

public struct DescribeSecurityGroupsResult: Codable, Equatable {
    public var nextToken: String?
    public var securityGroups: SecurityGroupList?

    public init(nextToken: String? = nil,
                securityGroups: SecurityGroupList? = nil) {
        self.nextToken = nextToken
        self.securityGroups = securityGroups
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case securityGroups = "securityGroupInfo"
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotAttributeRequest: Codable, Equatable {
    public var attribute: SnapshotAttributeName
    public var dryRun: Boolean?
    public var snapshotId: SnapshotId

    public init(attribute: SnapshotAttributeName,
                dryRun: Boolean? = nil,
                snapshotId: SnapshotId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case snapshotId = "SnapshotId"
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotAttributeResult: Codable, Equatable {
    public var createVolumePermissions: CreateVolumePermissionList?
    public var productCodes: ProductCodeList?
    public var snapshotId: String?

    public init(createVolumePermissions: CreateVolumePermissionList? = nil,
                productCodes: ProductCodeList? = nil,
                snapshotId: String? = nil) {
        self.createVolumePermissions = createVolumePermissions
        self.productCodes = productCodes
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case createVolumePermissions = "createVolumePermission"
        case productCodes
        case snapshotId
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var ownerIds: OwnerStringList?
    public var restorableByUserIds: RestorableByStringList?
    public var snapshotIds: SnapshotIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                ownerIds: OwnerStringList? = nil,
                restorableByUserIds: RestorableByStringList? = nil,
                snapshotIds: SnapshotIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerIds = ownerIds
        self.restorableByUserIds = restorableByUserIds
        self.snapshotIds = snapshotIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case ownerIds = "Owner"
        case restorableByUserIds = "RestorableBy"
        case snapshotIds = "SnapshotId"
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotsResult: Codable, Equatable {
    public var nextToken: String?
    public var snapshots: SnapshotList?

    public init(nextToken: String? = nil,
                snapshots: SnapshotList? = nil) {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case snapshots = "snapshotSet"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotDatafeedSubscriptionRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DescribeSpotDatafeedSubscriptionResult: Codable, Equatable {
    public var spotDatafeedSubscription: SpotDatafeedSubscription?

    public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
        self.spotDatafeedSubscription = spotDatafeedSubscription
    }

    enum CodingKeys: String, CodingKey {
        case spotDatafeedSubscription
    }

    public func validate() throws {
        try spotDatafeedSubscription?.validate()
    }
}

public struct DescribeSpotFleetInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: DescribeSpotFleetInstancesMaxResults?
    public var nextToken: String?
    public var spotFleetRequestId: SpotFleetRequestId

    public init(dryRun: Boolean? = nil,
                maxResults: DescribeSpotFleetInstancesMaxResults? = nil,
                nextToken: String? = nil,
                spotFleetRequestId: SpotFleetRequestId) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case maxResults
        case nextToken
        case spotFleetRequestId
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeSpotFleetInstancesMaxResults()
    }
}

public struct DescribeSpotFleetInstancesResponse: Codable, Equatable {
    public var activeInstances: ActiveInstanceSet?
    public var nextToken: String?
    public var spotFleetRequestId: String?

    public init(activeInstances: ActiveInstanceSet? = nil,
                nextToken: String? = nil,
                spotFleetRequestId: String? = nil) {
        self.activeInstances = activeInstances
        self.nextToken = nextToken
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case activeInstances = "activeInstanceSet"
        case nextToken
        case spotFleetRequestId
    }

    public func validate() throws {
    }
}

public struct DescribeSpotFleetRequestHistoryRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var eventType: EventType?
    public var maxResults: DescribeSpotFleetRequestHistoryMaxResults?
    public var nextToken: String?
    public var spotFleetRequestId: SpotFleetRequestId
    public var startTime: DateTime

    public init(dryRun: Boolean? = nil,
                eventType: EventType? = nil,
                maxResults: DescribeSpotFleetRequestHistoryMaxResults? = nil,
                nextToken: String? = nil,
                spotFleetRequestId: SpotFleetRequestId,
                startTime: DateTime) {
        self.dryRun = dryRun
        self.eventType = eventType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spotFleetRequestId = spotFleetRequestId
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case eventType
        case maxResults
        case nextToken
        case spotFleetRequestId
        case startTime
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeSpotFleetRequestHistoryMaxResults()
    }
}

public struct DescribeSpotFleetRequestHistoryResponse: Codable, Equatable {
    public var historyRecords: HistoryRecords?
    public var lastEvaluatedTime: DateTime?
    public var nextToken: String?
    public var spotFleetRequestId: String?
    public var startTime: DateTime?

    public init(historyRecords: HistoryRecords? = nil,
                lastEvaluatedTime: DateTime? = nil,
                nextToken: String? = nil,
                spotFleetRequestId: String? = nil,
                startTime: DateTime? = nil) {
        self.historyRecords = historyRecords
        self.lastEvaluatedTime = lastEvaluatedTime
        self.nextToken = nextToken
        self.spotFleetRequestId = spotFleetRequestId
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case historyRecords = "historyRecordSet"
        case lastEvaluatedTime
        case nextToken
        case spotFleetRequestId
        case startTime
    }

    public func validate() throws {
    }
}

public struct DescribeSpotFleetRequestsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: Integer?
    public var nextToken: String?
    public var spotFleetRequestIds: SpotFleetRequestIdList?

    public init(dryRun: Boolean? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                spotFleetRequestIds: SpotFleetRequestIdList? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spotFleetRequestIds = spotFleetRequestIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case maxResults
        case nextToken
        case spotFleetRequestIds = "spotFleetRequestId"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotFleetRequestsResponse: Codable, Equatable {
    public var nextToken: String?
    public var spotFleetRequestConfigs: SpotFleetRequestConfigSet?

    public init(nextToken: String? = nil,
                spotFleetRequestConfigs: SpotFleetRequestConfigSet? = nil) {
        self.nextToken = nextToken
        self.spotFleetRequestConfigs = spotFleetRequestConfigs
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case spotFleetRequestConfigs = "spotFleetRequestConfigSet"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotInstanceRequestsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var spotInstanceRequestIds: SpotInstanceRequestIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                spotInstanceRequestIds: SpotInstanceRequestIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spotInstanceRequestIds = spotInstanceRequestIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case spotInstanceRequestIds = "SpotInstanceRequestId"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotInstanceRequestsResult: Codable, Equatable {
    public var nextToken: String?
    public var spotInstanceRequests: SpotInstanceRequestList?

    public init(nextToken: String? = nil,
                spotInstanceRequests: SpotInstanceRequestList? = nil) {
        self.nextToken = nextToken
        self.spotInstanceRequests = spotInstanceRequests
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case spotInstanceRequests = "spotInstanceRequestSet"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotPriceHistoryRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var dryRun: Boolean?
    public var endTime: DateTime?
    public var filters: FilterList?
    public var instanceTypes: InstanceTypeList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var productDescriptions: ProductDescriptionList?
    public var startTime: DateTime?

    public init(availabilityZone: String? = nil,
                dryRun: Boolean? = nil,
                endTime: DateTime? = nil,
                filters: FilterList? = nil,
                instanceTypes: InstanceTypeList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                productDescriptions: ProductDescriptionList? = nil,
                startTime: DateTime? = nil) {
        self.availabilityZone = availabilityZone
        self.dryRun = dryRun
        self.endTime = endTime
        self.filters = filters
        self.instanceTypes = instanceTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productDescriptions = productDescriptions
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case dryRun
        case endTime
        case filters = "Filter"
        case instanceTypes = "InstanceType"
        case maxResults
        case nextToken
        case productDescriptions = "ProductDescription"
        case startTime
    }

    public func validate() throws {
    }
}

public struct DescribeSpotPriceHistoryResult: Codable, Equatable {
    public var nextToken: String?
    public var spotPriceHistory: SpotPriceHistoryList?

    public init(nextToken: String? = nil,
                spotPriceHistory: SpotPriceHistoryList? = nil) {
        self.nextToken = nextToken
        self.spotPriceHistory = spotPriceHistory
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case spotPriceHistory = "spotPriceHistorySet"
    }

    public func validate() throws {
    }
}

public struct DescribeStaleSecurityGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: DescribeStaleSecurityGroupsMaxResults?
    public var nextToken: DescribeStaleSecurityGroupsNextToken?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                maxResults: DescribeStaleSecurityGroupsMaxResults? = nil,
                nextToken: DescribeStaleSecurityGroupsNextToken? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcId = "VpcId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeStaleSecurityGroupsMaxResults()
        try nextToken?.validateAsDescribeStaleSecurityGroupsNextToken()
    }
}

public struct DescribeStaleSecurityGroupsResult: Codable, Equatable {
    public var nextToken: String?
    public var staleSecurityGroupSet: StaleSecurityGroupSet?

    public init(nextToken: String? = nil,
                staleSecurityGroupSet: StaleSecurityGroupSet? = nil) {
        self.nextToken = nextToken
        self.staleSecurityGroupSet = staleSecurityGroupSet
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case staleSecurityGroupSet
    }

    public func validate() throws {
    }
}

public struct DescribeSubnetsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeSubnetsMaxResults?
    public var nextToken: String?
    public var subnetIds: SubnetIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeSubnetsMaxResults? = nil,
                nextToken: String? = nil,
                subnetIds: SubnetIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subnetIds = subnetIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetIds = "SubnetId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeSubnetsMaxResults()
    }
}

public struct DescribeSubnetsResult: Codable, Equatable {
    public var nextToken: String?
    public var subnets: SubnetList?

    public init(nextToken: String? = nil,
                subnets: SubnetList? = nil) {
        self.nextToken = nextToken
        self.subnets = subnets
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case subnets = "subnetSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTagsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeTagsResult: Codable, Equatable {
    public var nextToken: String?
    public var tags: TagDescriptionList?

    public init(nextToken: String? = nil,
                tags: TagDescriptionList? = nil) {
        self.nextToken = nextToken
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTrafficMirrorFiltersRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TrafficMirroringMaxResults?
    public var nextToken: NextToken?
    public var trafficMirrorFilterIds: TrafficMirrorFilterIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TrafficMirroringMaxResults? = nil,
                nextToken: NextToken? = nil,
                trafficMirrorFilterIds: TrafficMirrorFilterIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trafficMirrorFilterIds = trafficMirrorFilterIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case trafficMirrorFilterIds = "TrafficMirrorFilterId"
    }

    public func validate() throws {
        try maxResults?.validateAsTrafficMirroringMaxResults()
    }
}

public struct DescribeTrafficMirrorFiltersResult: Codable, Equatable {
    public var nextToken: String?
    public var trafficMirrorFilters: TrafficMirrorFilterSet?

    public init(nextToken: String? = nil,
                trafficMirrorFilters: TrafficMirrorFilterSet? = nil) {
        self.nextToken = nextToken
        self.trafficMirrorFilters = trafficMirrorFilters
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case trafficMirrorFilters = "trafficMirrorFilterSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTrafficMirrorSessionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TrafficMirroringMaxResults?
    public var nextToken: NextToken?
    public var trafficMirrorSessionIds: TrafficMirrorSessionIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TrafficMirroringMaxResults? = nil,
                nextToken: NextToken? = nil,
                trafficMirrorSessionIds: TrafficMirrorSessionIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trafficMirrorSessionIds = trafficMirrorSessionIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case trafficMirrorSessionIds = "TrafficMirrorSessionId"
    }

    public func validate() throws {
        try maxResults?.validateAsTrafficMirroringMaxResults()
    }
}

public struct DescribeTrafficMirrorSessionsResult: Codable, Equatable {
    public var nextToken: String?
    public var trafficMirrorSessions: TrafficMirrorSessionSet?

    public init(nextToken: String? = nil,
                trafficMirrorSessions: TrafficMirrorSessionSet? = nil) {
        self.nextToken = nextToken
        self.trafficMirrorSessions = trafficMirrorSessions
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case trafficMirrorSessions = "trafficMirrorSessionSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTrafficMirrorTargetsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TrafficMirroringMaxResults?
    public var nextToken: NextToken?
    public var trafficMirrorTargetIds: TrafficMirrorTargetIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TrafficMirroringMaxResults? = nil,
                nextToken: NextToken? = nil,
                trafficMirrorTargetIds: TrafficMirrorTargetIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trafficMirrorTargetIds = trafficMirrorTargetIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case trafficMirrorTargetIds = "TrafficMirrorTargetId"
    }

    public func validate() throws {
        try maxResults?.validateAsTrafficMirroringMaxResults()
    }
}

public struct DescribeTrafficMirrorTargetsResult: Codable, Equatable {
    public var nextToken: String?
    public var trafficMirrorTargets: TrafficMirrorTargetSet?

    public init(nextToken: String? = nil,
                trafficMirrorTargets: TrafficMirrorTargetSet? = nil) {
        self.nextToken = nextToken
        self.trafficMirrorTargets = trafficMirrorTargets
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case trafficMirrorTargets = "trafficMirrorTargetSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayAttachmentsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentIds = transitGatewayAttachmentIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentIds = "TransitGatewayAttachmentIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayAttachmentsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayAttachments: TransitGatewayAttachmentList?

    public init(nextToken: String? = nil,
                transitGatewayAttachments: TransitGatewayAttachmentList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayAttachments = transitGatewayAttachments
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayAttachments
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayConnectPeersRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayConnectPeerIds: TransitGatewayConnectPeerIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayConnectPeerIds: TransitGatewayConnectPeerIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayConnectPeerIds = transitGatewayConnectPeerIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayConnectPeerIds = "TransitGatewayConnectPeerIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayConnectPeersResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayConnectPeers: TransitGatewayConnectPeerList?

    public init(nextToken: String? = nil,
                transitGatewayConnectPeers: TransitGatewayConnectPeerList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayConnectPeers = transitGatewayConnectPeers
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayConnectPeers = "transitGatewayConnectPeerSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayConnectsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentIds = transitGatewayAttachmentIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentIds = "TransitGatewayAttachmentIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayConnectsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayConnects: TransitGatewayConnectList?

    public init(nextToken: String? = nil,
                transitGatewayConnects: TransitGatewayConnectList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayConnects = transitGatewayConnects
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayConnects = "transitGatewayConnectSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayMulticastDomainsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayMulticastDomainIds: TransitGatewayMulticastDomainIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayMulticastDomainIds: TransitGatewayMulticastDomainIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayMulticastDomainIds = transitGatewayMulticastDomainIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayMulticastDomainIds = "TransitGatewayMulticastDomainIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayMulticastDomainsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayMulticastDomains: TransitGatewayMulticastDomainList?

    public init(nextToken: String? = nil,
                transitGatewayMulticastDomains: TransitGatewayMulticastDomainList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayMulticastDomains = transitGatewayMulticastDomains
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayMulticastDomains
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayPeeringAttachmentsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentIds = transitGatewayAttachmentIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentIds = "TransitGatewayAttachmentIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayPeeringAttachmentsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayPeeringAttachments: TransitGatewayPeeringAttachmentList?

    public init(nextToken: String? = nil,
                transitGatewayPeeringAttachments: TransitGatewayPeeringAttachmentList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayPeeringAttachments = transitGatewayPeeringAttachments
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayPeeringAttachments
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayRouteTablesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayRouteTableIds: TransitGatewayRouteTableIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayRouteTableIds: TransitGatewayRouteTableIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayRouteTableIds = transitGatewayRouteTableIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayRouteTableIds = "TransitGatewayRouteTableIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayRouteTablesResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayRouteTables: TransitGatewayRouteTableList?

    public init(nextToken: String? = nil,
                transitGatewayRouteTables: TransitGatewayRouteTableList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayRouteTables = transitGatewayRouteTables
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayRouteTables
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayVpcAttachmentsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentIds = transitGatewayAttachmentIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentIds = "TransitGatewayAttachmentIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayVpcAttachmentsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayVpcAttachments: TransitGatewayVpcAttachmentList?

    public init(nextToken: String? = nil,
                transitGatewayVpcAttachments: TransitGatewayVpcAttachmentList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayVpcAttachments = transitGatewayVpcAttachments
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayVpcAttachments
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayIds: TransitGatewayIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayIds: TransitGatewayIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayIds = transitGatewayIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayIds = "TransitGatewayIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewaysResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGateways: TransitGatewayList?

    public init(nextToken: String? = nil,
                transitGateways: TransitGatewayList? = nil) {
        self.nextToken = nextToken
        self.transitGateways = transitGateways
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGateways = "transitGatewaySet"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumeAttributeRequest: Codable, Equatable {
    public var attribute: VolumeAttributeName
    public var dryRun: Boolean?
    public var volumeId: VolumeId

    public init(attribute: VolumeAttributeName,
                dryRun: Boolean? = nil,
                volumeId: VolumeId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumeAttributeResult: Codable, Equatable {
    public var autoEnableIO: AttributeBooleanValue?
    public var productCodes: ProductCodeList?
    public var volumeId: String?

    public init(autoEnableIO: AttributeBooleanValue? = nil,
                productCodes: ProductCodeList? = nil,
                volumeId: String? = nil) {
        self.autoEnableIO = autoEnableIO
        self.productCodes = productCodes
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case autoEnableIO
        case productCodes
        case volumeId
    }

    public func validate() throws {
        try autoEnableIO?.validate()
    }
}

public struct DescribeVolumeStatusRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var volumeIds: VolumeIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                volumeIds: VolumeIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.volumeIds = volumeIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case volumeIds = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumeStatusResult: Codable, Equatable {
    public var nextToken: String?
    public var volumeStatuses: VolumeStatusList?

    public init(nextToken: String? = nil,
                volumeStatuses: VolumeStatusList? = nil) {
        self.nextToken = nextToken
        self.volumeStatuses = volumeStatuses
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case volumeStatuses = "volumeStatusSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumesModificationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var volumeIds: VolumeIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                volumeIds: VolumeIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.volumeIds = volumeIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case volumeIds = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumesModificationsResult: Codable, Equatable {
    public var nextToken: String?
    public var volumesModifications: VolumeModificationList?

    public init(nextToken: String? = nil,
                volumesModifications: VolumeModificationList? = nil) {
        self.nextToken = nextToken
        self.volumesModifications = volumesModifications
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case volumesModifications = "volumeModificationSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var volumeIds: VolumeIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                volumeIds: VolumeIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.volumeIds = volumeIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults
        case nextToken
        case volumeIds = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumesResult: Codable, Equatable {
    public var nextToken: String?
    public var volumes: VolumeList?

    public init(nextToken: String? = nil,
                volumes: VolumeList? = nil) {
        self.nextToken = nextToken
        self.volumes = volumes
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case volumes = "volumeSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcAttributeRequest: Codable, Equatable {
    public var attribute: VpcAttributeName
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(attribute: VpcAttributeName,
                dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcAttributeResult: Codable, Equatable {
    public var enableDnsHostnames: AttributeBooleanValue?
    public var enableDnsSupport: AttributeBooleanValue?
    public var vpcId: String?

    public init(enableDnsHostnames: AttributeBooleanValue? = nil,
                enableDnsSupport: AttributeBooleanValue? = nil,
                vpcId: String? = nil) {
        self.enableDnsHostnames = enableDnsHostnames
        self.enableDnsSupport = enableDnsSupport
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case enableDnsHostnames
        case enableDnsSupport
        case vpcId
    }

    public func validate() throws {
        try enableDnsHostnames?.validate()
        try enableDnsSupport?.validate()
    }
}

public struct DescribeVpcClassicLinkDnsSupportRequest: Codable, Equatable {
    public var maxResults: DescribeVpcClassicLinkDnsSupportMaxResults?
    public var nextToken: DescribeVpcClassicLinkDnsSupportNextToken?
    public var vpcIds: VpcClassicLinkIdList?

    public init(maxResults: DescribeVpcClassicLinkDnsSupportMaxResults? = nil,
                nextToken: DescribeVpcClassicLinkDnsSupportNextToken? = nil,
                vpcIds: VpcClassicLinkIdList? = nil) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcIds = vpcIds
    }

    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case vpcIds = "VpcIds"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVpcClassicLinkDnsSupportMaxResults()
        try nextToken?.validateAsDescribeVpcClassicLinkDnsSupportNextToken()
    }
}

public struct DescribeVpcClassicLinkDnsSupportResult: Codable, Equatable {
    public var nextToken: DescribeVpcClassicLinkDnsSupportNextToken?
    public var vpcs: ClassicLinkDnsSupportList?

    public init(nextToken: DescribeVpcClassicLinkDnsSupportNextToken? = nil,
                vpcs: ClassicLinkDnsSupportList? = nil) {
        self.nextToken = nextToken
        self.vpcs = vpcs
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcs
    }

    public func validate() throws {
        try nextToken?.validateAsDescribeVpcClassicLinkDnsSupportNextToken()
    }
}

public struct DescribeVpcClassicLinkRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var vpcIds: VpcClassicLinkIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                vpcIds: VpcClassicLinkIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.vpcIds = vpcIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case vpcIds = "VpcId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcClassicLinkResult: Codable, Equatable {
    public var vpcs: VpcClassicLinkList?

    public init(vpcs: VpcClassicLinkList? = nil) {
        self.vpcs = vpcs
    }

    enum CodingKeys: String, CodingKey {
        case vpcs = "vpcSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointConnectionNotificationsRequest: Codable, Equatable {
    public var connectionNotificationId: ConnectionNotificationId?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(connectionNotificationId: ConnectionNotificationId? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.connectionNotificationId = connectionNotificationId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case connectionNotificationId = "ConnectionNotificationId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointConnectionNotificationsResult: Codable, Equatable {
    public var connectionNotificationSet: ConnectionNotificationSet?
    public var nextToken: String?

    public init(connectionNotificationSet: ConnectionNotificationSet? = nil,
                nextToken: String? = nil) {
        self.connectionNotificationSet = connectionNotificationSet
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case connectionNotificationSet
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointConnectionsResult: Codable, Equatable {
    public var nextToken: String?
    public var vpcEndpointConnections: VpcEndpointConnectionSet?

    public init(nextToken: String? = nil,
                vpcEndpointConnections: VpcEndpointConnectionSet? = nil) {
        self.nextToken = nextToken
        self.vpcEndpointConnections = vpcEndpointConnections
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcEndpointConnections = "vpcEndpointConnectionSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServiceConfigurationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var serviceIds: VpcEndpointServiceIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                serviceIds: VpcEndpointServiceIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIds = serviceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceIds = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServiceConfigurationsResult: Codable, Equatable {
    public var nextToken: String?
    public var serviceConfigurations: ServiceConfigurationSet?

    public init(nextToken: String? = nil,
                serviceConfigurations: ServiceConfigurationSet? = nil) {
        self.nextToken = nextToken
        self.serviceConfigurations = serviceConfigurations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case serviceConfigurations = "serviceConfigurationSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServicePermissionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var serviceId: VpcEndpointServiceId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                serviceId: VpcEndpointServiceId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServicePermissionsResult: Codable, Equatable {
    public var allowedPrincipals: AllowedPrincipalSet?
    public var nextToken: String?

    public init(allowedPrincipals: AllowedPrincipalSet? = nil,
                nextToken: String? = nil) {
        self.allowedPrincipals = allowedPrincipals
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case allowedPrincipals
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServicesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var serviceNames: ValueStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                serviceNames: ValueStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceNames = serviceNames
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceNames = "ServiceName"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServicesResult: Codable, Equatable {
    public var nextToken: String?
    public var serviceDetails: ServiceDetailSet?
    public var serviceNames: ValueStringList?

    public init(nextToken: String? = nil,
                serviceDetails: ServiceDetailSet? = nil,
                serviceNames: ValueStringList? = nil) {
        self.nextToken = nextToken
        self.serviceDetails = serviceDetails
        self.serviceNames = serviceNames
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case serviceDetails = "serviceDetailSet"
        case serviceNames = "serviceNameSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var vpcEndpointIds: VpcEndpointIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                vpcEndpointIds: VpcEndpointIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcEndpointIds = vpcEndpointIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcEndpointIds = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointsResult: Codable, Equatable {
    public var nextToken: String?
    public var vpcEndpoints: VpcEndpointSet?

    public init(nextToken: String? = nil,
                vpcEndpoints: VpcEndpointSet? = nil) {
        self.nextToken = nextToken
        self.vpcEndpoints = vpcEndpoints
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcEndpoints = "vpcEndpointSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcPeeringConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeVpcPeeringConnectionsMaxResults?
    public var nextToken: String?
    public var vpcPeeringConnectionIds: VpcPeeringConnectionIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeVpcPeeringConnectionsMaxResults? = nil,
                nextToken: String? = nil,
                vpcPeeringConnectionIds: VpcPeeringConnectionIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcPeeringConnectionIds = vpcPeeringConnectionIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcPeeringConnectionIds = "VpcPeeringConnectionId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVpcPeeringConnectionsMaxResults()
    }
}

public struct DescribeVpcPeeringConnectionsResult: Codable, Equatable {
    public var nextToken: String?
    public var vpcPeeringConnections: VpcPeeringConnectionList?

    public init(nextToken: String? = nil,
                vpcPeeringConnections: VpcPeeringConnectionList? = nil) {
        self.nextToken = nextToken
        self.vpcPeeringConnections = vpcPeeringConnections
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcPeeringConnections = "vpcPeeringConnectionSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeVpcsMaxResults?
    public var nextToken: String?
    public var vpcIds: VpcIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeVpcsMaxResults? = nil,
                nextToken: String? = nil,
                vpcIds: VpcIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcIds = vpcIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcIds = "VpcId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVpcsMaxResults()
    }
}

public struct DescribeVpcsResult: Codable, Equatable {
    public var nextToken: String?
    public var vpcs: VpcList?

    public init(nextToken: String? = nil,
                vpcs: VpcList? = nil) {
        self.nextToken = nextToken
        self.vpcs = vpcs
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcs = "vpcSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpnConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var vpnConnectionIds: VpnConnectionIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                vpnConnectionIds: VpnConnectionIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.vpnConnectionIds = vpnConnectionIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case vpnConnectionIds = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpnConnectionsResult: Codable, Equatable {
    public var vpnConnections: VpnConnectionList?

    public init(vpnConnections: VpnConnectionList? = nil) {
        self.vpnConnections = vpnConnections
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnections = "vpnConnectionSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpnGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var vpnGatewayIds: VpnGatewayIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                vpnGatewayIds: VpnGatewayIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.vpnGatewayIds = vpnGatewayIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case vpnGatewayIds = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpnGatewaysResult: Codable, Equatable {
    public var vpnGateways: VpnGatewayList?

    public init(vpnGateways: VpnGatewayList? = nil) {
        self.vpnGateways = vpnGateways
    }

    enum CodingKeys: String, CodingKey {
        case vpnGateways = "vpnGatewaySet"
    }

    public func validate() throws {
    }
}

public struct DetachClassicLinkVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId
        case vpcId
    }

    public func validate() throws {
    }
}

public struct DetachClassicLinkVpcResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DetachInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var internetGatewayId: InternetGatewayId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                internetGatewayId: InternetGatewayId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.internetGatewayId = internetGatewayId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case internetGatewayId
        case vpcId
    }

    public func validate() throws {
    }
}

public struct DetachNetworkInterfaceRequest: Codable, Equatable {
    public var attachmentId: NetworkInterfaceAttachmentId
    public var dryRun: Boolean?
    public var force: Boolean?

    public init(attachmentId: NetworkInterfaceAttachmentId,
                dryRun: Boolean? = nil,
                force: Boolean? = nil) {
        self.attachmentId = attachmentId
        self.dryRun = dryRun
        self.force = force
    }

    enum CodingKeys: String, CodingKey {
        case attachmentId
        case dryRun
        case force
    }

    public func validate() throws {
    }
}

public struct DetachVolumeRequest: Codable, Equatable {
    public var device: String?
    public var dryRun: Boolean?
    public var force: Boolean?
    public var instanceId: InstanceId?
    public var volumeId: VolumeId

    public init(device: String? = nil,
                dryRun: Boolean? = nil,
                force: Boolean? = nil,
                instanceId: InstanceId? = nil,
                volumeId: VolumeId) {
        self.device = device
        self.dryRun = dryRun
        self.force = force
        self.instanceId = instanceId
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case device = "Device"
        case dryRun
        case force = "Force"
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DetachVpnGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId
    public var vpnGatewayId: VpnGatewayId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId,
                vpnGatewayId: VpnGatewayId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId = "VpcId"
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct DhcpConfiguration: Codable, Equatable {
    public var key: String?
    public var values: DhcpConfigurationValueList?

    public init(key: String? = nil,
                values: DhcpConfigurationValueList? = nil) {
        self.key = key
        self.values = values
    }

    enum CodingKeys: String, CodingKey {
        case key
        case values = "valueSet"
    }

    public func validate() throws {
    }
}

public struct DhcpOptions: Codable, Equatable {
    public var dhcpConfigurations: DhcpConfigurationList?
    public var dhcpOptionsId: String?
    public var ownerId: String?
    public var tags: TagList?

    public init(dhcpConfigurations: DhcpConfigurationList? = nil,
                dhcpOptionsId: String? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil) {
        self.dhcpConfigurations = dhcpConfigurations
        self.dhcpOptionsId = dhcpOptionsId
        self.ownerId = ownerId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case dhcpConfigurations = "dhcpConfigurationSet"
        case dhcpOptionsId
        case ownerId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct DirectoryServiceAuthentication: Codable, Equatable {
    public var directoryId: String?

    public init(directoryId: String? = nil) {
        self.directoryId = directoryId
    }

    enum CodingKeys: String, CodingKey {
        case directoryId
    }

    public func validate() throws {
    }
}

public struct DirectoryServiceAuthenticationRequest: Codable, Equatable {
    public var directoryId: String?

    public init(directoryId: String? = nil) {
        self.directoryId = directoryId
    }

    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public func validate() throws {
    }
}

public struct DisableEbsEncryptionByDefaultRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DisableEbsEncryptionByDefaultResult: Codable, Equatable {
    public var ebsEncryptionByDefault: Boolean?

    public init(ebsEncryptionByDefault: Boolean? = nil) {
        self.ebsEncryptionByDefault = ebsEncryptionByDefault
    }

    enum CodingKeys: String, CodingKey {
        case ebsEncryptionByDefault
    }

    public func validate() throws {
    }
}

public struct DisableFastSnapshotRestoreErrorItem: Codable, Equatable {
    public var fastSnapshotRestoreStateErrors: DisableFastSnapshotRestoreStateErrorSet?
    public var snapshotId: String?

    public init(fastSnapshotRestoreStateErrors: DisableFastSnapshotRestoreStateErrorSet? = nil,
                snapshotId: String? = nil) {
        self.fastSnapshotRestoreStateErrors = fastSnapshotRestoreStateErrors
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case fastSnapshotRestoreStateErrors = "fastSnapshotRestoreStateErrorSet"
        case snapshotId
    }

    public func validate() throws {
    }
}

public struct DisableFastSnapshotRestoreStateError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct DisableFastSnapshotRestoreStateErrorItem: Codable, Equatable {
    public var availabilityZone: String?
    public var error: DisableFastSnapshotRestoreStateError?

    public init(availabilityZone: String? = nil,
                error: DisableFastSnapshotRestoreStateError? = nil) {
        self.availabilityZone = availabilityZone
        self.error = error
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case error
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct DisableFastSnapshotRestoreSuccessItem: Codable, Equatable {
    public var availabilityZone: String?
    public var disabledTime: MillisecondDateTime?
    public var disablingTime: MillisecondDateTime?
    public var enabledTime: MillisecondDateTime?
    public var enablingTime: MillisecondDateTime?
    public var optimizingTime: MillisecondDateTime?
    public var ownerAlias: String?
    public var ownerId: String?
    public var snapshotId: String?
    public var state: FastSnapshotRestoreStateCode?
    public var stateTransitionReason: String?

    public init(availabilityZone: String? = nil,
                disabledTime: MillisecondDateTime? = nil,
                disablingTime: MillisecondDateTime? = nil,
                enabledTime: MillisecondDateTime? = nil,
                enablingTime: MillisecondDateTime? = nil,
                optimizingTime: MillisecondDateTime? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                snapshotId: String? = nil,
                state: FastSnapshotRestoreStateCode? = nil,
                stateTransitionReason: String? = nil) {
        self.availabilityZone = availabilityZone
        self.disabledTime = disabledTime
        self.disablingTime = disablingTime
        self.enabledTime = enabledTime
        self.enablingTime = enablingTime
        self.optimizingTime = optimizingTime
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.snapshotId = snapshotId
        self.state = state
        self.stateTransitionReason = stateTransitionReason
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case disabledTime
        case disablingTime
        case enabledTime
        case enablingTime
        case optimizingTime
        case ownerAlias
        case ownerId
        case snapshotId
        case state
        case stateTransitionReason
    }

    public func validate() throws {
    }
}

public struct DisableFastSnapshotRestoresRequest: Codable, Equatable {
    public var availabilityZones: AvailabilityZoneStringList
    public var dryRun: Boolean?
    public var sourceSnapshotIds: SnapshotIdStringList

    public init(availabilityZones: AvailabilityZoneStringList,
                dryRun: Boolean? = nil,
                sourceSnapshotIds: SnapshotIdStringList) {
        self.availabilityZones = availabilityZones
        self.dryRun = dryRun
        self.sourceSnapshotIds = sourceSnapshotIds
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZone"
        case dryRun = "DryRun"
        case sourceSnapshotIds = "SourceSnapshotId"
    }

    public func validate() throws {
    }
}

public struct DisableFastSnapshotRestoresResult: Codable, Equatable {
    public var successful: DisableFastSnapshotRestoreSuccessSet?
    public var unsuccessful: DisableFastSnapshotRestoreErrorSet?

    public init(successful: DisableFastSnapshotRestoreSuccessSet? = nil,
                unsuccessful: DisableFastSnapshotRestoreErrorSet? = nil) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case successful
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DisableTransitGatewayRouteTablePropagationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DisableTransitGatewayRouteTablePropagationResult: Codable, Equatable {
    public var propagation: TransitGatewayPropagation?

    public init(propagation: TransitGatewayPropagation? = nil) {
        self.propagation = propagation
    }

    enum CodingKeys: String, CodingKey {
        case propagation
    }

    public func validate() throws {
        try propagation?.validate()
    }
}

public struct DisableVgwRoutePropagationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var gatewayId: VpnGatewayId
    public var routeTableId: RouteTableId

    public init(dryRun: Boolean? = nil,
                gatewayId: VpnGatewayId,
                routeTableId: RouteTableId) {
        self.dryRun = dryRun
        self.gatewayId = gatewayId
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
    }

    public func validate() throws {
    }
}

public struct DisableVpcClassicLinkDnsSupportRequest: Codable, Equatable {
    public var vpcId: VpcId?

    public init(vpcId: VpcId? = nil) {
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct DisableVpcClassicLinkDnsSupportResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DisableVpcClassicLinkRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId
    }

    public func validate() throws {
    }
}

public struct DisableVpcClassicLinkResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DisassociateAddressRequest: Codable, Equatable {
    public var associationId: ElasticIpAssociationId?
    public var dryRun: Boolean?
    public var publicIp: String?

    public init(associationId: ElasticIpAssociationId? = nil,
                dryRun: Boolean? = nil,
                publicIp: String? = nil) {
        self.associationId = associationId
        self.dryRun = dryRun
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case dryRun
        case publicIp = "PublicIp"
    }

    public func validate() throws {
    }
}

public struct DisassociateClientVpnTargetNetworkRequest: Codable, Equatable {
    public var associationId: ClientVpnAssociationId
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(associationId: ClientVpnAssociationId,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.associationId = associationId
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DisassociateClientVpnTargetNetworkResult: Codable, Equatable {
    public var associationId: String?
    public var status: AssociationStatus?

    public init(associationId: String? = nil,
                status: AssociationStatus? = nil) {
        self.associationId = associationId
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct DisassociateEnclaveCertificateIamRoleRequest: Codable, Equatable {
    public var certificateArn: ResourceArn?
    public var dryRun: Boolean?
    public var roleArn: ResourceArn?

    public init(certificateArn: ResourceArn? = nil,
                dryRun: Boolean? = nil,
                roleArn: ResourceArn? = nil) {
        self.certificateArn = certificateArn
        self.dryRun = dryRun
        self.roleArn = roleArn
    }

    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case dryRun = "DryRun"
        case roleArn = "RoleArn"
    }

    public func validate() throws {
        try certificateArn?.validateAsResourceArn()
        try roleArn?.validateAsResourceArn()
    }
}

public struct DisassociateEnclaveCertificateIamRoleResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DisassociateIamInstanceProfileRequest: Codable, Equatable {
    public var associationId: IamInstanceProfileAssociationId

    public init(associationId: IamInstanceProfileAssociationId) {
        self.associationId = associationId
    }

    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
    }

    public func validate() throws {
    }
}

public struct DisassociateIamInstanceProfileResult: Codable, Equatable {
    public var iamInstanceProfileAssociation: IamInstanceProfileAssociation?

    public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
        self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfileAssociation
    }

    public func validate() throws {
        try iamInstanceProfileAssociation?.validate()
    }
}

public struct DisassociateRouteTableRequest: Codable, Equatable {
    public var associationId: RouteTableAssociationId
    public var dryRun: Boolean?

    public init(associationId: RouteTableAssociationId,
                dryRun: Boolean? = nil) {
        self.associationId = associationId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DisassociateSubnetCidrBlockRequest: Codable, Equatable {
    public var associationId: SubnetCidrAssociationId

    public init(associationId: SubnetCidrAssociationId) {
        self.associationId = associationId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
    }

    public func validate() throws {
    }
}

public struct DisassociateSubnetCidrBlockResult: Codable, Equatable {
    public var ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation?
    public var subnetId: String?

    public init(ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil,
                subnetId: String? = nil) {
        self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrBlockAssociation
        case subnetId
    }

    public func validate() throws {
        try ipv6CidrBlockAssociation?.validate()
    }
}

public struct DisassociateTransitGatewayMulticastDomainRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetIds: TransitGatewaySubnetIdList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                subnetIds: TransitGatewaySubnetIdList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.subnetIds = subnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case subnetIds = "SubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct DisassociateTransitGatewayMulticastDomainResult: Codable, Equatable {
    public var associations: TransitGatewayMulticastDomainAssociations?

    public init(associations: TransitGatewayMulticastDomainAssociations? = nil) {
        self.associations = associations
    }

    enum CodingKeys: String, CodingKey {
        case associations
    }

    public func validate() throws {
        try associations?.validate()
    }
}

public struct DisassociateTransitGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DisassociateTransitGatewayRouteTableResult: Codable, Equatable {
    public var association: TransitGatewayAssociation?

    public init(association: TransitGatewayAssociation? = nil) {
        self.association = association
    }

    enum CodingKeys: String, CodingKey {
        case association
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct DisassociateVpcCidrBlockRequest: Codable, Equatable {
    public var associationId: VpcCidrAssociationId

    public init(associationId: VpcCidrAssociationId) {
        self.associationId = associationId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
    }

    public func validate() throws {
    }
}

public struct DisassociateVpcCidrBlockResult: Codable, Equatable {
    public var cidrBlockAssociation: VpcCidrBlockAssociation?
    public var ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation?
    public var vpcId: String?

    public init(cidrBlockAssociation: VpcCidrBlockAssociation? = nil,
                ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil,
                vpcId: String? = nil) {
        self.cidrBlockAssociation = cidrBlockAssociation
        self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlockAssociation
        case ipv6CidrBlockAssociation
        case vpcId
    }

    public func validate() throws {
        try cidrBlockAssociation?.validate()
        try ipv6CidrBlockAssociation?.validate()
    }
}

public struct DiskImage: Codable, Equatable {
    public var description: String?
    public var image: DiskImageDetail?
    public var volume: VolumeDetail?

    public init(description: String? = nil,
                image: DiskImageDetail? = nil,
                volume: VolumeDetail? = nil) {
        self.description = description
        self.image = image
        self.volume = volume
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case image = "Image"
        case volume = "Volume"
    }

    public func validate() throws {
        try image?.validate()
        try volume?.validate()
    }
}

public struct DiskImageDescription: Codable, Equatable {
    public var checksum: String?
    public var format: DiskImageFormat?
    public var importManifestUrl: String?
    public var size: Long?

    public init(checksum: String? = nil,
                format: DiskImageFormat? = nil,
                importManifestUrl: String? = nil,
                size: Long? = nil) {
        self.checksum = checksum
        self.format = format
        self.importManifestUrl = importManifestUrl
        self.size = size
    }

    enum CodingKeys: String, CodingKey {
        case checksum
        case format
        case importManifestUrl
        case size
    }

    public func validate() throws {
    }
}

public struct DiskImageDetail: Codable, Equatable {
    public var bytes: Long
    public var format: DiskImageFormat
    public var importManifestUrl: String

    public init(bytes: Long,
                format: DiskImageFormat,
                importManifestUrl: String) {
        self.bytes = bytes
        self.format = format
        self.importManifestUrl = importManifestUrl
    }

    enum CodingKeys: String, CodingKey {
        case bytes
        case format
        case importManifestUrl
    }

    public func validate() throws {
    }
}

public struct DiskImageVolumeDescription: Codable, Equatable {
    public var id: String?
    public var size: Long?

    public init(id: String? = nil,
                size: Long? = nil) {
        self.id = id
        self.size = size
    }

    enum CodingKeys: String, CodingKey {
        case id
        case size
    }

    public func validate() throws {
    }
}

public struct DiskInfo: Codable, Equatable {
    public var count: DiskCount?
    public var sizeInGB: DiskSize?
    public var type: DiskType?

    public init(count: DiskCount? = nil,
                sizeInGB: DiskSize? = nil,
                type: DiskType? = nil) {
        self.count = count
        self.sizeInGB = sizeInGB
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case count
        case sizeInGB
        case type
    }

    public func validate() throws {
    }
}

public struct DnsEntry: Codable, Equatable {
    public var dnsName: String?
    public var hostedZoneId: String?

    public init(dnsName: String? = nil,
                hostedZoneId: String? = nil) {
        self.dnsName = dnsName
        self.hostedZoneId = hostedZoneId
    }

    enum CodingKeys: String, CodingKey {
        case dnsName
        case hostedZoneId
    }

    public func validate() throws {
    }
}

public struct DnsServersOptionsModifyStructure: Codable, Equatable {
    public var customDnsServers: ValueStringList?
    public var enabled: Boolean?

    public init(customDnsServers: ValueStringList? = nil,
                enabled: Boolean? = nil) {
        self.customDnsServers = customDnsServers
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case customDnsServers = "CustomDnsServers"
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct EbsBlockDevice: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var kmsKeyId: String?
    public var snapshotId: String?
    public var throughput: Integer?
    public var volumeSize: Integer?
    public var volumeType: VolumeType?

    public init(deleteOnTermination: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: String? = nil,
                snapshotId: String? = nil,
                throughput: Integer? = nil,
                volumeSize: Integer? = nil,
                volumeType: VolumeType? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.snapshotId = snapshotId
        self.throughput = throughput
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination
        case encrypted
        case iops
        case kmsKeyId = "KmsKeyId"
        case snapshotId
        case throughput
        case volumeSize
        case volumeType
    }

    public func validate() throws {
    }
}

public struct EbsInfo: Codable, Equatable {
    public var ebsOptimizedInfo: EbsOptimizedInfo?
    public var ebsOptimizedSupport: EbsOptimizedSupport?
    public var encryptionSupport: EbsEncryptionSupport?
    public var nvmeSupport: EbsNvmeSupport?

    public init(ebsOptimizedInfo: EbsOptimizedInfo? = nil,
                ebsOptimizedSupport: EbsOptimizedSupport? = nil,
                encryptionSupport: EbsEncryptionSupport? = nil,
                nvmeSupport: EbsNvmeSupport? = nil) {
        self.ebsOptimizedInfo = ebsOptimizedInfo
        self.ebsOptimizedSupport = ebsOptimizedSupport
        self.encryptionSupport = encryptionSupport
        self.nvmeSupport = nvmeSupport
    }

    enum CodingKeys: String, CodingKey {
        case ebsOptimizedInfo
        case ebsOptimizedSupport
        case encryptionSupport
        case nvmeSupport
    }

    public func validate() throws {
        try ebsOptimizedInfo?.validate()
    }
}

public struct EbsInstanceBlockDevice: Codable, Equatable {
    public var attachTime: DateTime?
    public var deleteOnTermination: Boolean?
    public var status: AttachmentStatus?
    public var volumeId: String?

    public init(attachTime: DateTime? = nil,
                deleteOnTermination: Boolean? = nil,
                status: AttachmentStatus? = nil,
                volumeId: String? = nil) {
        self.attachTime = attachTime
        self.deleteOnTermination = deleteOnTermination
        self.status = status
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case attachTime
        case deleteOnTermination
        case status
        case volumeId
    }

    public func validate() throws {
    }
}

public struct EbsInstanceBlockDeviceSpecification: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var volumeId: VolumeId?

    public init(deleteOnTermination: Boolean? = nil,
                volumeId: VolumeId? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination
        case volumeId
    }

    public func validate() throws {
    }
}

public struct EbsOptimizedInfo: Codable, Equatable {
    public var baselineBandwidthInMbps: BaselineBandwidthInMbps?
    public var baselineIops: BaselineIops?
    public var baselineThroughputInMBps: BaselineThroughputInMBps?
    public var maximumBandwidthInMbps: MaximumBandwidthInMbps?
    public var maximumIops: MaximumIops?
    public var maximumThroughputInMBps: MaximumThroughputInMBps?

    public init(baselineBandwidthInMbps: BaselineBandwidthInMbps? = nil,
                baselineIops: BaselineIops? = nil,
                baselineThroughputInMBps: BaselineThroughputInMBps? = nil,
                maximumBandwidthInMbps: MaximumBandwidthInMbps? = nil,
                maximumIops: MaximumIops? = nil,
                maximumThroughputInMBps: MaximumThroughputInMBps? = nil) {
        self.baselineBandwidthInMbps = baselineBandwidthInMbps
        self.baselineIops = baselineIops
        self.baselineThroughputInMBps = baselineThroughputInMBps
        self.maximumBandwidthInMbps = maximumBandwidthInMbps
        self.maximumIops = maximumIops
        self.maximumThroughputInMBps = maximumThroughputInMBps
    }

    enum CodingKeys: String, CodingKey {
        case baselineBandwidthInMbps
        case baselineIops
        case baselineThroughputInMBps
        case maximumBandwidthInMbps
        case maximumIops
        case maximumThroughputInMBps
    }

    public func validate() throws {
    }
}

public struct EgressOnlyInternetGateway: Codable, Equatable {
    public var attachments: InternetGatewayAttachmentList?
    public var egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId?
    public var tags: TagList?

    public init(attachments: InternetGatewayAttachmentList? = nil,
                egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId? = nil,
                tags: TagList? = nil) {
        self.attachments = attachments
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case attachments = "attachmentSet"
        case egressOnlyInternetGatewayId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct ElasticGpuAssociation: Codable, Equatable {
    public var elasticGpuAssociationId: String?
    public var elasticGpuAssociationState: String?
    public var elasticGpuAssociationTime: String?
    public var elasticGpuId: String?

    public init(elasticGpuAssociationId: String? = nil,
                elasticGpuAssociationState: String? = nil,
                elasticGpuAssociationTime: String? = nil,
                elasticGpuId: String? = nil) {
        self.elasticGpuAssociationId = elasticGpuAssociationId
        self.elasticGpuAssociationState = elasticGpuAssociationState
        self.elasticGpuAssociationTime = elasticGpuAssociationTime
        self.elasticGpuId = elasticGpuId
    }

    enum CodingKeys: String, CodingKey {
        case elasticGpuAssociationId
        case elasticGpuAssociationState
        case elasticGpuAssociationTime
        case elasticGpuId
    }

    public func validate() throws {
    }
}

public struct ElasticGpuHealth: Codable, Equatable {
    public var status: ElasticGpuStatus?

    public init(status: ElasticGpuStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
    }
}

public struct ElasticGpuSpecification: Codable, Equatable {
    public var type: String

    public init(type: String) {
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func validate() throws {
    }
}

public struct ElasticGpuSpecificationResponse: Codable, Equatable {
    public var type: String?

    public init(type: String? = nil) {
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case type
    }

    public func validate() throws {
    }
}

public struct ElasticGpus: Codable, Equatable {
    public var availabilityZone: String?
    public var elasticGpuHealth: ElasticGpuHealth?
    public var elasticGpuId: String?
    public var elasticGpuState: ElasticGpuState?
    public var elasticGpuType: String?
    public var instanceId: String?
    public var tags: TagList?

    public init(availabilityZone: String? = nil,
                elasticGpuHealth: ElasticGpuHealth? = nil,
                elasticGpuId: String? = nil,
                elasticGpuState: ElasticGpuState? = nil,
                elasticGpuType: String? = nil,
                instanceId: String? = nil,
                tags: TagList? = nil) {
        self.availabilityZone = availabilityZone
        self.elasticGpuHealth = elasticGpuHealth
        self.elasticGpuId = elasticGpuId
        self.elasticGpuState = elasticGpuState
        self.elasticGpuType = elasticGpuType
        self.instanceId = instanceId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case elasticGpuHealth
        case elasticGpuId
        case elasticGpuState
        case elasticGpuType
        case instanceId
        case tags = "tagSet"
    }

    public func validate() throws {
        try elasticGpuHealth?.validate()
    }
}

public struct ElasticInferenceAccelerator: Codable, Equatable {
    public var count: ElasticInferenceAcceleratorCount?
    public var type: String

    public init(count: ElasticInferenceAcceleratorCount? = nil,
                type: String) {
        self.count = count
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case type = "Type"
    }

    public func validate() throws {
        try count?.validateAsElasticInferenceAcceleratorCount()
    }
}

public struct ElasticInferenceAcceleratorAssociation: Codable, Equatable {
    public var elasticInferenceAcceleratorArn: String?
    public var elasticInferenceAcceleratorAssociationId: String?
    public var elasticInferenceAcceleratorAssociationState: String?
    public var elasticInferenceAcceleratorAssociationTime: DateTime?

    public init(elasticInferenceAcceleratorArn: String? = nil,
                elasticInferenceAcceleratorAssociationId: String? = nil,
                elasticInferenceAcceleratorAssociationState: String? = nil,
                elasticInferenceAcceleratorAssociationTime: DateTime? = nil) {
        self.elasticInferenceAcceleratorArn = elasticInferenceAcceleratorArn
        self.elasticInferenceAcceleratorAssociationId = elasticInferenceAcceleratorAssociationId
        self.elasticInferenceAcceleratorAssociationState = elasticInferenceAcceleratorAssociationState
        self.elasticInferenceAcceleratorAssociationTime = elasticInferenceAcceleratorAssociationTime
    }

    enum CodingKeys: String, CodingKey {
        case elasticInferenceAcceleratorArn
        case elasticInferenceAcceleratorAssociationId
        case elasticInferenceAcceleratorAssociationState
        case elasticInferenceAcceleratorAssociationTime
    }

    public func validate() throws {
    }
}

public struct EnableEbsEncryptionByDefaultRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct EnableEbsEncryptionByDefaultResult: Codable, Equatable {
    public var ebsEncryptionByDefault: Boolean?

    public init(ebsEncryptionByDefault: Boolean? = nil) {
        self.ebsEncryptionByDefault = ebsEncryptionByDefault
    }

    enum CodingKeys: String, CodingKey {
        case ebsEncryptionByDefault
    }

    public func validate() throws {
    }
}

public struct EnableFastSnapshotRestoreErrorItem: Codable, Equatable {
    public var fastSnapshotRestoreStateErrors: EnableFastSnapshotRestoreStateErrorSet?
    public var snapshotId: String?

    public init(fastSnapshotRestoreStateErrors: EnableFastSnapshotRestoreStateErrorSet? = nil,
                snapshotId: String? = nil) {
        self.fastSnapshotRestoreStateErrors = fastSnapshotRestoreStateErrors
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case fastSnapshotRestoreStateErrors = "fastSnapshotRestoreStateErrorSet"
        case snapshotId
    }

    public func validate() throws {
    }
}

public struct EnableFastSnapshotRestoreStateError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct EnableFastSnapshotRestoreStateErrorItem: Codable, Equatable {
    public var availabilityZone: String?
    public var error: EnableFastSnapshotRestoreStateError?

    public init(availabilityZone: String? = nil,
                error: EnableFastSnapshotRestoreStateError? = nil) {
        self.availabilityZone = availabilityZone
        self.error = error
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case error
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct EnableFastSnapshotRestoreSuccessItem: Codable, Equatable {
    public var availabilityZone: String?
    public var disabledTime: MillisecondDateTime?
    public var disablingTime: MillisecondDateTime?
    public var enabledTime: MillisecondDateTime?
    public var enablingTime: MillisecondDateTime?
    public var optimizingTime: MillisecondDateTime?
    public var ownerAlias: String?
    public var ownerId: String?
    public var snapshotId: String?
    public var state: FastSnapshotRestoreStateCode?
    public var stateTransitionReason: String?

    public init(availabilityZone: String? = nil,
                disabledTime: MillisecondDateTime? = nil,
                disablingTime: MillisecondDateTime? = nil,
                enabledTime: MillisecondDateTime? = nil,
                enablingTime: MillisecondDateTime? = nil,
                optimizingTime: MillisecondDateTime? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                snapshotId: String? = nil,
                state: FastSnapshotRestoreStateCode? = nil,
                stateTransitionReason: String? = nil) {
        self.availabilityZone = availabilityZone
        self.disabledTime = disabledTime
        self.disablingTime = disablingTime
        self.enabledTime = enabledTime
        self.enablingTime = enablingTime
        self.optimizingTime = optimizingTime
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.snapshotId = snapshotId
        self.state = state
        self.stateTransitionReason = stateTransitionReason
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case disabledTime
        case disablingTime
        case enabledTime
        case enablingTime
        case optimizingTime
        case ownerAlias
        case ownerId
        case snapshotId
        case state
        case stateTransitionReason
    }

    public func validate() throws {
    }
}

public struct EnableFastSnapshotRestoresRequest: Codable, Equatable {
    public var availabilityZones: AvailabilityZoneStringList
    public var dryRun: Boolean?
    public var sourceSnapshotIds: SnapshotIdStringList

    public init(availabilityZones: AvailabilityZoneStringList,
                dryRun: Boolean? = nil,
                sourceSnapshotIds: SnapshotIdStringList) {
        self.availabilityZones = availabilityZones
        self.dryRun = dryRun
        self.sourceSnapshotIds = sourceSnapshotIds
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZone"
        case dryRun = "DryRun"
        case sourceSnapshotIds = "SourceSnapshotId"
    }

    public func validate() throws {
    }
}

public struct EnableFastSnapshotRestoresResult: Codable, Equatable {
    public var successful: EnableFastSnapshotRestoreSuccessSet?
    public var unsuccessful: EnableFastSnapshotRestoreErrorSet?

    public init(successful: EnableFastSnapshotRestoreSuccessSet? = nil,
                unsuccessful: EnableFastSnapshotRestoreErrorSet? = nil) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case successful
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct EnableTransitGatewayRouteTablePropagationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct EnableTransitGatewayRouteTablePropagationResult: Codable, Equatable {
    public var propagation: TransitGatewayPropagation?

    public init(propagation: TransitGatewayPropagation? = nil) {
        self.propagation = propagation
    }

    enum CodingKeys: String, CodingKey {
        case propagation
    }

    public func validate() throws {
        try propagation?.validate()
    }
}

public struct EnableVgwRoutePropagationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var gatewayId: VpnGatewayId
    public var routeTableId: RouteTableId

    public init(dryRun: Boolean? = nil,
                gatewayId: VpnGatewayId,
                routeTableId: RouteTableId) {
        self.dryRun = dryRun
        self.gatewayId = gatewayId
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
    }

    public func validate() throws {
    }
}

public struct EnableVolumeIORequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var volumeId: VolumeId

    public init(dryRun: Boolean? = nil,
                volumeId: VolumeId) {
        self.dryRun = dryRun
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case volumeId
    }

    public func validate() throws {
    }
}

public struct EnableVpcClassicLinkDnsSupportRequest: Codable, Equatable {
    public var vpcId: VpcId?

    public init(vpcId: VpcId? = nil) {
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct EnableVpcClassicLinkDnsSupportResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct EnableVpcClassicLinkRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId
    }

    public func validate() throws {
    }
}

public struct EnableVpcClassicLinkResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct EnclaveOptions: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct EnclaveOptionsRequest: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct EventInformation: Codable, Equatable {
    public var eventDescription: String?
    public var eventSubType: String?
    public var instanceId: String?

    public init(eventDescription: String? = nil,
                eventSubType: String? = nil,
                instanceId: String? = nil) {
        self.eventDescription = eventDescription
        self.eventSubType = eventSubType
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case eventDescription
        case eventSubType
        case instanceId
    }

    public func validate() throws {
    }
}

public struct Explanation: Codable, Equatable {
    public var acl: AnalysisComponent?
    public var aclRule: AnalysisAclRule?
    public var address: IpAddress?
    public var addresses: IpAddressList?
    public var attachedTo: AnalysisComponent?
    public var availabilityZones: ValueStringList?
    public var cidrs: ValueStringList?
    public var classicLoadBalancerListener: AnalysisLoadBalancerListener?
    public var component: AnalysisComponent?
    public var customerGateway: AnalysisComponent?
    public var destination: AnalysisComponent?
    public var destinationVpc: AnalysisComponent?
    public var direction: String?
    public var elasticLoadBalancerListener: AnalysisComponent?
    public var explanationCode: String?
    public var ingressRouteTable: AnalysisComponent?
    public var internetGateway: AnalysisComponent?
    public var loadBalancerArn: ResourceArn?
    public var loadBalancerListenerPort: Port?
    public var loadBalancerTarget: AnalysisLoadBalancerTarget?
    public var loadBalancerTargetGroup: AnalysisComponent?
    public var loadBalancerTargetGroups: AnalysisComponentList?
    public var loadBalancerTargetPort: Port?
    public var missingComponent: String?
    public var natGateway: AnalysisComponent?
    public var networkInterface: AnalysisComponent?
    public var packetField: String?
    public var port: Port?
    public var portRanges: PortRangeList?
    public var prefixList: AnalysisComponent?
    public var protocols: StringList?
    public var routeTable: AnalysisComponent?
    public var routeTableRoute: AnalysisRouteTableRoute?
    public var securityGroup: AnalysisComponent?
    public var securityGroupRule: AnalysisSecurityGroupRule?
    public var securityGroups: AnalysisComponentList?
    public var sourceVpc: AnalysisComponent?
    public var state: String?
    public var subnet: AnalysisComponent?
    public var subnetRouteTable: AnalysisComponent?
    public var vpc: AnalysisComponent?
    public var vpcEndpoint: AnalysisComponent?
    public var vpcPeeringConnection: AnalysisComponent?
    public var vpnConnection: AnalysisComponent?
    public var vpnGateway: AnalysisComponent?

    public init(acl: AnalysisComponent? = nil,
                aclRule: AnalysisAclRule? = nil,
                address: IpAddress? = nil,
                addresses: IpAddressList? = nil,
                attachedTo: AnalysisComponent? = nil,
                availabilityZones: ValueStringList? = nil,
                cidrs: ValueStringList? = nil,
                classicLoadBalancerListener: AnalysisLoadBalancerListener? = nil,
                component: AnalysisComponent? = nil,
                customerGateway: AnalysisComponent? = nil,
                destination: AnalysisComponent? = nil,
                destinationVpc: AnalysisComponent? = nil,
                direction: String? = nil,
                elasticLoadBalancerListener: AnalysisComponent? = nil,
                explanationCode: String? = nil,
                ingressRouteTable: AnalysisComponent? = nil,
                internetGateway: AnalysisComponent? = nil,
                loadBalancerArn: ResourceArn? = nil,
                loadBalancerListenerPort: Port? = nil,
                loadBalancerTarget: AnalysisLoadBalancerTarget? = nil,
                loadBalancerTargetGroup: AnalysisComponent? = nil,
                loadBalancerTargetGroups: AnalysisComponentList? = nil,
                loadBalancerTargetPort: Port? = nil,
                missingComponent: String? = nil,
                natGateway: AnalysisComponent? = nil,
                networkInterface: AnalysisComponent? = nil,
                packetField: String? = nil,
                port: Port? = nil,
                portRanges: PortRangeList? = nil,
                prefixList: AnalysisComponent? = nil,
                protocols: StringList? = nil,
                routeTable: AnalysisComponent? = nil,
                routeTableRoute: AnalysisRouteTableRoute? = nil,
                securityGroup: AnalysisComponent? = nil,
                securityGroupRule: AnalysisSecurityGroupRule? = nil,
                securityGroups: AnalysisComponentList? = nil,
                sourceVpc: AnalysisComponent? = nil,
                state: String? = nil,
                subnet: AnalysisComponent? = nil,
                subnetRouteTable: AnalysisComponent? = nil,
                vpc: AnalysisComponent? = nil,
                vpcEndpoint: AnalysisComponent? = nil,
                vpcPeeringConnection: AnalysisComponent? = nil,
                vpnConnection: AnalysisComponent? = nil,
                vpnGateway: AnalysisComponent? = nil) {
        self.acl = acl
        self.aclRule = aclRule
        self.address = address
        self.addresses = addresses
        self.attachedTo = attachedTo
        self.availabilityZones = availabilityZones
        self.cidrs = cidrs
        self.classicLoadBalancerListener = classicLoadBalancerListener
        self.component = component
        self.customerGateway = customerGateway
        self.destination = destination
        self.destinationVpc = destinationVpc
        self.direction = direction
        self.elasticLoadBalancerListener = elasticLoadBalancerListener
        self.explanationCode = explanationCode
        self.ingressRouteTable = ingressRouteTable
        self.internetGateway = internetGateway
        self.loadBalancerArn = loadBalancerArn
        self.loadBalancerListenerPort = loadBalancerListenerPort
        self.loadBalancerTarget = loadBalancerTarget
        self.loadBalancerTargetGroup = loadBalancerTargetGroup
        self.loadBalancerTargetGroups = loadBalancerTargetGroups
        self.loadBalancerTargetPort = loadBalancerTargetPort
        self.missingComponent = missingComponent
        self.natGateway = natGateway
        self.networkInterface = networkInterface
        self.packetField = packetField
        self.port = port
        self.portRanges = portRanges
        self.prefixList = prefixList
        self.protocols = protocols
        self.routeTable = routeTable
        self.routeTableRoute = routeTableRoute
        self.securityGroup = securityGroup
        self.securityGroupRule = securityGroupRule
        self.securityGroups = securityGroups
        self.sourceVpc = sourceVpc
        self.state = state
        self.subnet = subnet
        self.subnetRouteTable = subnetRouteTable
        self.vpc = vpc
        self.vpcEndpoint = vpcEndpoint
        self.vpcPeeringConnection = vpcPeeringConnection
        self.vpnConnection = vpnConnection
        self.vpnGateway = vpnGateway
    }

    enum CodingKeys: String, CodingKey {
        case acl
        case aclRule
        case address
        case addresses = "addressSet"
        case attachedTo
        case availabilityZones = "availabilityZoneSet"
        case cidrs = "cidrSet"
        case classicLoadBalancerListener
        case component
        case customerGateway
        case destination
        case destinationVpc
        case direction
        case elasticLoadBalancerListener
        case explanationCode
        case ingressRouteTable
        case internetGateway
        case loadBalancerArn
        case loadBalancerListenerPort
        case loadBalancerTarget
        case loadBalancerTargetGroup
        case loadBalancerTargetGroups = "loadBalancerTargetGroupSet"
        case loadBalancerTargetPort
        case missingComponent
        case natGateway
        case networkInterface
        case packetField
        case port
        case portRanges = "portRangeSet"
        case prefixList
        case protocols = "protocolSet"
        case routeTable
        case routeTableRoute
        case securityGroup
        case securityGroupRule
        case securityGroups = "securityGroupSet"
        case sourceVpc
        case state
        case subnet
        case subnetRouteTable
        case vpc
        case vpcEndpoint
        case vpcPeeringConnection
        case vpnConnection
        case vpnGateway
    }

    public func validate() throws {
        try acl?.validate()
        try aclRule?.validate()
        try address?.validateAsIpAddress()
        try attachedTo?.validate()
        try classicLoadBalancerListener?.validate()
        try component?.validate()
        try customerGateway?.validate()
        try destination?.validate()
        try destinationVpc?.validate()
        try elasticLoadBalancerListener?.validate()
        try ingressRouteTable?.validate()
        try internetGateway?.validate()
        try loadBalancerArn?.validateAsResourceArn()
        try loadBalancerListenerPort?.validateAsPort()
        try loadBalancerTarget?.validate()
        try loadBalancerTargetGroup?.validate()
        try loadBalancerTargetPort?.validateAsPort()
        try natGateway?.validate()
        try networkInterface?.validate()
        try port?.validateAsPort()
        try prefixList?.validate()
        try routeTable?.validate()
        try routeTableRoute?.validate()
        try securityGroup?.validate()
        try securityGroupRule?.validate()
        try sourceVpc?.validate()
        try subnet?.validate()
        try subnetRouteTable?.validate()
        try vpc?.validate()
        try vpcEndpoint?.validate()
        try vpcPeeringConnection?.validate()
        try vpnConnection?.validate()
        try vpnGateway?.validate()
    }
}

public struct ExportClientVpnClientCertificateRevocationListRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ExportClientVpnClientCertificateRevocationListResult: Codable, Equatable {
    public var certificateRevocationList: String?
    public var status: ClientCertificateRevocationListStatus?

    public init(certificateRevocationList: String? = nil,
                status: ClientCertificateRevocationListStatus? = nil) {
        self.certificateRevocationList = certificateRevocationList
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case certificateRevocationList
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct ExportClientVpnClientConfigurationRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ExportClientVpnClientConfigurationResult: Codable, Equatable {
    public var clientConfiguration: String?

    public init(clientConfiguration: String? = nil) {
        self.clientConfiguration = clientConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case clientConfiguration
    }

    public func validate() throws {
    }
}

public struct ExportImageRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var diskImageFormat: DiskImageFormat
    public var dryRun: Boolean?
    public var imageId: ImageId
    public var roleName: String?
    public var s3ExportLocation: ExportTaskS3LocationRequest
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                diskImageFormat: DiskImageFormat,
                dryRun: Boolean? = nil,
                imageId: ImageId,
                roleName: String? = nil,
                s3ExportLocation: ExportTaskS3LocationRequest,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.diskImageFormat = diskImageFormat
        self.dryRun = dryRun
        self.imageId = imageId
        self.roleName = roleName
        self.s3ExportLocation = s3ExportLocation
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case diskImageFormat = "DiskImageFormat"
        case dryRun = "DryRun"
        case imageId = "ImageId"
        case roleName = "RoleName"
        case s3ExportLocation = "S3ExportLocation"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try s3ExportLocation.validate()
    }
}

public struct ExportImageResult: Codable, Equatable {
    public var description: String?
    public var diskImageFormat: DiskImageFormat?
    public var exportImageTaskId: String?
    public var imageId: String?
    public var progress: String?
    public var roleName: String?
    public var s3ExportLocation: ExportTaskS3Location?
    public var status: String?
    public var statusMessage: String?
    public var tags: TagList?

    public init(description: String? = nil,
                diskImageFormat: DiskImageFormat? = nil,
                exportImageTaskId: String? = nil,
                imageId: String? = nil,
                progress: String? = nil,
                roleName: String? = nil,
                s3ExportLocation: ExportTaskS3Location? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.diskImageFormat = diskImageFormat
        self.exportImageTaskId = exportImageTaskId
        self.imageId = imageId
        self.progress = progress
        self.roleName = roleName
        self.s3ExportLocation = s3ExportLocation
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case diskImageFormat
        case exportImageTaskId
        case imageId
        case progress
        case roleName
        case s3ExportLocation
        case status
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try s3ExportLocation?.validate()
    }
}

public struct ExportImageTask: Codable, Equatable {
    public var description: String?
    public var exportImageTaskId: String?
    public var imageId: String?
    public var progress: String?
    public var s3ExportLocation: ExportTaskS3Location?
    public var status: String?
    public var statusMessage: String?
    public var tags: TagList?

    public init(description: String? = nil,
                exportImageTaskId: String? = nil,
                imageId: String? = nil,
                progress: String? = nil,
                s3ExportLocation: ExportTaskS3Location? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.exportImageTaskId = exportImageTaskId
        self.imageId = imageId
        self.progress = progress
        self.s3ExportLocation = s3ExportLocation
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case exportImageTaskId
        case imageId
        case progress
        case s3ExportLocation
        case status
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try s3ExportLocation?.validate()
    }
}

public struct ExportTask: Codable, Equatable {
    public var description: String?
    public var exportTaskId: String?
    public var exportToS3Task: ExportToS3Task?
    public var instanceExportDetails: InstanceExportDetails?
    public var state: ExportTaskState?
    public var statusMessage: String?
    public var tags: TagList?

    public init(description: String? = nil,
                exportTaskId: String? = nil,
                exportToS3Task: ExportToS3Task? = nil,
                instanceExportDetails: InstanceExportDetails? = nil,
                state: ExportTaskState? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.exportTaskId = exportTaskId
        self.exportToS3Task = exportToS3Task
        self.instanceExportDetails = instanceExportDetails
        self.state = state
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case exportTaskId
        case exportToS3Task = "exportToS3"
        case instanceExportDetails = "instanceExport"
        case state
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try exportToS3Task?.validate()
        try instanceExportDetails?.validate()
    }
}

public struct ExportTaskS3Location: Codable, Equatable {
    public var s3Bucket: String?
    public var s3Prefix: String?

    public init(s3Bucket: String? = nil,
                s3Prefix: String? = nil) {
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
    }

    enum CodingKeys: String, CodingKey {
        case s3Bucket
        case s3Prefix
    }

    public func validate() throws {
    }
}

public struct ExportTaskS3LocationRequest: Codable, Equatable {
    public var s3Bucket: String
    public var s3Prefix: String?

    public init(s3Bucket: String,
                s3Prefix: String? = nil) {
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
    }

    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
    }

    public func validate() throws {
    }
}

public struct ExportToS3Task: Codable, Equatable {
    public var containerFormat: ContainerFormat?
    public var diskImageFormat: DiskImageFormat?
    public var s3Bucket: String?
    public var s3Key: String?

    public init(containerFormat: ContainerFormat? = nil,
                diskImageFormat: DiskImageFormat? = nil,
                s3Bucket: String? = nil,
                s3Key: String? = nil) {
        self.containerFormat = containerFormat
        self.diskImageFormat = diskImageFormat
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }

    enum CodingKeys: String, CodingKey {
        case containerFormat
        case diskImageFormat
        case s3Bucket
        case s3Key
    }

    public func validate() throws {
    }
}

public struct ExportToS3TaskSpecification: Codable, Equatable {
    public var containerFormat: ContainerFormat?
    public var diskImageFormat: DiskImageFormat?
    public var s3Bucket: String?
    public var s3Prefix: String?

    public init(containerFormat: ContainerFormat? = nil,
                diskImageFormat: DiskImageFormat? = nil,
                s3Bucket: String? = nil,
                s3Prefix: String? = nil) {
        self.containerFormat = containerFormat
        self.diskImageFormat = diskImageFormat
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
    }

    enum CodingKeys: String, CodingKey {
        case containerFormat
        case diskImageFormat
        case s3Bucket
        case s3Prefix
    }

    public func validate() throws {
    }
}

public struct ExportTransitGatewayRoutesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var s3Bucket: String
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                s3Bucket: String,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.s3Bucket = s3Bucket
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case s3Bucket = "S3Bucket"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct ExportTransitGatewayRoutesResult: Codable, Equatable {
    public var s3Location: String?

    public init(s3Location: String? = nil) {
        self.s3Location = s3Location
    }

    enum CodingKeys: String, CodingKey {
        case s3Location
    }

    public func validate() throws {
    }
}

public struct FailedQueuedPurchaseDeletion: Codable, Equatable {
    public var error: DeleteQueuedReservedInstancesError?
    public var reservedInstancesId: String?

    public init(error: DeleteQueuedReservedInstancesError? = nil,
                reservedInstancesId: String? = nil) {
        self.error = error
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case reservedInstancesId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct FederatedAuthentication: Codable, Equatable {
    public var samlProviderArn: String?
    public var selfServiceSamlProviderArn: String?

    public init(samlProviderArn: String? = nil,
                selfServiceSamlProviderArn: String? = nil) {
        self.samlProviderArn = samlProviderArn
        self.selfServiceSamlProviderArn = selfServiceSamlProviderArn
    }

    enum CodingKeys: String, CodingKey {
        case samlProviderArn
        case selfServiceSamlProviderArn
    }

    public func validate() throws {
    }
}

public struct FederatedAuthenticationRequest: Codable, Equatable {
    public var sAMLProviderArn: String?
    public var selfServiceSAMLProviderArn: String?

    public init(sAMLProviderArn: String? = nil,
                selfServiceSAMLProviderArn: String? = nil) {
        self.sAMLProviderArn = sAMLProviderArn
        self.selfServiceSAMLProviderArn = selfServiceSAMLProviderArn
    }

    enum CodingKeys: String, CodingKey {
        case sAMLProviderArn = "SAMLProviderArn"
        case selfServiceSAMLProviderArn = "SelfServiceSAMLProviderArn"
    }

    public func validate() throws {
    }
}

public struct Filter: Codable, Equatable {
    public var name: String?
    public var values: ValueStringList?

    public init(name: String? = nil,
                values: ValueStringList? = nil) {
        self.name = name
        self.values = values
    }

    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Value"
    }

    public func validate() throws {
    }
}

public struct FleetData: Codable, Equatable {
    public var activityStatus: FleetActivityStatus?
    public var clientToken: String?
    public var createTime: DateTime?
    public var errors: DescribeFleetsErrorSet?
    public var excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy?
    public var fleetId: FleetId?
    public var fleetState: FleetStateCode?
    public var fulfilledCapacity: Double?
    public var fulfilledOnDemandCapacity: Double?
    public var instances: DescribeFleetsInstancesSet?
    public var launchTemplateConfigs: FleetLaunchTemplateConfigList?
    public var onDemandOptions: OnDemandOptions?
    public var replaceUnhealthyInstances: Boolean?
    public var spotOptions: SpotOptions?
    public var tags: TagList?
    public var targetCapacitySpecification: TargetCapacitySpecification?
    public var terminateInstancesWithExpiration: Boolean?
    public var type: FleetType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(activityStatus: FleetActivityStatus? = nil,
                clientToken: String? = nil,
                createTime: DateTime? = nil,
                errors: DescribeFleetsErrorSet? = nil,
                excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy? = nil,
                fleetId: FleetId? = nil,
                fleetState: FleetStateCode? = nil,
                fulfilledCapacity: Double? = nil,
                fulfilledOnDemandCapacity: Double? = nil,
                instances: DescribeFleetsInstancesSet? = nil,
                launchTemplateConfigs: FleetLaunchTemplateConfigList? = nil,
                onDemandOptions: OnDemandOptions? = nil,
                replaceUnhealthyInstances: Boolean? = nil,
                spotOptions: SpotOptions? = nil,
                tags: TagList? = nil,
                targetCapacitySpecification: TargetCapacitySpecification? = nil,
                terminateInstancesWithExpiration: Boolean? = nil,
                type: FleetType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.activityStatus = activityStatus
        self.clientToken = clientToken
        self.createTime = createTime
        self.errors = errors
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.fleetId = fleetId
        self.fleetState = fleetState
        self.fulfilledCapacity = fulfilledCapacity
        self.fulfilledOnDemandCapacity = fulfilledOnDemandCapacity
        self.instances = instances
        self.launchTemplateConfigs = launchTemplateConfigs
        self.onDemandOptions = onDemandOptions
        self.replaceUnhealthyInstances = replaceUnhealthyInstances
        self.spotOptions = spotOptions
        self.tags = tags
        self.targetCapacitySpecification = targetCapacitySpecification
        self.terminateInstancesWithExpiration = terminateInstancesWithExpiration
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case activityStatus
        case clientToken
        case createTime
        case errors = "errorSet"
        case excessCapacityTerminationPolicy
        case fleetId
        case fleetState
        case fulfilledCapacity
        case fulfilledOnDemandCapacity
        case instances = "fleetInstanceSet"
        case launchTemplateConfigs
        case onDemandOptions
        case replaceUnhealthyInstances
        case spotOptions
        case tags = "tagSet"
        case targetCapacitySpecification
        case terminateInstancesWithExpiration
        case type
        case validFrom
        case validUntil
    }

    public func validate() throws {
        try onDemandOptions?.validate()
        try spotOptions?.validate()
        try targetCapacitySpecification?.validate()
    }
}

public struct FleetLaunchTemplateConfig: Codable, Equatable {
    public var launchTemplateSpecification: FleetLaunchTemplateSpecification?
    public var overrides: FleetLaunchTemplateOverridesList?

    public init(launchTemplateSpecification: FleetLaunchTemplateSpecification? = nil,
                overrides: FleetLaunchTemplateOverridesList? = nil) {
        self.launchTemplateSpecification = launchTemplateSpecification
        self.overrides = overrides
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateSpecification
        case overrides
    }

    public func validate() throws {
        try launchTemplateSpecification?.validate()
    }
}

public struct FleetLaunchTemplateConfigRequest: Codable, Equatable {
    public var launchTemplateSpecification: FleetLaunchTemplateSpecificationRequest?
    public var overrides: FleetLaunchTemplateOverridesListRequest?

    public init(launchTemplateSpecification: FleetLaunchTemplateSpecificationRequest? = nil,
                overrides: FleetLaunchTemplateOverridesListRequest? = nil) {
        self.launchTemplateSpecification = launchTemplateSpecification
        self.overrides = overrides
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateSpecification = "LaunchTemplateSpecification"
        case overrides = "Overrides"
    }

    public func validate() throws {
        try launchTemplateSpecification?.validate()
        try overrides?.validateAsFleetLaunchTemplateOverridesListRequest()
    }
}

public struct FleetLaunchTemplateOverrides: Codable, Equatable {
    public var availabilityZone: String?
    public var instanceType: InstanceType?
    public var maxPrice: String?
    public var placement: PlacementResponse?
    public var priority: Double?
    public var subnetId: String?
    public var weightedCapacity: Double?

    public init(availabilityZone: String? = nil,
                instanceType: InstanceType? = nil,
                maxPrice: String? = nil,
                placement: PlacementResponse? = nil,
                priority: Double? = nil,
                subnetId: String? = nil,
                weightedCapacity: Double? = nil) {
        self.availabilityZone = availabilityZone
        self.instanceType = instanceType
        self.maxPrice = maxPrice
        self.placement = placement
        self.priority = priority
        self.subnetId = subnetId
        self.weightedCapacity = weightedCapacity
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case instanceType
        case maxPrice
        case placement
        case priority
        case subnetId
        case weightedCapacity
    }

    public func validate() throws {
        try placement?.validate()
    }
}

public struct FleetLaunchTemplateOverridesRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var instanceType: InstanceType?
    public var maxPrice: String?
    public var placement: Placement?
    public var priority: Double?
    public var subnetId: SubnetId?
    public var weightedCapacity: Double?

    public init(availabilityZone: String? = nil,
                instanceType: InstanceType? = nil,
                maxPrice: String? = nil,
                placement: Placement? = nil,
                priority: Double? = nil,
                subnetId: SubnetId? = nil,
                weightedCapacity: Double? = nil) {
        self.availabilityZone = availabilityZone
        self.instanceType = instanceType
        self.maxPrice = maxPrice
        self.placement = placement
        self.priority = priority
        self.subnetId = subnetId
        self.weightedCapacity = weightedCapacity
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case instanceType = "InstanceType"
        case maxPrice = "MaxPrice"
        case placement = "Placement"
        case priority = "Priority"
        case subnetId = "SubnetId"
        case weightedCapacity = "WeightedCapacity"
    }

    public func validate() throws {
        try placement?.validate()
    }
}

public struct FleetLaunchTemplateSpecification: Codable, Equatable {
    public var launchTemplateId: String?
    public var launchTemplateName: LaunchTemplateName?
    public var version: String?

    public init(launchTemplateId: String? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                version: String? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId
        case launchTemplateName
        case version
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct FleetLaunchTemplateSpecificationRequest: Codable, Equatable {
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?
    public var version: String?

    public init(launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                version: String? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case version = "Version"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct FleetSpotCapacityRebalance: Codable, Equatable {
    public var replacementStrategy: FleetReplacementStrategy?

    public init(replacementStrategy: FleetReplacementStrategy? = nil) {
        self.replacementStrategy = replacementStrategy
    }

    enum CodingKeys: String, CodingKey {
        case replacementStrategy
    }

    public func validate() throws {
    }
}

public struct FleetSpotCapacityRebalanceRequest: Codable, Equatable {
    public var replacementStrategy: FleetReplacementStrategy?

    public init(replacementStrategy: FleetReplacementStrategy? = nil) {
        self.replacementStrategy = replacementStrategy
    }

    enum CodingKeys: String, CodingKey {
        case replacementStrategy = "ReplacementStrategy"
    }

    public func validate() throws {
    }
}

public struct FleetSpotMaintenanceStrategies: Codable, Equatable {
    public var capacityRebalance: FleetSpotCapacityRebalance?

    public init(capacityRebalance: FleetSpotCapacityRebalance? = nil) {
        self.capacityRebalance = capacityRebalance
    }

    enum CodingKeys: String, CodingKey {
        case capacityRebalance
    }

    public func validate() throws {
        try capacityRebalance?.validate()
    }
}

public struct FleetSpotMaintenanceStrategiesRequest: Codable, Equatable {
    public var capacityRebalance: FleetSpotCapacityRebalanceRequest?

    public init(capacityRebalance: FleetSpotCapacityRebalanceRequest? = nil) {
        self.capacityRebalance = capacityRebalance
    }

    enum CodingKeys: String, CodingKey {
        case capacityRebalance = "CapacityRebalance"
    }

    public func validate() throws {
        try capacityRebalance?.validate()
    }
}

public struct FlowLog: Codable, Equatable {
    public var creationTime: MillisecondDateTime?
    public var deliverLogsErrorMessage: String?
    public var deliverLogsPermissionArn: String?
    public var deliverLogsStatus: String?
    public var flowLogId: String?
    public var flowLogStatus: String?
    public var logDestination: String?
    public var logDestinationType: LogDestinationType?
    public var logFormat: String?
    public var logGroupName: String?
    public var maxAggregationInterval: Integer?
    public var resourceId: String?
    public var tags: TagList?
    public var trafficType: TrafficType?

    public init(creationTime: MillisecondDateTime? = nil,
                deliverLogsErrorMessage: String? = nil,
                deliverLogsPermissionArn: String? = nil,
                deliverLogsStatus: String? = nil,
                flowLogId: String? = nil,
                flowLogStatus: String? = nil,
                logDestination: String? = nil,
                logDestinationType: LogDestinationType? = nil,
                logFormat: String? = nil,
                logGroupName: String? = nil,
                maxAggregationInterval: Integer? = nil,
                resourceId: String? = nil,
                tags: TagList? = nil,
                trafficType: TrafficType? = nil) {
        self.creationTime = creationTime
        self.deliverLogsErrorMessage = deliverLogsErrorMessage
        self.deliverLogsPermissionArn = deliverLogsPermissionArn
        self.deliverLogsStatus = deliverLogsStatus
        self.flowLogId = flowLogId
        self.flowLogStatus = flowLogStatus
        self.logDestination = logDestination
        self.logDestinationType = logDestinationType
        self.logFormat = logFormat
        self.logGroupName = logGroupName
        self.maxAggregationInterval = maxAggregationInterval
        self.resourceId = resourceId
        self.tags = tags
        self.trafficType = trafficType
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case deliverLogsErrorMessage
        case deliverLogsPermissionArn
        case deliverLogsStatus
        case flowLogId
        case flowLogStatus
        case logDestination
        case logDestinationType
        case logFormat
        case logGroupName
        case maxAggregationInterval
        case resourceId
        case tags = "tagSet"
        case trafficType
    }

    public func validate() throws {
    }
}

public struct FpgaDeviceInfo: Codable, Equatable {
    public var count: FpgaDeviceCount?
    public var manufacturer: FpgaDeviceManufacturerName?
    public var memoryInfo: FpgaDeviceMemoryInfo?
    public var name: FpgaDeviceName?

    public init(count: FpgaDeviceCount? = nil,
                manufacturer: FpgaDeviceManufacturerName? = nil,
                memoryInfo: FpgaDeviceMemoryInfo? = nil,
                name: FpgaDeviceName? = nil) {
        self.count = count
        self.manufacturer = manufacturer
        self.memoryInfo = memoryInfo
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case count
        case manufacturer
        case memoryInfo
        case name
    }

    public func validate() throws {
        try memoryInfo?.validate()
    }
}

public struct FpgaDeviceMemoryInfo: Codable, Equatable {
    public var sizeInMiB: FpgaDeviceMemorySize?

    public init(sizeInMiB: FpgaDeviceMemorySize? = nil) {
        self.sizeInMiB = sizeInMiB
    }

    enum CodingKeys: String, CodingKey {
        case sizeInMiB
    }

    public func validate() throws {
    }
}

public struct FpgaImage: Codable, Equatable {
    public var createTime: DateTime?
    public var dataRetentionSupport: Boolean?
    public var description: String?
    public var fpgaImageGlobalId: String?
    public var fpgaImageId: String?
    public var name: String?
    public var ownerAlias: String?
    public var ownerId: String?
    public var pciId: PciId?
    public var productCodes: ProductCodeList?
    public var `public`: Boolean?
    public var shellVersion: String?
    public var state: FpgaImageState?
    public var tags: TagList?
    public var updateTime: DateTime?

    public init(createTime: DateTime? = nil,
                dataRetentionSupport: Boolean? = nil,
                description: String? = nil,
                fpgaImageGlobalId: String? = nil,
                fpgaImageId: String? = nil,
                name: String? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                pciId: PciId? = nil,
                productCodes: ProductCodeList? = nil,
                `public`: Boolean? = nil,
                shellVersion: String? = nil,
                state: FpgaImageState? = nil,
                tags: TagList? = nil,
                updateTime: DateTime? = nil) {
        self.createTime = createTime
        self.dataRetentionSupport = dataRetentionSupport
        self.description = description
        self.fpgaImageGlobalId = fpgaImageGlobalId
        self.fpgaImageId = fpgaImageId
        self.name = name
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.pciId = pciId
        self.productCodes = productCodes
        self.`public` = `public`
        self.shellVersion = shellVersion
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }

    enum CodingKeys: String, CodingKey {
        case createTime
        case dataRetentionSupport
        case description
        case fpgaImageGlobalId
        case fpgaImageId
        case name
        case ownerAlias
        case ownerId
        case pciId
        case productCodes
        case `public` = "public"
        case shellVersion
        case state
        case tags
        case updateTime
    }

    public func validate() throws {
        try pciId?.validate()
        try state?.validate()
    }
}

public struct FpgaImageAttribute: Codable, Equatable {
    public var description: String?
    public var fpgaImageId: String?
    public var loadPermissions: LoadPermissionList?
    public var name: String?
    public var productCodes: ProductCodeList?

    public init(description: String? = nil,
                fpgaImageId: String? = nil,
                loadPermissions: LoadPermissionList? = nil,
                name: String? = nil,
                productCodes: ProductCodeList? = nil) {
        self.description = description
        self.fpgaImageId = fpgaImageId
        self.loadPermissions = loadPermissions
        self.name = name
        self.productCodes = productCodes
    }

    enum CodingKeys: String, CodingKey {
        case description
        case fpgaImageId
        case loadPermissions
        case name
        case productCodes
    }

    public func validate() throws {
    }
}

public struct FpgaImageState: Codable, Equatable {
    public var code: FpgaImageStateCode?
    public var message: String?

    public init(code: FpgaImageStateCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct FpgaInfo: Codable, Equatable {
    public var fpgas: FpgaDeviceInfoList?
    public var totalFpgaMemoryInMiB: TotalFpgaMemory?

    public init(fpgas: FpgaDeviceInfoList? = nil,
                totalFpgaMemoryInMiB: TotalFpgaMemory? = nil) {
        self.fpgas = fpgas
        self.totalFpgaMemoryInMiB = totalFpgaMemoryInMiB
    }

    enum CodingKeys: String, CodingKey {
        case fpgas
        case totalFpgaMemoryInMiB
    }

    public func validate() throws {
    }
}

public struct GetAssociatedEnclaveCertificateIamRolesRequest: Codable, Equatable {
    public var certificateArn: ResourceArn?
    public var dryRun: Boolean?

    public init(certificateArn: ResourceArn? = nil,
                dryRun: Boolean? = nil) {
        self.certificateArn = certificateArn
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case dryRun = "DryRun"
    }

    public func validate() throws {
        try certificateArn?.validateAsResourceArn()
    }
}

public struct GetAssociatedEnclaveCertificateIamRolesResult: Codable, Equatable {
    public var associatedRoles: AssociatedRolesList?

    public init(associatedRoles: AssociatedRolesList? = nil) {
        self.associatedRoles = associatedRoles
    }

    enum CodingKeys: String, CodingKey {
        case associatedRoles = "associatedRoleSet"
    }

    public func validate() throws {
    }
}

public struct GetAssociatedIpv6PoolCidrsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: Ipv6PoolMaxResults?
    public var nextToken: NextToken?
    public var poolId: Ipv6PoolEc2Id

    public init(dryRun: Boolean? = nil,
                maxResults: Ipv6PoolMaxResults? = nil,
                nextToken: NextToken? = nil,
                poolId: Ipv6PoolEc2Id) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolId = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsIpv6PoolMaxResults()
    }
}

public struct GetAssociatedIpv6PoolCidrsResult: Codable, Equatable {
    public var ipv6CidrAssociations: Ipv6CidrAssociationSet?
    public var nextToken: String?

    public init(ipv6CidrAssociations: Ipv6CidrAssociationSet? = nil,
                nextToken: String? = nil) {
        self.ipv6CidrAssociations = ipv6CidrAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrAssociations = "ipv6CidrAssociationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetCapacityReservationUsageRequest: Codable, Equatable {
    public var capacityReservationId: CapacityReservationId
    public var dryRun: Boolean?
    public var maxResults: GetCapacityReservationUsageRequestMaxResults?
    public var nextToken: String?

    public init(capacityReservationId: CapacityReservationId,
                dryRun: Boolean? = nil,
                maxResults: GetCapacityReservationUsageRequestMaxResults? = nil,
                nextToken: String? = nil) {
        self.capacityReservationId = capacityReservationId
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsGetCapacityReservationUsageRequestMaxResults()
    }
}

public struct GetCapacityReservationUsageResult: Codable, Equatable {
    public var availableInstanceCount: Integer?
    public var capacityReservationId: String?
    public var instanceType: String?
    public var instanceUsages: InstanceUsageSet?
    public var nextToken: String?
    public var state: CapacityReservationState?
    public var totalInstanceCount: Integer?

    public init(availableInstanceCount: Integer? = nil,
                capacityReservationId: String? = nil,
                instanceType: String? = nil,
                instanceUsages: InstanceUsageSet? = nil,
                nextToken: String? = nil,
                state: CapacityReservationState? = nil,
                totalInstanceCount: Integer? = nil) {
        self.availableInstanceCount = availableInstanceCount
        self.capacityReservationId = capacityReservationId
        self.instanceType = instanceType
        self.instanceUsages = instanceUsages
        self.nextToken = nextToken
        self.state = state
        self.totalInstanceCount = totalInstanceCount
    }

    enum CodingKeys: String, CodingKey {
        case availableInstanceCount
        case capacityReservationId
        case instanceType
        case instanceUsages = "instanceUsageSet"
        case nextToken
        case state
        case totalInstanceCount
    }

    public func validate() throws {
    }
}

public struct GetCoipPoolUsageRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: CoipPoolMaxResults?
    public var nextToken: String?
    public var poolId: CoipPoolId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: CoipPoolMaxResults? = nil,
                nextToken: String? = nil,
                poolId: CoipPoolId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolId = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsCoipPoolMaxResults()
    }
}

public struct GetCoipPoolUsageResult: Codable, Equatable {
    public var coipAddressUsages: CoipAddressUsageSet?
    public var coipPoolId: String?
    public var localGatewayRouteTableId: String?

    public init(coipAddressUsages: CoipAddressUsageSet? = nil,
                coipPoolId: String? = nil,
                localGatewayRouteTableId: String? = nil) {
        self.coipAddressUsages = coipAddressUsages
        self.coipPoolId = coipPoolId
        self.localGatewayRouteTableId = localGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case coipAddressUsages = "coipAddressUsageSet"
        case coipPoolId
        case localGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct GetConsoleOutputRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var latest: Boolean?

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                latest: Boolean? = nil) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.latest = latest
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId = "InstanceId"
        case latest = "Latest"
    }

    public func validate() throws {
    }
}

public struct GetConsoleOutputResult: Codable, Equatable {
    public var instanceId: String?
    public var output: String?
    public var timestamp: DateTime?

    public init(instanceId: String? = nil,
                output: String? = nil,
                timestamp: DateTime? = nil) {
        self.instanceId = instanceId
        self.output = output
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case output
        case timestamp
    }

    public func validate() throws {
    }
}

public struct GetConsoleScreenshotRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var wakeUp: Boolean?

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                wakeUp: Boolean? = nil) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.wakeUp = wakeUp
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
        case wakeUp = "WakeUp"
    }

    public func validate() throws {
    }
}

public struct GetConsoleScreenshotResult: Codable, Equatable {
    public var imageData: String?
    public var instanceId: String?

    public init(imageData: String? = nil,
                instanceId: String? = nil) {
        self.imageData = imageData
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case imageData
        case instanceId
    }

    public func validate() throws {
    }
}

public struct GetDefaultCreditSpecificationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceFamily: UnlimitedSupportedInstanceFamily

    public init(dryRun: Boolean? = nil,
                instanceFamily: UnlimitedSupportedInstanceFamily) {
        self.dryRun = dryRun
        self.instanceFamily = instanceFamily
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceFamily = "InstanceFamily"
    }

    public func validate() throws {
    }
}

public struct GetDefaultCreditSpecificationResult: Codable, Equatable {
    public var instanceFamilyCreditSpecification: InstanceFamilyCreditSpecification?

    public init(instanceFamilyCreditSpecification: InstanceFamilyCreditSpecification? = nil) {
        self.instanceFamilyCreditSpecification = instanceFamilyCreditSpecification
    }

    enum CodingKeys: String, CodingKey {
        case instanceFamilyCreditSpecification
    }

    public func validate() throws {
        try instanceFamilyCreditSpecification?.validate()
    }
}

public struct GetEbsDefaultKmsKeyIdRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct GetEbsDefaultKmsKeyIdResult: Codable, Equatable {
    public var kmsKeyId: String?

    public init(kmsKeyId: String? = nil) {
        self.kmsKeyId = kmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case kmsKeyId
    }

    public func validate() throws {
    }
}

public struct GetEbsEncryptionByDefaultRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct GetEbsEncryptionByDefaultResult: Codable, Equatable {
    public var ebsEncryptionByDefault: Boolean?

    public init(ebsEncryptionByDefault: Boolean? = nil) {
        self.ebsEncryptionByDefault = ebsEncryptionByDefault
    }

    enum CodingKeys: String, CodingKey {
        case ebsEncryptionByDefault
    }

    public func validate() throws {
    }
}

public struct GetGroupsForCapacityReservationRequest: Codable, Equatable {
    public var capacityReservationId: CapacityReservationId
    public var dryRun: Boolean?
    public var maxResults: GetGroupsForCapacityReservationRequestMaxResults?
    public var nextToken: String?

    public init(capacityReservationId: CapacityReservationId,
                dryRun: Boolean? = nil,
                maxResults: GetGroupsForCapacityReservationRequestMaxResults? = nil,
                nextToken: String? = nil) {
        self.capacityReservationId = capacityReservationId
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsGetGroupsForCapacityReservationRequestMaxResults()
    }
}

public struct GetGroupsForCapacityReservationResult: Codable, Equatable {
    public var capacityReservationGroups: CapacityReservationGroupSet?
    public var nextToken: String?

    public init(capacityReservationGroups: CapacityReservationGroupSet? = nil,
                nextToken: String? = nil) {
        self.capacityReservationGroups = capacityReservationGroups
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationGroups = "capacityReservationGroupSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetHostReservationPurchasePreviewRequest: Codable, Equatable {
    public var hostIdSet: RequestHostIdSet
    public var offeringId: OfferingId

    public init(hostIdSet: RequestHostIdSet,
                offeringId: OfferingId) {
        self.hostIdSet = hostIdSet
        self.offeringId = offeringId
    }

    enum CodingKeys: String, CodingKey {
        case hostIdSet = "HostIdSet"
        case offeringId = "OfferingId"
    }

    public func validate() throws {
    }
}

public struct GetHostReservationPurchasePreviewResult: Codable, Equatable {
    public var currencyCode: CurrencyCodeValues?
    public var purchase: PurchaseSet?
    public var totalHourlyPrice: String?
    public var totalUpfrontPrice: String?

    public init(currencyCode: CurrencyCodeValues? = nil,
                purchase: PurchaseSet? = nil,
                totalHourlyPrice: String? = nil,
                totalUpfrontPrice: String? = nil) {
        self.currencyCode = currencyCode
        self.purchase = purchase
        self.totalHourlyPrice = totalHourlyPrice
        self.totalUpfrontPrice = totalUpfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case purchase
        case totalHourlyPrice
        case totalUpfrontPrice
    }

    public func validate() throws {
    }
}

public struct GetLaunchTemplateDataRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct GetLaunchTemplateDataResult: Codable, Equatable {
    public var launchTemplateData: ResponseLaunchTemplateData?

    public init(launchTemplateData: ResponseLaunchTemplateData? = nil) {
        self.launchTemplateData = launchTemplateData
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateData
    }

    public func validate() throws {
        try launchTemplateData?.validate()
    }
}

public struct GetManagedPrefixListAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: GetManagedPrefixListAssociationsMaxResults?
    public var nextToken: NextToken?
    public var prefixListId: PrefixListResourceId

    public init(dryRun: Boolean? = nil,
                maxResults: GetManagedPrefixListAssociationsMaxResults? = nil,
                nextToken: NextToken? = nil,
                prefixListId: PrefixListResourceId) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.prefixListId = prefixListId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case prefixListId = "PrefixListId"
    }

    public func validate() throws {
        try maxResults?.validateAsGetManagedPrefixListAssociationsMaxResults()
    }
}

public struct GetManagedPrefixListAssociationsResult: Codable, Equatable {
    public var nextToken: String?
    public var prefixListAssociations: PrefixListAssociationSet?

    public init(nextToken: String? = nil,
                prefixListAssociations: PrefixListAssociationSet? = nil) {
        self.nextToken = nextToken
        self.prefixListAssociations = prefixListAssociations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case prefixListAssociations = "prefixListAssociationSet"
    }

    public func validate() throws {
    }
}

public struct GetManagedPrefixListEntriesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: PrefixListMaxResults?
    public var nextToken: NextToken?
    public var prefixListId: PrefixListResourceId
    public var targetVersion: Long?

    public init(dryRun: Boolean? = nil,
                maxResults: PrefixListMaxResults? = nil,
                nextToken: NextToken? = nil,
                prefixListId: PrefixListResourceId,
                targetVersion: Long? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.prefixListId = prefixListId
        self.targetVersion = targetVersion
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case prefixListId = "PrefixListId"
        case targetVersion = "TargetVersion"
    }

    public func validate() throws {
        try maxResults?.validateAsPrefixListMaxResults()
    }
}

public struct GetManagedPrefixListEntriesResult: Codable, Equatable {
    public var entries: PrefixListEntrySet?
    public var nextToken: NextToken?

    public init(entries: PrefixListEntrySet? = nil,
                nextToken: NextToken? = nil) {
        self.entries = entries
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case entries = "entrySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetPasswordDataRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct GetPasswordDataResult: Codable, Equatable {
    public var instanceId: String?
    public var passwordData: String?
    public var timestamp: DateTime?

    public init(instanceId: String? = nil,
                passwordData: String? = nil,
                timestamp: DateTime? = nil) {
        self.instanceId = instanceId
        self.passwordData = passwordData
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case passwordData
        case timestamp
    }

    public func validate() throws {
    }
}

public struct GetReservedInstancesExchangeQuoteRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var reservedInstanceIds: ReservedInstanceIdSet
    public var targetConfigurations: TargetConfigurationRequestSet?

    public init(dryRun: Boolean? = nil,
                reservedInstanceIds: ReservedInstanceIdSet,
                targetConfigurations: TargetConfigurationRequestSet? = nil) {
        self.dryRun = dryRun
        self.reservedInstanceIds = reservedInstanceIds
        self.targetConfigurations = targetConfigurations
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case reservedInstanceIds = "ReservedInstanceId"
        case targetConfigurations = "TargetConfiguration"
    }

    public func validate() throws {
    }
}

public struct GetReservedInstancesExchangeQuoteResult: Codable, Equatable {
    public var currencyCode: String?
    public var isValidExchange: Boolean?
    public var outputReservedInstancesWillExpireAt: DateTime?
    public var paymentDue: String?
    public var reservedInstanceValueRollup: ReservationValue?
    public var reservedInstanceValueSet: ReservedInstanceReservationValueSet?
    public var targetConfigurationValueRollup: ReservationValue?
    public var targetConfigurationValueSet: TargetReservationValueSet?
    public var validationFailureReason: String?

    public init(currencyCode: String? = nil,
                isValidExchange: Boolean? = nil,
                outputReservedInstancesWillExpireAt: DateTime? = nil,
                paymentDue: String? = nil,
                reservedInstanceValueRollup: ReservationValue? = nil,
                reservedInstanceValueSet: ReservedInstanceReservationValueSet? = nil,
                targetConfigurationValueRollup: ReservationValue? = nil,
                targetConfigurationValueSet: TargetReservationValueSet? = nil,
                validationFailureReason: String? = nil) {
        self.currencyCode = currencyCode
        self.isValidExchange = isValidExchange
        self.outputReservedInstancesWillExpireAt = outputReservedInstancesWillExpireAt
        self.paymentDue = paymentDue
        self.reservedInstanceValueRollup = reservedInstanceValueRollup
        self.reservedInstanceValueSet = reservedInstanceValueSet
        self.targetConfigurationValueRollup = targetConfigurationValueRollup
        self.targetConfigurationValueSet = targetConfigurationValueSet
        self.validationFailureReason = validationFailureReason
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case isValidExchange
        case outputReservedInstancesWillExpireAt
        case paymentDue
        case reservedInstanceValueRollup
        case reservedInstanceValueSet
        case targetConfigurationValueRollup
        case targetConfigurationValueSet
        case validationFailureReason
    }

    public func validate() throws {
        try reservedInstanceValueRollup?.validate()
        try targetConfigurationValueRollup?.validate()
    }
}

public struct GetTransitGatewayAttachmentPropagationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayAttachmentPropagationsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayAttachmentPropagations: TransitGatewayAttachmentPropagationList?

    public init(nextToken: String? = nil,
                transitGatewayAttachmentPropagations: TransitGatewayAttachmentPropagationList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayAttachmentPropagations = transitGatewayAttachmentPropagations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayAttachmentPropagations
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayMulticastDomainAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayMulticastDomainAssociationsResult: Codable, Equatable {
    public var multicastDomainAssociations: TransitGatewayMulticastDomainAssociationList?
    public var nextToken: String?

    public init(multicastDomainAssociations: TransitGatewayMulticastDomainAssociationList? = nil,
                nextToken: String? = nil) {
        self.multicastDomainAssociations = multicastDomainAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case multicastDomainAssociations
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayPrefixListReferencesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayPrefixListReferencesResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayPrefixListReferences: TransitGatewayPrefixListReferenceSet?

    public init(nextToken: String? = nil,
                transitGatewayPrefixListReferences: TransitGatewayPrefixListReferenceSet? = nil) {
        self.nextToken = nextToken
        self.transitGatewayPrefixListReferences = transitGatewayPrefixListReferences
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayPrefixListReferences = "transitGatewayPrefixListReferenceSet"
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayRouteTableAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayRouteTableAssociationsResult: Codable, Equatable {
    public var associations: TransitGatewayRouteTableAssociationList?
    public var nextToken: String?

    public init(associations: TransitGatewayRouteTableAssociationList? = nil,
                nextToken: String? = nil) {
        self.associations = associations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case associations
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayRouteTablePropagationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayRouteTablePropagationsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayRouteTablePropagations: TransitGatewayRouteTablePropagationList?

    public init(nextToken: String? = nil,
                transitGatewayRouteTablePropagations: TransitGatewayRouteTablePropagationList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayRouteTablePropagations = transitGatewayRouteTablePropagations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayRouteTablePropagations
    }

    public func validate() throws {
    }
}

public struct GpuDeviceInfo: Codable, Equatable {
    public var count: GpuDeviceCount?
    public var manufacturer: GpuDeviceManufacturerName?
    public var memoryInfo: GpuDeviceMemoryInfo?
    public var name: GpuDeviceName?

    public init(count: GpuDeviceCount? = nil,
                manufacturer: GpuDeviceManufacturerName? = nil,
                memoryInfo: GpuDeviceMemoryInfo? = nil,
                name: GpuDeviceName? = nil) {
        self.count = count
        self.manufacturer = manufacturer
        self.memoryInfo = memoryInfo
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case count
        case manufacturer
        case memoryInfo
        case name
    }

    public func validate() throws {
        try memoryInfo?.validate()
    }
}

public struct GpuDeviceMemoryInfo: Codable, Equatable {
    public var sizeInMiB: GpuDeviceMemorySize?

    public init(sizeInMiB: GpuDeviceMemorySize? = nil) {
        self.sizeInMiB = sizeInMiB
    }

    enum CodingKeys: String, CodingKey {
        case sizeInMiB
    }

    public func validate() throws {
    }
}

public struct GpuInfo: Codable, Equatable {
    public var gpus: GpuDeviceInfoList?
    public var totalGpuMemoryInMiB: TotalGpuMemory?

    public init(gpus: GpuDeviceInfoList? = nil,
                totalGpuMemoryInMiB: TotalGpuMemory? = nil) {
        self.gpus = gpus
        self.totalGpuMemoryInMiB = totalGpuMemoryInMiB
    }

    enum CodingKeys: String, CodingKey {
        case gpus
        case totalGpuMemoryInMiB
    }

    public func validate() throws {
    }
}

public struct GroupIdentifier: Codable, Equatable {
    public var groupId: String?
    public var groupName: String?

    public init(groupId: String? = nil,
                groupName: String? = nil) {
        self.groupId = groupId
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case groupName
    }

    public func validate() throws {
    }
}

public struct HibernationOptions: Codable, Equatable {
    public var configured: Boolean?

    public init(configured: Boolean? = nil) {
        self.configured = configured
    }

    enum CodingKeys: String, CodingKey {
        case configured
    }

    public func validate() throws {
    }
}

public struct HibernationOptionsRequest: Codable, Equatable {
    public var configured: Boolean?

    public init(configured: Boolean? = nil) {
        self.configured = configured
    }

    enum CodingKeys: String, CodingKey {
        case configured = "Configured"
    }

    public func validate() throws {
    }
}

public struct HistoryRecord: Codable, Equatable {
    public var eventInformation: EventInformation?
    public var eventType: EventType?
    public var timestamp: DateTime?

    public init(eventInformation: EventInformation? = nil,
                eventType: EventType? = nil,
                timestamp: DateTime? = nil) {
        self.eventInformation = eventInformation
        self.eventType = eventType
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case eventInformation
        case eventType
        case timestamp
    }

    public func validate() throws {
        try eventInformation?.validate()
    }
}

public struct HistoryRecordEntry: Codable, Equatable {
    public var eventInformation: EventInformation?
    public var eventType: FleetEventType?
    public var timestamp: DateTime?

    public init(eventInformation: EventInformation? = nil,
                eventType: FleetEventType? = nil,
                timestamp: DateTime? = nil) {
        self.eventInformation = eventInformation
        self.eventType = eventType
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case eventInformation
        case eventType
        case timestamp
    }

    public func validate() throws {
        try eventInformation?.validate()
    }
}

public struct Host: Codable, Equatable {
    public var allocationTime: DateTime?
    public var allowsMultipleInstanceTypes: AllowsMultipleInstanceTypes?
    public var autoPlacement: AutoPlacement?
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var availableCapacity: AvailableCapacity?
    public var clientToken: String?
    public var hostId: String?
    public var hostProperties: HostProperties?
    public var hostRecovery: HostRecovery?
    public var hostReservationId: String?
    public var instances: HostInstanceList?
    public var memberOfServiceLinkedResourceGroup: Boolean?
    public var ownerId: String?
    public var releaseTime: DateTime?
    public var state: AllocationState?
    public var tags: TagList?

    public init(allocationTime: DateTime? = nil,
                allowsMultipleInstanceTypes: AllowsMultipleInstanceTypes? = nil,
                autoPlacement: AutoPlacement? = nil,
                availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                availableCapacity: AvailableCapacity? = nil,
                clientToken: String? = nil,
                hostId: String? = nil,
                hostProperties: HostProperties? = nil,
                hostRecovery: HostRecovery? = nil,
                hostReservationId: String? = nil,
                instances: HostInstanceList? = nil,
                memberOfServiceLinkedResourceGroup: Boolean? = nil,
                ownerId: String? = nil,
                releaseTime: DateTime? = nil,
                state: AllocationState? = nil,
                tags: TagList? = nil) {
        self.allocationTime = allocationTime
        self.allowsMultipleInstanceTypes = allowsMultipleInstanceTypes
        self.autoPlacement = autoPlacement
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.availableCapacity = availableCapacity
        self.clientToken = clientToken
        self.hostId = hostId
        self.hostProperties = hostProperties
        self.hostRecovery = hostRecovery
        self.hostReservationId = hostReservationId
        self.instances = instances
        self.memberOfServiceLinkedResourceGroup = memberOfServiceLinkedResourceGroup
        self.ownerId = ownerId
        self.releaseTime = releaseTime
        self.state = state
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case allocationTime
        case allowsMultipleInstanceTypes
        case autoPlacement
        case availabilityZone
        case availabilityZoneId
        case availableCapacity
        case clientToken
        case hostId
        case hostProperties
        case hostRecovery
        case hostReservationId
        case instances
        case memberOfServiceLinkedResourceGroup
        case ownerId
        case releaseTime
        case state
        case tags = "tagSet"
    }

    public func validate() throws {
        try availableCapacity?.validate()
        try hostProperties?.validate()
    }
}

public struct HostInstance: Codable, Equatable {
    public var instanceId: String?
    public var instanceType: String?
    public var ownerId: String?

    public init(instanceId: String? = nil,
                instanceType: String? = nil,
                ownerId: String? = nil) {
        self.instanceId = instanceId
        self.instanceType = instanceType
        self.ownerId = ownerId
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case instanceType
        case ownerId
    }

    public func validate() throws {
    }
}

public struct HostOffering: Codable, Equatable {
    public var currencyCode: CurrencyCodeValues?
    public var duration: Integer?
    public var hourlyPrice: String?
    public var instanceFamily: String?
    public var offeringId: String?
    public var paymentOption: PaymentOption?
    public var upfrontPrice: String?

    public init(currencyCode: CurrencyCodeValues? = nil,
                duration: Integer? = nil,
                hourlyPrice: String? = nil,
                instanceFamily: String? = nil,
                offeringId: String? = nil,
                paymentOption: PaymentOption? = nil,
                upfrontPrice: String? = nil) {
        self.currencyCode = currencyCode
        self.duration = duration
        self.hourlyPrice = hourlyPrice
        self.instanceFamily = instanceFamily
        self.offeringId = offeringId
        self.paymentOption = paymentOption
        self.upfrontPrice = upfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case duration
        case hourlyPrice
        case instanceFamily
        case offeringId
        case paymentOption
        case upfrontPrice
    }

    public func validate() throws {
    }
}

public struct HostProperties: Codable, Equatable {
    public var cores: Integer?
    public var instanceFamily: String?
    public var instanceType: String?
    public var sockets: Integer?
    public var totalVCpus: Integer?

    public init(cores: Integer? = nil,
                instanceFamily: String? = nil,
                instanceType: String? = nil,
                sockets: Integer? = nil,
                totalVCpus: Integer? = nil) {
        self.cores = cores
        self.instanceFamily = instanceFamily
        self.instanceType = instanceType
        self.sockets = sockets
        self.totalVCpus = totalVCpus
    }

    enum CodingKeys: String, CodingKey {
        case cores
        case instanceFamily
        case instanceType
        case sockets
        case totalVCpus
    }

    public func validate() throws {
    }
}

public struct HostReservation: Codable, Equatable {
    public var count: Integer?
    public var currencyCode: CurrencyCodeValues?
    public var duration: Integer?
    public var end: DateTime?
    public var hostIdSet: ResponseHostIdSet?
    public var hostReservationId: String?
    public var hourlyPrice: String?
    public var instanceFamily: String?
    public var offeringId: String?
    public var paymentOption: PaymentOption?
    public var start: DateTime?
    public var state: ReservationState?
    public var tags: TagList?
    public var upfrontPrice: String?

    public init(count: Integer? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                duration: Integer? = nil,
                end: DateTime? = nil,
                hostIdSet: ResponseHostIdSet? = nil,
                hostReservationId: String? = nil,
                hourlyPrice: String? = nil,
                instanceFamily: String? = nil,
                offeringId: String? = nil,
                paymentOption: PaymentOption? = nil,
                start: DateTime? = nil,
                state: ReservationState? = nil,
                tags: TagList? = nil,
                upfrontPrice: String? = nil) {
        self.count = count
        self.currencyCode = currencyCode
        self.duration = duration
        self.end = end
        self.hostIdSet = hostIdSet
        self.hostReservationId = hostReservationId
        self.hourlyPrice = hourlyPrice
        self.instanceFamily = instanceFamily
        self.offeringId = offeringId
        self.paymentOption = paymentOption
        self.start = start
        self.state = state
        self.tags = tags
        self.upfrontPrice = upfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case count
        case currencyCode
        case duration
        case end
        case hostIdSet
        case hostReservationId
        case hourlyPrice
        case instanceFamily
        case offeringId
        case paymentOption
        case start
        case state
        case tags = "tagSet"
        case upfrontPrice
    }

    public func validate() throws {
    }
}

public struct IKEVersionsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct IKEVersionsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct IamInstanceProfile: Codable, Equatable {
    public var arn: String?
    public var id: String?

    public init(arn: String? = nil,
                id: String? = nil) {
        self.arn = arn
        self.id = id
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case id
    }

    public func validate() throws {
    }
}

public struct IamInstanceProfileAssociation: Codable, Equatable {
    public var associationId: String?
    public var iamInstanceProfile: IamInstanceProfile?
    public var instanceId: String?
    public var state: IamInstanceProfileAssociationState?
    public var timestamp: DateTime?

    public init(associationId: String? = nil,
                iamInstanceProfile: IamInstanceProfile? = nil,
                instanceId: String? = nil,
                state: IamInstanceProfileAssociationState? = nil,
                timestamp: DateTime? = nil) {
        self.associationId = associationId
        self.iamInstanceProfile = iamInstanceProfile
        self.instanceId = instanceId
        self.state = state
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case iamInstanceProfile
        case instanceId
        case state
        case timestamp
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
    }
}

public struct IamInstanceProfileSpecification: Codable, Equatable {
    public var arn: String?
    public var name: String?

    public init(arn: String? = nil,
                name: String? = nil) {
        self.arn = arn
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case name
    }

    public func validate() throws {
    }
}

public struct IcmpTypeCode: Codable, Equatable {
    public var code: Integer?
    public var type: Integer?

    public init(code: Integer? = nil,
                type: Integer? = nil) {
        self.code = code
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case code
        case type
    }

    public func validate() throws {
    }
}

public struct IdFormat: Codable, Equatable {
    public var deadline: DateTime?
    public var resource: String?
    public var useLongIds: Boolean?

    public init(deadline: DateTime? = nil,
                resource: String? = nil,
                useLongIds: Boolean? = nil) {
        self.deadline = deadline
        self.resource = resource
        self.useLongIds = useLongIds
    }

    enum CodingKeys: String, CodingKey {
        case deadline
        case resource
        case useLongIds
    }

    public func validate() throws {
    }
}

public struct Image: Codable, Equatable {
    public var architecture: ArchitectureValues?
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var creationDate: String?
    public var description: String?
    public var enaSupport: Boolean?
    public var hypervisor: HypervisorType?
    public var imageId: String?
    public var imageLocation: String?
    public var imageOwnerAlias: String?
    public var imageType: ImageTypeValues?
    public var kernelId: String?
    public var name: String?
    public var ownerId: String?
    public var platform: PlatformValues?
    public var platformDetails: String?
    public var productCodes: ProductCodeList?
    public var `public`: Boolean?
    public var ramdiskId: String?
    public var rootDeviceName: String?
    public var rootDeviceType: DeviceType?
    public var sriovNetSupport: String?
    public var state: ImageState?
    public var stateReason: StateReason?
    public var tags: TagList?
    public var usageOperation: String?
    public var virtualizationType: VirtualizationType?

    public init(architecture: ArchitectureValues? = nil,
                blockDeviceMappings: BlockDeviceMappingList? = nil,
                creationDate: String? = nil,
                description: String? = nil,
                enaSupport: Boolean? = nil,
                hypervisor: HypervisorType? = nil,
                imageId: String? = nil,
                imageLocation: String? = nil,
                imageOwnerAlias: String? = nil,
                imageType: ImageTypeValues? = nil,
                kernelId: String? = nil,
                name: String? = nil,
                ownerId: String? = nil,
                platform: PlatformValues? = nil,
                platformDetails: String? = nil,
                productCodes: ProductCodeList? = nil,
                `public`: Boolean? = nil,
                ramdiskId: String? = nil,
                rootDeviceName: String? = nil,
                rootDeviceType: DeviceType? = nil,
                sriovNetSupport: String? = nil,
                state: ImageState? = nil,
                stateReason: StateReason? = nil,
                tags: TagList? = nil,
                usageOperation: String? = nil,
                virtualizationType: VirtualizationType? = nil) {
        self.architecture = architecture
        self.blockDeviceMappings = blockDeviceMappings
        self.creationDate = creationDate
        self.description = description
        self.enaSupport = enaSupport
        self.hypervisor = hypervisor
        self.imageId = imageId
        self.imageLocation = imageLocation
        self.imageOwnerAlias = imageOwnerAlias
        self.imageType = imageType
        self.kernelId = kernelId
        self.name = name
        self.ownerId = ownerId
        self.platform = platform
        self.platformDetails = platformDetails
        self.productCodes = productCodes
        self.`public` = `public`
        self.ramdiskId = ramdiskId
        self.rootDeviceName = rootDeviceName
        self.rootDeviceType = rootDeviceType
        self.sriovNetSupport = sriovNetSupport
        self.state = state
        self.stateReason = stateReason
        self.tags = tags
        self.usageOperation = usageOperation
        self.virtualizationType = virtualizationType
    }

    enum CodingKeys: String, CodingKey {
        case architecture
        case blockDeviceMappings = "blockDeviceMapping"
        case creationDate
        case description
        case enaSupport
        case hypervisor
        case imageId
        case imageLocation
        case imageOwnerAlias
        case imageType
        case kernelId
        case name
        case ownerId = "imageOwnerId"
        case platform
        case platformDetails
        case productCodes
        case `public` = "isPublic"
        case ramdiskId
        case rootDeviceName
        case rootDeviceType
        case sriovNetSupport
        case state = "imageState"
        case stateReason
        case tags = "tagSet"
        case usageOperation
        case virtualizationType
    }

    public func validate() throws {
        try stateReason?.validate()
    }
}

public struct ImageAttribute: Codable, Equatable {
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var description: AttributeValue?
    public var imageId: String?
    public var kernelId: AttributeValue?
    public var launchPermissions: LaunchPermissionList?
    public var productCodes: ProductCodeList?
    public var ramdiskId: AttributeValue?
    public var sriovNetSupport: AttributeValue?

    public init(blockDeviceMappings: BlockDeviceMappingList? = nil,
                description: AttributeValue? = nil,
                imageId: String? = nil,
                kernelId: AttributeValue? = nil,
                launchPermissions: LaunchPermissionList? = nil,
                productCodes: ProductCodeList? = nil,
                ramdiskId: AttributeValue? = nil,
                sriovNetSupport: AttributeValue? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.description = description
        self.imageId = imageId
        self.kernelId = kernelId
        self.launchPermissions = launchPermissions
        self.productCodes = productCodes
        self.ramdiskId = ramdiskId
        self.sriovNetSupport = sriovNetSupport
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "blockDeviceMapping"
        case description
        case imageId
        case kernelId = "kernel"
        case launchPermissions = "launchPermission"
        case productCodes
        case ramdiskId = "ramdisk"
        case sriovNetSupport
    }

    public func validate() throws {
        try description?.validate()
        try kernelId?.validate()
        try ramdiskId?.validate()
        try sriovNetSupport?.validate()
    }
}

public struct ImageDiskContainer: Codable, Equatable {
    public var description: String?
    public var deviceName: String?
    public var format: String?
    public var snapshotId: SnapshotId?
    public var url: String?
    public var userBucket: UserBucket?

    public init(description: String? = nil,
                deviceName: String? = nil,
                format: String? = nil,
                snapshotId: SnapshotId? = nil,
                url: String? = nil,
                userBucket: UserBucket? = nil) {
        self.description = description
        self.deviceName = deviceName
        self.format = format
        self.snapshotId = snapshotId
        self.url = url
        self.userBucket = userBucket
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case deviceName = "DeviceName"
        case format = "Format"
        case snapshotId = "SnapshotId"
        case url = "Url"
        case userBucket = "UserBucket"
    }

    public func validate() throws {
        try userBucket?.validate()
    }
}

public struct ImportClientVpnClientCertificateRevocationListRequest: Codable, Equatable {
    public var certificateRevocationList: String
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(certificateRevocationList: String,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.certificateRevocationList = certificateRevocationList
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case certificateRevocationList = "CertificateRevocationList"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ImportClientVpnClientCertificateRevocationListResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ImportImageLicenseConfigurationRequest: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func validate() throws {
    }
}

public struct ImportImageLicenseConfigurationResponse: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn
    }

    public func validate() throws {
    }
}

public struct ImportImageRequest: Codable, Equatable {
    public var architecture: String?
    public var clientData: ClientData?
    public var clientToken: String?
    public var description: String?
    public var diskContainers: ImageDiskContainerList?
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var hypervisor: String?
    public var kmsKeyId: KmsKeyId?
    public var licenseSpecifications: ImportImageLicenseSpecificationListRequest?
    public var licenseType: String?
    public var platform: String?
    public var roleName: String?
    public var tagSpecifications: TagSpecificationList?

    public init(architecture: String? = nil,
                clientData: ClientData? = nil,
                clientToken: String? = nil,
                description: String? = nil,
                diskContainers: ImageDiskContainerList? = nil,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                hypervisor: String? = nil,
                kmsKeyId: KmsKeyId? = nil,
                licenseSpecifications: ImportImageLicenseSpecificationListRequest? = nil,
                licenseType: String? = nil,
                platform: String? = nil,
                roleName: String? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.architecture = architecture
        self.clientData = clientData
        self.clientToken = clientToken
        self.description = description
        self.diskContainers = diskContainers
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.hypervisor = hypervisor
        self.kmsKeyId = kmsKeyId
        self.licenseSpecifications = licenseSpecifications
        self.licenseType = licenseType
        self.platform = platform
        self.roleName = roleName
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case architecture = "Architecture"
        case clientData = "ClientData"
        case clientToken = "ClientToken"
        case description = "Description"
        case diskContainers = "DiskContainer"
        case dryRun = "DryRun"
        case encrypted = "Encrypted"
        case hypervisor = "Hypervisor"
        case kmsKeyId = "KmsKeyId"
        case licenseSpecifications = "LicenseSpecifications"
        case licenseType = "LicenseType"
        case platform = "Platform"
        case roleName = "RoleName"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try clientData?.validate()
    }
}

public struct ImportImageResult: Codable, Equatable {
    public var architecture: String?
    public var description: String?
    public var encrypted: Boolean?
    public var hypervisor: String?
    public var imageId: String?
    public var importTaskId: ImportImageTaskId?
    public var kmsKeyId: KmsKeyId?
    public var licenseSpecifications: ImportImageLicenseSpecificationListResponse?
    public var licenseType: String?
    public var platform: String?
    public var progress: String?
    public var snapshotDetails: SnapshotDetailList?
    public var status: String?
    public var statusMessage: String?
    public var tags: TagList?

    public init(architecture: String? = nil,
                description: String? = nil,
                encrypted: Boolean? = nil,
                hypervisor: String? = nil,
                imageId: String? = nil,
                importTaskId: ImportImageTaskId? = nil,
                kmsKeyId: KmsKeyId? = nil,
                licenseSpecifications: ImportImageLicenseSpecificationListResponse? = nil,
                licenseType: String? = nil,
                platform: String? = nil,
                progress: String? = nil,
                snapshotDetails: SnapshotDetailList? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.architecture = architecture
        self.description = description
        self.encrypted = encrypted
        self.hypervisor = hypervisor
        self.imageId = imageId
        self.importTaskId = importTaskId
        self.kmsKeyId = kmsKeyId
        self.licenseSpecifications = licenseSpecifications
        self.licenseType = licenseType
        self.platform = platform
        self.progress = progress
        self.snapshotDetails = snapshotDetails
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case architecture
        case description
        case encrypted
        case hypervisor
        case imageId
        case importTaskId
        case kmsKeyId
        case licenseSpecifications
        case licenseType
        case platform
        case progress
        case snapshotDetails = "snapshotDetailSet"
        case status
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct ImportImageTask: Codable, Equatable {
    public var architecture: String?
    public var description: String?
    public var encrypted: Boolean?
    public var hypervisor: String?
    public var imageId: String?
    public var importTaskId: String?
    public var kmsKeyId: String?
    public var licenseSpecifications: ImportImageLicenseSpecificationListResponse?
    public var licenseType: String?
    public var platform: String?
    public var progress: String?
    public var snapshotDetails: SnapshotDetailList?
    public var status: String?
    public var statusMessage: String?
    public var tags: TagList?

    public init(architecture: String? = nil,
                description: String? = nil,
                encrypted: Boolean? = nil,
                hypervisor: String? = nil,
                imageId: String? = nil,
                importTaskId: String? = nil,
                kmsKeyId: String? = nil,
                licenseSpecifications: ImportImageLicenseSpecificationListResponse? = nil,
                licenseType: String? = nil,
                platform: String? = nil,
                progress: String? = nil,
                snapshotDetails: SnapshotDetailList? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.architecture = architecture
        self.description = description
        self.encrypted = encrypted
        self.hypervisor = hypervisor
        self.imageId = imageId
        self.importTaskId = importTaskId
        self.kmsKeyId = kmsKeyId
        self.licenseSpecifications = licenseSpecifications
        self.licenseType = licenseType
        self.platform = platform
        self.progress = progress
        self.snapshotDetails = snapshotDetails
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case architecture
        case description
        case encrypted
        case hypervisor
        case imageId
        case importTaskId
        case kmsKeyId
        case licenseSpecifications
        case licenseType
        case platform
        case progress
        case snapshotDetails = "snapshotDetailSet"
        case status
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct ImportInstanceLaunchSpecification: Codable, Equatable {
    public var additionalInfo: String?
    public var architecture: ArchitectureValues?
    public var groupIds: SecurityGroupIdStringList?
    public var groupNames: SecurityGroupStringList?
    public var instanceInitiatedShutdownBehavior: ShutdownBehavior?
    public var instanceType: InstanceType?
    public var monitoring: Boolean?
    public var placement: Placement?
    public var privateIpAddress: String?
    public var subnetId: SubnetId?
    public var userData: UserData?

    public init(additionalInfo: String? = nil,
                architecture: ArchitectureValues? = nil,
                groupIds: SecurityGroupIdStringList? = nil,
                groupNames: SecurityGroupStringList? = nil,
                instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil,
                instanceType: InstanceType? = nil,
                monitoring: Boolean? = nil,
                placement: Placement? = nil,
                privateIpAddress: String? = nil,
                subnetId: SubnetId? = nil,
                userData: UserData? = nil) {
        self.additionalInfo = additionalInfo
        self.architecture = architecture
        self.groupIds = groupIds
        self.groupNames = groupNames
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceType = instanceType
        self.monitoring = monitoring
        self.placement = placement
        self.privateIpAddress = privateIpAddress
        self.subnetId = subnetId
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case additionalInfo
        case architecture
        case groupIds = "GroupId"
        case groupNames = "GroupName"
        case instanceInitiatedShutdownBehavior
        case instanceType
        case monitoring
        case placement
        case privateIpAddress
        case subnetId
        case userData
    }

    public func validate() throws {
        try placement?.validate()
        try userData?.validate()
    }
}

public struct ImportInstanceRequest: Codable, Equatable {
    public var description: String?
    public var diskImages: DiskImageList?
    public var dryRun: Boolean?
    public var launchSpecification: ImportInstanceLaunchSpecification?
    public var platform: PlatformValues

    public init(description: String? = nil,
                diskImages: DiskImageList? = nil,
                dryRun: Boolean? = nil,
                launchSpecification: ImportInstanceLaunchSpecification? = nil,
                platform: PlatformValues) {
        self.description = description
        self.diskImages = diskImages
        self.dryRun = dryRun
        self.launchSpecification = launchSpecification
        self.platform = platform
    }

    enum CodingKeys: String, CodingKey {
        case description
        case diskImages = "diskImage"
        case dryRun
        case launchSpecification
        case platform
    }

    public func validate() throws {
        try launchSpecification?.validate()
    }
}

public struct ImportInstanceResult: Codable, Equatable {
    public var conversionTask: ConversionTask?

    public init(conversionTask: ConversionTask? = nil) {
        self.conversionTask = conversionTask
    }

    enum CodingKeys: String, CodingKey {
        case conversionTask
    }

    public func validate() throws {
        try conversionTask?.validate()
    }
}

public struct ImportInstanceTaskDetails: Codable, Equatable {
    public var description: String?
    public var instanceId: String?
    public var platform: PlatformValues?
    public var volumes: ImportInstanceVolumeDetailSet?

    public init(description: String? = nil,
                instanceId: String? = nil,
                platform: PlatformValues? = nil,
                volumes: ImportInstanceVolumeDetailSet? = nil) {
        self.description = description
        self.instanceId = instanceId
        self.platform = platform
        self.volumes = volumes
    }

    enum CodingKeys: String, CodingKey {
        case description
        case instanceId
        case platform
        case volumes
    }

    public func validate() throws {
    }
}

public struct ImportInstanceVolumeDetailItem: Codable, Equatable {
    public var availabilityZone: String?
    public var bytesConverted: Long?
    public var description: String?
    public var image: DiskImageDescription?
    public var status: String?
    public var statusMessage: String?
    public var volume: DiskImageVolumeDescription?

    public init(availabilityZone: String? = nil,
                bytesConverted: Long? = nil,
                description: String? = nil,
                image: DiskImageDescription? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                volume: DiskImageVolumeDescription? = nil) {
        self.availabilityZone = availabilityZone
        self.bytesConverted = bytesConverted
        self.description = description
        self.image = image
        self.status = status
        self.statusMessage = statusMessage
        self.volume = volume
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case bytesConverted
        case description
        case image
        case status
        case statusMessage
        case volume
    }

    public func validate() throws {
        try image?.validate()
        try volume?.validate()
    }
}

public struct ImportKeyPairRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var keyName: String
    public var publicKeyMaterial: Blob
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                keyName: String,
                publicKeyMaterial: Blob,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.keyName = keyName
        self.publicKeyMaterial = publicKeyMaterial
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case keyName
        case publicKeyMaterial
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct ImportKeyPairResult: Codable, Equatable {
    public var keyFingerprint: String?
    public var keyName: String?
    public var keyPairId: String?
    public var tags: TagList?

    public init(keyFingerprint: String? = nil,
                keyName: String? = nil,
                keyPairId: String? = nil,
                tags: TagList? = nil) {
        self.keyFingerprint = keyFingerprint
        self.keyName = keyName
        self.keyPairId = keyPairId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case keyFingerprint
        case keyName
        case keyPairId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct ImportSnapshotRequest: Codable, Equatable {
    public var clientData: ClientData?
    public var clientToken: String?
    public var description: String?
    public var diskContainer: SnapshotDiskContainer?
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var kmsKeyId: KmsKeyId?
    public var roleName: String?
    public var tagSpecifications: TagSpecificationList?

    public init(clientData: ClientData? = nil,
                clientToken: String? = nil,
                description: String? = nil,
                diskContainer: SnapshotDiskContainer? = nil,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                kmsKeyId: KmsKeyId? = nil,
                roleName: String? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientData = clientData
        self.clientToken = clientToken
        self.description = description
        self.diskContainer = diskContainer
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.roleName = roleName
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientData = "ClientData"
        case clientToken = "ClientToken"
        case description = "Description"
        case diskContainer = "DiskContainer"
        case dryRun = "DryRun"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case roleName = "RoleName"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try clientData?.validate()
        try diskContainer?.validate()
    }
}

public struct ImportSnapshotResult: Codable, Equatable {
    public var description: String?
    public var importTaskId: String?
    public var snapshotTaskDetail: SnapshotTaskDetail?
    public var tags: TagList?

    public init(description: String? = nil,
                importTaskId: String? = nil,
                snapshotTaskDetail: SnapshotTaskDetail? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.importTaskId = importTaskId
        self.snapshotTaskDetail = snapshotTaskDetail
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case importTaskId
        case snapshotTaskDetail
        case tags = "tagSet"
    }

    public func validate() throws {
        try snapshotTaskDetail?.validate()
    }
}

public struct ImportSnapshotTask: Codable, Equatable {
    public var description: String?
    public var importTaskId: String?
    public var snapshotTaskDetail: SnapshotTaskDetail?
    public var tags: TagList?

    public init(description: String? = nil,
                importTaskId: String? = nil,
                snapshotTaskDetail: SnapshotTaskDetail? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.importTaskId = importTaskId
        self.snapshotTaskDetail = snapshotTaskDetail
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case importTaskId
        case snapshotTaskDetail
        case tags = "tagSet"
    }

    public func validate() throws {
        try snapshotTaskDetail?.validate()
    }
}

public struct ImportVolumeRequest: Codable, Equatable {
    public var availabilityZone: String
    public var description: String?
    public var dryRun: Boolean?
    public var image: DiskImageDetail
    public var volume: VolumeDetail

    public init(availabilityZone: String,
                description: String? = nil,
                dryRun: Boolean? = nil,
                image: DiskImageDetail,
                volume: VolumeDetail) {
        self.availabilityZone = availabilityZone
        self.description = description
        self.dryRun = dryRun
        self.image = image
        self.volume = volume
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case description
        case dryRun
        case image
        case volume
    }

    public func validate() throws {
        try image.validate()
        try volume.validate()
    }
}

public struct ImportVolumeResult: Codable, Equatable {
    public var conversionTask: ConversionTask?

    public init(conversionTask: ConversionTask? = nil) {
        self.conversionTask = conversionTask
    }

    enum CodingKeys: String, CodingKey {
        case conversionTask
    }

    public func validate() throws {
        try conversionTask?.validate()
    }
}

public struct ImportVolumeTaskDetails: Codable, Equatable {
    public var availabilityZone: String?
    public var bytesConverted: Long?
    public var description: String?
    public var image: DiskImageDescription?
    public var volume: DiskImageVolumeDescription?

    public init(availabilityZone: String? = nil,
                bytesConverted: Long? = nil,
                description: String? = nil,
                image: DiskImageDescription? = nil,
                volume: DiskImageVolumeDescription? = nil) {
        self.availabilityZone = availabilityZone
        self.bytesConverted = bytesConverted
        self.description = description
        self.image = image
        self.volume = volume
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case bytesConverted
        case description
        case image
        case volume
    }

    public func validate() throws {
        try image?.validate()
        try volume?.validate()
    }
}

public struct InferenceAcceleratorInfo: Codable, Equatable {
    public var accelerators: InferenceDeviceInfoList?

    public init(accelerators: InferenceDeviceInfoList? = nil) {
        self.accelerators = accelerators
    }

    enum CodingKeys: String, CodingKey {
        case accelerators
    }

    public func validate() throws {
    }
}

public struct InferenceDeviceInfo: Codable, Equatable {
    public var count: InferenceDeviceCount?
    public var manufacturer: InferenceDeviceManufacturerName?
    public var name: InferenceDeviceName?

    public init(count: InferenceDeviceCount? = nil,
                manufacturer: InferenceDeviceManufacturerName? = nil,
                name: InferenceDeviceName? = nil) {
        self.count = count
        self.manufacturer = manufacturer
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case count
        case manufacturer
        case name
    }

    public func validate() throws {
    }
}

public struct Instance: Codable, Equatable {
    public var amiLaunchIndex: Integer?
    public var architecture: ArchitectureValues?
    public var blockDeviceMappings: InstanceBlockDeviceMappingList?
    public var capacityReservationId: String?
    public var capacityReservationSpecification: CapacityReservationSpecificationResponse?
    public var clientToken: String?
    public var cpuOptions: CpuOptions?
    public var ebsOptimized: Boolean?
    public var elasticGpuAssociations: ElasticGpuAssociationList?
    public var elasticInferenceAcceleratorAssociations: ElasticInferenceAcceleratorAssociationList?
    public var enaSupport: Boolean?
    public var enclaveOptions: EnclaveOptions?
    public var hibernationOptions: HibernationOptions?
    public var hypervisor: HypervisorType?
    public var iamInstanceProfile: IamInstanceProfile?
    public var imageId: String?
    public var instanceId: String?
    public var instanceLifecycle: InstanceLifecycleType?
    public var instanceType: InstanceType?
    public var kernelId: String?
    public var keyName: String?
    public var launchTime: DateTime?
    public var licenses: LicenseList?
    public var metadataOptions: InstanceMetadataOptionsResponse?
    public var monitoring: Monitoring?
    public var networkInterfaces: InstanceNetworkInterfaceList?
    public var outpostArn: String?
    public var placement: Placement?
    public var platform: PlatformValues?
    public var privateDnsName: String?
    public var privateIpAddress: String?
    public var productCodes: ProductCodeList?
    public var publicDnsName: String?
    public var publicIpAddress: String?
    public var ramdiskId: String?
    public var rootDeviceName: String?
    public var rootDeviceType: DeviceType?
    public var securityGroups: GroupIdentifierList?
    public var sourceDestCheck: Boolean?
    public var spotInstanceRequestId: String?
    public var sriovNetSupport: String?
    public var state: InstanceState?
    public var stateReason: StateReason?
    public var stateTransitionReason: String?
    public var subnetId: String?
    public var tags: TagList?
    public var virtualizationType: VirtualizationType?
    public var vpcId: String?

    public init(amiLaunchIndex: Integer? = nil,
                architecture: ArchitectureValues? = nil,
                blockDeviceMappings: InstanceBlockDeviceMappingList? = nil,
                capacityReservationId: String? = nil,
                capacityReservationSpecification: CapacityReservationSpecificationResponse? = nil,
                clientToken: String? = nil,
                cpuOptions: CpuOptions? = nil,
                ebsOptimized: Boolean? = nil,
                elasticGpuAssociations: ElasticGpuAssociationList? = nil,
                elasticInferenceAcceleratorAssociations: ElasticInferenceAcceleratorAssociationList? = nil,
                enaSupport: Boolean? = nil,
                enclaveOptions: EnclaveOptions? = nil,
                hibernationOptions: HibernationOptions? = nil,
                hypervisor: HypervisorType? = nil,
                iamInstanceProfile: IamInstanceProfile? = nil,
                imageId: String? = nil,
                instanceId: String? = nil,
                instanceLifecycle: InstanceLifecycleType? = nil,
                instanceType: InstanceType? = nil,
                kernelId: String? = nil,
                keyName: String? = nil,
                launchTime: DateTime? = nil,
                licenses: LicenseList? = nil,
                metadataOptions: InstanceMetadataOptionsResponse? = nil,
                monitoring: Monitoring? = nil,
                networkInterfaces: InstanceNetworkInterfaceList? = nil,
                outpostArn: String? = nil,
                placement: Placement? = nil,
                platform: PlatformValues? = nil,
                privateDnsName: String? = nil,
                privateIpAddress: String? = nil,
                productCodes: ProductCodeList? = nil,
                publicDnsName: String? = nil,
                publicIpAddress: String? = nil,
                ramdiskId: String? = nil,
                rootDeviceName: String? = nil,
                rootDeviceType: DeviceType? = nil,
                securityGroups: GroupIdentifierList? = nil,
                sourceDestCheck: Boolean? = nil,
                spotInstanceRequestId: String? = nil,
                sriovNetSupport: String? = nil,
                state: InstanceState? = nil,
                stateReason: StateReason? = nil,
                stateTransitionReason: String? = nil,
                subnetId: String? = nil,
                tags: TagList? = nil,
                virtualizationType: VirtualizationType? = nil,
                vpcId: String? = nil) {
        self.amiLaunchIndex = amiLaunchIndex
        self.architecture = architecture
        self.blockDeviceMappings = blockDeviceMappings
        self.capacityReservationId = capacityReservationId
        self.capacityReservationSpecification = capacityReservationSpecification
        self.clientToken = clientToken
        self.cpuOptions = cpuOptions
        self.ebsOptimized = ebsOptimized
        self.elasticGpuAssociations = elasticGpuAssociations
        self.elasticInferenceAcceleratorAssociations = elasticInferenceAcceleratorAssociations
        self.enaSupport = enaSupport
        self.enclaveOptions = enclaveOptions
        self.hibernationOptions = hibernationOptions
        self.hypervisor = hypervisor
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceId = instanceId
        self.instanceLifecycle = instanceLifecycle
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.launchTime = launchTime
        self.licenses = licenses
        self.metadataOptions = metadataOptions
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.outpostArn = outpostArn
        self.placement = placement
        self.platform = platform
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
        self.productCodes = productCodes
        self.publicDnsName = publicDnsName
        self.publicIpAddress = publicIpAddress
        self.ramdiskId = ramdiskId
        self.rootDeviceName = rootDeviceName
        self.rootDeviceType = rootDeviceType
        self.securityGroups = securityGroups
        self.sourceDestCheck = sourceDestCheck
        self.spotInstanceRequestId = spotInstanceRequestId
        self.sriovNetSupport = sriovNetSupport
        self.state = state
        self.stateReason = stateReason
        self.stateTransitionReason = stateTransitionReason
        self.subnetId = subnetId
        self.tags = tags
        self.virtualizationType = virtualizationType
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case amiLaunchIndex
        case architecture
        case blockDeviceMappings = "blockDeviceMapping"
        case capacityReservationId
        case capacityReservationSpecification
        case clientToken
        case cpuOptions
        case ebsOptimized
        case elasticGpuAssociations = "elasticGpuAssociationSet"
        case elasticInferenceAcceleratorAssociations = "elasticInferenceAcceleratorAssociationSet"
        case enaSupport
        case enclaveOptions
        case hibernationOptions
        case hypervisor
        case iamInstanceProfile
        case imageId
        case instanceId
        case instanceLifecycle
        case instanceType
        case kernelId
        case keyName
        case launchTime
        case licenses = "licenseSet"
        case metadataOptions
        case monitoring
        case networkInterfaces = "networkInterfaceSet"
        case outpostArn
        case placement
        case platform
        case privateDnsName
        case privateIpAddress
        case productCodes
        case publicDnsName = "dnsName"
        case publicIpAddress = "ipAddress"
        case ramdiskId
        case rootDeviceName
        case rootDeviceType
        case securityGroups = "groupSet"
        case sourceDestCheck
        case spotInstanceRequestId
        case sriovNetSupport
        case state = "instanceState"
        case stateReason
        case stateTransitionReason = "reason"
        case subnetId
        case tags = "tagSet"
        case virtualizationType
        case vpcId
    }

    public func validate() throws {
        try capacityReservationSpecification?.validate()
        try cpuOptions?.validate()
        try enclaveOptions?.validate()
        try hibernationOptions?.validate()
        try iamInstanceProfile?.validate()
        try metadataOptions?.validate()
        try monitoring?.validate()
        try placement?.validate()
        try state?.validate()
        try stateReason?.validate()
    }
}

public struct InstanceAttribute: Codable, Equatable {
    public var blockDeviceMappings: InstanceBlockDeviceMappingList?
    public var disableApiTermination: AttributeBooleanValue?
    public var ebsOptimized: AttributeBooleanValue?
    public var enaSupport: AttributeBooleanValue?
    public var enclaveOptions: EnclaveOptions?
    public var groups: GroupIdentifierList?
    public var instanceId: String?
    public var instanceInitiatedShutdownBehavior: AttributeValue?
    public var instanceType: AttributeValue?
    public var kernelId: AttributeValue?
    public var productCodes: ProductCodeList?
    public var ramdiskId: AttributeValue?
    public var rootDeviceName: AttributeValue?
    public var sourceDestCheck: AttributeBooleanValue?
    public var sriovNetSupport: AttributeValue?
    public var userData: AttributeValue?

    public init(blockDeviceMappings: InstanceBlockDeviceMappingList? = nil,
                disableApiTermination: AttributeBooleanValue? = nil,
                ebsOptimized: AttributeBooleanValue? = nil,
                enaSupport: AttributeBooleanValue? = nil,
                enclaveOptions: EnclaveOptions? = nil,
                groups: GroupIdentifierList? = nil,
                instanceId: String? = nil,
                instanceInitiatedShutdownBehavior: AttributeValue? = nil,
                instanceType: AttributeValue? = nil,
                kernelId: AttributeValue? = nil,
                productCodes: ProductCodeList? = nil,
                ramdiskId: AttributeValue? = nil,
                rootDeviceName: AttributeValue? = nil,
                sourceDestCheck: AttributeBooleanValue? = nil,
                sriovNetSupport: AttributeValue? = nil,
                userData: AttributeValue? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.disableApiTermination = disableApiTermination
        self.ebsOptimized = ebsOptimized
        self.enaSupport = enaSupport
        self.enclaveOptions = enclaveOptions
        self.groups = groups
        self.instanceId = instanceId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.productCodes = productCodes
        self.ramdiskId = ramdiskId
        self.rootDeviceName = rootDeviceName
        self.sourceDestCheck = sourceDestCheck
        self.sriovNetSupport = sriovNetSupport
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "blockDeviceMapping"
        case disableApiTermination
        case ebsOptimized
        case enaSupport
        case enclaveOptions
        case groups = "groupSet"
        case instanceId
        case instanceInitiatedShutdownBehavior
        case instanceType
        case kernelId = "kernel"
        case productCodes
        case ramdiskId = "ramdisk"
        case rootDeviceName
        case sourceDestCheck
        case sriovNetSupport
        case userData
    }

    public func validate() throws {
        try disableApiTermination?.validate()
        try ebsOptimized?.validate()
        try enaSupport?.validate()
        try enclaveOptions?.validate()
        try instanceInitiatedShutdownBehavior?.validate()
        try instanceType?.validate()
        try kernelId?.validate()
        try ramdiskId?.validate()
        try rootDeviceName?.validate()
        try sourceDestCheck?.validate()
        try sriovNetSupport?.validate()
        try userData?.validate()
    }
}

public struct InstanceBlockDeviceMapping: Codable, Equatable {
    public var deviceName: String?
    public var ebs: EbsInstanceBlockDevice?

    public init(deviceName: String? = nil,
                ebs: EbsInstanceBlockDevice? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
    }

    enum CodingKeys: String, CodingKey {
        case deviceName
        case ebs
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct InstanceBlockDeviceMappingSpecification: Codable, Equatable {
    public var deviceName: String?
    public var ebs: EbsInstanceBlockDeviceSpecification?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: EbsInstanceBlockDeviceSpecification? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct InstanceCapacity: Codable, Equatable {
    public var availableCapacity: Integer?
    public var instanceType: String?
    public var totalCapacity: Integer?

    public init(availableCapacity: Integer? = nil,
                instanceType: String? = nil,
                totalCapacity: Integer? = nil) {
        self.availableCapacity = availableCapacity
        self.instanceType = instanceType
        self.totalCapacity = totalCapacity
    }

    enum CodingKeys: String, CodingKey {
        case availableCapacity
        case instanceType
        case totalCapacity
    }

    public func validate() throws {
    }
}

public struct InstanceCount: Codable, Equatable {
    public var instanceCount: Integer?
    public var state: ListingState?

    public init(instanceCount: Integer? = nil,
                state: ListingState? = nil) {
        self.instanceCount = instanceCount
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case instanceCount
        case state
    }

    public func validate() throws {
    }
}

public struct InstanceCreditSpecification: Codable, Equatable {
    public var cpuCredits: String?
    public var instanceId: String?

    public init(cpuCredits: String? = nil,
                instanceId: String? = nil) {
        self.cpuCredits = cpuCredits
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits
        case instanceId
    }

    public func validate() throws {
    }
}

public struct InstanceCreditSpecificationRequest: Codable, Equatable {
    public var cpuCredits: String?
    public var instanceId: InstanceId?

    public init(cpuCredits: String? = nil,
                instanceId: InstanceId? = nil) {
        self.cpuCredits = cpuCredits
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits = "CpuCredits"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct InstanceExportDetails: Codable, Equatable {
    public var instanceId: String?
    public var targetEnvironment: ExportEnvironment?

    public init(instanceId: String? = nil,
                targetEnvironment: ExportEnvironment? = nil) {
        self.instanceId = instanceId
        self.targetEnvironment = targetEnvironment
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case targetEnvironment
    }

    public func validate() throws {
    }
}

public struct InstanceFamilyCreditSpecification: Codable, Equatable {
    public var cpuCredits: String?
    public var instanceFamily: UnlimitedSupportedInstanceFamily?

    public init(cpuCredits: String? = nil,
                instanceFamily: UnlimitedSupportedInstanceFamily? = nil) {
        self.cpuCredits = cpuCredits
        self.instanceFamily = instanceFamily
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits
        case instanceFamily
    }

    public func validate() throws {
    }
}

public struct InstanceIpv6Address: Codable, Equatable {
    public var ipv6Address: String?

    public init(ipv6Address: String? = nil) {
        self.ipv6Address = ipv6Address
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Address
    }

    public func validate() throws {
    }
}

public struct InstanceIpv6AddressRequest: Codable, Equatable {
    public var ipv6Address: String?

    public init(ipv6Address: String? = nil) {
        self.ipv6Address = ipv6Address
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Address = "Ipv6Address"
    }

    public func validate() throws {
    }
}

public struct InstanceMarketOptionsRequest: Codable, Equatable {
    public var marketType: MarketType?
    public var spotOptions: SpotMarketOptions?

    public init(marketType: MarketType? = nil,
                spotOptions: SpotMarketOptions? = nil) {
        self.marketType = marketType
        self.spotOptions = spotOptions
    }

    enum CodingKeys: String, CodingKey {
        case marketType = "MarketType"
        case spotOptions = "SpotOptions"
    }

    public func validate() throws {
        try spotOptions?.validate()
    }
}

public struct InstanceMetadataOptionsRequest: Codable, Equatable {
    public var httpEndpoint: InstanceMetadataEndpointState?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: HttpTokensState?

    public init(httpEndpoint: InstanceMetadataEndpointState? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: HttpTokensState? = nil) {
        self.httpEndpoint = httpEndpoint
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
    }

    enum CodingKeys: String, CodingKey {
        case httpEndpoint = "HttpEndpoint"
        case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
        case httpTokens = "HttpTokens"
    }

    public func validate() throws {
    }
}

public struct InstanceMetadataOptionsResponse: Codable, Equatable {
    public var httpEndpoint: InstanceMetadataEndpointState?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: HttpTokensState?
    public var state: InstanceMetadataOptionsState?

    public init(httpEndpoint: InstanceMetadataEndpointState? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: HttpTokensState? = nil,
                state: InstanceMetadataOptionsState? = nil) {
        self.httpEndpoint = httpEndpoint
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case httpEndpoint
        case httpPutResponseHopLimit
        case httpTokens
        case state
    }

    public func validate() throws {
    }
}

public struct InstanceMonitoring: Codable, Equatable {
    public var instanceId: String?
    public var monitoring: Monitoring?

    public init(instanceId: String? = nil,
                monitoring: Monitoring? = nil) {
        self.instanceId = instanceId
        self.monitoring = monitoring
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case monitoring
    }

    public func validate() throws {
        try monitoring?.validate()
    }
}

public struct InstanceNetworkInterface: Codable, Equatable {
    public var association: InstanceNetworkInterfaceAssociation?
    public var attachment: InstanceNetworkInterfaceAttachment?
    public var description: String?
    public var groups: GroupIdentifierList?
    public var interfaceType: String?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var macAddress: String?
    public var networkInterfaceId: String?
    public var ownerId: String?
    public var privateDnsName: String?
    public var privateIpAddress: String?
    public var privateIpAddresses: InstancePrivateIpAddressList?
    public var sourceDestCheck: Boolean?
    public var status: NetworkInterfaceStatus?
    public var subnetId: String?
    public var vpcId: String?

    public init(association: InstanceNetworkInterfaceAssociation? = nil,
                attachment: InstanceNetworkInterfaceAttachment? = nil,
                description: String? = nil,
                groups: GroupIdentifierList? = nil,
                interfaceType: String? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                macAddress: String? = nil,
                networkInterfaceId: String? = nil,
                ownerId: String? = nil,
                privateDnsName: String? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: InstancePrivateIpAddressList? = nil,
                sourceDestCheck: Boolean? = nil,
                status: NetworkInterfaceStatus? = nil,
                subnetId: String? = nil,
                vpcId: String? = nil) {
        self.association = association
        self.attachment = attachment
        self.description = description
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv6Addresses = ipv6Addresses
        self.macAddress = macAddress
        self.networkInterfaceId = networkInterfaceId
        self.ownerId = ownerId
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.sourceDestCheck = sourceDestCheck
        self.status = status
        self.subnetId = subnetId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case association
        case attachment
        case description
        case groups = "groupSet"
        case interfaceType
        case ipv6Addresses = "ipv6AddressesSet"
        case macAddress
        case networkInterfaceId
        case ownerId
        case privateDnsName
        case privateIpAddress
        case privateIpAddresses = "privateIpAddressesSet"
        case sourceDestCheck
        case status
        case subnetId
        case vpcId
    }

    public func validate() throws {
        try association?.validate()
        try attachment?.validate()
    }
}

public struct InstanceNetworkInterfaceAssociation: Codable, Equatable {
    public var carrierIp: String?
    public var ipOwnerId: String?
    public var publicDnsName: String?
    public var publicIp: String?

    public init(carrierIp: String? = nil,
                ipOwnerId: String? = nil,
                publicDnsName: String? = nil,
                publicIp: String? = nil) {
        self.carrierIp = carrierIp
        self.ipOwnerId = ipOwnerId
        self.publicDnsName = publicDnsName
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case carrierIp
        case ipOwnerId
        case publicDnsName
        case publicIp
    }

    public func validate() throws {
    }
}

public struct InstanceNetworkInterfaceAttachment: Codable, Equatable {
    public var attachTime: DateTime?
    public var attachmentId: String?
    public var deleteOnTermination: Boolean?
    public var deviceIndex: Integer?
    public var networkCardIndex: Integer?
    public var status: AttachmentStatus?

    public init(attachTime: DateTime? = nil,
                attachmentId: String? = nil,
                deleteOnTermination: Boolean? = nil,
                deviceIndex: Integer? = nil,
                networkCardIndex: Integer? = nil,
                status: AttachmentStatus? = nil) {
        self.attachTime = attachTime
        self.attachmentId = attachmentId
        self.deleteOnTermination = deleteOnTermination
        self.deviceIndex = deviceIndex
        self.networkCardIndex = networkCardIndex
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case attachTime
        case attachmentId
        case deleteOnTermination
        case deviceIndex
        case networkCardIndex
        case status
    }

    public func validate() throws {
    }
}

public struct InstanceNetworkInterfaceSpecification: Codable, Equatable {
    public var associateCarrierIpAddress: Boolean?
    public var associatePublicIpAddress: Boolean?
    public var deleteOnTermination: Boolean?
    public var description: String?
    public var deviceIndex: Integer?
    public var groups: SecurityGroupIdStringList?
    public var interfaceType: String?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var networkCardIndex: Integer?
    public var networkInterfaceId: String?
    public var privateIpAddress: String?
    public var privateIpAddresses: PrivateIpAddressSpecificationList?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: String?

    public init(associateCarrierIpAddress: Boolean? = nil,
                associatePublicIpAddress: Boolean? = nil,
                deleteOnTermination: Boolean? = nil,
                description: String? = nil,
                deviceIndex: Integer? = nil,
                groups: SecurityGroupIdStringList? = nil,
                interfaceType: String? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                networkCardIndex: Integer? = nil,
                networkInterfaceId: String? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: PrivateIpAddressSpecificationList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: String? = nil) {
        self.associateCarrierIpAddress = associateCarrierIpAddress
        self.associatePublicIpAddress = associatePublicIpAddress
        self.deleteOnTermination = deleteOnTermination
        self.description = description
        self.deviceIndex = deviceIndex
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.networkCardIndex = networkCardIndex
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associateCarrierIpAddress = "AssociateCarrierIpAddress"
        case associatePublicIpAddress
        case deleteOnTermination
        case description
        case deviceIndex
        case groups = "SecurityGroupId"
        case interfaceType = "InterfaceType"
        case ipv6AddressCount
        case ipv6Addresses = "ipv6AddressesSet"
        case networkCardIndex = "NetworkCardIndex"
        case networkInterfaceId
        case privateIpAddress
        case privateIpAddresses = "privateIpAddressesSet"
        case secondaryPrivateIpAddressCount
        case subnetId
    }

    public func validate() throws {
    }
}

public struct InstancePrivateIpAddress: Codable, Equatable {
    public var association: InstanceNetworkInterfaceAssociation?
    public var primary: Boolean?
    public var privateDnsName: String?
    public var privateIpAddress: String?

    public init(association: InstanceNetworkInterfaceAssociation? = nil,
                primary: Boolean? = nil,
                privateDnsName: String? = nil,
                privateIpAddress: String? = nil) {
        self.association = association
        self.primary = primary
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case association
        case primary
        case privateDnsName
        case privateIpAddress
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct InstanceSpecification: Codable, Equatable {
    public var excludeBootVolume: Boolean?
    public var instanceId: InstanceId?

    public init(excludeBootVolume: Boolean? = nil,
                instanceId: InstanceId? = nil) {
        self.excludeBootVolume = excludeBootVolume
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case excludeBootVolume = "ExcludeBootVolume"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct InstanceState: Codable, Equatable {
    public var code: Integer?
    public var name: InstanceStateName?

    public init(code: Integer? = nil,
                name: InstanceStateName? = nil) {
        self.code = code
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case code
        case name
    }

    public func validate() throws {
    }
}

public struct InstanceStateChange: Codable, Equatable {
    public var currentState: InstanceState?
    public var instanceId: String?
    public var previousState: InstanceState?

    public init(currentState: InstanceState? = nil,
                instanceId: String? = nil,
                previousState: InstanceState? = nil) {
        self.currentState = currentState
        self.instanceId = instanceId
        self.previousState = previousState
    }

    enum CodingKeys: String, CodingKey {
        case currentState
        case instanceId
        case previousState
    }

    public func validate() throws {
        try currentState?.validate()
        try previousState?.validate()
    }
}

public struct InstanceStatus: Codable, Equatable {
    public var availabilityZone: String?
    public var events: InstanceStatusEventList?
    public var instanceId: String?
    public var instanceState: InstanceState?
    public var instanceStatus: InstanceStatusSummary?
    public var outpostArn: String?
    public var systemStatus: InstanceStatusSummary?

    public init(availabilityZone: String? = nil,
                events: InstanceStatusEventList? = nil,
                instanceId: String? = nil,
                instanceState: InstanceState? = nil,
                instanceStatus: InstanceStatusSummary? = nil,
                outpostArn: String? = nil,
                systemStatus: InstanceStatusSummary? = nil) {
        self.availabilityZone = availabilityZone
        self.events = events
        self.instanceId = instanceId
        self.instanceState = instanceState
        self.instanceStatus = instanceStatus
        self.outpostArn = outpostArn
        self.systemStatus = systemStatus
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case events = "eventsSet"
        case instanceId
        case instanceState
        case instanceStatus
        case outpostArn
        case systemStatus
    }

    public func validate() throws {
        try instanceState?.validate()
        try instanceStatus?.validate()
        try systemStatus?.validate()
    }
}

public struct InstanceStatusDetails: Codable, Equatable {
    public var impairedSince: DateTime?
    public var name: StatusName?
    public var status: StatusType?

    public init(impairedSince: DateTime? = nil,
                name: StatusName? = nil,
                status: StatusType? = nil) {
        self.impairedSince = impairedSince
        self.name = name
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case impairedSince
        case name
        case status
    }

    public func validate() throws {
    }
}

public struct InstanceStatusEvent: Codable, Equatable {
    public var code: EventCode?
    public var description: String?
    public var instanceEventId: InstanceEventId?
    public var notAfter: DateTime?
    public var notBefore: DateTime?
    public var notBeforeDeadline: DateTime?

    public init(code: EventCode? = nil,
                description: String? = nil,
                instanceEventId: InstanceEventId? = nil,
                notAfter: DateTime? = nil,
                notBefore: DateTime? = nil,
                notBeforeDeadline: DateTime? = nil) {
        self.code = code
        self.description = description
        self.instanceEventId = instanceEventId
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.notBeforeDeadline = notBeforeDeadline
    }

    enum CodingKeys: String, CodingKey {
        case code
        case description
        case instanceEventId
        case notAfter
        case notBefore
        case notBeforeDeadline
    }

    public func validate() throws {
    }
}

public struct InstanceStatusSummary: Codable, Equatable {
    public var details: InstanceStatusDetailsList?
    public var status: SummaryStatus?

    public init(details: InstanceStatusDetailsList? = nil,
                status: SummaryStatus? = nil) {
        self.details = details
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case details
        case status
    }

    public func validate() throws {
    }
}

public struct InstanceStorageInfo: Codable, Equatable {
    public var disks: DiskInfoList?
    public var nvmeSupport: EphemeralNvmeSupport?
    public var totalSizeInGB: DiskSize?

    public init(disks: DiskInfoList? = nil,
                nvmeSupport: EphemeralNvmeSupport? = nil,
                totalSizeInGB: DiskSize? = nil) {
        self.disks = disks
        self.nvmeSupport = nvmeSupport
        self.totalSizeInGB = totalSizeInGB
    }

    enum CodingKeys: String, CodingKey {
        case disks
        case nvmeSupport
        case totalSizeInGB
    }

    public func validate() throws {
    }
}

public struct InstanceTagNotificationAttribute: Codable, Equatable {
    public var includeAllTagsOfInstance: Boolean?
    public var instanceTagKeys: InstanceTagKeySet?

    public init(includeAllTagsOfInstance: Boolean? = nil,
                instanceTagKeys: InstanceTagKeySet? = nil) {
        self.includeAllTagsOfInstance = includeAllTagsOfInstance
        self.instanceTagKeys = instanceTagKeys
    }

    enum CodingKeys: String, CodingKey {
        case includeAllTagsOfInstance
        case instanceTagKeys = "instanceTagKeySet"
    }

    public func validate() throws {
    }
}

public struct InstanceTypeInfo: Codable, Equatable {
    public var autoRecoverySupported: AutoRecoveryFlag?
    public var bareMetal: BareMetalFlag?
    public var burstablePerformanceSupported: BurstablePerformanceFlag?
    public var currentGeneration: CurrentGenerationFlag?
    public var dedicatedHostsSupported: DedicatedHostFlag?
    public var ebsInfo: EbsInfo?
    public var fpgaInfo: FpgaInfo?
    public var freeTierEligible: FreeTierEligibleFlag?
    public var gpuInfo: GpuInfo?
    public var hibernationSupported: HibernationFlag?
    public var hypervisor: InstanceTypeHypervisor?
    public var inferenceAcceleratorInfo: InferenceAcceleratorInfo?
    public var instanceStorageInfo: InstanceStorageInfo?
    public var instanceStorageSupported: InstanceStorageFlag?
    public var instanceType: InstanceType?
    public var memoryInfo: MemoryInfo?
    public var networkInfo: NetworkInfo?
    public var placementGroupInfo: PlacementGroupInfo?
    public var processorInfo: ProcessorInfo?
    public var supportedRootDeviceTypes: RootDeviceTypeList?
    public var supportedUsageClasses: UsageClassTypeList?
    public var supportedVirtualizationTypes: VirtualizationTypeList?
    public var vCpuInfo: VCpuInfo?

    public init(autoRecoverySupported: AutoRecoveryFlag? = nil,
                bareMetal: BareMetalFlag? = nil,
                burstablePerformanceSupported: BurstablePerformanceFlag? = nil,
                currentGeneration: CurrentGenerationFlag? = nil,
                dedicatedHostsSupported: DedicatedHostFlag? = nil,
                ebsInfo: EbsInfo? = nil,
                fpgaInfo: FpgaInfo? = nil,
                freeTierEligible: FreeTierEligibleFlag? = nil,
                gpuInfo: GpuInfo? = nil,
                hibernationSupported: HibernationFlag? = nil,
                hypervisor: InstanceTypeHypervisor? = nil,
                inferenceAcceleratorInfo: InferenceAcceleratorInfo? = nil,
                instanceStorageInfo: InstanceStorageInfo? = nil,
                instanceStorageSupported: InstanceStorageFlag? = nil,
                instanceType: InstanceType? = nil,
                memoryInfo: MemoryInfo? = nil,
                networkInfo: NetworkInfo? = nil,
                placementGroupInfo: PlacementGroupInfo? = nil,
                processorInfo: ProcessorInfo? = nil,
                supportedRootDeviceTypes: RootDeviceTypeList? = nil,
                supportedUsageClasses: UsageClassTypeList? = nil,
                supportedVirtualizationTypes: VirtualizationTypeList? = nil,
                vCpuInfo: VCpuInfo? = nil) {
        self.autoRecoverySupported = autoRecoverySupported
        self.bareMetal = bareMetal
        self.burstablePerformanceSupported = burstablePerformanceSupported
        self.currentGeneration = currentGeneration
        self.dedicatedHostsSupported = dedicatedHostsSupported
        self.ebsInfo = ebsInfo
        self.fpgaInfo = fpgaInfo
        self.freeTierEligible = freeTierEligible
        self.gpuInfo = gpuInfo
        self.hibernationSupported = hibernationSupported
        self.hypervisor = hypervisor
        self.inferenceAcceleratorInfo = inferenceAcceleratorInfo
        self.instanceStorageInfo = instanceStorageInfo
        self.instanceStorageSupported = instanceStorageSupported
        self.instanceType = instanceType
        self.memoryInfo = memoryInfo
        self.networkInfo = networkInfo
        self.placementGroupInfo = placementGroupInfo
        self.processorInfo = processorInfo
        self.supportedRootDeviceTypes = supportedRootDeviceTypes
        self.supportedUsageClasses = supportedUsageClasses
        self.supportedVirtualizationTypes = supportedVirtualizationTypes
        self.vCpuInfo = vCpuInfo
    }

    enum CodingKeys: String, CodingKey {
        case autoRecoverySupported
        case bareMetal
        case burstablePerformanceSupported
        case currentGeneration
        case dedicatedHostsSupported
        case ebsInfo
        case fpgaInfo
        case freeTierEligible
        case gpuInfo
        case hibernationSupported
        case hypervisor
        case inferenceAcceleratorInfo
        case instanceStorageInfo
        case instanceStorageSupported
        case instanceType
        case memoryInfo
        case networkInfo
        case placementGroupInfo
        case processorInfo
        case supportedRootDeviceTypes
        case supportedUsageClasses
        case supportedVirtualizationTypes
        case vCpuInfo
    }

    public func validate() throws {
        try ebsInfo?.validate()
        try fpgaInfo?.validate()
        try gpuInfo?.validate()
        try inferenceAcceleratorInfo?.validate()
        try instanceStorageInfo?.validate()
        try memoryInfo?.validate()
        try networkInfo?.validate()
        try placementGroupInfo?.validate()
        try processorInfo?.validate()
        try vCpuInfo?.validate()
    }
}

public struct InstanceTypeOffering: Codable, Equatable {
    public var instanceType: InstanceType?
    public var location: Location?
    public var locationType: LocationType?

    public init(instanceType: InstanceType? = nil,
                location: Location? = nil,
                locationType: LocationType? = nil) {
        self.instanceType = instanceType
        self.location = location
        self.locationType = locationType
    }

    enum CodingKeys: String, CodingKey {
        case instanceType
        case location
        case locationType
    }

    public func validate() throws {
    }
}

public struct InstanceUsage: Codable, Equatable {
    public var accountId: String?
    public var usedInstanceCount: Integer?

    public init(accountId: String? = nil,
                usedInstanceCount: Integer? = nil) {
        self.accountId = accountId
        self.usedInstanceCount = usedInstanceCount
    }

    enum CodingKeys: String, CodingKey {
        case accountId
        case usedInstanceCount
    }

    public func validate() throws {
    }
}

public struct InternetGateway: Codable, Equatable {
    public var attachments: InternetGatewayAttachmentList?
    public var internetGatewayId: String?
    public var ownerId: String?
    public var tags: TagList?

    public init(attachments: InternetGatewayAttachmentList? = nil,
                internetGatewayId: String? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil) {
        self.attachments = attachments
        self.internetGatewayId = internetGatewayId
        self.ownerId = ownerId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case attachments = "attachmentSet"
        case internetGatewayId
        case ownerId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct InternetGatewayAttachment: Codable, Equatable {
    public var state: AttachmentStatus?
    public var vpcId: String?

    public init(state: AttachmentStatus? = nil,
                vpcId: String? = nil) {
        self.state = state
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case vpcId
    }

    public func validate() throws {
    }
}

public struct IpPermission: Codable, Equatable {
    public var fromPort: Integer?
    public var ipProtocol: String?
    public var ipRanges: IpRangeList?
    public var ipv6Ranges: Ipv6RangeList?
    public var prefixListIds: PrefixListIdList?
    public var toPort: Integer?
    public var userIdGroupPairs: UserIdGroupPairList?

    public init(fromPort: Integer? = nil,
                ipProtocol: String? = nil,
                ipRanges: IpRangeList? = nil,
                ipv6Ranges: Ipv6RangeList? = nil,
                prefixListIds: PrefixListIdList? = nil,
                toPort: Integer? = nil,
                userIdGroupPairs: UserIdGroupPairList? = nil) {
        self.fromPort = fromPort
        self.ipProtocol = ipProtocol
        self.ipRanges = ipRanges
        self.ipv6Ranges = ipv6Ranges
        self.prefixListIds = prefixListIds
        self.toPort = toPort
        self.userIdGroupPairs = userIdGroupPairs
    }

    enum CodingKeys: String, CodingKey {
        case fromPort
        case ipProtocol
        case ipRanges
        case ipv6Ranges
        case prefixListIds
        case toPort
        case userIdGroupPairs = "groups"
    }

    public func validate() throws {
    }
}

public struct IpRange: Codable, Equatable {
    public var cidrIp: String?
    public var description: String?

    public init(cidrIp: String? = nil,
                description: String? = nil) {
        self.cidrIp = cidrIp
        self.description = description
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp
        case description
    }

    public func validate() throws {
    }
}

public struct Ipv6CidrAssociation: Codable, Equatable {
    public var associatedResource: String?
    public var ipv6Cidr: String?

    public init(associatedResource: String? = nil,
                ipv6Cidr: String? = nil) {
        self.associatedResource = associatedResource
        self.ipv6Cidr = ipv6Cidr
    }

    enum CodingKeys: String, CodingKey {
        case associatedResource
        case ipv6Cidr
    }

    public func validate() throws {
    }
}

public struct Ipv6CidrBlock: Codable, Equatable {
    public var ipv6CidrBlock: String?

    public init(ipv6CidrBlock: String? = nil) {
        self.ipv6CidrBlock = ipv6CidrBlock
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrBlock
    }

    public func validate() throws {
    }
}

public struct Ipv6Pool: Codable, Equatable {
    public var description: String?
    public var poolCidrBlocks: PoolCidrBlocksSet?
    public var poolId: String?
    public var tags: TagList?

    public init(description: String? = nil,
                poolCidrBlocks: PoolCidrBlocksSet? = nil,
                poolId: String? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.poolCidrBlocks = poolCidrBlocks
        self.poolId = poolId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case poolCidrBlocks = "poolCidrBlockSet"
        case poolId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct Ipv6Range: Codable, Equatable {
    public var cidrIpv6: String?
    public var description: String?

    public init(cidrIpv6: String? = nil,
                description: String? = nil) {
        self.cidrIpv6 = cidrIpv6
        self.description = description
    }

    enum CodingKeys: String, CodingKey {
        case cidrIpv6
        case description
    }

    public func validate() throws {
    }
}

public struct KeyPair: Codable, Equatable {
    public var keyFingerprint: String?
    public var keyMaterial: SensitiveUserData?
    public var keyName: String?
    public var keyPairId: String?
    public var tags: TagList?

    public init(keyFingerprint: String? = nil,
                keyMaterial: SensitiveUserData? = nil,
                keyName: String? = nil,
                keyPairId: String? = nil,
                tags: TagList? = nil) {
        self.keyFingerprint = keyFingerprint
        self.keyMaterial = keyMaterial
        self.keyName = keyName
        self.keyPairId = keyPairId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case keyFingerprint
        case keyMaterial
        case keyName
        case keyPairId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct KeyPairInfo: Codable, Equatable {
    public var keyFingerprint: String?
    public var keyName: String?
    public var keyPairId: String?
    public var tags: TagList?

    public init(keyFingerprint: String? = nil,
                keyName: String? = nil,
                keyPairId: String? = nil,
                tags: TagList? = nil) {
        self.keyFingerprint = keyFingerprint
        self.keyName = keyName
        self.keyPairId = keyPairId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case keyFingerprint
        case keyName
        case keyPairId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct LastError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct LaunchPermission: Codable, Equatable {
    public var group: PermissionGroup?
    public var userId: String?

    public init(group: PermissionGroup? = nil,
                userId: String? = nil) {
        self.group = group
        self.userId = userId
    }

    enum CodingKeys: String, CodingKey {
        case group
        case userId
    }

    public func validate() throws {
    }
}

public struct LaunchPermissionModifications: Codable, Equatable {
    public var add: LaunchPermissionList?
    public var remove: LaunchPermissionList?

    public init(add: LaunchPermissionList? = nil,
                remove: LaunchPermissionList? = nil) {
        self.add = add
        self.remove = remove
    }

    enum CodingKeys: String, CodingKey {
        case add = "Add"
        case remove = "Remove"
    }

    public func validate() throws {
    }
}

public struct LaunchSpecification: Codable, Equatable {
    public var addressingType: String?
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var ebsOptimized: Boolean?
    public var iamInstanceProfile: IamInstanceProfileSpecification?
    public var imageId: String?
    public var instanceType: InstanceType?
    public var kernelId: String?
    public var keyName: String?
    public var monitoring: RunInstancesMonitoringEnabled?
    public var networkInterfaces: InstanceNetworkInterfaceSpecificationList?
    public var placement: SpotPlacement?
    public var ramdiskId: String?
    public var securityGroups: GroupIdentifierList?
    public var subnetId: String?
    public var userData: String?

    public init(addressingType: String? = nil,
                blockDeviceMappings: BlockDeviceMappingList? = nil,
                ebsOptimized: Boolean? = nil,
                iamInstanceProfile: IamInstanceProfileSpecification? = nil,
                imageId: String? = nil,
                instanceType: InstanceType? = nil,
                kernelId: String? = nil,
                keyName: String? = nil,
                monitoring: RunInstancesMonitoringEnabled? = nil,
                networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil,
                placement: SpotPlacement? = nil,
                ramdiskId: String? = nil,
                securityGroups: GroupIdentifierList? = nil,
                subnetId: String? = nil,
                userData: String? = nil) {
        self.addressingType = addressingType
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramdiskId = ramdiskId
        self.securityGroups = securityGroups
        self.subnetId = subnetId
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case addressingType
        case blockDeviceMappings = "blockDeviceMapping"
        case ebsOptimized
        case iamInstanceProfile
        case imageId
        case instanceType
        case kernelId
        case keyName
        case monitoring
        case networkInterfaces = "networkInterfaceSet"
        case placement
        case ramdiskId
        case securityGroups = "groupSet"
        case subnetId
        case userData
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct LaunchTemplate: Codable, Equatable {
    public var createTime: DateTime?
    public var createdBy: String?
    public var defaultVersionNumber: Long?
    public var latestVersionNumber: Long?
    public var launchTemplateId: String?
    public var launchTemplateName: LaunchTemplateName?
    public var tags: TagList?

    public init(createTime: DateTime? = nil,
                createdBy: String? = nil,
                defaultVersionNumber: Long? = nil,
                latestVersionNumber: Long? = nil,
                launchTemplateId: String? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                tags: TagList? = nil) {
        self.createTime = createTime
        self.createdBy = createdBy
        self.defaultVersionNumber = defaultVersionNumber
        self.latestVersionNumber = latestVersionNumber
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case createTime
        case createdBy
        case defaultVersionNumber
        case latestVersionNumber
        case launchTemplateId
        case launchTemplateName
        case tags = "tagSet"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct LaunchTemplateAndOverridesResponse: Codable, Equatable {
    public var launchTemplateSpecification: FleetLaunchTemplateSpecification?
    public var overrides: FleetLaunchTemplateOverrides?

    public init(launchTemplateSpecification: FleetLaunchTemplateSpecification? = nil,
                overrides: FleetLaunchTemplateOverrides? = nil) {
        self.launchTemplateSpecification = launchTemplateSpecification
        self.overrides = overrides
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateSpecification
        case overrides
    }

    public func validate() throws {
        try launchTemplateSpecification?.validate()
        try overrides?.validate()
    }
}

public struct LaunchTemplateBlockDeviceMapping: Codable, Equatable {
    public var deviceName: String?
    public var ebs: LaunchTemplateEbsBlockDevice?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: LaunchTemplateEbsBlockDevice? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct LaunchTemplateBlockDeviceMappingRequest: Codable, Equatable {
    public var deviceName: String?
    public var ebs: LaunchTemplateEbsBlockDeviceRequest?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: LaunchTemplateEbsBlockDeviceRequest? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName = "DeviceName"
        case ebs = "Ebs"
        case noDevice = "NoDevice"
        case virtualName = "VirtualName"
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct LaunchTemplateCapacityReservationSpecificationRequest: Codable, Equatable {
    public var capacityReservationPreference: CapacityReservationPreference?
    public var capacityReservationTarget: CapacityReservationTarget?

    public init(capacityReservationPreference: CapacityReservationPreference? = nil,
                capacityReservationTarget: CapacityReservationTarget? = nil) {
        self.capacityReservationPreference = capacityReservationPreference
        self.capacityReservationTarget = capacityReservationTarget
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationPreference = "CapacityReservationPreference"
        case capacityReservationTarget = "CapacityReservationTarget"
    }

    public func validate() throws {
        try capacityReservationTarget?.validate()
    }
}

public struct LaunchTemplateCapacityReservationSpecificationResponse: Codable, Equatable {
    public var capacityReservationPreference: CapacityReservationPreference?
    public var capacityReservationTarget: CapacityReservationTargetResponse?

    public init(capacityReservationPreference: CapacityReservationPreference? = nil,
                capacityReservationTarget: CapacityReservationTargetResponse? = nil) {
        self.capacityReservationPreference = capacityReservationPreference
        self.capacityReservationTarget = capacityReservationTarget
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationPreference
        case capacityReservationTarget
    }

    public func validate() throws {
        try capacityReservationTarget?.validate()
    }
}

public struct LaunchTemplateConfig: Codable, Equatable {
    public var launchTemplateSpecification: FleetLaunchTemplateSpecification?
    public var overrides: LaunchTemplateOverridesList?

    public init(launchTemplateSpecification: FleetLaunchTemplateSpecification? = nil,
                overrides: LaunchTemplateOverridesList? = nil) {
        self.launchTemplateSpecification = launchTemplateSpecification
        self.overrides = overrides
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateSpecification
        case overrides
    }

    public func validate() throws {
        try launchTemplateSpecification?.validate()
    }
}

public struct LaunchTemplateCpuOptions: Codable, Equatable {
    public var coreCount: Integer?
    public var threadsPerCore: Integer?

    public init(coreCount: Integer? = nil,
                threadsPerCore: Integer? = nil) {
        self.coreCount = coreCount
        self.threadsPerCore = threadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case coreCount
        case threadsPerCore
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateCpuOptionsRequest: Codable, Equatable {
    public var coreCount: Integer?
    public var threadsPerCore: Integer?

    public init(coreCount: Integer? = nil,
                threadsPerCore: Integer? = nil) {
        self.coreCount = coreCount
        self.threadsPerCore = threadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case coreCount = "CoreCount"
        case threadsPerCore = "ThreadsPerCore"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateEbsBlockDevice: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var kmsKeyId: KmsKeyId?
    public var snapshotId: SnapshotId?
    public var throughput: Integer?
    public var volumeSize: Integer?
    public var volumeType: VolumeType?

    public init(deleteOnTermination: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: KmsKeyId? = nil,
                snapshotId: SnapshotId? = nil,
                throughput: Integer? = nil,
                volumeSize: Integer? = nil,
                volumeType: VolumeType? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.snapshotId = snapshotId
        self.throughput = throughput
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination
        case encrypted
        case iops
        case kmsKeyId
        case snapshotId
        case throughput
        case volumeSize
        case volumeType
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateEbsBlockDeviceRequest: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var kmsKeyId: KmsKeyId?
    public var snapshotId: SnapshotId?
    public var throughput: Integer?
    public var volumeSize: Integer?
    public var volumeType: VolumeType?

    public init(deleteOnTermination: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: KmsKeyId? = nil,
                snapshotId: SnapshotId? = nil,
                throughput: Integer? = nil,
                volumeSize: Integer? = nil,
                volumeType: VolumeType? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.snapshotId = snapshotId
        self.throughput = throughput
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination = "DeleteOnTermination"
        case encrypted = "Encrypted"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case snapshotId = "SnapshotId"
        case throughput = "Throughput"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateElasticInferenceAccelerator: Codable, Equatable {
    public var count: LaunchTemplateElasticInferenceAcceleratorCount?
    public var type: String

    public init(count: LaunchTemplateElasticInferenceAcceleratorCount? = nil,
                type: String) {
        self.count = count
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case type = "Type"
    }

    public func validate() throws {
        try count?.validateAsLaunchTemplateElasticInferenceAcceleratorCount()
    }
}

public struct LaunchTemplateElasticInferenceAcceleratorResponse: Codable, Equatable {
    public var count: Integer?
    public var type: String?

    public init(count: Integer? = nil,
                type: String? = nil) {
        self.count = count
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case count
        case type
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateEnclaveOptions: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateEnclaveOptionsRequest: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateHibernationOptions: Codable, Equatable {
    public var configured: Boolean?

    public init(configured: Boolean? = nil) {
        self.configured = configured
    }

    enum CodingKeys: String, CodingKey {
        case configured
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateHibernationOptionsRequest: Codable, Equatable {
    public var configured: Boolean?

    public init(configured: Boolean? = nil) {
        self.configured = configured
    }

    enum CodingKeys: String, CodingKey {
        case configured = "Configured"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateIamInstanceProfileSpecification: Codable, Equatable {
    public var arn: String?
    public var name: String?

    public init(arn: String? = nil,
                name: String? = nil) {
        self.arn = arn
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case name
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateIamInstanceProfileSpecificationRequest: Codable, Equatable {
    public var arn: String?
    public var name: String?

    public init(arn: String? = nil,
                name: String? = nil) {
        self.arn = arn
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceMarketOptions: Codable, Equatable {
    public var marketType: MarketType?
    public var spotOptions: LaunchTemplateSpotMarketOptions?

    public init(marketType: MarketType? = nil,
                spotOptions: LaunchTemplateSpotMarketOptions? = nil) {
        self.marketType = marketType
        self.spotOptions = spotOptions
    }

    enum CodingKeys: String, CodingKey {
        case marketType
        case spotOptions
    }

    public func validate() throws {
        try spotOptions?.validate()
    }
}

public struct LaunchTemplateInstanceMarketOptionsRequest: Codable, Equatable {
    public var marketType: MarketType?
    public var spotOptions: LaunchTemplateSpotMarketOptionsRequest?

    public init(marketType: MarketType? = nil,
                spotOptions: LaunchTemplateSpotMarketOptionsRequest? = nil) {
        self.marketType = marketType
        self.spotOptions = spotOptions
    }

    enum CodingKeys: String, CodingKey {
        case marketType = "MarketType"
        case spotOptions = "SpotOptions"
    }

    public func validate() throws {
        try spotOptions?.validate()
    }
}

public struct LaunchTemplateInstanceMetadataOptions: Codable, Equatable {
    public var httpEndpoint: LaunchTemplateInstanceMetadataEndpointState?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: LaunchTemplateHttpTokensState?
    public var state: LaunchTemplateInstanceMetadataOptionsState?

    public init(httpEndpoint: LaunchTemplateInstanceMetadataEndpointState? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: LaunchTemplateHttpTokensState? = nil,
                state: LaunchTemplateInstanceMetadataOptionsState? = nil) {
        self.httpEndpoint = httpEndpoint
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case httpEndpoint
        case httpPutResponseHopLimit
        case httpTokens
        case state
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceMetadataOptionsRequest: Codable, Equatable {
    public var httpEndpoint: LaunchTemplateInstanceMetadataEndpointState?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: LaunchTemplateHttpTokensState?

    public init(httpEndpoint: LaunchTemplateInstanceMetadataEndpointState? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: LaunchTemplateHttpTokensState? = nil) {
        self.httpEndpoint = httpEndpoint
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
    }

    enum CodingKeys: String, CodingKey {
        case httpEndpoint = "HttpEndpoint"
        case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
        case httpTokens = "HttpTokens"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceNetworkInterfaceSpecification: Codable, Equatable {
    public var associateCarrierIpAddress: Boolean?
    public var associatePublicIpAddress: Boolean?
    public var deleteOnTermination: Boolean?
    public var description: String?
    public var deviceIndex: Integer?
    public var groups: GroupIdStringList?
    public var interfaceType: String?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var networkCardIndex: Integer?
    public var networkInterfaceId: NetworkInterfaceId?
    public var privateIpAddress: String?
    public var privateIpAddresses: PrivateIpAddressSpecificationList?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: SubnetId?

    public init(associateCarrierIpAddress: Boolean? = nil,
                associatePublicIpAddress: Boolean? = nil,
                deleteOnTermination: Boolean? = nil,
                description: String? = nil,
                deviceIndex: Integer? = nil,
                groups: GroupIdStringList? = nil,
                interfaceType: String? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                networkCardIndex: Integer? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: PrivateIpAddressSpecificationList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: SubnetId? = nil) {
        self.associateCarrierIpAddress = associateCarrierIpAddress
        self.associatePublicIpAddress = associatePublicIpAddress
        self.deleteOnTermination = deleteOnTermination
        self.description = description
        self.deviceIndex = deviceIndex
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.networkCardIndex = networkCardIndex
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associateCarrierIpAddress
        case associatePublicIpAddress
        case deleteOnTermination
        case description
        case deviceIndex
        case groups = "groupSet"
        case interfaceType
        case ipv6AddressCount
        case ipv6Addresses = "ipv6AddressesSet"
        case networkCardIndex
        case networkInterfaceId
        case privateIpAddress
        case privateIpAddresses = "privateIpAddressesSet"
        case secondaryPrivateIpAddressCount
        case subnetId
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceNetworkInterfaceSpecificationRequest: Codable, Equatable {
    public var associateCarrierIpAddress: Boolean?
    public var associatePublicIpAddress: Boolean?
    public var deleteOnTermination: Boolean?
    public var description: String?
    public var deviceIndex: Integer?
    public var groups: SecurityGroupIdStringList?
    public var interfaceType: String?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressListRequest?
    public var networkCardIndex: Integer?
    public var networkInterfaceId: NetworkInterfaceId?
    public var privateIpAddress: String?
    public var privateIpAddresses: PrivateIpAddressSpecificationList?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: SubnetId?

    public init(associateCarrierIpAddress: Boolean? = nil,
                associatePublicIpAddress: Boolean? = nil,
                deleteOnTermination: Boolean? = nil,
                description: String? = nil,
                deviceIndex: Integer? = nil,
                groups: SecurityGroupIdStringList? = nil,
                interfaceType: String? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressListRequest? = nil,
                networkCardIndex: Integer? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: PrivateIpAddressSpecificationList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: SubnetId? = nil) {
        self.associateCarrierIpAddress = associateCarrierIpAddress
        self.associatePublicIpAddress = associatePublicIpAddress
        self.deleteOnTermination = deleteOnTermination
        self.description = description
        self.deviceIndex = deviceIndex
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.networkCardIndex = networkCardIndex
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associateCarrierIpAddress = "AssociateCarrierIpAddress"
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case deleteOnTermination = "DeleteOnTermination"
        case description = "Description"
        case deviceIndex = "DeviceIndex"
        case groups = "SecurityGroupId"
        case interfaceType = "InterfaceType"
        case ipv6AddressCount = "Ipv6AddressCount"
        case ipv6Addresses = "Ipv6Addresses"
        case networkCardIndex = "NetworkCardIndex"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddress = "PrivateIpAddress"
        case privateIpAddresses = "PrivateIpAddresses"
        case secondaryPrivateIpAddressCount = "SecondaryPrivateIpAddressCount"
        case subnetId = "SubnetId"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateLicenseConfiguration: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateLicenseConfigurationRequest: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateOverrides: Codable, Equatable {
    public var availabilityZone: String?
    public var instanceType: InstanceType?
    public var priority: Double?
    public var spotPrice: String?
    public var subnetId: String?
    public var weightedCapacity: Double?

    public init(availabilityZone: String? = nil,
                instanceType: InstanceType? = nil,
                priority: Double? = nil,
                spotPrice: String? = nil,
                subnetId: String? = nil,
                weightedCapacity: Double? = nil) {
        self.availabilityZone = availabilityZone
        self.instanceType = instanceType
        self.priority = priority
        self.spotPrice = spotPrice
        self.subnetId = subnetId
        self.weightedCapacity = weightedCapacity
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case instanceType
        case priority
        case spotPrice
        case subnetId
        case weightedCapacity
    }

    public func validate() throws {
    }
}

public struct LaunchTemplatePlacement: Codable, Equatable {
    public var affinity: String?
    public var availabilityZone: String?
    public var groupName: String?
    public var hostId: String?
    public var hostResourceGroupArn: String?
    public var partitionNumber: Integer?
    public var spreadDomain: String?
    public var tenancy: Tenancy?

    public init(affinity: String? = nil,
                availabilityZone: String? = nil,
                groupName: String? = nil,
                hostId: String? = nil,
                hostResourceGroupArn: String? = nil,
                partitionNumber: Integer? = nil,
                spreadDomain: String? = nil,
                tenancy: Tenancy? = nil) {
        self.affinity = affinity
        self.availabilityZone = availabilityZone
        self.groupName = groupName
        self.hostId = hostId
        self.hostResourceGroupArn = hostResourceGroupArn
        self.partitionNumber = partitionNumber
        self.spreadDomain = spreadDomain
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case affinity
        case availabilityZone
        case groupName
        case hostId
        case hostResourceGroupArn
        case partitionNumber
        case spreadDomain
        case tenancy
    }

    public func validate() throws {
    }
}

public struct LaunchTemplatePlacementRequest: Codable, Equatable {
    public var affinity: String?
    public var availabilityZone: String?
    public var groupName: PlacementGroupName?
    public var hostId: DedicatedHostId?
    public var hostResourceGroupArn: String?
    public var partitionNumber: Integer?
    public var spreadDomain: String?
    public var tenancy: Tenancy?

    public init(affinity: String? = nil,
                availabilityZone: String? = nil,
                groupName: PlacementGroupName? = nil,
                hostId: DedicatedHostId? = nil,
                hostResourceGroupArn: String? = nil,
                partitionNumber: Integer? = nil,
                spreadDomain: String? = nil,
                tenancy: Tenancy? = nil) {
        self.affinity = affinity
        self.availabilityZone = availabilityZone
        self.groupName = groupName
        self.hostId = hostId
        self.hostResourceGroupArn = hostResourceGroupArn
        self.partitionNumber = partitionNumber
        self.spreadDomain = spreadDomain
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case affinity = "Affinity"
        case availabilityZone = "AvailabilityZone"
        case groupName = "GroupName"
        case hostId = "HostId"
        case hostResourceGroupArn = "HostResourceGroupArn"
        case partitionNumber = "PartitionNumber"
        case spreadDomain = "SpreadDomain"
        case tenancy = "Tenancy"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateSpecification: Codable, Equatable {
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: String?
    public var version: String?

    public init(launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: String? = nil,
                version: String? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case version = "Version"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateSpotMarketOptions: Codable, Equatable {
    public var blockDurationMinutes: Integer?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var maxPrice: String?
    public var spotInstanceType: SpotInstanceType?
    public var validUntil: DateTime?

    public init(blockDurationMinutes: Integer? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                maxPrice: String? = nil,
                spotInstanceType: SpotInstanceType? = nil,
                validUntil: DateTime? = nil) {
        self.blockDurationMinutes = blockDurationMinutes
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.maxPrice = maxPrice
        self.spotInstanceType = spotInstanceType
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case blockDurationMinutes
        case instanceInterruptionBehavior
        case maxPrice
        case spotInstanceType
        case validUntil
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateSpotMarketOptionsRequest: Codable, Equatable {
    public var blockDurationMinutes: Integer?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var maxPrice: String?
    public var spotInstanceType: SpotInstanceType?
    public var validUntil: DateTime?

    public init(blockDurationMinutes: Integer? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                maxPrice: String? = nil,
                spotInstanceType: SpotInstanceType? = nil,
                validUntil: DateTime? = nil) {
        self.blockDurationMinutes = blockDurationMinutes
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.maxPrice = maxPrice
        self.spotInstanceType = spotInstanceType
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case blockDurationMinutes = "BlockDurationMinutes"
        case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
        case maxPrice = "MaxPrice"
        case spotInstanceType = "SpotInstanceType"
        case validUntil = "ValidUntil"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateTagSpecification: Codable, Equatable {
    public var resourceType: ResourceType?
    public var tags: TagList?

    public init(resourceType: ResourceType? = nil,
                tags: TagList? = nil) {
        self.resourceType = resourceType
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case resourceType
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateTagSpecificationRequest: Codable, Equatable {
    public var resourceType: ResourceType?
    public var tags: TagList?

    public init(resourceType: ResourceType? = nil,
                tags: TagList? = nil) {
        self.resourceType = resourceType
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case resourceType = "ResourceType"
        case tags = "Tag"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateVersion: Codable, Equatable {
    public var createTime: DateTime?
    public var createdBy: String?
    public var defaultVersion: Boolean?
    public var launchTemplateData: ResponseLaunchTemplateData?
    public var launchTemplateId: String?
    public var launchTemplateName: LaunchTemplateName?
    public var versionDescription: VersionDescription?
    public var versionNumber: Long?

    public init(createTime: DateTime? = nil,
                createdBy: String? = nil,
                defaultVersion: Boolean? = nil,
                launchTemplateData: ResponseLaunchTemplateData? = nil,
                launchTemplateId: String? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                versionDescription: VersionDescription? = nil,
                versionNumber: Long? = nil) {
        self.createTime = createTime
        self.createdBy = createdBy
        self.defaultVersion = defaultVersion
        self.launchTemplateData = launchTemplateData
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.versionDescription = versionDescription
        self.versionNumber = versionNumber
    }

    enum CodingKeys: String, CodingKey {
        case createTime
        case createdBy
        case defaultVersion
        case launchTemplateData
        case launchTemplateId
        case launchTemplateName
        case versionDescription
        case versionNumber
    }

    public func validate() throws {
        try launchTemplateData?.validate()
        try launchTemplateName?.validateAsLaunchTemplateName()
        try versionDescription?.validateAsVersionDescription()
    }
}

public struct LaunchTemplatesMonitoring: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct LaunchTemplatesMonitoringRequest: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct LicenseConfiguration: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn
    }

    public func validate() throws {
    }
}

public struct LicenseConfigurationRequest: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func validate() throws {
    }
}

public struct LoadBalancersConfig: Codable, Equatable {
    public var classicLoadBalancersConfig: ClassicLoadBalancersConfig?
    public var targetGroupsConfig: TargetGroupsConfig?

    public init(classicLoadBalancersConfig: ClassicLoadBalancersConfig? = nil,
                targetGroupsConfig: TargetGroupsConfig? = nil) {
        self.classicLoadBalancersConfig = classicLoadBalancersConfig
        self.targetGroupsConfig = targetGroupsConfig
    }

    enum CodingKeys: String, CodingKey {
        case classicLoadBalancersConfig
        case targetGroupsConfig
    }

    public func validate() throws {
        try classicLoadBalancersConfig?.validate()
        try targetGroupsConfig?.validate()
    }
}

public struct LoadPermission: Codable, Equatable {
    public var group: PermissionGroup?
    public var userId: String?

    public init(group: PermissionGroup? = nil,
                userId: String? = nil) {
        self.group = group
        self.userId = userId
    }

    enum CodingKeys: String, CodingKey {
        case group
        case userId
    }

    public func validate() throws {
    }
}

public struct LoadPermissionModifications: Codable, Equatable {
    public var add: LoadPermissionListRequest?
    public var remove: LoadPermissionListRequest?

    public init(add: LoadPermissionListRequest? = nil,
                remove: LoadPermissionListRequest? = nil) {
        self.add = add
        self.remove = remove
    }

    enum CodingKeys: String, CodingKey {
        case add = "Add"
        case remove = "Remove"
    }

    public func validate() throws {
    }
}

public struct LoadPermissionRequest: Codable, Equatable {
    public var group: PermissionGroup?
    public var userId: String?

    public init(group: PermissionGroup? = nil,
                userId: String? = nil) {
        self.group = group
        self.userId = userId
    }

    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case userId = "UserId"
    }

    public func validate() throws {
    }
}

public struct LocalGateway: Codable, Equatable {
    public var localGatewayId: LocalGatewayId?
    public var outpostArn: String?
    public var ownerId: String?
    public var state: String?
    public var tags: TagList?

    public init(localGatewayId: LocalGatewayId? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                state: String? = nil,
                tags: TagList? = nil) {
        self.localGatewayId = localGatewayId
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case outpostArn
        case ownerId
        case state
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct LocalGatewayRoute: Codable, Equatable {
    public var destinationCidrBlock: String?
    public var localGatewayRouteTableArn: ResourceArn?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId?
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId?
    public var ownerId: String?
    public var state: LocalGatewayRouteState?
    public var type: LocalGatewayRouteType?

    public init(destinationCidrBlock: String? = nil,
                localGatewayRouteTableArn: ResourceArn? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId? = nil,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId? = nil,
                ownerId: String? = nil,
                state: LocalGatewayRouteState? = nil,
                type: LocalGatewayRouteType? = nil) {
        self.destinationCidrBlock = destinationCidrBlock
        self.localGatewayRouteTableArn = localGatewayRouteTableArn
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
        self.ownerId = ownerId
        self.state = state
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock
        case localGatewayRouteTableArn
        case localGatewayRouteTableId
        case localGatewayVirtualInterfaceGroupId
        case ownerId
        case state
        case type
    }

    public func validate() throws {
        try localGatewayRouteTableArn?.validateAsResourceArn()
    }
}

public struct LocalGatewayRouteTable: Codable, Equatable {
    public var localGatewayId: LocalGatewayId?
    public var localGatewayRouteTableArn: ResourceArn?
    public var localGatewayRouteTableId: String?
    public var outpostArn: String?
    public var ownerId: String?
    public var state: String?
    public var tags: TagList?

    public init(localGatewayId: LocalGatewayId? = nil,
                localGatewayRouteTableArn: ResourceArn? = nil,
                localGatewayRouteTableId: String? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                state: String? = nil,
                tags: TagList? = nil) {
        self.localGatewayId = localGatewayId
        self.localGatewayRouteTableArn = localGatewayRouteTableArn
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case localGatewayRouteTableArn
        case localGatewayRouteTableId
        case outpostArn
        case ownerId
        case state
        case tags = "tagSet"
    }

    public func validate() throws {
        try localGatewayRouteTableArn?.validateAsResourceArn()
    }
}

public struct LocalGatewayRouteTableVirtualInterfaceGroupAssociation: Codable, Equatable {
    public var localGatewayId: String?
    public var localGatewayRouteTableArn: ResourceArn?
    public var localGatewayRouteTableId: LocalGatewayId?
    public var localGatewayRouteTableVirtualInterfaceGroupAssociationId: LocalGatewayRouteTableVirtualInterfaceGroupAssociationId?
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId?
    public var ownerId: String?
    public var state: String?
    public var tags: TagList?

    public init(localGatewayId: String? = nil,
                localGatewayRouteTableArn: ResourceArn? = nil,
                localGatewayRouteTableId: LocalGatewayId? = nil,
                localGatewayRouteTableVirtualInterfaceGroupAssociationId: LocalGatewayRouteTableVirtualInterfaceGroupAssociationId? = nil,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId? = nil,
                ownerId: String? = nil,
                state: String? = nil,
                tags: TagList? = nil) {
        self.localGatewayId = localGatewayId
        self.localGatewayRouteTableArn = localGatewayRouteTableArn
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayRouteTableVirtualInterfaceGroupAssociationId = localGatewayRouteTableVirtualInterfaceGroupAssociationId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case localGatewayRouteTableArn
        case localGatewayRouteTableId
        case localGatewayRouteTableVirtualInterfaceGroupAssociationId
        case localGatewayVirtualInterfaceGroupId
        case ownerId
        case state
        case tags = "tagSet"
    }

    public func validate() throws {
        try localGatewayRouteTableArn?.validateAsResourceArn()
    }
}

public struct LocalGatewayRouteTableVpcAssociation: Codable, Equatable {
    public var localGatewayId: String?
    public var localGatewayRouteTableArn: ResourceArn?
    public var localGatewayRouteTableId: String?
    public var localGatewayRouteTableVpcAssociationId: LocalGatewayRouteTableVpcAssociationId?
    public var ownerId: String?
    public var state: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(localGatewayId: String? = nil,
                localGatewayRouteTableArn: ResourceArn? = nil,
                localGatewayRouteTableId: String? = nil,
                localGatewayRouteTableVpcAssociationId: LocalGatewayRouteTableVpcAssociationId? = nil,
                ownerId: String? = nil,
                state: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.localGatewayId = localGatewayId
        self.localGatewayRouteTableArn = localGatewayRouteTableArn
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayRouteTableVpcAssociationId = localGatewayRouteTableVpcAssociationId
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case localGatewayRouteTableArn
        case localGatewayRouteTableId
        case localGatewayRouteTableVpcAssociationId
        case ownerId
        case state
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
        try localGatewayRouteTableArn?.validateAsResourceArn()
    }
}

public struct LocalGatewayVirtualInterface: Codable, Equatable {
    public var localAddress: String?
    public var localBgpAsn: Integer?
    public var localGatewayId: String?
    public var localGatewayVirtualInterfaceId: LocalGatewayVirtualInterfaceId?
    public var ownerId: String?
    public var peerAddress: String?
    public var peerBgpAsn: Integer?
    public var tags: TagList?
    public var vlan: Integer?

    public init(localAddress: String? = nil,
                localBgpAsn: Integer? = nil,
                localGatewayId: String? = nil,
                localGatewayVirtualInterfaceId: LocalGatewayVirtualInterfaceId? = nil,
                ownerId: String? = nil,
                peerAddress: String? = nil,
                peerBgpAsn: Integer? = nil,
                tags: TagList? = nil,
                vlan: Integer? = nil) {
        self.localAddress = localAddress
        self.localBgpAsn = localBgpAsn
        self.localGatewayId = localGatewayId
        self.localGatewayVirtualInterfaceId = localGatewayVirtualInterfaceId
        self.ownerId = ownerId
        self.peerAddress = peerAddress
        self.peerBgpAsn = peerBgpAsn
        self.tags = tags
        self.vlan = vlan
    }

    enum CodingKeys: String, CodingKey {
        case localAddress
        case localBgpAsn
        case localGatewayId
        case localGatewayVirtualInterfaceId
        case ownerId
        case peerAddress
        case peerBgpAsn
        case tags = "tagSet"
        case vlan
    }

    public func validate() throws {
    }
}

public struct LocalGatewayVirtualInterfaceGroup: Codable, Equatable {
    public var localGatewayId: String?
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId?
    public var localGatewayVirtualInterfaceIds: LocalGatewayVirtualInterfaceIdSet?
    public var ownerId: String?
    public var tags: TagList?

    public init(localGatewayId: String? = nil,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId? = nil,
                localGatewayVirtualInterfaceIds: LocalGatewayVirtualInterfaceIdSet? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil) {
        self.localGatewayId = localGatewayId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
        self.localGatewayVirtualInterfaceIds = localGatewayVirtualInterfaceIds
        self.ownerId = ownerId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case localGatewayVirtualInterfaceGroupId
        case localGatewayVirtualInterfaceIds = "localGatewayVirtualInterfaceIdSet"
        case ownerId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct ManagedPrefixList: Codable, Equatable {
    public var addressFamily: String?
    public var maxEntries: Integer?
    public var ownerId: String?
    public var prefixListArn: ResourceArn?
    public var prefixListId: PrefixListResourceId?
    public var prefixListName: String?
    public var state: PrefixListState?
    public var stateMessage: String?
    public var tags: TagList?
    public var version: Long?

    public init(addressFamily: String? = nil,
                maxEntries: Integer? = nil,
                ownerId: String? = nil,
                prefixListArn: ResourceArn? = nil,
                prefixListId: PrefixListResourceId? = nil,
                prefixListName: String? = nil,
                state: PrefixListState? = nil,
                stateMessage: String? = nil,
                tags: TagList? = nil,
                version: Long? = nil) {
        self.addressFamily = addressFamily
        self.maxEntries = maxEntries
        self.ownerId = ownerId
        self.prefixListArn = prefixListArn
        self.prefixListId = prefixListId
        self.prefixListName = prefixListName
        self.state = state
        self.stateMessage = stateMessage
        self.tags = tags
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case addressFamily
        case maxEntries
        case ownerId
        case prefixListArn
        case prefixListId
        case prefixListName
        case state
        case stateMessage
        case tags = "tagSet"
        case version
    }

    public func validate() throws {
        try prefixListArn?.validateAsResourceArn()
    }
}

public struct MemoryInfo: Codable, Equatable {
    public var sizeInMiB: MemorySize?

    public init(sizeInMiB: MemorySize? = nil) {
        self.sizeInMiB = sizeInMiB
    }

    enum CodingKeys: String, CodingKey {
        case sizeInMiB
    }

    public func validate() throws {
    }
}

public struct ModifyAvailabilityZoneGroupRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupName: String
    public var optInStatus: ModifyAvailabilityZoneOptInStatus

    public init(dryRun: Boolean? = nil,
                groupName: String,
                optInStatus: ModifyAvailabilityZoneOptInStatus) {
        self.dryRun = dryRun
        self.groupName = groupName
        self.optInStatus = optInStatus
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupName = "GroupName"
        case optInStatus = "OptInStatus"
    }

    public func validate() throws {
    }
}

public struct ModifyAvailabilityZoneGroupResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyCapacityReservationRequest: Codable, Equatable {
    public var capacityReservationId: CapacityReservationId
    public var dryRun: Boolean?
    public var endDate: DateTime?
    public var endDateType: EndDateType?
    public var instanceCount: Integer?

    public init(capacityReservationId: CapacityReservationId,
                dryRun: Boolean? = nil,
                endDate: DateTime? = nil,
                endDateType: EndDateType? = nil,
                instanceCount: Integer? = nil) {
        self.capacityReservationId = capacityReservationId
        self.dryRun = dryRun
        self.endDate = endDate
        self.endDateType = endDateType
        self.instanceCount = instanceCount
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case dryRun = "DryRun"
        case endDate = "EndDate"
        case endDateType = "EndDateType"
        case instanceCount = "InstanceCount"
    }

    public func validate() throws {
    }
}

public struct ModifyCapacityReservationResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyClientVpnEndpointRequest: Codable, Equatable {
    public var clientConnectOptions: ClientConnectOptions?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var connectionLogOptions: ConnectionLogOptions?
    public var description: String?
    public var dnsServers: DnsServersOptionsModifyStructure?
    public var dryRun: Boolean?
    public var securityGroupIds: ClientVpnSecurityGroupIdSet?
    public var selfServicePortal: SelfServicePortal?
    public var serverCertificateArn: String?
    public var splitTunnel: Boolean?
    public var vpcId: VpcId?
    public var vpnPort: Integer?

    public init(clientConnectOptions: ClientConnectOptions? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                connectionLogOptions: ConnectionLogOptions? = nil,
                description: String? = nil,
                dnsServers: DnsServersOptionsModifyStructure? = nil,
                dryRun: Boolean? = nil,
                securityGroupIds: ClientVpnSecurityGroupIdSet? = nil,
                selfServicePortal: SelfServicePortal? = nil,
                serverCertificateArn: String? = nil,
                splitTunnel: Boolean? = nil,
                vpcId: VpcId? = nil,
                vpnPort: Integer? = nil) {
        self.clientConnectOptions = clientConnectOptions
        self.clientVpnEndpointId = clientVpnEndpointId
        self.connectionLogOptions = connectionLogOptions
        self.description = description
        self.dnsServers = dnsServers
        self.dryRun = dryRun
        self.securityGroupIds = securityGroupIds
        self.selfServicePortal = selfServicePortal
        self.serverCertificateArn = serverCertificateArn
        self.splitTunnel = splitTunnel
        self.vpcId = vpcId
        self.vpnPort = vpnPort
    }

    enum CodingKeys: String, CodingKey {
        case clientConnectOptions = "ClientConnectOptions"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case connectionLogOptions = "ConnectionLogOptions"
        case description = "Description"
        case dnsServers = "DnsServers"
        case dryRun = "DryRun"
        case securityGroupIds = "SecurityGroupId"
        case selfServicePortal = "SelfServicePortal"
        case serverCertificateArn = "ServerCertificateArn"
        case splitTunnel = "SplitTunnel"
        case vpcId = "VpcId"
        case vpnPort = "VpnPort"
    }

    public func validate() throws {
        try clientConnectOptions?.validate()
        try connectionLogOptions?.validate()
        try dnsServers?.validate()
    }
}

public struct ModifyClientVpnEndpointResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyDefaultCreditSpecificationRequest: Codable, Equatable {
    public var cpuCredits: String
    public var dryRun: Boolean?
    public var instanceFamily: UnlimitedSupportedInstanceFamily

    public init(cpuCredits: String,
                dryRun: Boolean? = nil,
                instanceFamily: UnlimitedSupportedInstanceFamily) {
        self.cpuCredits = cpuCredits
        self.dryRun = dryRun
        self.instanceFamily = instanceFamily
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits = "CpuCredits"
        case dryRun = "DryRun"
        case instanceFamily = "InstanceFamily"
    }

    public func validate() throws {
    }
}

public struct ModifyDefaultCreditSpecificationResult: Codable, Equatable {
    public var instanceFamilyCreditSpecification: InstanceFamilyCreditSpecification?

    public init(instanceFamilyCreditSpecification: InstanceFamilyCreditSpecification? = nil) {
        self.instanceFamilyCreditSpecification = instanceFamilyCreditSpecification
    }

    enum CodingKeys: String, CodingKey {
        case instanceFamilyCreditSpecification
    }

    public func validate() throws {
        try instanceFamilyCreditSpecification?.validate()
    }
}

public struct ModifyEbsDefaultKmsKeyIdRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var kmsKeyId: KmsKeyId

    public init(dryRun: Boolean? = nil,
                kmsKeyId: KmsKeyId) {
        self.dryRun = dryRun
        self.kmsKeyId = kmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case kmsKeyId = "KmsKeyId"
    }

    public func validate() throws {
    }
}

public struct ModifyEbsDefaultKmsKeyIdResult: Codable, Equatable {
    public var kmsKeyId: String?

    public init(kmsKeyId: String? = nil) {
        self.kmsKeyId = kmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case kmsKeyId
    }

    public func validate() throws {
    }
}

public struct ModifyFleetRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy?
    public var fleetId: FleetId
    public var launchTemplateConfigs: FleetLaunchTemplateConfigListRequest?
    public var targetCapacitySpecification: TargetCapacitySpecificationRequest?

    public init(dryRun: Boolean? = nil,
                excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy? = nil,
                fleetId: FleetId,
                launchTemplateConfigs: FleetLaunchTemplateConfigListRequest? = nil,
                targetCapacitySpecification: TargetCapacitySpecificationRequest? = nil) {
        self.dryRun = dryRun
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.fleetId = fleetId
        self.launchTemplateConfigs = launchTemplateConfigs
        self.targetCapacitySpecification = targetCapacitySpecification
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case excessCapacityTerminationPolicy = "ExcessCapacityTerminationPolicy"
        case fleetId = "FleetId"
        case launchTemplateConfigs = "LaunchTemplateConfig"
        case targetCapacitySpecification = "TargetCapacitySpecification"
    }

    public func validate() throws {
        try launchTemplateConfigs?.validateAsFleetLaunchTemplateConfigListRequest()
        try targetCapacitySpecification?.validate()
    }
}

public struct ModifyFleetResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyFpgaImageAttributeRequest: Codable, Equatable {
    public var attribute: FpgaImageAttributeName?
    public var description: String?
    public var dryRun: Boolean?
    public var fpgaImageId: FpgaImageId
    public var loadPermission: LoadPermissionModifications?
    public var name: String?
    public var operationType: OperationType?
    public var productCodes: ProductCodeStringList?
    public var userGroups: UserGroupStringList?
    public var userIds: UserIdStringList?

    public init(attribute: FpgaImageAttributeName? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                fpgaImageId: FpgaImageId,
                loadPermission: LoadPermissionModifications? = nil,
                name: String? = nil,
                operationType: OperationType? = nil,
                productCodes: ProductCodeStringList? = nil,
                userGroups: UserGroupStringList? = nil,
                userIds: UserIdStringList? = nil) {
        self.attribute = attribute
        self.description = description
        self.dryRun = dryRun
        self.fpgaImageId = fpgaImageId
        self.loadPermission = loadPermission
        self.name = name
        self.operationType = operationType
        self.productCodes = productCodes
        self.userGroups = userGroups
        self.userIds = userIds
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case description = "Description"
        case dryRun = "DryRun"
        case fpgaImageId = "FpgaImageId"
        case loadPermission = "LoadPermission"
        case name = "Name"
        case operationType = "OperationType"
        case productCodes = "ProductCode"
        case userGroups = "UserGroup"
        case userIds = "UserId"
    }

    public func validate() throws {
        try loadPermission?.validate()
    }
}

public struct ModifyFpgaImageAttributeResult: Codable, Equatable {
    public var fpgaImageAttribute: FpgaImageAttribute?

    public init(fpgaImageAttribute: FpgaImageAttribute? = nil) {
        self.fpgaImageAttribute = fpgaImageAttribute
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImageAttribute
    }

    public func validate() throws {
        try fpgaImageAttribute?.validate()
    }
}

public struct ModifyHostsRequest: Codable, Equatable {
    public var autoPlacement: AutoPlacement?
    public var hostIds: RequestHostIdList
    public var hostRecovery: HostRecovery?
    public var instanceFamily: String?
    public var instanceType: String?

    public init(autoPlacement: AutoPlacement? = nil,
                hostIds: RequestHostIdList,
                hostRecovery: HostRecovery? = nil,
                instanceFamily: String? = nil,
                instanceType: String? = nil) {
        self.autoPlacement = autoPlacement
        self.hostIds = hostIds
        self.hostRecovery = hostRecovery
        self.instanceFamily = instanceFamily
        self.instanceType = instanceType
    }

    enum CodingKeys: String, CodingKey {
        case autoPlacement
        case hostIds = "hostId"
        case hostRecovery = "HostRecovery"
        case instanceFamily = "InstanceFamily"
        case instanceType = "InstanceType"
    }

    public func validate() throws {
    }
}

public struct ModifyHostsResult: Codable, Equatable {
    public var successful: ResponseHostIdList?
    public var unsuccessful: UnsuccessfulItemList?

    public init(successful: ResponseHostIdList? = nil,
                unsuccessful: UnsuccessfulItemList? = nil) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case successful
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct ModifyIdFormatRequest: Codable, Equatable {
    public var resource: String
    public var useLongIds: Boolean

    public init(resource: String,
                useLongIds: Boolean) {
        self.resource = resource
        self.useLongIds = useLongIds
    }

    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
        case useLongIds = "UseLongIds"
    }

    public func validate() throws {
    }
}

public struct ModifyIdentityIdFormatRequest: Codable, Equatable {
    public var principalArn: String
    public var resource: String
    public var useLongIds: Boolean

    public init(principalArn: String,
                resource: String,
                useLongIds: Boolean) {
        self.principalArn = principalArn
        self.resource = resource
        self.useLongIds = useLongIds
    }

    enum CodingKeys: String, CodingKey {
        case principalArn
        case resource
        case useLongIds
    }

    public func validate() throws {
    }
}

public struct ModifyImageAttributeRequest: Codable, Equatable {
    public var attribute: String?
    public var description: AttributeValue?
    public var dryRun: Boolean?
    public var imageId: ImageId
    public var launchPermission: LaunchPermissionModifications?
    public var operationType: OperationType?
    public var productCodes: ProductCodeStringList?
    public var userGroups: UserGroupStringList?
    public var userIds: UserIdStringList?
    public var value: String?

    public init(attribute: String? = nil,
                description: AttributeValue? = nil,
                dryRun: Boolean? = nil,
                imageId: ImageId,
                launchPermission: LaunchPermissionModifications? = nil,
                operationType: OperationType? = nil,
                productCodes: ProductCodeStringList? = nil,
                userGroups: UserGroupStringList? = nil,
                userIds: UserIdStringList? = nil,
                value: String? = nil) {
        self.attribute = attribute
        self.description = description
        self.dryRun = dryRun
        self.imageId = imageId
        self.launchPermission = launchPermission
        self.operationType = operationType
        self.productCodes = productCodes
        self.userGroups = userGroups
        self.userIds = userIds
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case description = "Description"
        case dryRun
        case imageId = "ImageId"
        case launchPermission = "LaunchPermission"
        case operationType = "OperationType"
        case productCodes = "ProductCode"
        case userGroups = "UserGroup"
        case userIds = "UserId"
        case value = "Value"
    }

    public func validate() throws {
        try description?.validate()
        try launchPermission?.validate()
    }
}

public struct ModifyInstanceAttributeRequest: Codable, Equatable {
    public var attribute: InstanceAttributeName?
    public var blockDeviceMappings: InstanceBlockDeviceMappingSpecificationList?
    public var disableApiTermination: AttributeBooleanValue?
    public var dryRun: Boolean?
    public var ebsOptimized: AttributeBooleanValue?
    public var enaSupport: AttributeBooleanValue?
    public var groups: GroupIdStringList?
    public var instanceId: InstanceId
    public var instanceInitiatedShutdownBehavior: AttributeValue?
    public var instanceType: AttributeValue?
    public var kernel: AttributeValue?
    public var ramdisk: AttributeValue?
    public var sourceDestCheck: AttributeBooleanValue?
    public var sriovNetSupport: AttributeValue?
    public var userData: BlobAttributeValue?
    public var value: String?

    public init(attribute: InstanceAttributeName? = nil,
                blockDeviceMappings: InstanceBlockDeviceMappingSpecificationList? = nil,
                disableApiTermination: AttributeBooleanValue? = nil,
                dryRun: Boolean? = nil,
                ebsOptimized: AttributeBooleanValue? = nil,
                enaSupport: AttributeBooleanValue? = nil,
                groups: GroupIdStringList? = nil,
                instanceId: InstanceId,
                instanceInitiatedShutdownBehavior: AttributeValue? = nil,
                instanceType: AttributeValue? = nil,
                kernel: AttributeValue? = nil,
                ramdisk: AttributeValue? = nil,
                sourceDestCheck: AttributeBooleanValue? = nil,
                sriovNetSupport: AttributeValue? = nil,
                userData: BlobAttributeValue? = nil,
                value: String? = nil) {
        self.attribute = attribute
        self.blockDeviceMappings = blockDeviceMappings
        self.disableApiTermination = disableApiTermination
        self.dryRun = dryRun
        self.ebsOptimized = ebsOptimized
        self.enaSupport = enaSupport
        self.groups = groups
        self.instanceId = instanceId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceType = instanceType
        self.kernel = kernel
        self.ramdisk = ramdisk
        self.sourceDestCheck = sourceDestCheck
        self.sriovNetSupport = sriovNetSupport
        self.userData = userData
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case attribute
        case blockDeviceMappings = "blockDeviceMapping"
        case disableApiTermination
        case dryRun
        case ebsOptimized
        case enaSupport
        case groups = "GroupId"
        case instanceId
        case instanceInitiatedShutdownBehavior
        case instanceType
        case kernel
        case ramdisk
        case sourceDestCheck = "SourceDestCheck"
        case sriovNetSupport
        case userData
        case value
    }

    public func validate() throws {
        try disableApiTermination?.validate()
        try ebsOptimized?.validate()
        try enaSupport?.validate()
        try instanceInitiatedShutdownBehavior?.validate()
        try instanceType?.validate()
        try kernel?.validate()
        try ramdisk?.validate()
        try sourceDestCheck?.validate()
        try sriovNetSupport?.validate()
        try userData?.validate()
    }
}

public struct ModifyInstanceCapacityReservationAttributesRequest: Codable, Equatable {
    public var capacityReservationSpecification: CapacityReservationSpecification
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(capacityReservationSpecification: CapacityReservationSpecification,
                dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.capacityReservationSpecification = capacityReservationSpecification
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
        try capacityReservationSpecification.validate()
    }
}

public struct ModifyInstanceCapacityReservationAttributesResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceCreditSpecificationRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var instanceCreditSpecifications: InstanceCreditSpecificationListRequest

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                instanceCreditSpecifications: InstanceCreditSpecificationListRequest) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.instanceCreditSpecifications = instanceCreditSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case instanceCreditSpecifications = "InstanceCreditSpecification"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceCreditSpecificationResult: Codable, Equatable {
    public var successfulInstanceCreditSpecifications: SuccessfulInstanceCreditSpecificationSet?
    public var unsuccessfulInstanceCreditSpecifications: UnsuccessfulInstanceCreditSpecificationSet?

    public init(successfulInstanceCreditSpecifications: SuccessfulInstanceCreditSpecificationSet? = nil,
                unsuccessfulInstanceCreditSpecifications: UnsuccessfulInstanceCreditSpecificationSet? = nil) {
        self.successfulInstanceCreditSpecifications = successfulInstanceCreditSpecifications
        self.unsuccessfulInstanceCreditSpecifications = unsuccessfulInstanceCreditSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case successfulInstanceCreditSpecifications = "successfulInstanceCreditSpecificationSet"
        case unsuccessfulInstanceCreditSpecifications = "unsuccessfulInstanceCreditSpecificationSet"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceEventStartTimeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceEventId: String
    public var instanceId: InstanceId
    public var notBefore: DateTime

    public init(dryRun: Boolean? = nil,
                instanceEventId: String,
                instanceId: InstanceId,
                notBefore: DateTime) {
        self.dryRun = dryRun
        self.instanceEventId = instanceEventId
        self.instanceId = instanceId
        self.notBefore = notBefore
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceEventId = "InstanceEventId"
        case instanceId = "InstanceId"
        case notBefore = "NotBefore"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceEventStartTimeResult: Codable, Equatable {
    public var event: InstanceStatusEvent?

    public init(event: InstanceStatusEvent? = nil) {
        self.event = event
    }

    enum CodingKeys: String, CodingKey {
        case event
    }

    public func validate() throws {
        try event?.validate()
    }
}

public struct ModifyInstanceMetadataOptionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var httpEndpoint: InstanceMetadataEndpointState?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: HttpTokensState?
    public var instanceId: InstanceId

    public init(dryRun: Boolean? = nil,
                httpEndpoint: InstanceMetadataEndpointState? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: HttpTokensState? = nil,
                instanceId: InstanceId) {
        self.dryRun = dryRun
        self.httpEndpoint = httpEndpoint
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case httpEndpoint = "HttpEndpoint"
        case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
        case httpTokens = "HttpTokens"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceMetadataOptionsResult: Codable, Equatable {
    public var instanceId: String?
    public var instanceMetadataOptions: InstanceMetadataOptionsResponse?

    public init(instanceId: String? = nil,
                instanceMetadataOptions: InstanceMetadataOptionsResponse? = nil) {
        self.instanceId = instanceId
        self.instanceMetadataOptions = instanceMetadataOptions
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case instanceMetadataOptions
    }

    public func validate() throws {
        try instanceMetadataOptions?.validate()
    }
}

public struct ModifyInstancePlacementRequest: Codable, Equatable {
    public var affinity: Affinity?
    public var groupName: PlacementGroupName?
    public var hostId: DedicatedHostId?
    public var hostResourceGroupArn: String?
    public var instanceId: InstanceId
    public var partitionNumber: Integer?
    public var tenancy: HostTenancy?

    public init(affinity: Affinity? = nil,
                groupName: PlacementGroupName? = nil,
                hostId: DedicatedHostId? = nil,
                hostResourceGroupArn: String? = nil,
                instanceId: InstanceId,
                partitionNumber: Integer? = nil,
                tenancy: HostTenancy? = nil) {
        self.affinity = affinity
        self.groupName = groupName
        self.hostId = hostId
        self.hostResourceGroupArn = hostResourceGroupArn
        self.instanceId = instanceId
        self.partitionNumber = partitionNumber
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case affinity
        case groupName = "GroupName"
        case hostId
        case hostResourceGroupArn = "HostResourceGroupArn"
        case instanceId
        case partitionNumber = "PartitionNumber"
        case tenancy
    }

    public func validate() throws {
    }
}

public struct ModifyInstancePlacementResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyLaunchTemplateRequest: Codable, Equatable {
    public var clientToken: String?
    public var defaultVersion: String?
    public var dryRun: Boolean?
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?

    public init(clientToken: String? = nil,
                defaultVersion: String? = nil,
                dryRun: Boolean? = nil,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil) {
        self.clientToken = clientToken
        self.defaultVersion = defaultVersion
        self.dryRun = dryRun
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case defaultVersion = "SetDefaultVersion"
        case dryRun = "DryRun"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct ModifyLaunchTemplateResult: Codable, Equatable {
    public var launchTemplate: LaunchTemplate?

    public init(launchTemplate: LaunchTemplate? = nil) {
        self.launchTemplate = launchTemplate
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplate
    }

    public func validate() throws {
        try launchTemplate?.validate()
    }
}

public struct ModifyManagedPrefixListRequest: Codable, Equatable {
    public var addEntries: AddPrefixListEntries?
    public var currentVersion: Long?
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId
    public var prefixListName: String?
    public var removeEntries: RemovePrefixListEntries?

    public init(addEntries: AddPrefixListEntries? = nil,
                currentVersion: Long? = nil,
                dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId,
                prefixListName: String? = nil,
                removeEntries: RemovePrefixListEntries? = nil) {
        self.addEntries = addEntries
        self.currentVersion = currentVersion
        self.dryRun = dryRun
        self.prefixListId = prefixListId
        self.prefixListName = prefixListName
        self.removeEntries = removeEntries
    }

    enum CodingKeys: String, CodingKey {
        case addEntries = "AddEntry"
        case currentVersion = "CurrentVersion"
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
        case prefixListName = "PrefixListName"
        case removeEntries = "RemoveEntry"
    }

    public func validate() throws {
        try addEntries?.validateAsAddPrefixListEntries()
        try removeEntries?.validateAsRemovePrefixListEntries()
    }
}

public struct ModifyManagedPrefixListResult: Codable, Equatable {
    public var prefixList: ManagedPrefixList?

    public init(prefixList: ManagedPrefixList? = nil) {
        self.prefixList = prefixList
    }

    enum CodingKeys: String, CodingKey {
        case prefixList
    }

    public func validate() throws {
        try prefixList?.validate()
    }
}

public struct ModifyNetworkInterfaceAttributeRequest: Codable, Equatable {
    public var attachment: NetworkInterfaceAttachmentChanges?
    public var description: AttributeValue?
    public var dryRun: Boolean?
    public var groups: SecurityGroupIdStringList?
    public var networkInterfaceId: NetworkInterfaceId
    public var sourceDestCheck: AttributeBooleanValue?

    public init(attachment: NetworkInterfaceAttachmentChanges? = nil,
                description: AttributeValue? = nil,
                dryRun: Boolean? = nil,
                groups: SecurityGroupIdStringList? = nil,
                networkInterfaceId: NetworkInterfaceId,
                sourceDestCheck: AttributeBooleanValue? = nil) {
        self.attachment = attachment
        self.description = description
        self.dryRun = dryRun
        self.groups = groups
        self.networkInterfaceId = networkInterfaceId
        self.sourceDestCheck = sourceDestCheck
    }

    enum CodingKeys: String, CodingKey {
        case attachment
        case description
        case dryRun
        case groups = "SecurityGroupId"
        case networkInterfaceId
        case sourceDestCheck
    }

    public func validate() throws {
        try attachment?.validate()
        try description?.validate()
        try sourceDestCheck?.validate()
    }
}

public struct ModifyReservedInstancesRequest: Codable, Equatable {
    public var clientToken: String?
    public var reservedInstancesIds: ReservedInstancesIdStringList
    public var targetConfigurations: ReservedInstancesConfigurationList

    public init(clientToken: String? = nil,
                reservedInstancesIds: ReservedInstancesIdStringList,
                targetConfigurations: ReservedInstancesConfigurationList) {
        self.clientToken = clientToken
        self.reservedInstancesIds = reservedInstancesIds
        self.targetConfigurations = targetConfigurations
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case reservedInstancesIds = "ReservedInstancesId"
        case targetConfigurations = "ReservedInstancesConfigurationSetItemType"
    }

    public func validate() throws {
    }
}

public struct ModifyReservedInstancesResult: Codable, Equatable {
    public var reservedInstancesModificationId: String?

    public init(reservedInstancesModificationId: String? = nil) {
        self.reservedInstancesModificationId = reservedInstancesModificationId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesModificationId
    }

    public func validate() throws {
    }
}

public struct ModifySnapshotAttributeRequest: Codable, Equatable {
    public var attribute: SnapshotAttributeName?
    public var createVolumePermission: CreateVolumePermissionModifications?
    public var dryRun: Boolean?
    public var groupNames: GroupNameStringList?
    public var operationType: OperationType?
    public var snapshotId: SnapshotId
    public var userIds: UserIdStringList?

    public init(attribute: SnapshotAttributeName? = nil,
                createVolumePermission: CreateVolumePermissionModifications? = nil,
                dryRun: Boolean? = nil,
                groupNames: GroupNameStringList? = nil,
                operationType: OperationType? = nil,
                snapshotId: SnapshotId,
                userIds: UserIdStringList? = nil) {
        self.attribute = attribute
        self.createVolumePermission = createVolumePermission
        self.dryRun = dryRun
        self.groupNames = groupNames
        self.operationType = operationType
        self.snapshotId = snapshotId
        self.userIds = userIds
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case createVolumePermission = "CreateVolumePermission"
        case dryRun
        case groupNames = "UserGroup"
        case operationType = "OperationType"
        case snapshotId = "SnapshotId"
        case userIds = "UserId"
    }

    public func validate() throws {
        try createVolumePermission?.validate()
    }
}

public struct ModifySpotFleetRequestRequest: Codable, Equatable {
    public var excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy?
    public var launchTemplateConfigs: LaunchTemplateConfigList?
    public var onDemandTargetCapacity: Integer?
    public var spotFleetRequestId: SpotFleetRequestId
    public var targetCapacity: Integer?

    public init(excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy? = nil,
                launchTemplateConfigs: LaunchTemplateConfigList? = nil,
                onDemandTargetCapacity: Integer? = nil,
                spotFleetRequestId: SpotFleetRequestId,
                targetCapacity: Integer? = nil) {
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.launchTemplateConfigs = launchTemplateConfigs
        self.onDemandTargetCapacity = onDemandTargetCapacity
        self.spotFleetRequestId = spotFleetRequestId
        self.targetCapacity = targetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case excessCapacityTerminationPolicy
        case launchTemplateConfigs = "LaunchTemplateConfig"
        case onDemandTargetCapacity = "OnDemandTargetCapacity"
        case spotFleetRequestId
        case targetCapacity
    }

    public func validate() throws {
    }
}

public struct ModifySpotFleetRequestResponse: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifySubnetAttributeRequest: Codable, Equatable {
    public var assignIpv6AddressOnCreation: AttributeBooleanValue?
    public var customerOwnedIpv4Pool: CoipPoolId?
    public var mapCustomerOwnedIpOnLaunch: AttributeBooleanValue?
    public var mapPublicIpOnLaunch: AttributeBooleanValue?
    public var subnetId: SubnetId

    public init(assignIpv6AddressOnCreation: AttributeBooleanValue? = nil,
                customerOwnedIpv4Pool: CoipPoolId? = nil,
                mapCustomerOwnedIpOnLaunch: AttributeBooleanValue? = nil,
                mapPublicIpOnLaunch: AttributeBooleanValue? = nil,
                subnetId: SubnetId) {
        self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.mapCustomerOwnedIpOnLaunch = mapCustomerOwnedIpOnLaunch
        self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case assignIpv6AddressOnCreation = "AssignIpv6AddressOnCreation"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case mapCustomerOwnedIpOnLaunch = "MapCustomerOwnedIpOnLaunch"
        case mapPublicIpOnLaunch = "MapPublicIpOnLaunch"
        case subnetId
    }

    public func validate() throws {
        try assignIpv6AddressOnCreation?.validate()
        try mapCustomerOwnedIpOnLaunch?.validate()
        try mapPublicIpOnLaunch?.validate()
    }
}

public struct ModifyTrafficMirrorFilterNetworkServicesRequest: Codable, Equatable {
    public var addNetworkServices: TrafficMirrorNetworkServiceList?
    public var dryRun: Boolean?
    public var removeNetworkServices: TrafficMirrorNetworkServiceList?
    public var trafficMirrorFilterId: TrafficMirrorFilterId

    public init(addNetworkServices: TrafficMirrorNetworkServiceList? = nil,
                dryRun: Boolean? = nil,
                removeNetworkServices: TrafficMirrorNetworkServiceList? = nil,
                trafficMirrorFilterId: TrafficMirrorFilterId) {
        self.addNetworkServices = addNetworkServices
        self.dryRun = dryRun
        self.removeNetworkServices = removeNetworkServices
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case addNetworkServices = "AddNetworkService"
        case dryRun = "DryRun"
        case removeNetworkServices = "RemoveNetworkService"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
    }

    public func validate() throws {
    }
}

public struct ModifyTrafficMirrorFilterNetworkServicesResult: Codable, Equatable {
    public var trafficMirrorFilter: TrafficMirrorFilter?

    public init(trafficMirrorFilter: TrafficMirrorFilter? = nil) {
        self.trafficMirrorFilter = trafficMirrorFilter
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorFilter
    }

    public func validate() throws {
        try trafficMirrorFilter?.validate()
    }
}

public struct ModifyTrafficMirrorFilterRuleRequest: Codable, Equatable {
    public var description: String?
    public var destinationCidrBlock: String?
    public var destinationPortRange: TrafficMirrorPortRangeRequest?
    public var dryRun: Boolean?
    public var `protocol`: Integer?
    public var removeFields: TrafficMirrorFilterRuleFieldList?
    public var ruleAction: TrafficMirrorRuleAction?
    public var ruleNumber: Integer?
    public var sourceCidrBlock: String?
    public var sourcePortRange: TrafficMirrorPortRangeRequest?
    public var trafficDirection: TrafficDirection?
    public var trafficMirrorFilterRuleId: TrafficMirrorFilterRuleId

    public init(description: String? = nil,
                destinationCidrBlock: String? = nil,
                destinationPortRange: TrafficMirrorPortRangeRequest? = nil,
                dryRun: Boolean? = nil,
                `protocol`: Integer? = nil,
                removeFields: TrafficMirrorFilterRuleFieldList? = nil,
                ruleAction: TrafficMirrorRuleAction? = nil,
                ruleNumber: Integer? = nil,
                sourceCidrBlock: String? = nil,
                sourcePortRange: TrafficMirrorPortRangeRequest? = nil,
                trafficDirection: TrafficDirection? = nil,
                trafficMirrorFilterRuleId: TrafficMirrorFilterRuleId) {
        self.description = description
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationPortRange = destinationPortRange
        self.dryRun = dryRun
        self.`protocol` = `protocol`
        self.removeFields = removeFields
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
        self.sourceCidrBlock = sourceCidrBlock
        self.sourcePortRange = sourcePortRange
        self.trafficDirection = trafficDirection
        self.trafficMirrorFilterRuleId = trafficMirrorFilterRuleId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationPortRange = "DestinationPortRange"
        case dryRun = "DryRun"
        case `protocol` = "Protocol"
        case removeFields = "RemoveField"
        case ruleAction = "RuleAction"
        case ruleNumber = "RuleNumber"
        case sourceCidrBlock = "SourceCidrBlock"
        case sourcePortRange = "SourcePortRange"
        case trafficDirection = "TrafficDirection"
        case trafficMirrorFilterRuleId = "TrafficMirrorFilterRuleId"
    }

    public func validate() throws {
        try destinationPortRange?.validate()
        try sourcePortRange?.validate()
    }
}

public struct ModifyTrafficMirrorFilterRuleResult: Codable, Equatable {
    public var trafficMirrorFilterRule: TrafficMirrorFilterRule?

    public init(trafficMirrorFilterRule: TrafficMirrorFilterRule? = nil) {
        self.trafficMirrorFilterRule = trafficMirrorFilterRule
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorFilterRule
    }

    public func validate() throws {
        try trafficMirrorFilterRule?.validate()
    }
}

public struct ModifyTrafficMirrorSessionRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var packetLength: Integer?
    public var removeFields: TrafficMirrorSessionFieldList?
    public var sessionNumber: Integer?
    public var trafficMirrorFilterId: TrafficMirrorFilterId?
    public var trafficMirrorSessionId: TrafficMirrorSessionId
    public var trafficMirrorTargetId: TrafficMirrorTargetId?
    public var virtualNetworkId: Integer?

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                packetLength: Integer? = nil,
                removeFields: TrafficMirrorSessionFieldList? = nil,
                sessionNumber: Integer? = nil,
                trafficMirrorFilterId: TrafficMirrorFilterId? = nil,
                trafficMirrorSessionId: TrafficMirrorSessionId,
                trafficMirrorTargetId: TrafficMirrorTargetId? = nil,
                virtualNetworkId: Integer? = nil) {
        self.description = description
        self.dryRun = dryRun
        self.packetLength = packetLength
        self.removeFields = removeFields
        self.sessionNumber = sessionNumber
        self.trafficMirrorFilterId = trafficMirrorFilterId
        self.trafficMirrorSessionId = trafficMirrorSessionId
        self.trafficMirrorTargetId = trafficMirrorTargetId
        self.virtualNetworkId = virtualNetworkId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case packetLength = "PacketLength"
        case removeFields = "RemoveField"
        case sessionNumber = "SessionNumber"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
        case trafficMirrorSessionId = "TrafficMirrorSessionId"
        case trafficMirrorTargetId = "TrafficMirrorTargetId"
        case virtualNetworkId = "VirtualNetworkId"
    }

    public func validate() throws {
    }
}

public struct ModifyTrafficMirrorSessionResult: Codable, Equatable {
    public var trafficMirrorSession: TrafficMirrorSession?

    public init(trafficMirrorSession: TrafficMirrorSession? = nil) {
        self.trafficMirrorSession = trafficMirrorSession
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorSession
    }

    public func validate() throws {
        try trafficMirrorSession?.validate()
    }
}

public struct ModifyTransitGatewayOptions: Codable, Equatable {
    public var addTransitGatewayCidrBlocks: TransitGatewayCidrBlockStringList?
    public var associationDefaultRouteTableId: TransitGatewayRouteTableId?
    public var autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue?
    public var defaultRouteTableAssociation: DefaultRouteTableAssociationValue?
    public var defaultRouteTablePropagation: DefaultRouteTablePropagationValue?
    public var dnsSupport: DnsSupportValue?
    public var propagationDefaultRouteTableId: TransitGatewayRouteTableId?
    public var removeTransitGatewayCidrBlocks: TransitGatewayCidrBlockStringList?
    public var vpnEcmpSupport: VpnEcmpSupportValue?

    public init(addTransitGatewayCidrBlocks: TransitGatewayCidrBlockStringList? = nil,
                associationDefaultRouteTableId: TransitGatewayRouteTableId? = nil,
                autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue? = nil,
                defaultRouteTableAssociation: DefaultRouteTableAssociationValue? = nil,
                defaultRouteTablePropagation: DefaultRouteTablePropagationValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                propagationDefaultRouteTableId: TransitGatewayRouteTableId? = nil,
                removeTransitGatewayCidrBlocks: TransitGatewayCidrBlockStringList? = nil,
                vpnEcmpSupport: VpnEcmpSupportValue? = nil) {
        self.addTransitGatewayCidrBlocks = addTransitGatewayCidrBlocks
        self.associationDefaultRouteTableId = associationDefaultRouteTableId
        self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
        self.defaultRouteTableAssociation = defaultRouteTableAssociation
        self.defaultRouteTablePropagation = defaultRouteTablePropagation
        self.dnsSupport = dnsSupport
        self.propagationDefaultRouteTableId = propagationDefaultRouteTableId
        self.removeTransitGatewayCidrBlocks = removeTransitGatewayCidrBlocks
        self.vpnEcmpSupport = vpnEcmpSupport
    }

    enum CodingKeys: String, CodingKey {
        case addTransitGatewayCidrBlocks = "AddTransitGatewayCidrBlocks"
        case associationDefaultRouteTableId = "AssociationDefaultRouteTableId"
        case autoAcceptSharedAttachments = "AutoAcceptSharedAttachments"
        case defaultRouteTableAssociation = "DefaultRouteTableAssociation"
        case defaultRouteTablePropagation = "DefaultRouteTablePropagation"
        case dnsSupport = "DnsSupport"
        case propagationDefaultRouteTableId = "PropagationDefaultRouteTableId"
        case removeTransitGatewayCidrBlocks = "RemoveTransitGatewayCidrBlocks"
        case vpnEcmpSupport = "VpnEcmpSupport"
    }

    public func validate() throws {
    }
}

public struct ModifyTransitGatewayPrefixListReferenceRequest: Codable, Equatable {
    public var blackhole: Boolean?
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(blackhole: Boolean? = nil,
                dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.blackhole = blackhole
        self.dryRun = dryRun
        self.prefixListId = prefixListId
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole = "Blackhole"
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct ModifyTransitGatewayPrefixListReferenceResult: Codable, Equatable {
    public var transitGatewayPrefixListReference: TransitGatewayPrefixListReference?

    public init(transitGatewayPrefixListReference: TransitGatewayPrefixListReference? = nil) {
        self.transitGatewayPrefixListReference = transitGatewayPrefixListReference
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPrefixListReference
    }

    public func validate() throws {
        try transitGatewayPrefixListReference?.validate()
    }
}

public struct ModifyTransitGatewayRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var options: ModifyTransitGatewayOptions?
    public var transitGatewayId: TransitGatewayId

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                options: ModifyTransitGatewayOptions? = nil,
                transitGatewayId: TransitGatewayId) {
        self.description = description
        self.dryRun = dryRun
        self.options = options
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case options = "Options"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct ModifyTransitGatewayResult: Codable, Equatable {
    public var transitGateway: TransitGateway?

    public init(transitGateway: TransitGateway? = nil) {
        self.transitGateway = transitGateway
    }

    enum CodingKeys: String, CodingKey {
        case transitGateway
    }

    public func validate() throws {
        try transitGateway?.validate()
    }
}

public struct ModifyTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var addSubnetIds: TransitGatewaySubnetIdList?
    public var dryRun: Boolean?
    public var options: ModifyTransitGatewayVpcAttachmentRequestOptions?
    public var removeSubnetIds: TransitGatewaySubnetIdList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(addSubnetIds: TransitGatewaySubnetIdList? = nil,
                dryRun: Boolean? = nil,
                options: ModifyTransitGatewayVpcAttachmentRequestOptions? = nil,
                removeSubnetIds: TransitGatewaySubnetIdList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.addSubnetIds = addSubnetIds
        self.dryRun = dryRun
        self.options = options
        self.removeSubnetIds = removeSubnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case addSubnetIds = "AddSubnetIds"
        case dryRun = "DryRun"
        case options = "Options"
        case removeSubnetIds = "RemoveSubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct ModifyTransitGatewayVpcAttachmentRequestOptions: Codable, Equatable {
    public var applianceModeSupport: ApplianceModeSupportValue?
    public var dnsSupport: DnsSupportValue?
    public var ipv6Support: Ipv6SupportValue?

    public init(applianceModeSupport: ApplianceModeSupportValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                ipv6Support: Ipv6SupportValue? = nil) {
        self.applianceModeSupport = applianceModeSupport
        self.dnsSupport = dnsSupport
        self.ipv6Support = ipv6Support
    }

    enum CodingKeys: String, CodingKey {
        case applianceModeSupport = "ApplianceModeSupport"
        case dnsSupport = "DnsSupport"
        case ipv6Support = "Ipv6Support"
    }

    public func validate() throws {
    }
}

public struct ModifyTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct ModifyVolumeAttributeRequest: Codable, Equatable {
    public var autoEnableIO: AttributeBooleanValue?
    public var dryRun: Boolean?
    public var volumeId: VolumeId

    public init(autoEnableIO: AttributeBooleanValue? = nil,
                dryRun: Boolean? = nil,
                volumeId: VolumeId) {
        self.autoEnableIO = autoEnableIO
        self.dryRun = dryRun
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case autoEnableIO = "AutoEnableIO"
        case dryRun
        case volumeId = "VolumeId"
    }

    public func validate() throws {
        try autoEnableIO?.validate()
    }
}

public struct ModifyVolumeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var iops: Integer?
    public var size: Integer?
    public var throughput: Integer?
    public var volumeId: VolumeId
    public var volumeType: VolumeType?

    public init(dryRun: Boolean? = nil,
                iops: Integer? = nil,
                size: Integer? = nil,
                throughput: Integer? = nil,
                volumeId: VolumeId,
                volumeType: VolumeType? = nil) {
        self.dryRun = dryRun
        self.iops = iops
        self.size = size
        self.throughput = throughput
        self.volumeId = volumeId
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case iops = "Iops"
        case size = "Size"
        case throughput = "Throughput"
        case volumeId = "VolumeId"
        case volumeType = "VolumeType"
    }

    public func validate() throws {
    }
}

public struct ModifyVolumeResult: Codable, Equatable {
    public var volumeModification: VolumeModification?

    public init(volumeModification: VolumeModification? = nil) {
        self.volumeModification = volumeModification
    }

    enum CodingKeys: String, CodingKey {
        case volumeModification
    }

    public func validate() throws {
        try volumeModification?.validate()
    }
}

public struct ModifyVpcAttributeRequest: Codable, Equatable {
    public var enableDnsHostnames: AttributeBooleanValue?
    public var enableDnsSupport: AttributeBooleanValue?
    public var vpcId: VpcId

    public init(enableDnsHostnames: AttributeBooleanValue? = nil,
                enableDnsSupport: AttributeBooleanValue? = nil,
                vpcId: VpcId) {
        self.enableDnsHostnames = enableDnsHostnames
        self.enableDnsSupport = enableDnsSupport
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case enableDnsHostnames = "EnableDnsHostnames"
        case enableDnsSupport = "EnableDnsSupport"
        case vpcId
    }

    public func validate() throws {
        try enableDnsHostnames?.validate()
        try enableDnsSupport?.validate()
    }
}

public struct ModifyVpcEndpointConnectionNotificationRequest: Codable, Equatable {
    public var connectionEvents: ValueStringList?
    public var connectionNotificationArn: String?
    public var connectionNotificationId: ConnectionNotificationId
    public var dryRun: Boolean?

    public init(connectionEvents: ValueStringList? = nil,
                connectionNotificationArn: String? = nil,
                connectionNotificationId: ConnectionNotificationId,
                dryRun: Boolean? = nil) {
        self.connectionEvents = connectionEvents
        self.connectionNotificationArn = connectionNotificationArn
        self.connectionNotificationId = connectionNotificationId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case connectionEvents = "ConnectionEvents"
        case connectionNotificationArn = "ConnectionNotificationArn"
        case connectionNotificationId = "ConnectionNotificationId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointConnectionNotificationResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointRequest: Codable, Equatable {
    public var addRouteTableIds: VpcEndpointRouteTableIdList?
    public var addSecurityGroupIds: VpcEndpointSecurityGroupIdList?
    public var addSubnetIds: VpcEndpointSubnetIdList?
    public var dryRun: Boolean?
    public var policyDocument: String?
    public var privateDnsEnabled: Boolean?
    public var removeRouteTableIds: VpcEndpointRouteTableIdList?
    public var removeSecurityGroupIds: VpcEndpointSecurityGroupIdList?
    public var removeSubnetIds: VpcEndpointSubnetIdList?
    public var resetPolicy: Boolean?
    public var vpcEndpointId: VpcEndpointId

    public init(addRouteTableIds: VpcEndpointRouteTableIdList? = nil,
                addSecurityGroupIds: VpcEndpointSecurityGroupIdList? = nil,
                addSubnetIds: VpcEndpointSubnetIdList? = nil,
                dryRun: Boolean? = nil,
                policyDocument: String? = nil,
                privateDnsEnabled: Boolean? = nil,
                removeRouteTableIds: VpcEndpointRouteTableIdList? = nil,
                removeSecurityGroupIds: VpcEndpointSecurityGroupIdList? = nil,
                removeSubnetIds: VpcEndpointSubnetIdList? = nil,
                resetPolicy: Boolean? = nil,
                vpcEndpointId: VpcEndpointId) {
        self.addRouteTableIds = addRouteTableIds
        self.addSecurityGroupIds = addSecurityGroupIds
        self.addSubnetIds = addSubnetIds
        self.dryRun = dryRun
        self.policyDocument = policyDocument
        self.privateDnsEnabled = privateDnsEnabled
        self.removeRouteTableIds = removeRouteTableIds
        self.removeSecurityGroupIds = removeSecurityGroupIds
        self.removeSubnetIds = removeSubnetIds
        self.resetPolicy = resetPolicy
        self.vpcEndpointId = vpcEndpointId
    }

    enum CodingKeys: String, CodingKey {
        case addRouteTableIds = "AddRouteTableId"
        case addSecurityGroupIds = "AddSecurityGroupId"
        case addSubnetIds = "AddSubnetId"
        case dryRun = "DryRun"
        case policyDocument = "PolicyDocument"
        case privateDnsEnabled = "PrivateDnsEnabled"
        case removeRouteTableIds = "RemoveRouteTableId"
        case removeSecurityGroupIds = "RemoveSecurityGroupId"
        case removeSubnetIds = "RemoveSubnetId"
        case resetPolicy = "ResetPolicy"
        case vpcEndpointId = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServiceConfigurationRequest: Codable, Equatable {
    public var acceptanceRequired: Boolean?
    public var addGatewayLoadBalancerArns: ValueStringList?
    public var addNetworkLoadBalancerArns: ValueStringList?
    public var dryRun: Boolean?
    public var privateDnsName: String?
    public var removeGatewayLoadBalancerArns: ValueStringList?
    public var removeNetworkLoadBalancerArns: ValueStringList?
    public var removePrivateDnsName: Boolean?
    public var serviceId: VpcEndpointServiceId

    public init(acceptanceRequired: Boolean? = nil,
                addGatewayLoadBalancerArns: ValueStringList? = nil,
                addNetworkLoadBalancerArns: ValueStringList? = nil,
                dryRun: Boolean? = nil,
                privateDnsName: String? = nil,
                removeGatewayLoadBalancerArns: ValueStringList? = nil,
                removeNetworkLoadBalancerArns: ValueStringList? = nil,
                removePrivateDnsName: Boolean? = nil,
                serviceId: VpcEndpointServiceId) {
        self.acceptanceRequired = acceptanceRequired
        self.addGatewayLoadBalancerArns = addGatewayLoadBalancerArns
        self.addNetworkLoadBalancerArns = addNetworkLoadBalancerArns
        self.dryRun = dryRun
        self.privateDnsName = privateDnsName
        self.removeGatewayLoadBalancerArns = removeGatewayLoadBalancerArns
        self.removeNetworkLoadBalancerArns = removeNetworkLoadBalancerArns
        self.removePrivateDnsName = removePrivateDnsName
        self.serviceId = serviceId
    }

    enum CodingKeys: String, CodingKey {
        case acceptanceRequired = "AcceptanceRequired"
        case addGatewayLoadBalancerArns = "AddGatewayLoadBalancerArn"
        case addNetworkLoadBalancerArns = "AddNetworkLoadBalancerArn"
        case dryRun = "DryRun"
        case privateDnsName = "PrivateDnsName"
        case removeGatewayLoadBalancerArns = "RemoveGatewayLoadBalancerArn"
        case removeNetworkLoadBalancerArns = "RemoveNetworkLoadBalancerArn"
        case removePrivateDnsName = "RemovePrivateDnsName"
        case serviceId = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServiceConfigurationResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServicePermissionsRequest: Codable, Equatable {
    public var addAllowedPrincipals: ValueStringList?
    public var dryRun: Boolean?
    public var removeAllowedPrincipals: ValueStringList?
    public var serviceId: VpcEndpointServiceId

    public init(addAllowedPrincipals: ValueStringList? = nil,
                dryRun: Boolean? = nil,
                removeAllowedPrincipals: ValueStringList? = nil,
                serviceId: VpcEndpointServiceId) {
        self.addAllowedPrincipals = addAllowedPrincipals
        self.dryRun = dryRun
        self.removeAllowedPrincipals = removeAllowedPrincipals
        self.serviceId = serviceId
    }

    enum CodingKeys: String, CodingKey {
        case addAllowedPrincipals = "AddAllowedPrincipals"
        case dryRun = "DryRun"
        case removeAllowedPrincipals = "RemoveAllowedPrincipals"
        case serviceId = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServicePermissionsResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcPeeringConnectionOptionsRequest: Codable, Equatable {
    public var accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest?
    public var dryRun: Boolean?
    public var requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId

    public init(accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil,
                dryRun: Boolean? = nil,
                requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId) {
        self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
        self.dryRun = dryRun
        self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case accepterPeeringConnectionOptions = "AccepterPeeringConnectionOptions"
        case dryRun = "DryRun"
        case requesterPeeringConnectionOptions = "RequesterPeeringConnectionOptions"
        case vpcPeeringConnectionId = "VpcPeeringConnectionId"
    }

    public func validate() throws {
        try accepterPeeringConnectionOptions?.validate()
        try requesterPeeringConnectionOptions?.validate()
    }
}

public struct ModifyVpcPeeringConnectionOptionsResult: Codable, Equatable {
    public var accepterPeeringConnectionOptions: PeeringConnectionOptions?
    public var requesterPeeringConnectionOptions: PeeringConnectionOptions?

    public init(accepterPeeringConnectionOptions: PeeringConnectionOptions? = nil,
                requesterPeeringConnectionOptions: PeeringConnectionOptions? = nil) {
        self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
        self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
    }

    enum CodingKeys: String, CodingKey {
        case accepterPeeringConnectionOptions
        case requesterPeeringConnectionOptions
    }

    public func validate() throws {
        try accepterPeeringConnectionOptions?.validate()
        try requesterPeeringConnectionOptions?.validate()
    }
}

public struct ModifyVpcTenancyRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceTenancy: VpcTenancy
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                instanceTenancy: VpcTenancy,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.instanceTenancy = instanceTenancy
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceTenancy = "InstanceTenancy"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcTenancyResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpnConnectionOptionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localIpv4NetworkCidr: String?
    public var localIpv6NetworkCidr: String?
    public var remoteIpv4NetworkCidr: String?
    public var remoteIpv6NetworkCidr: String?
    public var vpnConnectionId: VpnConnectionId

    public init(dryRun: Boolean? = nil,
                localIpv4NetworkCidr: String? = nil,
                localIpv6NetworkCidr: String? = nil,
                remoteIpv4NetworkCidr: String? = nil,
                remoteIpv6NetworkCidr: String? = nil,
                vpnConnectionId: VpnConnectionId) {
        self.dryRun = dryRun
        self.localIpv4NetworkCidr = localIpv4NetworkCidr
        self.localIpv6NetworkCidr = localIpv6NetworkCidr
        self.remoteIpv4NetworkCidr = remoteIpv4NetworkCidr
        self.remoteIpv6NetworkCidr = remoteIpv6NetworkCidr
        self.vpnConnectionId = vpnConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localIpv4NetworkCidr = "LocalIpv4NetworkCidr"
        case localIpv6NetworkCidr = "LocalIpv6NetworkCidr"
        case remoteIpv4NetworkCidr = "RemoteIpv4NetworkCidr"
        case remoteIpv6NetworkCidr = "RemoteIpv6NetworkCidr"
        case vpnConnectionId = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpnConnectionOptionsResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct ModifyVpnConnectionRequest: Codable, Equatable {
    public var customerGatewayId: CustomerGatewayId?
    public var dryRun: Boolean?
    public var transitGatewayId: TransitGatewayId?
    public var vpnConnectionId: VpnConnectionId
    public var vpnGatewayId: VpnGatewayId?

    public init(customerGatewayId: CustomerGatewayId? = nil,
                dryRun: Boolean? = nil,
                transitGatewayId: TransitGatewayId? = nil,
                vpnConnectionId: VpnConnectionId,
                vpnGatewayId: VpnGatewayId? = nil) {
        self.customerGatewayId = customerGatewayId
        self.dryRun = dryRun
        self.transitGatewayId = transitGatewayId
        self.vpnConnectionId = vpnConnectionId
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case customerGatewayId = "CustomerGatewayId"
        case dryRun = "DryRun"
        case transitGatewayId = "TransitGatewayId"
        case vpnConnectionId = "VpnConnectionId"
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpnConnectionResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct ModifyVpnTunnelCertificateRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpnConnectionId: VpnConnectionId
    public var vpnTunnelOutsideIpAddress: String

    public init(dryRun: Boolean? = nil,
                vpnConnectionId: VpnConnectionId,
                vpnTunnelOutsideIpAddress: String) {
        self.dryRun = dryRun
        self.vpnConnectionId = vpnConnectionId
        self.vpnTunnelOutsideIpAddress = vpnTunnelOutsideIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case vpnConnectionId = "VpnConnectionId"
        case vpnTunnelOutsideIpAddress = "VpnTunnelOutsideIpAddress"
    }

    public func validate() throws {
    }
}

public struct ModifyVpnTunnelCertificateResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct ModifyVpnTunnelOptionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tunnelOptions: ModifyVpnTunnelOptionsSpecification
    public var vpnConnectionId: VpnConnectionId
    public var vpnTunnelOutsideIpAddress: String

    public init(dryRun: Boolean? = nil,
                tunnelOptions: ModifyVpnTunnelOptionsSpecification,
                vpnConnectionId: VpnConnectionId,
                vpnTunnelOutsideIpAddress: String) {
        self.dryRun = dryRun
        self.tunnelOptions = tunnelOptions
        self.vpnConnectionId = vpnConnectionId
        self.vpnTunnelOutsideIpAddress = vpnTunnelOutsideIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case tunnelOptions = "TunnelOptions"
        case vpnConnectionId = "VpnConnectionId"
        case vpnTunnelOutsideIpAddress = "VpnTunnelOutsideIpAddress"
    }

    public func validate() throws {
        try tunnelOptions.validate()
    }
}

public struct ModifyVpnTunnelOptionsResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct ModifyVpnTunnelOptionsSpecification: Codable, Equatable {
    public var dPDTimeoutAction: String?
    public var dPDTimeoutSeconds: Integer?
    public var iKEVersions: IKEVersionsRequestList?
    public var phase1DHGroupNumbers: Phase1DHGroupNumbersRequestList?
    public var phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsRequestList?
    public var phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsRequestList?
    public var phase1LifetimeSeconds: Integer?
    public var phase2DHGroupNumbers: Phase2DHGroupNumbersRequestList?
    public var phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsRequestList?
    public var phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsRequestList?
    public var phase2LifetimeSeconds: Integer?
    public var preSharedKey: String?
    public var rekeyFuzzPercentage: Integer?
    public var rekeyMarginTimeSeconds: Integer?
    public var replayWindowSize: Integer?
    public var startupAction: String?
    public var tunnelInsideCidr: String?
    public var tunnelInsideIpv6Cidr: String?

    public init(dPDTimeoutAction: String? = nil,
                dPDTimeoutSeconds: Integer? = nil,
                iKEVersions: IKEVersionsRequestList? = nil,
                phase1DHGroupNumbers: Phase1DHGroupNumbersRequestList? = nil,
                phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsRequestList? = nil,
                phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsRequestList? = nil,
                phase1LifetimeSeconds: Integer? = nil,
                phase2DHGroupNumbers: Phase2DHGroupNumbersRequestList? = nil,
                phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsRequestList? = nil,
                phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsRequestList? = nil,
                phase2LifetimeSeconds: Integer? = nil,
                preSharedKey: String? = nil,
                rekeyFuzzPercentage: Integer? = nil,
                rekeyMarginTimeSeconds: Integer? = nil,
                replayWindowSize: Integer? = nil,
                startupAction: String? = nil,
                tunnelInsideCidr: String? = nil,
                tunnelInsideIpv6Cidr: String? = nil) {
        self.dPDTimeoutAction = dPDTimeoutAction
        self.dPDTimeoutSeconds = dPDTimeoutSeconds
        self.iKEVersions = iKEVersions
        self.phase1DHGroupNumbers = phase1DHGroupNumbers
        self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
        self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
        self.phase1LifetimeSeconds = phase1LifetimeSeconds
        self.phase2DHGroupNumbers = phase2DHGroupNumbers
        self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
        self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
        self.phase2LifetimeSeconds = phase2LifetimeSeconds
        self.preSharedKey = preSharedKey
        self.rekeyFuzzPercentage = rekeyFuzzPercentage
        self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
        self.replayWindowSize = replayWindowSize
        self.startupAction = startupAction
        self.tunnelInsideCidr = tunnelInsideCidr
        self.tunnelInsideIpv6Cidr = tunnelInsideIpv6Cidr
    }

    enum CodingKeys: String, CodingKey {
        case dPDTimeoutAction = "DPDTimeoutAction"
        case dPDTimeoutSeconds = "DPDTimeoutSeconds"
        case iKEVersions = "IKEVersion"
        case phase1DHGroupNumbers = "Phase1DHGroupNumber"
        case phase1EncryptionAlgorithms = "Phase1EncryptionAlgorithm"
        case phase1IntegrityAlgorithms = "Phase1IntegrityAlgorithm"
        case phase1LifetimeSeconds = "Phase1LifetimeSeconds"
        case phase2DHGroupNumbers = "Phase2DHGroupNumber"
        case phase2EncryptionAlgorithms = "Phase2EncryptionAlgorithm"
        case phase2IntegrityAlgorithms = "Phase2IntegrityAlgorithm"
        case phase2LifetimeSeconds = "Phase2LifetimeSeconds"
        case preSharedKey = "PreSharedKey"
        case rekeyFuzzPercentage = "RekeyFuzzPercentage"
        case rekeyMarginTimeSeconds = "RekeyMarginTimeSeconds"
        case replayWindowSize = "ReplayWindowSize"
        case startupAction = "StartupAction"
        case tunnelInsideCidr = "TunnelInsideCidr"
        case tunnelInsideIpv6Cidr = "TunnelInsideIpv6Cidr"
    }

    public func validate() throws {
    }
}

public struct MonitorInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct MonitorInstancesResult: Codable, Equatable {
    public var instanceMonitorings: InstanceMonitoringList?

    public init(instanceMonitorings: InstanceMonitoringList? = nil) {
        self.instanceMonitorings = instanceMonitorings
    }

    enum CodingKeys: String, CodingKey {
        case instanceMonitorings = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct Monitoring: Codable, Equatable {
    public var state: MonitoringState?

    public init(state: MonitoringState? = nil) {
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case state
    }

    public func validate() throws {
    }
}

public struct MoveAddressToVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var publicIp: String

    public init(dryRun: Boolean? = nil,
                publicIp: String) {
        self.dryRun = dryRun
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case publicIp
    }

    public func validate() throws {
    }
}

public struct MoveAddressToVpcResult: Codable, Equatable {
    public var allocationId: String?
    public var status: Status?

    public init(allocationId: String? = nil,
                status: Status? = nil) {
        self.allocationId = allocationId
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case status
    }

    public func validate() throws {
    }
}

public struct MovingAddressStatus: Codable, Equatable {
    public var moveStatus: MoveStatus?
    public var publicIp: String?

    public init(moveStatus: MoveStatus? = nil,
                publicIp: String? = nil) {
        self.moveStatus = moveStatus
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case moveStatus
        case publicIp
    }

    public func validate() throws {
    }
}

public struct NatGateway: Codable, Equatable {
    public var createTime: DateTime?
    public var deleteTime: DateTime?
    public var failureCode: String?
    public var failureMessage: String?
    public var natGatewayAddresses: NatGatewayAddressList?
    public var natGatewayId: String?
    public var provisionedBandwidth: ProvisionedBandwidth?
    public var state: NatGatewayState?
    public var subnetId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(createTime: DateTime? = nil,
                deleteTime: DateTime? = nil,
                failureCode: String? = nil,
                failureMessage: String? = nil,
                natGatewayAddresses: NatGatewayAddressList? = nil,
                natGatewayId: String? = nil,
                provisionedBandwidth: ProvisionedBandwidth? = nil,
                state: NatGatewayState? = nil,
                subnetId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.createTime = createTime
        self.deleteTime = deleteTime
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.natGatewayAddresses = natGatewayAddresses
        self.natGatewayId = natGatewayId
        self.provisionedBandwidth = provisionedBandwidth
        self.state = state
        self.subnetId = subnetId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case createTime
        case deleteTime
        case failureCode
        case failureMessage
        case natGatewayAddresses = "natGatewayAddressSet"
        case natGatewayId
        case provisionedBandwidth
        case state
        case subnetId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
        try provisionedBandwidth?.validate()
    }
}

public struct NatGatewayAddress: Codable, Equatable {
    public var allocationId: String?
    public var networkInterfaceId: String?
    public var privateIp: String?
    public var publicIp: String?

    public init(allocationId: String? = nil,
                networkInterfaceId: String? = nil,
                privateIp: String? = nil,
                publicIp: String? = nil) {
        self.allocationId = allocationId
        self.networkInterfaceId = networkInterfaceId
        self.privateIp = privateIp
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case networkInterfaceId
        case privateIp
        case publicIp
    }

    public func validate() throws {
    }
}

public struct NetworkAcl: Codable, Equatable {
    public var associations: NetworkAclAssociationList?
    public var entries: NetworkAclEntryList?
    public var isDefault: Boolean?
    public var networkAclId: String?
    public var ownerId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(associations: NetworkAclAssociationList? = nil,
                entries: NetworkAclEntryList? = nil,
                isDefault: Boolean? = nil,
                networkAclId: String? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.associations = associations
        self.entries = entries
        self.isDefault = isDefault
        self.networkAclId = networkAclId
        self.ownerId = ownerId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case associations = "associationSet"
        case entries = "entrySet"
        case isDefault = "default"
        case networkAclId
        case ownerId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct NetworkAclAssociation: Codable, Equatable {
    public var networkAclAssociationId: String?
    public var networkAclId: String?
    public var subnetId: String?

    public init(networkAclAssociationId: String? = nil,
                networkAclId: String? = nil,
                subnetId: String? = nil) {
        self.networkAclAssociationId = networkAclAssociationId
        self.networkAclId = networkAclId
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case networkAclAssociationId
        case networkAclId
        case subnetId
    }

    public func validate() throws {
    }
}

public struct NetworkAclEntry: Codable, Equatable {
    public var cidrBlock: String?
    public var egress: Boolean?
    public var icmpTypeCode: IcmpTypeCode?
    public var ipv6CidrBlock: String?
    public var portRange: PortRange?
    public var `protocol`: String?
    public var ruleAction: RuleAction?
    public var ruleNumber: Integer?

    public init(cidrBlock: String? = nil,
                egress: Boolean? = nil,
                icmpTypeCode: IcmpTypeCode? = nil,
                ipv6CidrBlock: String? = nil,
                portRange: PortRange? = nil,
                `protocol`: String? = nil,
                ruleAction: RuleAction? = nil,
                ruleNumber: Integer? = nil) {
        self.cidrBlock = cidrBlock
        self.egress = egress
        self.icmpTypeCode = icmpTypeCode
        self.ipv6CidrBlock = ipv6CidrBlock
        self.portRange = portRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case egress
        case icmpTypeCode
        case ipv6CidrBlock
        case portRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
    }

    public func validate() throws {
        try icmpTypeCode?.validate()
        try portRange?.validate()
    }
}

public struct NetworkCardInfo: Codable, Equatable {
    public var maximumNetworkInterfaces: MaxNetworkInterfaces?
    public var networkCardIndex: NetworkCardIndex?
    public var networkPerformance: NetworkPerformance?

    public init(maximumNetworkInterfaces: MaxNetworkInterfaces? = nil,
                networkCardIndex: NetworkCardIndex? = nil,
                networkPerformance: NetworkPerformance? = nil) {
        self.maximumNetworkInterfaces = maximumNetworkInterfaces
        self.networkCardIndex = networkCardIndex
        self.networkPerformance = networkPerformance
    }

    enum CodingKeys: String, CodingKey {
        case maximumNetworkInterfaces
        case networkCardIndex
        case networkPerformance
    }

    public func validate() throws {
    }
}

public struct NetworkInfo: Codable, Equatable {
    public var defaultNetworkCardIndex: DefaultNetworkCardIndex?
    public var efaSupported: EfaSupportedFlag?
    public var enaSupport: EnaSupport?
    public var ipv4AddressesPerInterface: MaxIpv4AddrPerInterface?
    public var ipv6AddressesPerInterface: MaxIpv6AddrPerInterface?
    public var ipv6Supported: Ipv6Flag?
    public var maximumNetworkCards: MaximumNetworkCards?
    public var maximumNetworkInterfaces: MaxNetworkInterfaces?
    public var networkCards: NetworkCardInfoList?
    public var networkPerformance: NetworkPerformance?

    public init(defaultNetworkCardIndex: DefaultNetworkCardIndex? = nil,
                efaSupported: EfaSupportedFlag? = nil,
                enaSupport: EnaSupport? = nil,
                ipv4AddressesPerInterface: MaxIpv4AddrPerInterface? = nil,
                ipv6AddressesPerInterface: MaxIpv6AddrPerInterface? = nil,
                ipv6Supported: Ipv6Flag? = nil,
                maximumNetworkCards: MaximumNetworkCards? = nil,
                maximumNetworkInterfaces: MaxNetworkInterfaces? = nil,
                networkCards: NetworkCardInfoList? = nil,
                networkPerformance: NetworkPerformance? = nil) {
        self.defaultNetworkCardIndex = defaultNetworkCardIndex
        self.efaSupported = efaSupported
        self.enaSupport = enaSupport
        self.ipv4AddressesPerInterface = ipv4AddressesPerInterface
        self.ipv6AddressesPerInterface = ipv6AddressesPerInterface
        self.ipv6Supported = ipv6Supported
        self.maximumNetworkCards = maximumNetworkCards
        self.maximumNetworkInterfaces = maximumNetworkInterfaces
        self.networkCards = networkCards
        self.networkPerformance = networkPerformance
    }

    enum CodingKeys: String, CodingKey {
        case defaultNetworkCardIndex
        case efaSupported
        case enaSupport
        case ipv4AddressesPerInterface
        case ipv6AddressesPerInterface
        case ipv6Supported
        case maximumNetworkCards
        case maximumNetworkInterfaces
        case networkCards
        case networkPerformance
    }

    public func validate() throws {
    }
}

public struct NetworkInsightsAnalysis: Codable, Equatable {
    public var alternatePathHints: AlternatePathHintList?
    public var explanations: ExplanationList?
    public var filterInArns: ArnList?
    public var forwardPathComponents: PathComponentList?
    public var networkInsightsAnalysisArn: ResourceArn?
    public var networkInsightsAnalysisId: NetworkInsightsAnalysisId?
    public var networkInsightsPathId: NetworkInsightsPathId?
    public var networkPathFound: Boolean?
    public var returnPathComponents: PathComponentList?
    public var startDate: MillisecondDateTime?
    public var status: AnalysisStatus?
    public var statusMessage: String?
    public var tags: TagList?

    public init(alternatePathHints: AlternatePathHintList? = nil,
                explanations: ExplanationList? = nil,
                filterInArns: ArnList? = nil,
                forwardPathComponents: PathComponentList? = nil,
                networkInsightsAnalysisArn: ResourceArn? = nil,
                networkInsightsAnalysisId: NetworkInsightsAnalysisId? = nil,
                networkInsightsPathId: NetworkInsightsPathId? = nil,
                networkPathFound: Boolean? = nil,
                returnPathComponents: PathComponentList? = nil,
                startDate: MillisecondDateTime? = nil,
                status: AnalysisStatus? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.alternatePathHints = alternatePathHints
        self.explanations = explanations
        self.filterInArns = filterInArns
        self.forwardPathComponents = forwardPathComponents
        self.networkInsightsAnalysisArn = networkInsightsAnalysisArn
        self.networkInsightsAnalysisId = networkInsightsAnalysisId
        self.networkInsightsPathId = networkInsightsPathId
        self.networkPathFound = networkPathFound
        self.returnPathComponents = returnPathComponents
        self.startDate = startDate
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case alternatePathHints = "alternatePathHintSet"
        case explanations = "explanationSet"
        case filterInArns = "filterInArnSet"
        case forwardPathComponents = "forwardPathComponentSet"
        case networkInsightsAnalysisArn
        case networkInsightsAnalysisId
        case networkInsightsPathId
        case networkPathFound
        case returnPathComponents = "returnPathComponentSet"
        case startDate
        case status
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try networkInsightsAnalysisArn?.validateAsResourceArn()
    }
}

public struct NetworkInsightsPath: Codable, Equatable {
    public var createdDate: MillisecondDateTime?
    public var destination: String?
    public var destinationIp: IpAddress?
    public var destinationPort: Integer?
    public var networkInsightsPathArn: ResourceArn?
    public var networkInsightsPathId: NetworkInsightsPathId?
    public var `protocol`: Protocol?
    public var source: String?
    public var sourceIp: IpAddress?
    public var tags: TagList?

    public init(createdDate: MillisecondDateTime? = nil,
                destination: String? = nil,
                destinationIp: IpAddress? = nil,
                destinationPort: Integer? = nil,
                networkInsightsPathArn: ResourceArn? = nil,
                networkInsightsPathId: NetworkInsightsPathId? = nil,
                `protocol`: Protocol? = nil,
                source: String? = nil,
                sourceIp: IpAddress? = nil,
                tags: TagList? = nil) {
        self.createdDate = createdDate
        self.destination = destination
        self.destinationIp = destinationIp
        self.destinationPort = destinationPort
        self.networkInsightsPathArn = networkInsightsPathArn
        self.networkInsightsPathId = networkInsightsPathId
        self.`protocol` = `protocol`
        self.source = source
        self.sourceIp = sourceIp
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case createdDate
        case destination
        case destinationIp
        case destinationPort
        case networkInsightsPathArn
        case networkInsightsPathId
        case `protocol` = "protocol"
        case source
        case sourceIp
        case tags = "tagSet"
    }

    public func validate() throws {
        try destinationIp?.validateAsIpAddress()
        try networkInsightsPathArn?.validateAsResourceArn()
        try sourceIp?.validateAsIpAddress()
    }
}

public struct NetworkInterface: Codable, Equatable {
    public var association: NetworkInterfaceAssociation?
    public var attachment: NetworkInterfaceAttachment?
    public var availabilityZone: String?
    public var description: String?
    public var groups: GroupIdentifierList?
    public var interfaceType: NetworkInterfaceType?
    public var ipv6Addresses: NetworkInterfaceIpv6AddressesList?
    public var macAddress: String?
    public var networkInterfaceId: String?
    public var outpostArn: String?
    public var ownerId: String?
    public var privateDnsName: String?
    public var privateIpAddress: String?
    public var privateIpAddresses: NetworkInterfacePrivateIpAddressList?
    public var requesterId: String?
    public var requesterManaged: Boolean?
    public var sourceDestCheck: Boolean?
    public var status: NetworkInterfaceStatus?
    public var subnetId: String?
    public var tagSet: TagList?
    public var vpcId: String?

    public init(association: NetworkInterfaceAssociation? = nil,
                attachment: NetworkInterfaceAttachment? = nil,
                availabilityZone: String? = nil,
                description: String? = nil,
                groups: GroupIdentifierList? = nil,
                interfaceType: NetworkInterfaceType? = nil,
                ipv6Addresses: NetworkInterfaceIpv6AddressesList? = nil,
                macAddress: String? = nil,
                networkInterfaceId: String? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                privateDnsName: String? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: NetworkInterfacePrivateIpAddressList? = nil,
                requesterId: String? = nil,
                requesterManaged: Boolean? = nil,
                sourceDestCheck: Boolean? = nil,
                status: NetworkInterfaceStatus? = nil,
                subnetId: String? = nil,
                tagSet: TagList? = nil,
                vpcId: String? = nil) {
        self.association = association
        self.attachment = attachment
        self.availabilityZone = availabilityZone
        self.description = description
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv6Addresses = ipv6Addresses
        self.macAddress = macAddress
        self.networkInterfaceId = networkInterfaceId
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.requesterId = requesterId
        self.requesterManaged = requesterManaged
        self.sourceDestCheck = sourceDestCheck
        self.status = status
        self.subnetId = subnetId
        self.tagSet = tagSet
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case association
        case attachment
        case availabilityZone
        case description
        case groups = "groupSet"
        case interfaceType
        case ipv6Addresses = "ipv6AddressesSet"
        case macAddress
        case networkInterfaceId
        case outpostArn
        case ownerId
        case privateDnsName
        case privateIpAddress
        case privateIpAddresses = "privateIpAddressesSet"
        case requesterId
        case requesterManaged
        case sourceDestCheck
        case status
        case subnetId
        case tagSet
        case vpcId
    }

    public func validate() throws {
        try association?.validate()
        try attachment?.validate()
    }
}

public struct NetworkInterfaceAssociation: Codable, Equatable {
    public var allocationId: String?
    public var associationId: String?
    public var carrierIp: String?
    public var customerOwnedIp: String?
    public var ipOwnerId: String?
    public var publicDnsName: String?
    public var publicIp: String?

    public init(allocationId: String? = nil,
                associationId: String? = nil,
                carrierIp: String? = nil,
                customerOwnedIp: String? = nil,
                ipOwnerId: String? = nil,
                publicDnsName: String? = nil,
                publicIp: String? = nil) {
        self.allocationId = allocationId
        self.associationId = associationId
        self.carrierIp = carrierIp
        self.customerOwnedIp = customerOwnedIp
        self.ipOwnerId = ipOwnerId
        self.publicDnsName = publicDnsName
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case associationId
        case carrierIp
        case customerOwnedIp
        case ipOwnerId
        case publicDnsName
        case publicIp
    }

    public func validate() throws {
    }
}

public struct NetworkInterfaceAttachment: Codable, Equatable {
    public var attachTime: DateTime?
    public var attachmentId: String?
    public var deleteOnTermination: Boolean?
    public var deviceIndex: Integer?
    public var instanceId: String?
    public var instanceOwnerId: String?
    public var networkCardIndex: Integer?
    public var status: AttachmentStatus?

    public init(attachTime: DateTime? = nil,
                attachmentId: String? = nil,
                deleteOnTermination: Boolean? = nil,
                deviceIndex: Integer? = nil,
                instanceId: String? = nil,
                instanceOwnerId: String? = nil,
                networkCardIndex: Integer? = nil,
                status: AttachmentStatus? = nil) {
        self.attachTime = attachTime
        self.attachmentId = attachmentId
        self.deleteOnTermination = deleteOnTermination
        self.deviceIndex = deviceIndex
        self.instanceId = instanceId
        self.instanceOwnerId = instanceOwnerId
        self.networkCardIndex = networkCardIndex
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case attachTime
        case attachmentId
        case deleteOnTermination
        case deviceIndex
        case instanceId
        case instanceOwnerId
        case networkCardIndex
        case status
    }

    public func validate() throws {
    }
}

public struct NetworkInterfaceAttachmentChanges: Codable, Equatable {
    public var attachmentId: NetworkInterfaceAttachmentId?
    public var deleteOnTermination: Boolean?

    public init(attachmentId: NetworkInterfaceAttachmentId? = nil,
                deleteOnTermination: Boolean? = nil) {
        self.attachmentId = attachmentId
        self.deleteOnTermination = deleteOnTermination
    }

    enum CodingKeys: String, CodingKey {
        case attachmentId
        case deleteOnTermination
    }

    public func validate() throws {
    }
}

public struct NetworkInterfaceIpv6Address: Codable, Equatable {
    public var ipv6Address: String?

    public init(ipv6Address: String? = nil) {
        self.ipv6Address = ipv6Address
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Address
    }

    public func validate() throws {
    }
}

public struct NetworkInterfacePermission: Codable, Equatable {
    public var awsAccountId: String?
    public var awsService: String?
    public var networkInterfaceId: String?
    public var networkInterfacePermissionId: String?
    public var permission: InterfacePermissionType?
    public var permissionState: NetworkInterfacePermissionState?

    public init(awsAccountId: String? = nil,
                awsService: String? = nil,
                networkInterfaceId: String? = nil,
                networkInterfacePermissionId: String? = nil,
                permission: InterfacePermissionType? = nil,
                permissionState: NetworkInterfacePermissionState? = nil) {
        self.awsAccountId = awsAccountId
        self.awsService = awsService
        self.networkInterfaceId = networkInterfaceId
        self.networkInterfacePermissionId = networkInterfacePermissionId
        self.permission = permission
        self.permissionState = permissionState
    }

    enum CodingKeys: String, CodingKey {
        case awsAccountId
        case awsService
        case networkInterfaceId
        case networkInterfacePermissionId
        case permission
        case permissionState
    }

    public func validate() throws {
        try permissionState?.validate()
    }
}

public struct NetworkInterfacePermissionState: Codable, Equatable {
    public var state: NetworkInterfacePermissionStateCode?
    public var statusMessage: String?

    public init(state: NetworkInterfacePermissionStateCode? = nil,
                statusMessage: String? = nil) {
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct NetworkInterfacePrivateIpAddress: Codable, Equatable {
    public var association: NetworkInterfaceAssociation?
    public var primary: Boolean?
    public var privateDnsName: String?
    public var privateIpAddress: String?

    public init(association: NetworkInterfaceAssociation? = nil,
                primary: Boolean? = nil,
                privateDnsName: String? = nil,
                privateIpAddress: String? = nil) {
        self.association = association
        self.primary = primary
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case association
        case primary
        case privateDnsName
        case privateIpAddress
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct NewDhcpConfiguration: Codable, Equatable {
    public var key: String?
    public var values: ValueStringList?

    public init(key: String? = nil,
                values: ValueStringList? = nil) {
        self.key = key
        self.values = values
    }

    enum CodingKeys: String, CodingKey {
        case key
        case values = "Value"
    }

    public func validate() throws {
    }
}

public struct OnDemandOptions: Codable, Equatable {
    public var allocationStrategy: FleetOnDemandAllocationStrategy?
    public var capacityReservationOptions: CapacityReservationOptions?
    public var maxTotalPrice: String?
    public var minTargetCapacity: Integer?
    public var singleAvailabilityZone: Boolean?
    public var singleInstanceType: Boolean?

    public init(allocationStrategy: FleetOnDemandAllocationStrategy? = nil,
                capacityReservationOptions: CapacityReservationOptions? = nil,
                maxTotalPrice: String? = nil,
                minTargetCapacity: Integer? = nil,
                singleAvailabilityZone: Boolean? = nil,
                singleInstanceType: Boolean? = nil) {
        self.allocationStrategy = allocationStrategy
        self.capacityReservationOptions = capacityReservationOptions
        self.maxTotalPrice = maxTotalPrice
        self.minTargetCapacity = minTargetCapacity
        self.singleAvailabilityZone = singleAvailabilityZone
        self.singleInstanceType = singleInstanceType
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy
        case capacityReservationOptions
        case maxTotalPrice
        case minTargetCapacity
        case singleAvailabilityZone
        case singleInstanceType
    }

    public func validate() throws {
        try capacityReservationOptions?.validate()
    }
}

public struct OnDemandOptionsRequest: Codable, Equatable {
    public var allocationStrategy: FleetOnDemandAllocationStrategy?
    public var capacityReservationOptions: CapacityReservationOptionsRequest?
    public var maxTotalPrice: String?
    public var minTargetCapacity: Integer?
    public var singleAvailabilityZone: Boolean?
    public var singleInstanceType: Boolean?

    public init(allocationStrategy: FleetOnDemandAllocationStrategy? = nil,
                capacityReservationOptions: CapacityReservationOptionsRequest? = nil,
                maxTotalPrice: String? = nil,
                minTargetCapacity: Integer? = nil,
                singleAvailabilityZone: Boolean? = nil,
                singleInstanceType: Boolean? = nil) {
        self.allocationStrategy = allocationStrategy
        self.capacityReservationOptions = capacityReservationOptions
        self.maxTotalPrice = maxTotalPrice
        self.minTargetCapacity = minTargetCapacity
        self.singleAvailabilityZone = singleAvailabilityZone
        self.singleInstanceType = singleInstanceType
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy = "AllocationStrategy"
        case capacityReservationOptions = "CapacityReservationOptions"
        case maxTotalPrice = "MaxTotalPrice"
        case minTargetCapacity = "MinTargetCapacity"
        case singleAvailabilityZone = "SingleAvailabilityZone"
        case singleInstanceType = "SingleInstanceType"
    }

    public func validate() throws {
        try capacityReservationOptions?.validate()
    }
}

public struct PathComponent: Codable, Equatable {
    public var aclRule: AnalysisAclRule?
    public var component: AnalysisComponent?
    public var destinationVpc: AnalysisComponent?
    public var inboundHeader: AnalysisPacketHeader?
    public var outboundHeader: AnalysisPacketHeader?
    public var routeTableRoute: AnalysisRouteTableRoute?
    public var securityGroupRule: AnalysisSecurityGroupRule?
    public var sequenceNumber: Integer?
    public var sourceVpc: AnalysisComponent?
    public var subnet: AnalysisComponent?
    public var vpc: AnalysisComponent?

    public init(aclRule: AnalysisAclRule? = nil,
                component: AnalysisComponent? = nil,
                destinationVpc: AnalysisComponent? = nil,
                inboundHeader: AnalysisPacketHeader? = nil,
                outboundHeader: AnalysisPacketHeader? = nil,
                routeTableRoute: AnalysisRouteTableRoute? = nil,
                securityGroupRule: AnalysisSecurityGroupRule? = nil,
                sequenceNumber: Integer? = nil,
                sourceVpc: AnalysisComponent? = nil,
                subnet: AnalysisComponent? = nil,
                vpc: AnalysisComponent? = nil) {
        self.aclRule = aclRule
        self.component = component
        self.destinationVpc = destinationVpc
        self.inboundHeader = inboundHeader
        self.outboundHeader = outboundHeader
        self.routeTableRoute = routeTableRoute
        self.securityGroupRule = securityGroupRule
        self.sequenceNumber = sequenceNumber
        self.sourceVpc = sourceVpc
        self.subnet = subnet
        self.vpc = vpc
    }

    enum CodingKeys: String, CodingKey {
        case aclRule
        case component
        case destinationVpc
        case inboundHeader
        case outboundHeader
        case routeTableRoute
        case securityGroupRule
        case sequenceNumber
        case sourceVpc
        case subnet
        case vpc
    }

    public func validate() throws {
        try aclRule?.validate()
        try component?.validate()
        try destinationVpc?.validate()
        try inboundHeader?.validate()
        try outboundHeader?.validate()
        try routeTableRoute?.validate()
        try securityGroupRule?.validate()
        try sourceVpc?.validate()
        try subnet?.validate()
        try vpc?.validate()
    }
}

public struct PciId: Codable, Equatable {
    public var deviceId: String?
    public var subsystemId: String?
    public var subsystemVendorId: String?
    public var vendorId: String?

    public init(deviceId: String? = nil,
                subsystemId: String? = nil,
                subsystemVendorId: String? = nil,
                vendorId: String? = nil) {
        self.deviceId = deviceId
        self.subsystemId = subsystemId
        self.subsystemVendorId = subsystemVendorId
        self.vendorId = vendorId
    }

    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case subsystemId = "SubsystemId"
        case subsystemVendorId = "SubsystemVendorId"
        case vendorId = "VendorId"
    }

    public func validate() throws {
    }
}

public struct PeeringAttachmentStatus: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct PeeringConnectionOptions: Codable, Equatable {
    public var allowDnsResolutionFromRemoteVpc: Boolean?
    public var allowEgressFromLocalClassicLinkToRemoteVpc: Boolean?
    public var allowEgressFromLocalVpcToRemoteClassicLink: Boolean?

    public init(allowDnsResolutionFromRemoteVpc: Boolean? = nil,
                allowEgressFromLocalClassicLinkToRemoteVpc: Boolean? = nil,
                allowEgressFromLocalVpcToRemoteClassicLink: Boolean? = nil) {
        self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
        self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
    }

    enum CodingKeys: String, CodingKey {
        case allowDnsResolutionFromRemoteVpc
        case allowEgressFromLocalClassicLinkToRemoteVpc
        case allowEgressFromLocalVpcToRemoteClassicLink
    }

    public func validate() throws {
    }
}

public struct PeeringConnectionOptionsRequest: Codable, Equatable {
    public var allowDnsResolutionFromRemoteVpc: Boolean?
    public var allowEgressFromLocalClassicLinkToRemoteVpc: Boolean?
    public var allowEgressFromLocalVpcToRemoteClassicLink: Boolean?

    public init(allowDnsResolutionFromRemoteVpc: Boolean? = nil,
                allowEgressFromLocalClassicLinkToRemoteVpc: Boolean? = nil,
                allowEgressFromLocalVpcToRemoteClassicLink: Boolean? = nil) {
        self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
        self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
    }

    enum CodingKeys: String, CodingKey {
        case allowDnsResolutionFromRemoteVpc = "AllowDnsResolutionFromRemoteVpc"
        case allowEgressFromLocalClassicLinkToRemoteVpc = "AllowEgressFromLocalClassicLinkToRemoteVpc"
        case allowEgressFromLocalVpcToRemoteClassicLink = "AllowEgressFromLocalVpcToRemoteClassicLink"
    }

    public func validate() throws {
    }
}

public struct PeeringTgwInfo: Codable, Equatable {
    public var ownerId: String?
    public var region: String?
    public var transitGatewayId: String?

    public init(ownerId: String? = nil,
                region: String? = nil,
                transitGatewayId: String? = nil) {
        self.ownerId = ownerId
        self.region = region
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case ownerId
        case region
        case transitGatewayId
    }

    public func validate() throws {
    }
}

public struct Phase1DHGroupNumbersListValue: Codable, Equatable {
    public var value: Integer?

    public init(value: Integer? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase1DHGroupNumbersRequestListValue: Codable, Equatable {
    public var value: Integer?

    public init(value: Integer? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase1EncryptionAlgorithmsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase1EncryptionAlgorithmsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase1IntegrityAlgorithmsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase1IntegrityAlgorithmsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase2DHGroupNumbersListValue: Codable, Equatable {
    public var value: Integer?

    public init(value: Integer? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase2DHGroupNumbersRequestListValue: Codable, Equatable {
    public var value: Integer?

    public init(value: Integer? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase2EncryptionAlgorithmsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase2EncryptionAlgorithmsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase2IntegrityAlgorithmsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase2IntegrityAlgorithmsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Placement: Codable, Equatable {
    public var affinity: String?
    public var availabilityZone: String?
    public var groupName: String?
    public var hostId: String?
    public var hostResourceGroupArn: String?
    public var partitionNumber: Integer?
    public var spreadDomain: String?
    public var tenancy: Tenancy?

    public init(affinity: String? = nil,
                availabilityZone: String? = nil,
                groupName: String? = nil,
                hostId: String? = nil,
                hostResourceGroupArn: String? = nil,
                partitionNumber: Integer? = nil,
                spreadDomain: String? = nil,
                tenancy: Tenancy? = nil) {
        self.affinity = affinity
        self.availabilityZone = availabilityZone
        self.groupName = groupName
        self.hostId = hostId
        self.hostResourceGroupArn = hostResourceGroupArn
        self.partitionNumber = partitionNumber
        self.spreadDomain = spreadDomain
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case affinity
        case availabilityZone
        case groupName
        case hostId
        case hostResourceGroupArn
        case partitionNumber
        case spreadDomain
        case tenancy
    }

    public func validate() throws {
    }
}

public struct PlacementGroup: Codable, Equatable {
    public var groupId: String?
    public var groupName: String?
    public var partitionCount: Integer?
    public var state: PlacementGroupState?
    public var strategy: PlacementStrategy?
    public var tags: TagList?

    public init(groupId: String? = nil,
                groupName: String? = nil,
                partitionCount: Integer? = nil,
                state: PlacementGroupState? = nil,
                strategy: PlacementStrategy? = nil,
                tags: TagList? = nil) {
        self.groupId = groupId
        self.groupName = groupName
        self.partitionCount = partitionCount
        self.state = state
        self.strategy = strategy
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case groupName
        case partitionCount
        case state
        case strategy
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct PlacementGroupInfo: Codable, Equatable {
    public var supportedStrategies: PlacementGroupStrategyList?

    public init(supportedStrategies: PlacementGroupStrategyList? = nil) {
        self.supportedStrategies = supportedStrategies
    }

    enum CodingKeys: String, CodingKey {
        case supportedStrategies
    }

    public func validate() throws {
    }
}

public struct PlacementResponse: Codable, Equatable {
    public var groupName: String?

    public init(groupName: String? = nil) {
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case groupName
    }

    public func validate() throws {
    }
}

public struct PoolCidrBlock: Codable, Equatable {
    public var cidr: String?

    public init(cidr: String? = nil) {
        self.cidr = cidr
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "poolCidrBlock"
    }

    public func validate() throws {
    }
}

public struct PortRange: Codable, Equatable {
    public var from: Integer?
    public var to: Integer?

    public init(from: Integer? = nil,
                to: Integer? = nil) {
        self.from = from
        self.to = to
    }

    enum CodingKeys: String, CodingKey {
        case from
        case to
    }

    public func validate() throws {
    }
}

public struct PrefixList: Codable, Equatable {
    public var cidrs: ValueStringList?
    public var prefixListId: String?
    public var prefixListName: String?

    public init(cidrs: ValueStringList? = nil,
                prefixListId: String? = nil,
                prefixListName: String? = nil) {
        self.cidrs = cidrs
        self.prefixListId = prefixListId
        self.prefixListName = prefixListName
    }

    enum CodingKeys: String, CodingKey {
        case cidrs = "cidrSet"
        case prefixListId
        case prefixListName
    }

    public func validate() throws {
    }
}

public struct PrefixListAssociation: Codable, Equatable {
    public var resourceId: String?
    public var resourceOwner: String?

    public init(resourceId: String? = nil,
                resourceOwner: String? = nil) {
        self.resourceId = resourceId
        self.resourceOwner = resourceOwner
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceOwner
    }

    public func validate() throws {
    }
}

public struct PrefixListEntry: Codable, Equatable {
    public var cidr: String?
    public var description: String?

    public init(cidr: String? = nil,
                description: String? = nil) {
        self.cidr = cidr
        self.description = description
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case description
    }

    public func validate() throws {
    }
}

public struct PrefixListId: Codable, Equatable {
    public var description: String?
    public var prefixListId: String?

    public init(description: String? = nil,
                prefixListId: String? = nil) {
        self.description = description
        self.prefixListId = prefixListId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case prefixListId
    }

    public func validate() throws {
    }
}

public struct PriceSchedule: Codable, Equatable {
    public var active: Boolean?
    public var currencyCode: CurrencyCodeValues?
    public var price: Double?
    public var term: Long?

    public init(active: Boolean? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                price: Double? = nil,
                term: Long? = nil) {
        self.active = active
        self.currencyCode = currencyCode
        self.price = price
        self.term = term
    }

    enum CodingKeys: String, CodingKey {
        case active
        case currencyCode
        case price
        case term
    }

    public func validate() throws {
    }
}

public struct PriceScheduleSpecification: Codable, Equatable {
    public var currencyCode: CurrencyCodeValues?
    public var price: Double?
    public var term: Long?

    public init(currencyCode: CurrencyCodeValues? = nil,
                price: Double? = nil,
                term: Long? = nil) {
        self.currencyCode = currencyCode
        self.price = price
        self.term = term
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case price
        case term
    }

    public func validate() throws {
    }
}

public struct PricingDetail: Codable, Equatable {
    public var count: Integer?
    public var price: Double?

    public init(count: Integer? = nil,
                price: Double? = nil) {
        self.count = count
        self.price = price
    }

    enum CodingKeys: String, CodingKey {
        case count
        case price
    }

    public func validate() throws {
    }
}

public struct PrincipalIdFormat: Codable, Equatable {
    public var arn: String?
    public var statuses: IdFormatList?

    public init(arn: String? = nil,
                statuses: IdFormatList? = nil) {
        self.arn = arn
        self.statuses = statuses
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case statuses = "statusSet"
    }

    public func validate() throws {
    }
}

public struct PrivateDnsDetails: Codable, Equatable {
    public var privateDnsName: String?

    public init(privateDnsName: String? = nil) {
        self.privateDnsName = privateDnsName
    }

    enum CodingKeys: String, CodingKey {
        case privateDnsName
    }

    public func validate() throws {
    }
}

public struct PrivateDnsNameConfiguration: Codable, Equatable {
    public var name: String?
    public var state: DnsNameState?
    public var type: String?
    public var value: String?

    public init(name: String? = nil,
                state: DnsNameState? = nil,
                type: String? = nil,
                value: String? = nil) {
        self.name = name
        self.state = state
        self.type = type
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case name
        case state
        case type
        case value
    }

    public func validate() throws {
    }
}

public struct PrivateIpAddressSpecification: Codable, Equatable {
    public var primary: Boolean?
    public var privateIpAddress: String?

    public init(primary: Boolean? = nil,
                privateIpAddress: String? = nil) {
        self.primary = primary
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case primary
        case privateIpAddress
    }

    public func validate() throws {
    }
}

public struct ProcessorInfo: Codable, Equatable {
    public var supportedArchitectures: ArchitectureTypeList?
    public var sustainedClockSpeedInGhz: ProcessorSustainedClockSpeed?

    public init(supportedArchitectures: ArchitectureTypeList? = nil,
                sustainedClockSpeedInGhz: ProcessorSustainedClockSpeed? = nil) {
        self.supportedArchitectures = supportedArchitectures
        self.sustainedClockSpeedInGhz = sustainedClockSpeedInGhz
    }

    enum CodingKeys: String, CodingKey {
        case supportedArchitectures
        case sustainedClockSpeedInGhz
    }

    public func validate() throws {
    }
}

public struct ProductCode: Codable, Equatable {
    public var productCodeId: String?
    public var productCodeType: ProductCodeValues?

    public init(productCodeId: String? = nil,
                productCodeType: ProductCodeValues? = nil) {
        self.productCodeId = productCodeId
        self.productCodeType = productCodeType
    }

    enum CodingKeys: String, CodingKey {
        case productCodeId = "productCode"
        case productCodeType = "type"
    }

    public func validate() throws {
    }
}

public struct PropagatingVgw: Codable, Equatable {
    public var gatewayId: String?

    public init(gatewayId: String? = nil) {
        self.gatewayId = gatewayId
    }

    enum CodingKeys: String, CodingKey {
        case gatewayId
    }

    public func validate() throws {
    }
}

public struct ProvisionByoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var cidrAuthorizationContext: CidrAuthorizationContext?
    public var description: String?
    public var dryRun: Boolean?
    public var poolTagSpecifications: TagSpecificationList?
    public var publiclyAdvertisable: Boolean?

    public init(cidr: String,
                cidrAuthorizationContext: CidrAuthorizationContext? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                poolTagSpecifications: TagSpecificationList? = nil,
                publiclyAdvertisable: Boolean? = nil) {
        self.cidr = cidr
        self.cidrAuthorizationContext = cidrAuthorizationContext
        self.description = description
        self.dryRun = dryRun
        self.poolTagSpecifications = poolTagSpecifications
        self.publiclyAdvertisable = publiclyAdvertisable
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
        case description = "Description"
        case dryRun = "DryRun"
        case poolTagSpecifications = "PoolTagSpecification"
        case publiclyAdvertisable = "PubliclyAdvertisable"
    }

    public func validate() throws {
        try cidrAuthorizationContext?.validate()
    }
}

public struct ProvisionByoipCidrResult: Codable, Equatable {
    public var byoipCidr: ByoipCidr?

    public init(byoipCidr: ByoipCidr? = nil) {
        self.byoipCidr = byoipCidr
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidr
    }

    public func validate() throws {
        try byoipCidr?.validate()
    }
}

public struct ProvisionedBandwidth: Codable, Equatable {
    public var provisionTime: DateTime?
    public var provisioned: String?
    public var requestTime: DateTime?
    public var requested: String?
    public var status: String?

    public init(provisionTime: DateTime? = nil,
                provisioned: String? = nil,
                requestTime: DateTime? = nil,
                requested: String? = nil,
                status: String? = nil) {
        self.provisionTime = provisionTime
        self.provisioned = provisioned
        self.requestTime = requestTime
        self.requested = requested
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case provisionTime
        case provisioned
        case requestTime
        case requested
        case status
    }

    public func validate() throws {
    }
}

public struct PublicIpv4Pool: Codable, Equatable {
    public var description: String?
    public var networkBorderGroup: String?
    public var poolAddressRanges: PublicIpv4PoolRangeSet?
    public var poolId: String?
    public var tags: TagList?
    public var totalAddressCount: Integer?
    public var totalAvailableAddressCount: Integer?

    public init(description: String? = nil,
                networkBorderGroup: String? = nil,
                poolAddressRanges: PublicIpv4PoolRangeSet? = nil,
                poolId: String? = nil,
                tags: TagList? = nil,
                totalAddressCount: Integer? = nil,
                totalAvailableAddressCount: Integer? = nil) {
        self.description = description
        self.networkBorderGroup = networkBorderGroup
        self.poolAddressRanges = poolAddressRanges
        self.poolId = poolId
        self.tags = tags
        self.totalAddressCount = totalAddressCount
        self.totalAvailableAddressCount = totalAvailableAddressCount
    }

    enum CodingKeys: String, CodingKey {
        case description
        case networkBorderGroup
        case poolAddressRanges = "poolAddressRangeSet"
        case poolId
        case tags = "tagSet"
        case totalAddressCount
        case totalAvailableAddressCount
    }

    public func validate() throws {
    }
}

public struct PublicIpv4PoolRange: Codable, Equatable {
    public var addressCount: Integer?
    public var availableAddressCount: Integer?
    public var firstAddress: String?
    public var lastAddress: String?

    public init(addressCount: Integer? = nil,
                availableAddressCount: Integer? = nil,
                firstAddress: String? = nil,
                lastAddress: String? = nil) {
        self.addressCount = addressCount
        self.availableAddressCount = availableAddressCount
        self.firstAddress = firstAddress
        self.lastAddress = lastAddress
    }

    enum CodingKeys: String, CodingKey {
        case addressCount
        case availableAddressCount
        case firstAddress
        case lastAddress
    }

    public func validate() throws {
    }
}

public struct Purchase: Codable, Equatable {
    public var currencyCode: CurrencyCodeValues?
    public var duration: Integer?
    public var hostIdSet: ResponseHostIdSet?
    public var hostReservationId: String?
    public var hourlyPrice: String?
    public var instanceFamily: String?
    public var paymentOption: PaymentOption?
    public var upfrontPrice: String?

    public init(currencyCode: CurrencyCodeValues? = nil,
                duration: Integer? = nil,
                hostIdSet: ResponseHostIdSet? = nil,
                hostReservationId: String? = nil,
                hourlyPrice: String? = nil,
                instanceFamily: String? = nil,
                paymentOption: PaymentOption? = nil,
                upfrontPrice: String? = nil) {
        self.currencyCode = currencyCode
        self.duration = duration
        self.hostIdSet = hostIdSet
        self.hostReservationId = hostReservationId
        self.hourlyPrice = hourlyPrice
        self.instanceFamily = instanceFamily
        self.paymentOption = paymentOption
        self.upfrontPrice = upfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case duration
        case hostIdSet
        case hostReservationId
        case hourlyPrice
        case instanceFamily
        case paymentOption
        case upfrontPrice
    }

    public func validate() throws {
    }
}

public struct PurchaseHostReservationRequest: Codable, Equatable {
    public var clientToken: String?
    public var currencyCode: CurrencyCodeValues?
    public var hostIdSet: RequestHostIdSet
    public var limitPrice: String?
    public var offeringId: OfferingId
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                hostIdSet: RequestHostIdSet,
                limitPrice: String? = nil,
                offeringId: OfferingId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.currencyCode = currencyCode
        self.hostIdSet = hostIdSet
        self.limitPrice = limitPrice
        self.offeringId = offeringId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case currencyCode = "CurrencyCode"
        case hostIdSet = "HostIdSet"
        case limitPrice = "LimitPrice"
        case offeringId = "OfferingId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct PurchaseHostReservationResult: Codable, Equatable {
    public var clientToken: String?
    public var currencyCode: CurrencyCodeValues?
    public var purchase: PurchaseSet?
    public var totalHourlyPrice: String?
    public var totalUpfrontPrice: String?

    public init(clientToken: String? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                purchase: PurchaseSet? = nil,
                totalHourlyPrice: String? = nil,
                totalUpfrontPrice: String? = nil) {
        self.clientToken = clientToken
        self.currencyCode = currencyCode
        self.purchase = purchase
        self.totalHourlyPrice = totalHourlyPrice
        self.totalUpfrontPrice = totalUpfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case currencyCode
        case purchase
        case totalHourlyPrice
        case totalUpfrontPrice
    }

    public func validate() throws {
    }
}

public struct PurchaseRequest: Codable, Equatable {
    public var instanceCount: Integer
    public var purchaseToken: String

    public init(instanceCount: Integer,
                purchaseToken: String) {
        self.instanceCount = instanceCount
        self.purchaseToken = purchaseToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceCount = "InstanceCount"
        case purchaseToken = "PurchaseToken"
    }

    public func validate() throws {
    }
}

public struct PurchaseReservedInstancesOfferingRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceCount: Integer
    public var limitPrice: ReservedInstanceLimitPrice?
    public var purchaseTime: DateTime?
    public var reservedInstancesOfferingId: ReservedInstancesOfferingId

    public init(dryRun: Boolean? = nil,
                instanceCount: Integer,
                limitPrice: ReservedInstanceLimitPrice? = nil,
                purchaseTime: DateTime? = nil,
                reservedInstancesOfferingId: ReservedInstancesOfferingId) {
        self.dryRun = dryRun
        self.instanceCount = instanceCount
        self.limitPrice = limitPrice
        self.purchaseTime = purchaseTime
        self.reservedInstancesOfferingId = reservedInstancesOfferingId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceCount = "InstanceCount"
        case limitPrice
        case purchaseTime = "PurchaseTime"
        case reservedInstancesOfferingId = "ReservedInstancesOfferingId"
    }

    public func validate() throws {
        try limitPrice?.validate()
    }
}

public struct PurchaseReservedInstancesOfferingResult: Codable, Equatable {
    public var reservedInstancesId: String?

    public init(reservedInstancesId: String? = nil) {
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesId
    }

    public func validate() throws {
    }
}

public struct PurchaseScheduledInstancesRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var purchaseRequests: PurchaseRequestSet

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                purchaseRequests: PurchaseRequestSet) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.purchaseRequests = purchaseRequests
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case purchaseRequests = "PurchaseRequest"
    }

    public func validate() throws {
        try purchaseRequests.validateAsPurchaseRequestSet()
    }
}

public struct PurchaseScheduledInstancesResult: Codable, Equatable {
    public var scheduledInstanceSet: PurchasedScheduledInstanceSet?

    public init(scheduledInstanceSet: PurchasedScheduledInstanceSet? = nil) {
        self.scheduledInstanceSet = scheduledInstanceSet
    }

    enum CodingKeys: String, CodingKey {
        case scheduledInstanceSet
    }

    public func validate() throws {
    }
}

public struct RebootInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct RecurringCharge: Codable, Equatable {
    public var amount: Double?
    public var frequency: RecurringChargeFrequency?

    public init(amount: Double? = nil,
                frequency: RecurringChargeFrequency? = nil) {
        self.amount = amount
        self.frequency = frequency
    }

    enum CodingKeys: String, CodingKey {
        case amount
        case frequency
    }

    public func validate() throws {
    }
}

public struct Region: Codable, Equatable {
    public var endpoint: String?
    public var optInStatus: String?
    public var regionName: String?

    public init(endpoint: String? = nil,
                optInStatus: String? = nil,
                regionName: String? = nil) {
        self.endpoint = endpoint
        self.optInStatus = optInStatus
        self.regionName = regionName
    }

    enum CodingKeys: String, CodingKey {
        case endpoint = "regionEndpoint"
        case optInStatus
        case regionName
    }

    public func validate() throws {
    }
}

public struct RegisterImageRequest: Codable, Equatable {
    public var architecture: ArchitectureValues?
    public var billingProducts: BillingProductList?
    public var blockDeviceMappings: BlockDeviceMappingRequestList?
    public var description: String?
    public var dryRun: Boolean?
    public var enaSupport: Boolean?
    public var imageLocation: String?
    public var kernelId: KernelId?
    public var name: String
    public var ramdiskId: RamdiskId?
    public var rootDeviceName: String?
    public var sriovNetSupport: String?
    public var virtualizationType: String?

    public init(architecture: ArchitectureValues? = nil,
                billingProducts: BillingProductList? = nil,
                blockDeviceMappings: BlockDeviceMappingRequestList? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                enaSupport: Boolean? = nil,
                imageLocation: String? = nil,
                kernelId: KernelId? = nil,
                name: String,
                ramdiskId: RamdiskId? = nil,
                rootDeviceName: String? = nil,
                sriovNetSupport: String? = nil,
                virtualizationType: String? = nil) {
        self.architecture = architecture
        self.billingProducts = billingProducts
        self.blockDeviceMappings = blockDeviceMappings
        self.description = description
        self.dryRun = dryRun
        self.enaSupport = enaSupport
        self.imageLocation = imageLocation
        self.kernelId = kernelId
        self.name = name
        self.ramdiskId = ramdiskId
        self.rootDeviceName = rootDeviceName
        self.sriovNetSupport = sriovNetSupport
        self.virtualizationType = virtualizationType
    }

    enum CodingKeys: String, CodingKey {
        case architecture
        case billingProducts = "BillingProduct"
        case blockDeviceMappings = "BlockDeviceMapping"
        case description
        case dryRun
        case enaSupport
        case imageLocation = "ImageLocation"
        case kernelId
        case name
        case ramdiskId
        case rootDeviceName
        case sriovNetSupport
        case virtualizationType
    }

    public func validate() throws {
    }
}

public struct RegisterImageResult: Codable, Equatable {
    public var imageId: String?

    public init(imageId: String? = nil) {
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case imageId
    }

    public func validate() throws {
    }
}

public struct RegisterInstanceEventNotificationAttributesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceTagAttribute: RegisterInstanceTagAttributeRequest?

    public init(dryRun: Boolean? = nil,
                instanceTagAttribute: RegisterInstanceTagAttributeRequest? = nil) {
        self.dryRun = dryRun
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceTagAttribute = "InstanceTagAttribute"
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct RegisterInstanceEventNotificationAttributesResult: Codable, Equatable {
    public var instanceTagAttribute: InstanceTagNotificationAttribute?

    public init(instanceTagAttribute: InstanceTagNotificationAttribute? = nil) {
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case instanceTagAttribute
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct RegisterInstanceTagAttributeRequest: Codable, Equatable {
    public var includeAllTagsOfInstance: Boolean?
    public var instanceTagKeys: InstanceTagKeySet?

    public init(includeAllTagsOfInstance: Boolean? = nil,
                instanceTagKeys: InstanceTagKeySet? = nil) {
        self.includeAllTagsOfInstance = includeAllTagsOfInstance
        self.instanceTagKeys = instanceTagKeys
    }

    enum CodingKeys: String, CodingKey {
        case includeAllTagsOfInstance = "IncludeAllTagsOfInstance"
        case instanceTagKeys = "InstanceTagKey"
    }

    public func validate() throws {
    }
}

public struct RegisterTransitGatewayMulticastGroupMembersRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupIpAddress: String?
    public var networkInterfaceIds: TransitGatewayNetworkInterfaceIdList?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                groupIpAddress: String? = nil,
                networkInterfaceIds: TransitGatewayNetworkInterfaceIdList? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.groupIpAddress = groupIpAddress
        self.networkInterfaceIds = networkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupIpAddress = "GroupIpAddress"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct RegisterTransitGatewayMulticastGroupMembersResult: Codable, Equatable {
    public var registeredMulticastGroupMembers: TransitGatewayMulticastRegisteredGroupMembers?

    public init(registeredMulticastGroupMembers: TransitGatewayMulticastRegisteredGroupMembers? = nil) {
        self.registeredMulticastGroupMembers = registeredMulticastGroupMembers
    }

    enum CodingKeys: String, CodingKey {
        case registeredMulticastGroupMembers
    }

    public func validate() throws {
        try registeredMulticastGroupMembers?.validate()
    }
}

public struct RegisterTransitGatewayMulticastGroupSourcesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupIpAddress: String?
    public var networkInterfaceIds: TransitGatewayNetworkInterfaceIdList?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                groupIpAddress: String? = nil,
                networkInterfaceIds: TransitGatewayNetworkInterfaceIdList? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.groupIpAddress = groupIpAddress
        self.networkInterfaceIds = networkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupIpAddress = "GroupIpAddress"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct RegisterTransitGatewayMulticastGroupSourcesResult: Codable, Equatable {
    public var registeredMulticastGroupSources: TransitGatewayMulticastRegisteredGroupSources?

    public init(registeredMulticastGroupSources: TransitGatewayMulticastRegisteredGroupSources? = nil) {
        self.registeredMulticastGroupSources = registeredMulticastGroupSources
    }

    enum CodingKeys: String, CodingKey {
        case registeredMulticastGroupSources
    }

    public func validate() throws {
        try registeredMulticastGroupSources?.validate()
    }
}

public struct RejectTransitGatewayMulticastDomainAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetIds: ValueStringList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                subnetIds: ValueStringList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.subnetIds = subnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case subnetIds = "SubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct RejectTransitGatewayMulticastDomainAssociationsResult: Codable, Equatable {
    public var associations: TransitGatewayMulticastDomainAssociations?

    public init(associations: TransitGatewayMulticastDomainAssociations? = nil) {
        self.associations = associations
    }

    enum CodingKeys: String, CodingKey {
        case associations
    }

    public func validate() throws {
        try associations?.validate()
    }
}

public struct RejectTransitGatewayPeeringAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct RejectTransitGatewayPeeringAttachmentResult: Codable, Equatable {
    public var transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment?

    public init(transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment? = nil) {
        self.transitGatewayPeeringAttachment = transitGatewayPeeringAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPeeringAttachment
    }

    public func validate() throws {
        try transitGatewayPeeringAttachment?.validate()
    }
}

public struct RejectTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct RejectTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct RejectVpcEndpointConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var serviceId: VpcEndpointServiceId
    public var vpcEndpointIds: VpcEndpointIdList

    public init(dryRun: Boolean? = nil,
                serviceId: VpcEndpointServiceId,
                vpcEndpointIds: VpcEndpointIdList) {
        self.dryRun = dryRun
        self.serviceId = serviceId
        self.vpcEndpointIds = vpcEndpointIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case serviceId = "ServiceId"
        case vpcEndpointIds = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct RejectVpcEndpointConnectionsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct RejectVpcPeeringConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId

    public init(dryRun: Boolean? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId) {
        self.dryRun = dryRun
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct RejectVpcPeeringConnectionResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ReleaseAddressRequest: Codable, Equatable {
    public var allocationId: AllocationId?
    public var dryRun: Boolean?
    public var networkBorderGroup: String?
    public var publicIp: String?

    public init(allocationId: AllocationId? = nil,
                dryRun: Boolean? = nil,
                networkBorderGroup: String? = nil,
                publicIp: String? = nil) {
        self.allocationId = allocationId
        self.dryRun = dryRun
        self.networkBorderGroup = networkBorderGroup
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case dryRun
        case networkBorderGroup = "NetworkBorderGroup"
        case publicIp = "PublicIp"
    }

    public func validate() throws {
    }
}

public struct ReleaseHostsRequest: Codable, Equatable {
    public var hostIds: RequestHostIdList

    public init(hostIds: RequestHostIdList) {
        self.hostIds = hostIds
    }

    enum CodingKeys: String, CodingKey {
        case hostIds = "hostId"
    }

    public func validate() throws {
    }
}

public struct ReleaseHostsResult: Codable, Equatable {
    public var successful: ResponseHostIdList?
    public var unsuccessful: UnsuccessfulItemList?

    public init(successful: ResponseHostIdList? = nil,
                unsuccessful: UnsuccessfulItemList? = nil) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case successful
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct RemovePrefixListEntry: Codable, Equatable {
    public var cidr: String

    public init(cidr: String) {
        self.cidr = cidr
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
    }

    public func validate() throws {
    }
}

public struct ReplaceIamInstanceProfileAssociationRequest: Codable, Equatable {
    public var associationId: IamInstanceProfileAssociationId
    public var iamInstanceProfile: IamInstanceProfileSpecification

    public init(associationId: IamInstanceProfileAssociationId,
                iamInstanceProfile: IamInstanceProfileSpecification) {
        self.associationId = associationId
        self.iamInstanceProfile = iamInstanceProfile
    }

    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case iamInstanceProfile = "IamInstanceProfile"
    }

    public func validate() throws {
        try iamInstanceProfile.validate()
    }
}

public struct ReplaceIamInstanceProfileAssociationResult: Codable, Equatable {
    public var iamInstanceProfileAssociation: IamInstanceProfileAssociation?

    public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
        self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfileAssociation
    }

    public func validate() throws {
        try iamInstanceProfileAssociation?.validate()
    }
}

public struct ReplaceNetworkAclAssociationRequest: Codable, Equatable {
    public var associationId: NetworkAclAssociationId
    public var dryRun: Boolean?
    public var networkAclId: NetworkAclId

    public init(associationId: NetworkAclAssociationId,
                dryRun: Boolean? = nil,
                networkAclId: NetworkAclId) {
        self.associationId = associationId
        self.dryRun = dryRun
        self.networkAclId = networkAclId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case dryRun
        case networkAclId
    }

    public func validate() throws {
    }
}

public struct ReplaceNetworkAclAssociationResult: Codable, Equatable {
    public var newAssociationId: String?

    public init(newAssociationId: String? = nil) {
        self.newAssociationId = newAssociationId
    }

    enum CodingKeys: String, CodingKey {
        case newAssociationId
    }

    public func validate() throws {
    }
}

public struct ReplaceNetworkAclEntryRequest: Codable, Equatable {
    public var cidrBlock: String?
    public var dryRun: Boolean?
    public var egress: Boolean
    public var icmpTypeCode: IcmpTypeCode?
    public var ipv6CidrBlock: String?
    public var networkAclId: NetworkAclId
    public var portRange: PortRange?
    public var `protocol`: String
    public var ruleAction: RuleAction
    public var ruleNumber: Integer

    public init(cidrBlock: String? = nil,
                dryRun: Boolean? = nil,
                egress: Boolean,
                icmpTypeCode: IcmpTypeCode? = nil,
                ipv6CidrBlock: String? = nil,
                networkAclId: NetworkAclId,
                portRange: PortRange? = nil,
                `protocol`: String,
                ruleAction: RuleAction,
                ruleNumber: Integer) {
        self.cidrBlock = cidrBlock
        self.dryRun = dryRun
        self.egress = egress
        self.icmpTypeCode = icmpTypeCode
        self.ipv6CidrBlock = ipv6CidrBlock
        self.networkAclId = networkAclId
        self.portRange = portRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case dryRun
        case egress
        case icmpTypeCode = "Icmp"
        case ipv6CidrBlock
        case networkAclId
        case portRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
    }

    public func validate() throws {
        try icmpTypeCode?.validate()
        try portRange?.validate()
    }
}

public struct ReplaceRouteRequest: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId?
    public var destinationCidrBlock: String?
    public var destinationIpv6CidrBlock: String?
    public var destinationPrefixListId: PrefixListResourceId?
    public var dryRun: Boolean?
    public var egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId?
    public var gatewayId: RouteGatewayId?
    public var instanceId: InstanceId?
    public var localGatewayId: LocalGatewayId?
    public var localTarget: Boolean?
    public var natGatewayId: NatGatewayId?
    public var networkInterfaceId: NetworkInterfaceId?
    public var routeTableId: RouteTableId
    public var transitGatewayId: TransitGatewayId?
    public var vpcEndpointId: VpcEndpointId?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId?

    public init(carrierGatewayId: CarrierGatewayId? = nil,
                destinationCidrBlock: String? = nil,
                destinationIpv6CidrBlock: String? = nil,
                destinationPrefixListId: PrefixListResourceId? = nil,
                dryRun: Boolean? = nil,
                egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId? = nil,
                gatewayId: RouteGatewayId? = nil,
                instanceId: InstanceId? = nil,
                localGatewayId: LocalGatewayId? = nil,
                localTarget: Boolean? = nil,
                natGatewayId: NatGatewayId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                routeTableId: RouteTableId,
                transitGatewayId: TransitGatewayId? = nil,
                vpcEndpointId: VpcEndpointId? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        self.destinationPrefixListId = destinationPrefixListId
        self.dryRun = dryRun
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.gatewayId = gatewayId
        self.instanceId = instanceId
        self.localGatewayId = localGatewayId
        self.localTarget = localTarget
        self.natGatewayId = natGatewayId
        self.networkInterfaceId = networkInterfaceId
        self.routeTableId = routeTableId
        self.transitGatewayId = transitGatewayId
        self.vpcEndpointId = vpcEndpointId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId = "CarrierGatewayId"
        case destinationCidrBlock
        case destinationIpv6CidrBlock
        case destinationPrefixListId = "DestinationPrefixListId"
        case dryRun
        case egressOnlyInternetGatewayId
        case gatewayId
        case instanceId
        case localGatewayId = "LocalGatewayId"
        case localTarget = "LocalTarget"
        case natGatewayId
        case networkInterfaceId
        case routeTableId
        case transitGatewayId = "TransitGatewayId"
        case vpcEndpointId = "VpcEndpointId"
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct ReplaceRouteTableAssociationRequest: Codable, Equatable {
    public var associationId: RouteTableAssociationId
    public var dryRun: Boolean?
    public var routeTableId: RouteTableId

    public init(associationId: RouteTableAssociationId,
                dryRun: Boolean? = nil,
                routeTableId: RouteTableId) {
        self.associationId = associationId
        self.dryRun = dryRun
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case dryRun
        case routeTableId
    }

    public func validate() throws {
    }
}

public struct ReplaceRouteTableAssociationResult: Codable, Equatable {
    public var associationState: RouteTableAssociationState?
    public var newAssociationId: String?

    public init(associationState: RouteTableAssociationState? = nil,
                newAssociationId: String? = nil) {
        self.associationState = associationState
        self.newAssociationId = newAssociationId
    }

    enum CodingKeys: String, CodingKey {
        case associationState
        case newAssociationId
    }

    public func validate() throws {
        try associationState?.validate()
    }
}

public struct ReplaceTransitGatewayRouteRequest: Codable, Equatable {
    public var blackhole: Boolean?
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(blackhole: Boolean? = nil,
                destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.blackhole = blackhole
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole = "Blackhole"
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct ReplaceTransitGatewayRouteResult: Codable, Equatable {
    public var route: TransitGatewayRoute?

    public init(route: TransitGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct ReportInstanceStatusRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var endTime: DateTime?
    public var instances: InstanceIdStringList
    public var reasonCodes: ReasonCodesList
    public var startTime: DateTime?
    public var status: ReportStatusType

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                endTime: DateTime? = nil,
                instances: InstanceIdStringList,
                reasonCodes: ReasonCodesList,
                startTime: DateTime? = nil,
                status: ReportStatusType) {
        self.description = description
        self.dryRun = dryRun
        self.endTime = endTime
        self.instances = instances
        self.reasonCodes = reasonCodes
        self.startTime = startTime
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case description
        case dryRun
        case endTime
        case instances = "instanceId"
        case reasonCodes = "reasonCode"
        case startTime
        case status
    }

    public func validate() throws {
    }
}

public struct RequestLaunchTemplateData: Codable, Equatable {
    public var blockDeviceMappings: LaunchTemplateBlockDeviceMappingRequestList?
    public var capacityReservationSpecification: LaunchTemplateCapacityReservationSpecificationRequest?
    public var cpuOptions: LaunchTemplateCpuOptionsRequest?
    public var creditSpecification: CreditSpecificationRequest?
    public var disableApiTermination: Boolean?
    public var ebsOptimized: Boolean?
    public var elasticGpuSpecifications: ElasticGpuSpecificationList?
    public var elasticInferenceAccelerators: LaunchTemplateElasticInferenceAcceleratorList?
    public var enclaveOptions: LaunchTemplateEnclaveOptionsRequest?
    public var hibernationOptions: LaunchTemplateHibernationOptionsRequest?
    public var iamInstanceProfile: LaunchTemplateIamInstanceProfileSpecificationRequest?
    public var imageId: ImageId?
    public var instanceInitiatedShutdownBehavior: ShutdownBehavior?
    public var instanceMarketOptions: LaunchTemplateInstanceMarketOptionsRequest?
    public var instanceType: InstanceType?
    public var kernelId: KernelId?
    public var keyName: KeyPairName?
    public var licenseSpecifications: LaunchTemplateLicenseSpecificationListRequest?
    public var metadataOptions: LaunchTemplateInstanceMetadataOptionsRequest?
    public var monitoring: LaunchTemplatesMonitoringRequest?
    public var networkInterfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList?
    public var placement: LaunchTemplatePlacementRequest?
    public var ramDiskId: RamdiskId?
    public var securityGroupIds: SecurityGroupIdStringList?
    public var securityGroups: SecurityGroupStringList?
    public var tagSpecifications: LaunchTemplateTagSpecificationRequestList?
    public var userData: String?

    public init(blockDeviceMappings: LaunchTemplateBlockDeviceMappingRequestList? = nil,
                capacityReservationSpecification: LaunchTemplateCapacityReservationSpecificationRequest? = nil,
                cpuOptions: LaunchTemplateCpuOptionsRequest? = nil,
                creditSpecification: CreditSpecificationRequest? = nil,
                disableApiTermination: Boolean? = nil,
                ebsOptimized: Boolean? = nil,
                elasticGpuSpecifications: ElasticGpuSpecificationList? = nil,
                elasticInferenceAccelerators: LaunchTemplateElasticInferenceAcceleratorList? = nil,
                enclaveOptions: LaunchTemplateEnclaveOptionsRequest? = nil,
                hibernationOptions: LaunchTemplateHibernationOptionsRequest? = nil,
                iamInstanceProfile: LaunchTemplateIamInstanceProfileSpecificationRequest? = nil,
                imageId: ImageId? = nil,
                instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil,
                instanceMarketOptions: LaunchTemplateInstanceMarketOptionsRequest? = nil,
                instanceType: InstanceType? = nil,
                kernelId: KernelId? = nil,
                keyName: KeyPairName? = nil,
                licenseSpecifications: LaunchTemplateLicenseSpecificationListRequest? = nil,
                metadataOptions: LaunchTemplateInstanceMetadataOptionsRequest? = nil,
                monitoring: LaunchTemplatesMonitoringRequest? = nil,
                networkInterfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList? = nil,
                placement: LaunchTemplatePlacementRequest? = nil,
                ramDiskId: RamdiskId? = nil,
                securityGroupIds: SecurityGroupIdStringList? = nil,
                securityGroups: SecurityGroupStringList? = nil,
                tagSpecifications: LaunchTemplateTagSpecificationRequestList? = nil,
                userData: String? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.capacityReservationSpecification = capacityReservationSpecification
        self.cpuOptions = cpuOptions
        self.creditSpecification = creditSpecification
        self.disableApiTermination = disableApiTermination
        self.ebsOptimized = ebsOptimized
        self.elasticGpuSpecifications = elasticGpuSpecifications
        self.elasticInferenceAccelerators = elasticInferenceAccelerators
        self.enclaveOptions = enclaveOptions
        self.hibernationOptions = hibernationOptions
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceMarketOptions = instanceMarketOptions
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.licenseSpecifications = licenseSpecifications
        self.metadataOptions = metadataOptions
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramDiskId = ramDiskId
        self.securityGroupIds = securityGroupIds
        self.securityGroups = securityGroups
        self.tagSpecifications = tagSpecifications
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "BlockDeviceMapping"
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case cpuOptions = "CpuOptions"
        case creditSpecification = "CreditSpecification"
        case disableApiTermination = "DisableApiTermination"
        case ebsOptimized = "EbsOptimized"
        case elasticGpuSpecifications = "ElasticGpuSpecification"
        case elasticInferenceAccelerators = "ElasticInferenceAccelerator"
        case enclaveOptions = "EnclaveOptions"
        case hibernationOptions = "HibernationOptions"
        case iamInstanceProfile = "IamInstanceProfile"
        case imageId = "ImageId"
        case instanceInitiatedShutdownBehavior = "InstanceInitiatedShutdownBehavior"
        case instanceMarketOptions = "InstanceMarketOptions"
        case instanceType = "InstanceType"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case licenseSpecifications = "LicenseSpecification"
        case metadataOptions = "MetadataOptions"
        case monitoring = "Monitoring"
        case networkInterfaces = "NetworkInterface"
        case placement = "Placement"
        case ramDiskId = "RamDiskId"
        case securityGroupIds = "SecurityGroupId"
        case securityGroups = "SecurityGroup"
        case tagSpecifications = "TagSpecification"
        case userData = "UserData"
    }

    public func validate() throws {
        try capacityReservationSpecification?.validate()
        try cpuOptions?.validate()
        try creditSpecification?.validate()
        try enclaveOptions?.validate()
        try hibernationOptions?.validate()
        try iamInstanceProfile?.validate()
        try instanceMarketOptions?.validate()
        try metadataOptions?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct RequestSpotFleetRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var spotFleetRequestConfig: SpotFleetRequestConfigData

    public init(dryRun: Boolean? = nil,
                spotFleetRequestConfig: SpotFleetRequestConfigData) {
        self.dryRun = dryRun
        self.spotFleetRequestConfig = spotFleetRequestConfig
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case spotFleetRequestConfig
    }

    public func validate() throws {
        try spotFleetRequestConfig.validate()
    }
}

public struct RequestSpotFleetResponse: Codable, Equatable {
    public var spotFleetRequestId: String?

    public init(spotFleetRequestId: String? = nil) {
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case spotFleetRequestId
    }

    public func validate() throws {
    }
}

public struct RequestSpotInstancesRequest: Codable, Equatable {
    public var availabilityZoneGroup: String?
    public var blockDurationMinutes: Integer?
    public var clientToken: String?
    public var dryRun: Boolean?
    public var instanceCount: Integer?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var launchGroup: String?
    public var launchSpecification: RequestSpotLaunchSpecification?
    public var spotPrice: String?
    public var tagSpecifications: TagSpecificationList?
    public var type: SpotInstanceType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(availabilityZoneGroup: String? = nil,
                blockDurationMinutes: Integer? = nil,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                instanceCount: Integer? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                launchGroup: String? = nil,
                launchSpecification: RequestSpotLaunchSpecification? = nil,
                spotPrice: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                type: SpotInstanceType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.availabilityZoneGroup = availabilityZoneGroup
        self.blockDurationMinutes = blockDurationMinutes
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.instanceCount = instanceCount
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.launchGroup = launchGroup
        self.launchSpecification = launchSpecification
        self.spotPrice = spotPrice
        self.tagSpecifications = tagSpecifications
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZoneGroup
        case blockDurationMinutes
        case clientToken
        case dryRun
        case instanceCount
        case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
        case launchGroup
        case launchSpecification = "LaunchSpecification"
        case spotPrice
        case tagSpecifications = "TagSpecification"
        case type
        case validFrom
        case validUntil
    }

    public func validate() throws {
        try launchSpecification?.validate()
    }
}

public struct RequestSpotInstancesResult: Codable, Equatable {
    public var spotInstanceRequests: SpotInstanceRequestList?

    public init(spotInstanceRequests: SpotInstanceRequestList? = nil) {
        self.spotInstanceRequests = spotInstanceRequests
    }

    enum CodingKeys: String, CodingKey {
        case spotInstanceRequests = "spotInstanceRequestSet"
    }

    public func validate() throws {
    }
}

public struct RequestSpotLaunchSpecification: Codable, Equatable {
    public var addressingType: String?
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var ebsOptimized: Boolean?
    public var iamInstanceProfile: IamInstanceProfileSpecification?
    public var imageId: ImageId?
    public var instanceType: InstanceType?
    public var kernelId: KernelId?
    public var keyName: KeyPairName?
    public var monitoring: RunInstancesMonitoringEnabled?
    public var networkInterfaces: InstanceNetworkInterfaceSpecificationList?
    public var placement: SpotPlacement?
    public var ramdiskId: RamdiskId?
    public var securityGroupIds: RequestSpotLaunchSpecificationSecurityGroupIdList?
    public var securityGroups: RequestSpotLaunchSpecificationSecurityGroupList?
    public var subnetId: SubnetId?
    public var userData: String?

    public init(addressingType: String? = nil,
                blockDeviceMappings: BlockDeviceMappingList? = nil,
                ebsOptimized: Boolean? = nil,
                iamInstanceProfile: IamInstanceProfileSpecification? = nil,
                imageId: ImageId? = nil,
                instanceType: InstanceType? = nil,
                kernelId: KernelId? = nil,
                keyName: KeyPairName? = nil,
                monitoring: RunInstancesMonitoringEnabled? = nil,
                networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil,
                placement: SpotPlacement? = nil,
                ramdiskId: RamdiskId? = nil,
                securityGroupIds: RequestSpotLaunchSpecificationSecurityGroupIdList? = nil,
                securityGroups: RequestSpotLaunchSpecificationSecurityGroupList? = nil,
                subnetId: SubnetId? = nil,
                userData: String? = nil) {
        self.addressingType = addressingType
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramdiskId = ramdiskId
        self.securityGroupIds = securityGroupIds
        self.securityGroups = securityGroups
        self.subnetId = subnetId
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case addressingType
        case blockDeviceMappings = "blockDeviceMapping"
        case ebsOptimized
        case iamInstanceProfile
        case imageId
        case instanceType
        case kernelId
        case keyName
        case monitoring
        case networkInterfaces = "NetworkInterface"
        case placement
        case ramdiskId
        case securityGroupIds = "SecurityGroupId"
        case securityGroups = "SecurityGroup"
        case subnetId
        case userData
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct Reservation: Codable, Equatable {
    public var groups: GroupIdentifierList?
    public var instances: InstanceList?
    public var ownerId: String?
    public var requesterId: String?
    public var reservationId: String?

    public init(groups: GroupIdentifierList? = nil,
                instances: InstanceList? = nil,
                ownerId: String? = nil,
                requesterId: String? = nil,
                reservationId: String? = nil) {
        self.groups = groups
        self.instances = instances
        self.ownerId = ownerId
        self.requesterId = requesterId
        self.reservationId = reservationId
    }

    enum CodingKeys: String, CodingKey {
        case groups = "groupSet"
        case instances = "instancesSet"
        case ownerId
        case requesterId
        case reservationId
    }

    public func validate() throws {
    }
}

public struct ReservationValue: Codable, Equatable {
    public var hourlyPrice: String?
    public var remainingTotalValue: String?
    public var remainingUpfrontValue: String?

    public init(hourlyPrice: String? = nil,
                remainingTotalValue: String? = nil,
                remainingUpfrontValue: String? = nil) {
        self.hourlyPrice = hourlyPrice
        self.remainingTotalValue = remainingTotalValue
        self.remainingUpfrontValue = remainingUpfrontValue
    }

    enum CodingKeys: String, CodingKey {
        case hourlyPrice
        case remainingTotalValue
        case remainingUpfrontValue
    }

    public func validate() throws {
    }
}

public struct ReservedInstanceLimitPrice: Codable, Equatable {
    public var amount: Double?
    public var currencyCode: CurrencyCodeValues?

    public init(amount: Double? = nil,
                currencyCode: CurrencyCodeValues? = nil) {
        self.amount = amount
        self.currencyCode = currencyCode
    }

    enum CodingKeys: String, CodingKey {
        case amount
        case currencyCode
    }

    public func validate() throws {
    }
}

public struct ReservedInstanceReservationValue: Codable, Equatable {
    public var reservationValue: ReservationValue?
    public var reservedInstanceId: String?

    public init(reservationValue: ReservationValue? = nil,
                reservedInstanceId: String? = nil) {
        self.reservationValue = reservationValue
        self.reservedInstanceId = reservedInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case reservationValue
        case reservedInstanceId
    }

    public func validate() throws {
        try reservationValue?.validate()
    }
}

public struct ReservedInstances: Codable, Equatable {
    public var availabilityZone: String?
    public var currencyCode: CurrencyCodeValues?
    public var duration: Long?
    public var end: DateTime?
    public var fixedPrice: Float?
    public var instanceCount: Integer?
    public var instanceTenancy: Tenancy?
    public var instanceType: InstanceType?
    public var offeringClass: OfferingClassType?
    public var offeringType: OfferingTypeValues?
    public var productDescription: RIProductDescription?
    public var recurringCharges: RecurringChargesList?
    public var reservedInstancesId: String?
    public var scope: Scope?
    public var start: DateTime?
    public var state: ReservedInstanceState?
    public var tags: TagList?
    public var usagePrice: Float?

    public init(availabilityZone: String? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                duration: Long? = nil,
                end: DateTime? = nil,
                fixedPrice: Float? = nil,
                instanceCount: Integer? = nil,
                instanceTenancy: Tenancy? = nil,
                instanceType: InstanceType? = nil,
                offeringClass: OfferingClassType? = nil,
                offeringType: OfferingTypeValues? = nil,
                productDescription: RIProductDescription? = nil,
                recurringCharges: RecurringChargesList? = nil,
                reservedInstancesId: String? = nil,
                scope: Scope? = nil,
                start: DateTime? = nil,
                state: ReservedInstanceState? = nil,
                tags: TagList? = nil,
                usagePrice: Float? = nil) {
        self.availabilityZone = availabilityZone
        self.currencyCode = currencyCode
        self.duration = duration
        self.end = end
        self.fixedPrice = fixedPrice
        self.instanceCount = instanceCount
        self.instanceTenancy = instanceTenancy
        self.instanceType = instanceType
        self.offeringClass = offeringClass
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.recurringCharges = recurringCharges
        self.reservedInstancesId = reservedInstancesId
        self.scope = scope
        self.start = start
        self.state = state
        self.tags = tags
        self.usagePrice = usagePrice
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case currencyCode
        case duration
        case end
        case fixedPrice
        case instanceCount
        case instanceTenancy
        case instanceType
        case offeringClass
        case offeringType
        case productDescription
        case recurringCharges
        case reservedInstancesId
        case scope
        case start
        case state
        case tags = "tagSet"
        case usagePrice
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesConfiguration: Codable, Equatable {
    public var availabilityZone: String?
    public var instanceCount: Integer?
    public var instanceType: InstanceType?
    public var platform: String?
    public var scope: Scope?

    public init(availabilityZone: String? = nil,
                instanceCount: Integer? = nil,
                instanceType: InstanceType? = nil,
                platform: String? = nil,
                scope: Scope? = nil) {
        self.availabilityZone = availabilityZone
        self.instanceCount = instanceCount
        self.instanceType = instanceType
        self.platform = platform
        self.scope = scope
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case instanceCount
        case instanceType
        case platform
        case scope
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesId: Codable, Equatable {
    public var reservedInstancesId: String?

    public init(reservedInstancesId: String? = nil) {
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesId
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesListing: Codable, Equatable {
    public var clientToken: String?
    public var createDate: DateTime?
    public var instanceCounts: InstanceCountList?
    public var priceSchedules: PriceScheduleList?
    public var reservedInstancesId: String?
    public var reservedInstancesListingId: String?
    public var status: ListingStatus?
    public var statusMessage: String?
    public var tags: TagList?
    public var updateDate: DateTime?

    public init(clientToken: String? = nil,
                createDate: DateTime? = nil,
                instanceCounts: InstanceCountList? = nil,
                priceSchedules: PriceScheduleList? = nil,
                reservedInstancesId: String? = nil,
                reservedInstancesListingId: String? = nil,
                status: ListingStatus? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil,
                updateDate: DateTime? = nil) {
        self.clientToken = clientToken
        self.createDate = createDate
        self.instanceCounts = instanceCounts
        self.priceSchedules = priceSchedules
        self.reservedInstancesId = reservedInstancesId
        self.reservedInstancesListingId = reservedInstancesListingId
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.updateDate = updateDate
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case createDate
        case instanceCounts
        case priceSchedules
        case reservedInstancesId
        case reservedInstancesListingId
        case status
        case statusMessage
        case tags = "tagSet"
        case updateDate
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesModification: Codable, Equatable {
    public var clientToken: String?
    public var createDate: DateTime?
    public var effectiveDate: DateTime?
    public var modificationResults: ReservedInstancesModificationResultList?
    public var reservedInstancesIds: ReservedIntancesIds?
    public var reservedInstancesModificationId: String?
    public var status: String?
    public var statusMessage: String?
    public var updateDate: DateTime?

    public init(clientToken: String? = nil,
                createDate: DateTime? = nil,
                effectiveDate: DateTime? = nil,
                modificationResults: ReservedInstancesModificationResultList? = nil,
                reservedInstancesIds: ReservedIntancesIds? = nil,
                reservedInstancesModificationId: String? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                updateDate: DateTime? = nil) {
        self.clientToken = clientToken
        self.createDate = createDate
        self.effectiveDate = effectiveDate
        self.modificationResults = modificationResults
        self.reservedInstancesIds = reservedInstancesIds
        self.reservedInstancesModificationId = reservedInstancesModificationId
        self.status = status
        self.statusMessage = statusMessage
        self.updateDate = updateDate
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case createDate
        case effectiveDate
        case modificationResults = "modificationResultSet"
        case reservedInstancesIds = "reservedInstancesSet"
        case reservedInstancesModificationId
        case status
        case statusMessage
        case updateDate
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesModificationResult: Codable, Equatable {
    public var reservedInstancesId: String?
    public var targetConfiguration: ReservedInstancesConfiguration?

    public init(reservedInstancesId: String? = nil,
                targetConfiguration: ReservedInstancesConfiguration? = nil) {
        self.reservedInstancesId = reservedInstancesId
        self.targetConfiguration = targetConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesId
        case targetConfiguration
    }

    public func validate() throws {
        try targetConfiguration?.validate()
    }
}

public struct ReservedInstancesOffering: Codable, Equatable {
    public var availabilityZone: String?
    public var currencyCode: CurrencyCodeValues?
    public var duration: Long?
    public var fixedPrice: Float?
    public var instanceTenancy: Tenancy?
    public var instanceType: InstanceType?
    public var marketplace: Boolean?
    public var offeringClass: OfferingClassType?
    public var offeringType: OfferingTypeValues?
    public var pricingDetails: PricingDetailsList?
    public var productDescription: RIProductDescription?
    public var recurringCharges: RecurringChargesList?
    public var reservedInstancesOfferingId: String?
    public var scope: Scope?
    public var usagePrice: Float?

    public init(availabilityZone: String? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                duration: Long? = nil,
                fixedPrice: Float? = nil,
                instanceTenancy: Tenancy? = nil,
                instanceType: InstanceType? = nil,
                marketplace: Boolean? = nil,
                offeringClass: OfferingClassType? = nil,
                offeringType: OfferingTypeValues? = nil,
                pricingDetails: PricingDetailsList? = nil,
                productDescription: RIProductDescription? = nil,
                recurringCharges: RecurringChargesList? = nil,
                reservedInstancesOfferingId: String? = nil,
                scope: Scope? = nil,
                usagePrice: Float? = nil) {
        self.availabilityZone = availabilityZone
        self.currencyCode = currencyCode
        self.duration = duration
        self.fixedPrice = fixedPrice
        self.instanceTenancy = instanceTenancy
        self.instanceType = instanceType
        self.marketplace = marketplace
        self.offeringClass = offeringClass
        self.offeringType = offeringType
        self.pricingDetails = pricingDetails
        self.productDescription = productDescription
        self.recurringCharges = recurringCharges
        self.reservedInstancesOfferingId = reservedInstancesOfferingId
        self.scope = scope
        self.usagePrice = usagePrice
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case currencyCode
        case duration
        case fixedPrice
        case instanceTenancy
        case instanceType
        case marketplace
        case offeringClass
        case offeringType
        case pricingDetails = "pricingDetailsSet"
        case productDescription
        case recurringCharges
        case reservedInstancesOfferingId
        case scope
        case usagePrice
    }

    public func validate() throws {
    }
}

public struct ResetEbsDefaultKmsKeyIdRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ResetEbsDefaultKmsKeyIdResult: Codable, Equatable {
    public var kmsKeyId: String?

    public init(kmsKeyId: String? = nil) {
        self.kmsKeyId = kmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case kmsKeyId
    }

    public func validate() throws {
    }
}

public struct ResetFpgaImageAttributeRequest: Codable, Equatable {
    public var attribute: ResetFpgaImageAttributeName?
    public var dryRun: Boolean?
    public var fpgaImageId: FpgaImageId

    public init(attribute: ResetFpgaImageAttributeName? = nil,
                dryRun: Boolean? = nil,
                fpgaImageId: FpgaImageId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun = "DryRun"
        case fpgaImageId = "FpgaImageId"
    }

    public func validate() throws {
    }
}

public struct ResetFpgaImageAttributeResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ResetImageAttributeRequest: Codable, Equatable {
    public var attribute: ResetImageAttributeName
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(attribute: ResetImageAttributeName,
                dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct ResetInstanceAttributeRequest: Codable, Equatable {
    public var attribute: InstanceAttributeName
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(attribute: InstanceAttributeName,
                dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case attribute
        case dryRun
        case instanceId
    }

    public func validate() throws {
    }
}

public struct ResetNetworkInterfaceAttributeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId
    public var sourceDestCheck: String?

    public init(dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId,
                sourceDestCheck: String? = nil) {
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
        self.sourceDestCheck = sourceDestCheck
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case networkInterfaceId
        case sourceDestCheck
    }

    public func validate() throws {
    }
}

public struct ResetSnapshotAttributeRequest: Codable, Equatable {
    public var attribute: SnapshotAttributeName
    public var dryRun: Boolean?
    public var snapshotId: SnapshotId

    public init(attribute: SnapshotAttributeName,
                dryRun: Boolean? = nil,
                snapshotId: SnapshotId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case snapshotId = "SnapshotId"
    }

    public func validate() throws {
    }
}

public struct ResponseError: Codable, Equatable {
    public var code: LaunchTemplateErrorCode?
    public var message: String?

    public init(code: LaunchTemplateErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ResponseLaunchTemplateData: Codable, Equatable {
    public var blockDeviceMappings: LaunchTemplateBlockDeviceMappingList?
    public var capacityReservationSpecification: LaunchTemplateCapacityReservationSpecificationResponse?
    public var cpuOptions: LaunchTemplateCpuOptions?
    public var creditSpecification: CreditSpecification?
    public var disableApiTermination: Boolean?
    public var ebsOptimized: Boolean?
    public var elasticGpuSpecifications: ElasticGpuSpecificationResponseList?
    public var elasticInferenceAccelerators: LaunchTemplateElasticInferenceAcceleratorResponseList?
    public var enclaveOptions: LaunchTemplateEnclaveOptions?
    public var hibernationOptions: LaunchTemplateHibernationOptions?
    public var iamInstanceProfile: LaunchTemplateIamInstanceProfileSpecification?
    public var imageId: String?
    public var instanceInitiatedShutdownBehavior: ShutdownBehavior?
    public var instanceMarketOptions: LaunchTemplateInstanceMarketOptions?
    public var instanceType: InstanceType?
    public var kernelId: String?
    public var keyName: String?
    public var licenseSpecifications: LaunchTemplateLicenseList?
    public var metadataOptions: LaunchTemplateInstanceMetadataOptions?
    public var monitoring: LaunchTemplatesMonitoring?
    public var networkInterfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationList?
    public var placement: LaunchTemplatePlacement?
    public var ramDiskId: String?
    public var securityGroupIds: ValueStringList?
    public var securityGroups: ValueStringList?
    public var tagSpecifications: LaunchTemplateTagSpecificationList?
    public var userData: String?

    public init(blockDeviceMappings: LaunchTemplateBlockDeviceMappingList? = nil,
                capacityReservationSpecification: LaunchTemplateCapacityReservationSpecificationResponse? = nil,
                cpuOptions: LaunchTemplateCpuOptions? = nil,
                creditSpecification: CreditSpecification? = nil,
                disableApiTermination: Boolean? = nil,
                ebsOptimized: Boolean? = nil,
                elasticGpuSpecifications: ElasticGpuSpecificationResponseList? = nil,
                elasticInferenceAccelerators: LaunchTemplateElasticInferenceAcceleratorResponseList? = nil,
                enclaveOptions: LaunchTemplateEnclaveOptions? = nil,
                hibernationOptions: LaunchTemplateHibernationOptions? = nil,
                iamInstanceProfile: LaunchTemplateIamInstanceProfileSpecification? = nil,
                imageId: String? = nil,
                instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil,
                instanceMarketOptions: LaunchTemplateInstanceMarketOptions? = nil,
                instanceType: InstanceType? = nil,
                kernelId: String? = nil,
                keyName: String? = nil,
                licenseSpecifications: LaunchTemplateLicenseList? = nil,
                metadataOptions: LaunchTemplateInstanceMetadataOptions? = nil,
                monitoring: LaunchTemplatesMonitoring? = nil,
                networkInterfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationList? = nil,
                placement: LaunchTemplatePlacement? = nil,
                ramDiskId: String? = nil,
                securityGroupIds: ValueStringList? = nil,
                securityGroups: ValueStringList? = nil,
                tagSpecifications: LaunchTemplateTagSpecificationList? = nil,
                userData: String? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.capacityReservationSpecification = capacityReservationSpecification
        self.cpuOptions = cpuOptions
        self.creditSpecification = creditSpecification
        self.disableApiTermination = disableApiTermination
        self.ebsOptimized = ebsOptimized
        self.elasticGpuSpecifications = elasticGpuSpecifications
        self.elasticInferenceAccelerators = elasticInferenceAccelerators
        self.enclaveOptions = enclaveOptions
        self.hibernationOptions = hibernationOptions
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceMarketOptions = instanceMarketOptions
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.licenseSpecifications = licenseSpecifications
        self.metadataOptions = metadataOptions
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramDiskId = ramDiskId
        self.securityGroupIds = securityGroupIds
        self.securityGroups = securityGroups
        self.tagSpecifications = tagSpecifications
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "blockDeviceMappingSet"
        case capacityReservationSpecification
        case cpuOptions
        case creditSpecification
        case disableApiTermination
        case ebsOptimized
        case elasticGpuSpecifications = "elasticGpuSpecificationSet"
        case elasticInferenceAccelerators = "elasticInferenceAcceleratorSet"
        case enclaveOptions
        case hibernationOptions
        case iamInstanceProfile
        case imageId
        case instanceInitiatedShutdownBehavior
        case instanceMarketOptions
        case instanceType
        case kernelId
        case keyName
        case licenseSpecifications = "licenseSet"
        case metadataOptions
        case monitoring
        case networkInterfaces = "networkInterfaceSet"
        case placement
        case ramDiskId
        case securityGroupIds = "securityGroupIdSet"
        case securityGroups = "securityGroupSet"
        case tagSpecifications = "tagSpecificationSet"
        case userData
    }

    public func validate() throws {
        try capacityReservationSpecification?.validate()
        try cpuOptions?.validate()
        try creditSpecification?.validate()
        try enclaveOptions?.validate()
        try hibernationOptions?.validate()
        try iamInstanceProfile?.validate()
        try instanceMarketOptions?.validate()
        try metadataOptions?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct RestoreAddressToClassicRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var publicIp: String

    public init(dryRun: Boolean? = nil,
                publicIp: String) {
        self.dryRun = dryRun
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case publicIp
    }

    public func validate() throws {
    }
}

public struct RestoreAddressToClassicResult: Codable, Equatable {
    public var publicIp: String?
    public var status: Status?

    public init(publicIp: String? = nil,
                status: Status? = nil) {
        self.publicIp = publicIp
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case publicIp
        case status
    }

    public func validate() throws {
    }
}

public struct RestoreManagedPrefixListVersionRequest: Codable, Equatable {
    public var currentVersion: Long
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId
    public var previousVersion: Long

    public init(currentVersion: Long,
                dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId,
                previousVersion: Long) {
        self.currentVersion = currentVersion
        self.dryRun = dryRun
        self.prefixListId = prefixListId
        self.previousVersion = previousVersion
    }

    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
        case previousVersion = "PreviousVersion"
    }

    public func validate() throws {
    }
}

public struct RestoreManagedPrefixListVersionResult: Codable, Equatable {
    public var prefixList: ManagedPrefixList?

    public init(prefixList: ManagedPrefixList? = nil) {
        self.prefixList = prefixList
    }

    enum CodingKeys: String, CodingKey {
        case prefixList
    }

    public func validate() throws {
        try prefixList?.validate()
    }
}

public struct RevokeClientVpnIngressRequest: Codable, Equatable {
    public var accessGroupId: String?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var revokeAllGroups: Boolean?
    public var targetNetworkCidr: String

    public init(accessGroupId: String? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                revokeAllGroups: Boolean? = nil,
                targetNetworkCidr: String) {
        self.accessGroupId = accessGroupId
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.revokeAllGroups = revokeAllGroups
        self.targetNetworkCidr = targetNetworkCidr
    }

    enum CodingKeys: String, CodingKey {
        case accessGroupId = "AccessGroupId"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case revokeAllGroups = "RevokeAllGroups"
        case targetNetworkCidr = "TargetNetworkCidr"
    }

    public func validate() throws {
    }
}

public struct RevokeClientVpnIngressResult: Codable, Equatable {
    public var status: ClientVpnAuthorizationRuleStatus?

    public init(status: ClientVpnAuthorizationRuleStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct RevokeSecurityGroupEgressRequest: Codable, Equatable {
    public var cidrIp: String?
    public var dryRun: Boolean?
    public var fromPort: Integer?
    public var groupId: SecurityGroupId
    public var ipPermissions: IpPermissionList?
    public var ipProtocol: String?
    public var sourceSecurityGroupName: String?
    public var sourceSecurityGroupOwnerId: String?
    public var toPort: Integer?

    public init(cidrIp: String? = nil,
                dryRun: Boolean? = nil,
                fromPort: Integer? = nil,
                groupId: SecurityGroupId,
                ipPermissions: IpPermissionList? = nil,
                ipProtocol: String? = nil,
                sourceSecurityGroupName: String? = nil,
                sourceSecurityGroupOwnerId: String? = nil,
                toPort: Integer? = nil) {
        self.cidrIp = cidrIp
        self.dryRun = dryRun
        self.fromPort = fromPort
        self.groupId = groupId
        self.ipPermissions = ipPermissions
        self.ipProtocol = ipProtocol
        self.sourceSecurityGroupName = sourceSecurityGroupName
        self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp
        case dryRun
        case fromPort
        case groupId
        case ipPermissions
        case ipProtocol
        case sourceSecurityGroupName
        case sourceSecurityGroupOwnerId
        case toPort
    }

    public func validate() throws {
    }
}

public struct RevokeSecurityGroupEgressResult: Codable, Equatable {
    public var `return`: Boolean?
    public var unknownIpPermissions: IpPermissionList?

    public init(`return`: Boolean? = nil,
                unknownIpPermissions: IpPermissionList? = nil) {
        self.`return` = `return`
        self.unknownIpPermissions = unknownIpPermissions
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
        case unknownIpPermissions = "unknownIpPermissionSet"
    }

    public func validate() throws {
    }
}

public struct RevokeSecurityGroupIngressRequest: Codable, Equatable {
    public var cidrIp: String?
    public var dryRun: Boolean?
    public var fromPort: Integer?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?
    public var ipPermissions: IpPermissionList?
    public var ipProtocol: String?
    public var sourceSecurityGroupName: String?
    public var sourceSecurityGroupOwnerId: String?
    public var toPort: Integer?

    public init(cidrIp: String? = nil,
                dryRun: Boolean? = nil,
                fromPort: Integer? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil,
                ipPermissions: IpPermissionList? = nil,
                ipProtocol: String? = nil,
                sourceSecurityGroupName: String? = nil,
                sourceSecurityGroupOwnerId: String? = nil,
                toPort: Integer? = nil) {
        self.cidrIp = cidrIp
        self.dryRun = dryRun
        self.fromPort = fromPort
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
        self.ipProtocol = ipProtocol
        self.sourceSecurityGroupName = sourceSecurityGroupName
        self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp = "CidrIp"
        case dryRun
        case fromPort = "FromPort"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
        case ipProtocol = "IpProtocol"
        case sourceSecurityGroupName = "SourceSecurityGroupName"
        case sourceSecurityGroupOwnerId = "SourceSecurityGroupOwnerId"
        case toPort = "ToPort"
    }

    public func validate() throws {
    }
}

public struct RevokeSecurityGroupIngressResult: Codable, Equatable {
    public var `return`: Boolean?
    public var unknownIpPermissions: IpPermissionList?

    public init(`return`: Boolean? = nil,
                unknownIpPermissions: IpPermissionList? = nil) {
        self.`return` = `return`
        self.unknownIpPermissions = unknownIpPermissions
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
        case unknownIpPermissions = "unknownIpPermissionSet"
    }

    public func validate() throws {
    }
}

public struct Route: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId?
    public var destinationCidrBlock: String?
    public var destinationIpv6CidrBlock: String?
    public var destinationPrefixListId: String?
    public var egressOnlyInternetGatewayId: String?
    public var gatewayId: String?
    public var instanceId: String?
    public var instanceOwnerId: String?
    public var localGatewayId: String?
    public var natGatewayId: String?
    public var networkInterfaceId: String?
    public var origin: RouteOrigin?
    public var state: RouteState?
    public var transitGatewayId: String?
    public var vpcPeeringConnectionId: String?

    public init(carrierGatewayId: CarrierGatewayId? = nil,
                destinationCidrBlock: String? = nil,
                destinationIpv6CidrBlock: String? = nil,
                destinationPrefixListId: String? = nil,
                egressOnlyInternetGatewayId: String? = nil,
                gatewayId: String? = nil,
                instanceId: String? = nil,
                instanceOwnerId: String? = nil,
                localGatewayId: String? = nil,
                natGatewayId: String? = nil,
                networkInterfaceId: String? = nil,
                origin: RouteOrigin? = nil,
                state: RouteState? = nil,
                transitGatewayId: String? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        self.destinationPrefixListId = destinationPrefixListId
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.gatewayId = gatewayId
        self.instanceId = instanceId
        self.instanceOwnerId = instanceOwnerId
        self.localGatewayId = localGatewayId
        self.natGatewayId = natGatewayId
        self.networkInterfaceId = networkInterfaceId
        self.origin = origin
        self.state = state
        self.transitGatewayId = transitGatewayId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId
        case destinationCidrBlock
        case destinationIpv6CidrBlock
        case destinationPrefixListId
        case egressOnlyInternetGatewayId
        case gatewayId
        case instanceId
        case instanceOwnerId
        case localGatewayId
        case natGatewayId
        case networkInterfaceId
        case origin
        case state
        case transitGatewayId
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct RouteTable: Codable, Equatable {
    public var associations: RouteTableAssociationList?
    public var ownerId: String?
    public var propagatingVgws: PropagatingVgwList?
    public var routeTableId: String?
    public var routes: RouteList?
    public var tags: TagList?
    public var vpcId: String?

    public init(associations: RouteTableAssociationList? = nil,
                ownerId: String? = nil,
                propagatingVgws: PropagatingVgwList? = nil,
                routeTableId: String? = nil,
                routes: RouteList? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.associations = associations
        self.ownerId = ownerId
        self.propagatingVgws = propagatingVgws
        self.routeTableId = routeTableId
        self.routes = routes
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case associations = "associationSet"
        case ownerId
        case propagatingVgws = "propagatingVgwSet"
        case routeTableId
        case routes = "routeSet"
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct RouteTableAssociation: Codable, Equatable {
    public var associationState: RouteTableAssociationState?
    public var gatewayId: String?
    public var main: Boolean?
    public var routeTableAssociationId: String?
    public var routeTableId: String?
    public var subnetId: String?

    public init(associationState: RouteTableAssociationState? = nil,
                gatewayId: String? = nil,
                main: Boolean? = nil,
                routeTableAssociationId: String? = nil,
                routeTableId: String? = nil,
                subnetId: String? = nil) {
        self.associationState = associationState
        self.gatewayId = gatewayId
        self.main = main
        self.routeTableAssociationId = routeTableAssociationId
        self.routeTableId = routeTableId
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associationState
        case gatewayId
        case main
        case routeTableAssociationId
        case routeTableId
        case subnetId
    }

    public func validate() throws {
        try associationState?.validate()
    }
}

public struct RouteTableAssociationState: Codable, Equatable {
    public var state: RouteTableAssociationStateCode?
    public var statusMessage: String?

    public init(state: RouteTableAssociationStateCode? = nil,
                statusMessage: String? = nil) {
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct RunInstancesMonitoringEnabled: Codable, Equatable {
    public var enabled: Boolean

    public init(enabled: Boolean) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct RunInstancesRequest: Codable, Equatable {
    public var additionalInfo: String?
    public var blockDeviceMappings: BlockDeviceMappingRequestList?
    public var capacityReservationSpecification: CapacityReservationSpecification?
    public var clientToken: String?
    public var cpuOptions: CpuOptionsRequest?
    public var creditSpecification: CreditSpecificationRequest?
    public var disableApiTermination: Boolean?
    public var dryRun: Boolean?
    public var ebsOptimized: Boolean?
    public var elasticGpuSpecification: ElasticGpuSpecifications?
    public var elasticInferenceAccelerators: ElasticInferenceAccelerators?
    public var enclaveOptions: EnclaveOptionsRequest?
    public var hibernationOptions: HibernationOptionsRequest?
    public var iamInstanceProfile: IamInstanceProfileSpecification?
    public var imageId: ImageId?
    public var instanceInitiatedShutdownBehavior: ShutdownBehavior?
    public var instanceMarketOptions: InstanceMarketOptionsRequest?
    public var instanceType: InstanceType?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var kernelId: KernelId?
    public var keyName: KeyPairName?
    public var launchTemplate: LaunchTemplateSpecification?
    public var licenseSpecifications: LicenseSpecificationListRequest?
    public var maxCount: Integer
    public var metadataOptions: InstanceMetadataOptionsRequest?
    public var minCount: Integer
    public var monitoring: RunInstancesMonitoringEnabled?
    public var networkInterfaces: InstanceNetworkInterfaceSpecificationList?
    public var placement: Placement?
    public var privateIpAddress: String?
    public var ramdiskId: RamdiskId?
    public var securityGroupIds: SecurityGroupIdStringList?
    public var securityGroups: SecurityGroupStringList?
    public var subnetId: SubnetId?
    public var tagSpecifications: TagSpecificationList?
    public var userData: String?

    public init(additionalInfo: String? = nil,
                blockDeviceMappings: BlockDeviceMappingRequestList? = nil,
                capacityReservationSpecification: CapacityReservationSpecification? = nil,
                clientToken: String? = nil,
                cpuOptions: CpuOptionsRequest? = nil,
                creditSpecification: CreditSpecificationRequest? = nil,
                disableApiTermination: Boolean? = nil,
                dryRun: Boolean? = nil,
                ebsOptimized: Boolean? = nil,
                elasticGpuSpecification: ElasticGpuSpecifications? = nil,
                elasticInferenceAccelerators: ElasticInferenceAccelerators? = nil,
                enclaveOptions: EnclaveOptionsRequest? = nil,
                hibernationOptions: HibernationOptionsRequest? = nil,
                iamInstanceProfile: IamInstanceProfileSpecification? = nil,
                imageId: ImageId? = nil,
                instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil,
                instanceMarketOptions: InstanceMarketOptionsRequest? = nil,
                instanceType: InstanceType? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                kernelId: KernelId? = nil,
                keyName: KeyPairName? = nil,
                launchTemplate: LaunchTemplateSpecification? = nil,
                licenseSpecifications: LicenseSpecificationListRequest? = nil,
                maxCount: Integer,
                metadataOptions: InstanceMetadataOptionsRequest? = nil,
                minCount: Integer,
                monitoring: RunInstancesMonitoringEnabled? = nil,
                networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil,
                placement: Placement? = nil,
                privateIpAddress: String? = nil,
                ramdiskId: RamdiskId? = nil,
                securityGroupIds: SecurityGroupIdStringList? = nil,
                securityGroups: SecurityGroupStringList? = nil,
                subnetId: SubnetId? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                userData: String? = nil) {
        self.additionalInfo = additionalInfo
        self.blockDeviceMappings = blockDeviceMappings
        self.capacityReservationSpecification = capacityReservationSpecification
        self.clientToken = clientToken
        self.cpuOptions = cpuOptions
        self.creditSpecification = creditSpecification
        self.disableApiTermination = disableApiTermination
        self.dryRun = dryRun
        self.ebsOptimized = ebsOptimized
        self.elasticGpuSpecification = elasticGpuSpecification
        self.elasticInferenceAccelerators = elasticInferenceAccelerators
        self.enclaveOptions = enclaveOptions
        self.hibernationOptions = hibernationOptions
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceMarketOptions = instanceMarketOptions
        self.instanceType = instanceType
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.kernelId = kernelId
        self.keyName = keyName
        self.launchTemplate = launchTemplate
        self.licenseSpecifications = licenseSpecifications
        self.maxCount = maxCount
        self.metadataOptions = metadataOptions
        self.minCount = minCount
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.privateIpAddress = privateIpAddress
        self.ramdiskId = ramdiskId
        self.securityGroupIds = securityGroupIds
        self.securityGroups = securityGroups
        self.subnetId = subnetId
        self.tagSpecifications = tagSpecifications
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case additionalInfo
        case blockDeviceMappings = "BlockDeviceMapping"
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case clientToken
        case cpuOptions = "CpuOptions"
        case creditSpecification = "CreditSpecification"
        case disableApiTermination
        case dryRun
        case ebsOptimized
        case elasticGpuSpecification = "ElasticGpuSpecification"
        case elasticInferenceAccelerators = "ElasticInferenceAccelerator"
        case enclaveOptions = "EnclaveOptions"
        case hibernationOptions = "HibernationOptions"
        case iamInstanceProfile
        case imageId = "ImageId"
        case instanceInitiatedShutdownBehavior
        case instanceMarketOptions = "InstanceMarketOptions"
        case instanceType = "InstanceType"
        case ipv6AddressCount = "Ipv6AddressCount"
        case ipv6Addresses = "Ipv6Address"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case launchTemplate = "LaunchTemplate"
        case licenseSpecifications = "LicenseSpecification"
        case maxCount = "MaxCount"
        case metadataOptions = "MetadataOptions"
        case minCount = "MinCount"
        case monitoring = "Monitoring"
        case networkInterfaces = "networkInterface"
        case placement = "Placement"
        case privateIpAddress
        case ramdiskId = "RamdiskId"
        case securityGroupIds = "SecurityGroupId"
        case securityGroups = "SecurityGroup"
        case subnetId = "SubnetId"
        case tagSpecifications = "TagSpecification"
        case userData = "UserData"
    }

    public func validate() throws {
        try capacityReservationSpecification?.validate()
        try cpuOptions?.validate()
        try creditSpecification?.validate()
        try enclaveOptions?.validate()
        try hibernationOptions?.validate()
        try iamInstanceProfile?.validate()
        try instanceMarketOptions?.validate()
        try launchTemplate?.validate()
        try metadataOptions?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct RunScheduledInstancesRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var instanceCount: Integer?
    public var launchSpecification: ScheduledInstancesLaunchSpecification
    public var scheduledInstanceId: ScheduledInstanceId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                instanceCount: Integer? = nil,
                launchSpecification: ScheduledInstancesLaunchSpecification,
                scheduledInstanceId: ScheduledInstanceId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.instanceCount = instanceCount
        self.launchSpecification = launchSpecification
        self.scheduledInstanceId = scheduledInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case instanceCount = "InstanceCount"
        case launchSpecification = "LaunchSpecification"
        case scheduledInstanceId = "ScheduledInstanceId"
    }

    public func validate() throws {
        try launchSpecification.validate()
    }
}

public struct RunScheduledInstancesResult: Codable, Equatable {
    public var instanceIdSet: InstanceIdSet?

    public init(instanceIdSet: InstanceIdSet? = nil) {
        self.instanceIdSet = instanceIdSet
    }

    enum CodingKeys: String, CodingKey {
        case instanceIdSet
    }

    public func validate() throws {
    }
}

public struct S3Storage: Codable, Equatable {
    public var aWSAccessKeyId: String?
    public var bucket: String?
    public var prefix: String?
    public var uploadPolicy: Blob?
    public var uploadPolicySignature: String?

    public init(aWSAccessKeyId: String? = nil,
                bucket: String? = nil,
                prefix: String? = nil,
                uploadPolicy: Blob? = nil,
                uploadPolicySignature: String? = nil) {
        self.aWSAccessKeyId = aWSAccessKeyId
        self.bucket = bucket
        self.prefix = prefix
        self.uploadPolicy = uploadPolicy
        self.uploadPolicySignature = uploadPolicySignature
    }

    enum CodingKeys: String, CodingKey {
        case aWSAccessKeyId = "AWSAccessKeyId"
        case bucket
        case prefix
        case uploadPolicy
        case uploadPolicySignature
    }

    public func validate() throws {
    }
}

public struct ScheduledInstance: Codable, Equatable {
    public var availabilityZone: String?
    public var createDate: DateTime?
    public var hourlyPrice: String?
    public var instanceCount: Integer?
    public var instanceType: String?
    public var networkPlatform: String?
    public var nextSlotStartTime: DateTime?
    public var platform: String?
    public var previousSlotEndTime: DateTime?
    public var recurrence: ScheduledInstanceRecurrence?
    public var scheduledInstanceId: String?
    public var slotDurationInHours: Integer?
    public var termEndDate: DateTime?
    public var termStartDate: DateTime?
    public var totalScheduledInstanceHours: Integer?

    public init(availabilityZone: String? = nil,
                createDate: DateTime? = nil,
                hourlyPrice: String? = nil,
                instanceCount: Integer? = nil,
                instanceType: String? = nil,
                networkPlatform: String? = nil,
                nextSlotStartTime: DateTime? = nil,
                platform: String? = nil,
                previousSlotEndTime: DateTime? = nil,
                recurrence: ScheduledInstanceRecurrence? = nil,
                scheduledInstanceId: String? = nil,
                slotDurationInHours: Integer? = nil,
                termEndDate: DateTime? = nil,
                termStartDate: DateTime? = nil,
                totalScheduledInstanceHours: Integer? = nil) {
        self.availabilityZone = availabilityZone
        self.createDate = createDate
        self.hourlyPrice = hourlyPrice
        self.instanceCount = instanceCount
        self.instanceType = instanceType
        self.networkPlatform = networkPlatform
        self.nextSlotStartTime = nextSlotStartTime
        self.platform = platform
        self.previousSlotEndTime = previousSlotEndTime
        self.recurrence = recurrence
        self.scheduledInstanceId = scheduledInstanceId
        self.slotDurationInHours = slotDurationInHours
        self.termEndDate = termEndDate
        self.termStartDate = termStartDate
        self.totalScheduledInstanceHours = totalScheduledInstanceHours
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case createDate
        case hourlyPrice
        case instanceCount
        case instanceType
        case networkPlatform
        case nextSlotStartTime
        case platform
        case previousSlotEndTime
        case recurrence
        case scheduledInstanceId
        case slotDurationInHours
        case termEndDate
        case termStartDate
        case totalScheduledInstanceHours
    }

    public func validate() throws {
        try recurrence?.validate()
    }
}

public struct ScheduledInstanceAvailability: Codable, Equatable {
    public var availabilityZone: String?
    public var availableInstanceCount: Integer?
    public var firstSlotStartTime: DateTime?
    public var hourlyPrice: String?
    public var instanceType: String?
    public var maxTermDurationInDays: Integer?
    public var minTermDurationInDays: Integer?
    public var networkPlatform: String?
    public var platform: String?
    public var purchaseToken: String?
    public var recurrence: ScheduledInstanceRecurrence?
    public var slotDurationInHours: Integer?
    public var totalScheduledInstanceHours: Integer?

    public init(availabilityZone: String? = nil,
                availableInstanceCount: Integer? = nil,
                firstSlotStartTime: DateTime? = nil,
                hourlyPrice: String? = nil,
                instanceType: String? = nil,
                maxTermDurationInDays: Integer? = nil,
                minTermDurationInDays: Integer? = nil,
                networkPlatform: String? = nil,
                platform: String? = nil,
                purchaseToken: String? = nil,
                recurrence: ScheduledInstanceRecurrence? = nil,
                slotDurationInHours: Integer? = nil,
                totalScheduledInstanceHours: Integer? = nil) {
        self.availabilityZone = availabilityZone
        self.availableInstanceCount = availableInstanceCount
        self.firstSlotStartTime = firstSlotStartTime
        self.hourlyPrice = hourlyPrice
        self.instanceType = instanceType
        self.maxTermDurationInDays = maxTermDurationInDays
        self.minTermDurationInDays = minTermDurationInDays
        self.networkPlatform = networkPlatform
        self.platform = platform
        self.purchaseToken = purchaseToken
        self.recurrence = recurrence
        self.slotDurationInHours = slotDurationInHours
        self.totalScheduledInstanceHours = totalScheduledInstanceHours
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case availableInstanceCount
        case firstSlotStartTime
        case hourlyPrice
        case instanceType
        case maxTermDurationInDays
        case minTermDurationInDays
        case networkPlatform
        case platform
        case purchaseToken
        case recurrence
        case slotDurationInHours
        case totalScheduledInstanceHours
    }

    public func validate() throws {
        try recurrence?.validate()
    }
}

public struct ScheduledInstanceRecurrence: Codable, Equatable {
    public var frequency: String?
    public var interval: Integer?
    public var occurrenceDaySet: OccurrenceDaySet?
    public var occurrenceRelativeToEnd: Boolean?
    public var occurrenceUnit: String?

    public init(frequency: String? = nil,
                interval: Integer? = nil,
                occurrenceDaySet: OccurrenceDaySet? = nil,
                occurrenceRelativeToEnd: Boolean? = nil,
                occurrenceUnit: String? = nil) {
        self.frequency = frequency
        self.interval = interval
        self.occurrenceDaySet = occurrenceDaySet
        self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
        self.occurrenceUnit = occurrenceUnit
    }

    enum CodingKeys: String, CodingKey {
        case frequency
        case interval
        case occurrenceDaySet
        case occurrenceRelativeToEnd
        case occurrenceUnit
    }

    public func validate() throws {
    }
}

public struct ScheduledInstanceRecurrenceRequest: Codable, Equatable {
    public var frequency: String?
    public var interval: Integer?
    public var occurrenceDays: OccurrenceDayRequestSet?
    public var occurrenceRelativeToEnd: Boolean?
    public var occurrenceUnit: String?

    public init(frequency: String? = nil,
                interval: Integer? = nil,
                occurrenceDays: OccurrenceDayRequestSet? = nil,
                occurrenceRelativeToEnd: Boolean? = nil,
                occurrenceUnit: String? = nil) {
        self.frequency = frequency
        self.interval = interval
        self.occurrenceDays = occurrenceDays
        self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
        self.occurrenceUnit = occurrenceUnit
    }

    enum CodingKeys: String, CodingKey {
        case frequency = "Frequency"
        case interval = "Interval"
        case occurrenceDays = "OccurrenceDay"
        case occurrenceRelativeToEnd = "OccurrenceRelativeToEnd"
        case occurrenceUnit = "OccurrenceUnit"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesBlockDeviceMapping: Codable, Equatable {
    public var deviceName: String?
    public var ebs: ScheduledInstancesEbs?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: ScheduledInstancesEbs? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName = "DeviceName"
        case ebs = "Ebs"
        case noDevice = "NoDevice"
        case virtualName = "VirtualName"
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct ScheduledInstancesEbs: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var snapshotId: SnapshotId?
    public var volumeSize: Integer?
    public var volumeType: String?

    public init(deleteOnTermination: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                snapshotId: SnapshotId? = nil,
                volumeSize: Integer? = nil,
                volumeType: String? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.encrypted = encrypted
        self.iops = iops
        self.snapshotId = snapshotId
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination = "DeleteOnTermination"
        case encrypted = "Encrypted"
        case iops = "Iops"
        case snapshotId = "SnapshotId"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesIamInstanceProfile: Codable, Equatable {
    public var arn: String?
    public var name: String?

    public init(arn: String? = nil,
                name: String? = nil) {
        self.arn = arn
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesIpv6Address: Codable, Equatable {
    public var ipv6Address: Ipv6Address?

    public init(ipv6Address: Ipv6Address? = nil) {
        self.ipv6Address = ipv6Address
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Address = "Ipv6Address"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesLaunchSpecification: Codable, Equatable {
    public var blockDeviceMappings: ScheduledInstancesBlockDeviceMappingSet?
    public var ebsOptimized: Boolean?
    public var iamInstanceProfile: ScheduledInstancesIamInstanceProfile?
    public var imageId: ImageId
    public var instanceType: String?
    public var kernelId: KernelId?
    public var keyName: KeyPairName?
    public var monitoring: ScheduledInstancesMonitoring?
    public var networkInterfaces: ScheduledInstancesNetworkInterfaceSet?
    public var placement: ScheduledInstancesPlacement?
    public var ramdiskId: RamdiskId?
    public var securityGroupIds: ScheduledInstancesSecurityGroupIdSet?
    public var subnetId: SubnetId?
    public var userData: String?

    public init(blockDeviceMappings: ScheduledInstancesBlockDeviceMappingSet? = nil,
                ebsOptimized: Boolean? = nil,
                iamInstanceProfile: ScheduledInstancesIamInstanceProfile? = nil,
                imageId: ImageId,
                instanceType: String? = nil,
                kernelId: KernelId? = nil,
                keyName: KeyPairName? = nil,
                monitoring: ScheduledInstancesMonitoring? = nil,
                networkInterfaces: ScheduledInstancesNetworkInterfaceSet? = nil,
                placement: ScheduledInstancesPlacement? = nil,
                ramdiskId: RamdiskId? = nil,
                securityGroupIds: ScheduledInstancesSecurityGroupIdSet? = nil,
                subnetId: SubnetId? = nil,
                userData: String? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramdiskId = ramdiskId
        self.securityGroupIds = securityGroupIds
        self.subnetId = subnetId
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "BlockDeviceMapping"
        case ebsOptimized = "EbsOptimized"
        case iamInstanceProfile = "IamInstanceProfile"
        case imageId = "ImageId"
        case instanceType = "InstanceType"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case monitoring = "Monitoring"
        case networkInterfaces = "NetworkInterface"
        case placement = "Placement"
        case ramdiskId = "RamdiskId"
        case securityGroupIds = "SecurityGroupId"
        case subnetId = "SubnetId"
        case userData = "UserData"
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct ScheduledInstancesMonitoring: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesNetworkInterface: Codable, Equatable {
    public var associatePublicIpAddress: Boolean?
    public var deleteOnTermination: Boolean?
    public var description: String?
    public var deviceIndex: Integer?
    public var groups: ScheduledInstancesSecurityGroupIdSet?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: ScheduledInstancesIpv6AddressList?
    public var networkInterfaceId: NetworkInterfaceId?
    public var privateIpAddress: String?
    public var privateIpAddressConfigs: PrivateIpAddressConfigSet?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: SubnetId?

    public init(associatePublicIpAddress: Boolean? = nil,
                deleteOnTermination: Boolean? = nil,
                description: String? = nil,
                deviceIndex: Integer? = nil,
                groups: ScheduledInstancesSecurityGroupIdSet? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: ScheduledInstancesIpv6AddressList? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                privateIpAddress: String? = nil,
                privateIpAddressConfigs: PrivateIpAddressConfigSet? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: SubnetId? = nil) {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.deleteOnTermination = deleteOnTermination
        self.description = description
        self.deviceIndex = deviceIndex
        self.groups = groups
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.privateIpAddressConfigs = privateIpAddressConfigs
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case deleteOnTermination = "DeleteOnTermination"
        case description = "Description"
        case deviceIndex = "DeviceIndex"
        case groups = "Group"
        case ipv6AddressCount = "Ipv6AddressCount"
        case ipv6Addresses = "Ipv6Address"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddress = "PrivateIpAddress"
        case privateIpAddressConfigs = "PrivateIpAddressConfig"
        case secondaryPrivateIpAddressCount = "SecondaryPrivateIpAddressCount"
        case subnetId = "SubnetId"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesPlacement: Codable, Equatable {
    public var availabilityZone: String?
    public var groupName: PlacementGroupName?

    public init(availabilityZone: String? = nil,
                groupName: PlacementGroupName? = nil) {
        self.availabilityZone = availabilityZone
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case groupName = "GroupName"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesPrivateIpAddressConfig: Codable, Equatable {
    public var primary: Boolean?
    public var privateIpAddress: String?

    public init(primary: Boolean? = nil,
                privateIpAddress: String? = nil) {
        self.primary = primary
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case primary = "Primary"
        case privateIpAddress = "PrivateIpAddress"
    }

    public func validate() throws {
    }
}

public struct SearchLocalGatewayRoutesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList
    public var localGatewayRouteTableId: LocalGatewayRoutetableId
    public var maxResults: MaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList,
                localGatewayRouteTableId: LocalGatewayRoutetableId,
                maxResults: MaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct SearchLocalGatewayRoutesResult: Codable, Equatable {
    public var nextToken: String?
    public var routes: LocalGatewayRouteList?

    public init(nextToken: String? = nil,
                routes: LocalGatewayRouteList? = nil) {
        self.nextToken = nextToken
        self.routes = routes
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case routes = "routeSet"
    }

    public func validate() throws {
    }
}

public struct SearchTransitGatewayMulticastGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct SearchTransitGatewayMulticastGroupsResult: Codable, Equatable {
    public var multicastGroups: TransitGatewayMulticastGroupList?
    public var nextToken: String?

    public init(multicastGroups: TransitGatewayMulticastGroupList? = nil,
                nextToken: String? = nil) {
        self.multicastGroups = multicastGroups
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case multicastGroups
        case nextToken
    }

    public func validate() throws {
    }
}

public struct SearchTransitGatewayRoutesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList
    public var maxResults: TransitGatewayMaxResults?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList,
                maxResults: TransitGatewayMaxResults? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct SearchTransitGatewayRoutesResult: Codable, Equatable {
    public var additionalRoutesAvailable: Boolean?
    public var routes: TransitGatewayRouteList?

    public init(additionalRoutesAvailable: Boolean? = nil,
                routes: TransitGatewayRouteList? = nil) {
        self.additionalRoutesAvailable = additionalRoutesAvailable
        self.routes = routes
    }

    enum CodingKeys: String, CodingKey {
        case additionalRoutesAvailable
        case routes = "routeSet"
    }

    public func validate() throws {
    }
}

public struct SecurityGroup: Codable, Equatable {
    public var description: String?
    public var groupId: String?
    public var groupName: String?
    public var ipPermissions: IpPermissionList?
    public var ipPermissionsEgress: IpPermissionList?
    public var ownerId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(description: String? = nil,
                groupId: String? = nil,
                groupName: String? = nil,
                ipPermissions: IpPermissionList? = nil,
                ipPermissionsEgress: IpPermissionList? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.description = description
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
        self.ipPermissionsEgress = ipPermissionsEgress
        self.ownerId = ownerId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case description = "groupDescription"
        case groupId
        case groupName
        case ipPermissions
        case ipPermissionsEgress
        case ownerId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct SecurityGroupIdentifier: Codable, Equatable {
    public var groupId: String?
    public var groupName: String?

    public init(groupId: String? = nil,
                groupName: String? = nil) {
        self.groupId = groupId
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case groupName
    }

    public func validate() throws {
    }
}

public struct SecurityGroupReference: Codable, Equatable {
    public var groupId: String?
    public var referencingVpcId: String?
    public var vpcPeeringConnectionId: String?

    public init(groupId: String? = nil,
                referencingVpcId: String? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.groupId = groupId
        self.referencingVpcId = referencingVpcId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case referencingVpcId
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct SendDiagnosticInterruptRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct ServiceConfiguration: Codable, Equatable {
    public var acceptanceRequired: Boolean?
    public var availabilityZones: ValueStringList?
    public var baseEndpointDnsNames: ValueStringList?
    public var gatewayLoadBalancerArns: ValueStringList?
    public var managesVpcEndpoints: Boolean?
    public var networkLoadBalancerArns: ValueStringList?
    public var privateDnsName: String?
    public var privateDnsNameConfiguration: PrivateDnsNameConfiguration?
    public var serviceId: String?
    public var serviceName: String?
    public var serviceState: ServiceState?
    public var serviceType: ServiceTypeDetailSet?
    public var tags: TagList?

    public init(acceptanceRequired: Boolean? = nil,
                availabilityZones: ValueStringList? = nil,
                baseEndpointDnsNames: ValueStringList? = nil,
                gatewayLoadBalancerArns: ValueStringList? = nil,
                managesVpcEndpoints: Boolean? = nil,
                networkLoadBalancerArns: ValueStringList? = nil,
                privateDnsName: String? = nil,
                privateDnsNameConfiguration: PrivateDnsNameConfiguration? = nil,
                serviceId: String? = nil,
                serviceName: String? = nil,
                serviceState: ServiceState? = nil,
                serviceType: ServiceTypeDetailSet? = nil,
                tags: TagList? = nil) {
        self.acceptanceRequired = acceptanceRequired
        self.availabilityZones = availabilityZones
        self.baseEndpointDnsNames = baseEndpointDnsNames
        self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
        self.managesVpcEndpoints = managesVpcEndpoints
        self.networkLoadBalancerArns = networkLoadBalancerArns
        self.privateDnsName = privateDnsName
        self.privateDnsNameConfiguration = privateDnsNameConfiguration
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceState = serviceState
        self.serviceType = serviceType
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case acceptanceRequired
        case availabilityZones = "availabilityZoneSet"
        case baseEndpointDnsNames = "baseEndpointDnsNameSet"
        case gatewayLoadBalancerArns = "gatewayLoadBalancerArnSet"
        case managesVpcEndpoints
        case networkLoadBalancerArns = "networkLoadBalancerArnSet"
        case privateDnsName
        case privateDnsNameConfiguration
        case serviceId
        case serviceName
        case serviceState
        case serviceType
        case tags = "tagSet"
    }

    public func validate() throws {
        try privateDnsNameConfiguration?.validate()
    }
}

public struct ServiceDetail: Codable, Equatable {
    public var acceptanceRequired: Boolean?
    public var availabilityZones: ValueStringList?
    public var baseEndpointDnsNames: ValueStringList?
    public var managesVpcEndpoints: Boolean?
    public var owner: String?
    public var privateDnsName: String?
    public var privateDnsNameVerificationState: DnsNameState?
    public var privateDnsNames: PrivateDnsDetailsSet?
    public var serviceId: String?
    public var serviceName: String?
    public var serviceType: ServiceTypeDetailSet?
    public var tags: TagList?
    public var vpcEndpointPolicySupported: Boolean?

    public init(acceptanceRequired: Boolean? = nil,
                availabilityZones: ValueStringList? = nil,
                baseEndpointDnsNames: ValueStringList? = nil,
                managesVpcEndpoints: Boolean? = nil,
                owner: String? = nil,
                privateDnsName: String? = nil,
                privateDnsNameVerificationState: DnsNameState? = nil,
                privateDnsNames: PrivateDnsDetailsSet? = nil,
                serviceId: String? = nil,
                serviceName: String? = nil,
                serviceType: ServiceTypeDetailSet? = nil,
                tags: TagList? = nil,
                vpcEndpointPolicySupported: Boolean? = nil) {
        self.acceptanceRequired = acceptanceRequired
        self.availabilityZones = availabilityZones
        self.baseEndpointDnsNames = baseEndpointDnsNames
        self.managesVpcEndpoints = managesVpcEndpoints
        self.owner = owner
        self.privateDnsName = privateDnsName
        self.privateDnsNameVerificationState = privateDnsNameVerificationState
        self.privateDnsNames = privateDnsNames
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceType = serviceType
        self.tags = tags
        self.vpcEndpointPolicySupported = vpcEndpointPolicySupported
    }

    enum CodingKeys: String, CodingKey {
        case acceptanceRequired
        case availabilityZones = "availabilityZoneSet"
        case baseEndpointDnsNames = "baseEndpointDnsNameSet"
        case managesVpcEndpoints
        case owner
        case privateDnsName
        case privateDnsNameVerificationState
        case privateDnsNames = "privateDnsNameSet"
        case serviceId
        case serviceName
        case serviceType
        case tags = "tagSet"
        case vpcEndpointPolicySupported
    }

    public func validate() throws {
    }
}

public struct ServiceTypeDetail: Codable, Equatable {
    public var serviceType: ServiceType?

    public init(serviceType: ServiceType? = nil) {
        self.serviceType = serviceType
    }

    enum CodingKeys: String, CodingKey {
        case serviceType
    }

    public func validate() throws {
    }
}

public struct SlotDateTimeRangeRequest: Codable, Equatable {
    public var earliestTime: DateTime
    public var latestTime: DateTime

    public init(earliestTime: DateTime,
                latestTime: DateTime) {
        self.earliestTime = earliestTime
        self.latestTime = latestTime
    }

    enum CodingKeys: String, CodingKey {
        case earliestTime = "EarliestTime"
        case latestTime = "LatestTime"
    }

    public func validate() throws {
    }
}

public struct SlotStartTimeRangeRequest: Codable, Equatable {
    public var earliestTime: DateTime?
    public var latestTime: DateTime?

    public init(earliestTime: DateTime? = nil,
                latestTime: DateTime? = nil) {
        self.earliestTime = earliestTime
        self.latestTime = latestTime
    }

    enum CodingKeys: String, CodingKey {
        case earliestTime = "EarliestTime"
        case latestTime = "LatestTime"
    }

    public func validate() throws {
    }
}

public struct Snapshot: Codable, Equatable {
    public var dataEncryptionKeyId: String?
    public var description: String?
    public var encrypted: Boolean?
    public var kmsKeyId: String?
    public var ownerAlias: String?
    public var ownerId: String?
    public var progress: String?
    public var snapshotId: String?
    public var startTime: DateTime?
    public var state: SnapshotState?
    public var stateMessage: String?
    public var tags: TagList?
    public var volumeId: String?
    public var volumeSize: Integer?

    public init(dataEncryptionKeyId: String? = nil,
                description: String? = nil,
                encrypted: Boolean? = nil,
                kmsKeyId: String? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                progress: String? = nil,
                snapshotId: String? = nil,
                startTime: DateTime? = nil,
                state: SnapshotState? = nil,
                stateMessage: String? = nil,
                tags: TagList? = nil,
                volumeId: String? = nil,
                volumeSize: Integer? = nil) {
        self.dataEncryptionKeyId = dataEncryptionKeyId
        self.description = description
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.progress = progress
        self.snapshotId = snapshotId
        self.startTime = startTime
        self.state = state
        self.stateMessage = stateMessage
        self.tags = tags
        self.volumeId = volumeId
        self.volumeSize = volumeSize
    }

    enum CodingKeys: String, CodingKey {
        case dataEncryptionKeyId
        case description
        case encrypted
        case kmsKeyId
        case ownerAlias
        case ownerId
        case progress
        case snapshotId
        case startTime
        case state = "status"
        case stateMessage = "statusMessage"
        case tags = "tagSet"
        case volumeId
        case volumeSize
    }

    public func validate() throws {
    }
}

public struct SnapshotDetail: Codable, Equatable {
    public var description: String?
    public var deviceName: String?
    public var diskImageSize: Double?
    public var format: String?
    public var progress: String?
    public var snapshotId: String?
    public var status: String?
    public var statusMessage: String?
    public var url: String?
    public var userBucket: UserBucketDetails?

    public init(description: String? = nil,
                deviceName: String? = nil,
                diskImageSize: Double? = nil,
                format: String? = nil,
                progress: String? = nil,
                snapshotId: String? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                url: String? = nil,
                userBucket: UserBucketDetails? = nil) {
        self.description = description
        self.deviceName = deviceName
        self.diskImageSize = diskImageSize
        self.format = format
        self.progress = progress
        self.snapshotId = snapshotId
        self.status = status
        self.statusMessage = statusMessage
        self.url = url
        self.userBucket = userBucket
    }

    enum CodingKeys: String, CodingKey {
        case description
        case deviceName
        case diskImageSize
        case format
        case progress
        case snapshotId
        case status
        case statusMessage
        case url
        case userBucket
    }

    public func validate() throws {
        try userBucket?.validate()
    }
}

public struct SnapshotDiskContainer: Codable, Equatable {
    public var description: String?
    public var format: String?
    public var url: String?
    public var userBucket: UserBucket?

    public init(description: String? = nil,
                format: String? = nil,
                url: String? = nil,
                userBucket: UserBucket? = nil) {
        self.description = description
        self.format = format
        self.url = url
        self.userBucket = userBucket
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case format = "Format"
        case url = "Url"
        case userBucket = "UserBucket"
    }

    public func validate() throws {
        try userBucket?.validate()
    }
}

public struct SnapshotInfo: Codable, Equatable {
    public var description: String?
    public var encrypted: Boolean?
    public var ownerId: String?
    public var progress: String?
    public var snapshotId: String?
    public var startTime: MillisecondDateTime?
    public var state: SnapshotState?
    public var tags: TagList?
    public var volumeId: String?
    public var volumeSize: Integer?

    public init(description: String? = nil,
                encrypted: Boolean? = nil,
                ownerId: String? = nil,
                progress: String? = nil,
                snapshotId: String? = nil,
                startTime: MillisecondDateTime? = nil,
                state: SnapshotState? = nil,
                tags: TagList? = nil,
                volumeId: String? = nil,
                volumeSize: Integer? = nil) {
        self.description = description
        self.encrypted = encrypted
        self.ownerId = ownerId
        self.progress = progress
        self.snapshotId = snapshotId
        self.startTime = startTime
        self.state = state
        self.tags = tags
        self.volumeId = volumeId
        self.volumeSize = volumeSize
    }

    enum CodingKeys: String, CodingKey {
        case description
        case encrypted
        case ownerId
        case progress
        case snapshotId
        case startTime
        case state
        case tags = "tagSet"
        case volumeId
        case volumeSize
    }

    public func validate() throws {
    }
}

public struct SnapshotTaskDetail: Codable, Equatable {
    public var description: String?
    public var diskImageSize: Double?
    public var encrypted: Boolean?
    public var format: String?
    public var kmsKeyId: String?
    public var progress: String?
    public var snapshotId: String?
    public var status: String?
    public var statusMessage: String?
    public var url: String?
    public var userBucket: UserBucketDetails?

    public init(description: String? = nil,
                diskImageSize: Double? = nil,
                encrypted: Boolean? = nil,
                format: String? = nil,
                kmsKeyId: String? = nil,
                progress: String? = nil,
                snapshotId: String? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                url: String? = nil,
                userBucket: UserBucketDetails? = nil) {
        self.description = description
        self.diskImageSize = diskImageSize
        self.encrypted = encrypted
        self.format = format
        self.kmsKeyId = kmsKeyId
        self.progress = progress
        self.snapshotId = snapshotId
        self.status = status
        self.statusMessage = statusMessage
        self.url = url
        self.userBucket = userBucket
    }

    enum CodingKeys: String, CodingKey {
        case description
        case diskImageSize
        case encrypted
        case format
        case kmsKeyId
        case progress
        case snapshotId
        case status
        case statusMessage
        case url
        case userBucket
    }

    public func validate() throws {
        try userBucket?.validate()
    }
}

public struct SpotCapacityRebalance: Codable, Equatable {
    public var replacementStrategy: ReplacementStrategy?

    public init(replacementStrategy: ReplacementStrategy? = nil) {
        self.replacementStrategy = replacementStrategy
    }

    enum CodingKeys: String, CodingKey {
        case replacementStrategy
    }

    public func validate() throws {
    }
}

public struct SpotDatafeedSubscription: Codable, Equatable {
    public var bucket: String?
    public var fault: SpotInstanceStateFault?
    public var ownerId: String?
    public var prefix: String?
    public var state: DatafeedSubscriptionState?

    public init(bucket: String? = nil,
                fault: SpotInstanceStateFault? = nil,
                ownerId: String? = nil,
                prefix: String? = nil,
                state: DatafeedSubscriptionState? = nil) {
        self.bucket = bucket
        self.fault = fault
        self.ownerId = ownerId
        self.prefix = prefix
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case bucket
        case fault
        case ownerId
        case prefix
        case state
    }

    public func validate() throws {
        try fault?.validate()
    }
}

public struct SpotFleetLaunchSpecification: Codable, Equatable {
    public var addressingType: String?
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var ebsOptimized: Boolean?
    public var iamInstanceProfile: IamInstanceProfileSpecification?
    public var imageId: String?
    public var instanceType: InstanceType?
    public var kernelId: String?
    public var keyName: String?
    public var monitoring: SpotFleetMonitoring?
    public var networkInterfaces: InstanceNetworkInterfaceSpecificationList?
    public var placement: SpotPlacement?
    public var ramdiskId: String?
    public var securityGroups: GroupIdentifierList?
    public var spotPrice: String?
    public var subnetId: String?
    public var tagSpecifications: SpotFleetTagSpecificationList?
    public var userData: String?
    public var weightedCapacity: Double?

    public init(addressingType: String? = nil,
                blockDeviceMappings: BlockDeviceMappingList? = nil,
                ebsOptimized: Boolean? = nil,
                iamInstanceProfile: IamInstanceProfileSpecification? = nil,
                imageId: String? = nil,
                instanceType: InstanceType? = nil,
                kernelId: String? = nil,
                keyName: String? = nil,
                monitoring: SpotFleetMonitoring? = nil,
                networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil,
                placement: SpotPlacement? = nil,
                ramdiskId: String? = nil,
                securityGroups: GroupIdentifierList? = nil,
                spotPrice: String? = nil,
                subnetId: String? = nil,
                tagSpecifications: SpotFleetTagSpecificationList? = nil,
                userData: String? = nil,
                weightedCapacity: Double? = nil) {
        self.addressingType = addressingType
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramdiskId = ramdiskId
        self.securityGroups = securityGroups
        self.spotPrice = spotPrice
        self.subnetId = subnetId
        self.tagSpecifications = tagSpecifications
        self.userData = userData
        self.weightedCapacity = weightedCapacity
    }

    enum CodingKeys: String, CodingKey {
        case addressingType
        case blockDeviceMappings = "blockDeviceMapping"
        case ebsOptimized
        case iamInstanceProfile
        case imageId
        case instanceType
        case kernelId
        case keyName
        case monitoring
        case networkInterfaces = "networkInterfaceSet"
        case placement
        case ramdiskId
        case securityGroups = "groupSet"
        case spotPrice
        case subnetId
        case tagSpecifications = "tagSpecificationSet"
        case userData
        case weightedCapacity
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct SpotFleetMonitoring: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct SpotFleetRequestConfig: Codable, Equatable {
    public var activityStatus: ActivityStatus?
    public var createTime: MillisecondDateTime?
    public var spotFleetRequestConfig: SpotFleetRequestConfigData?
    public var spotFleetRequestId: String?
    public var spotFleetRequestState: BatchState?
    public var tags: TagList?

    public init(activityStatus: ActivityStatus? = nil,
                createTime: MillisecondDateTime? = nil,
                spotFleetRequestConfig: SpotFleetRequestConfigData? = nil,
                spotFleetRequestId: String? = nil,
                spotFleetRequestState: BatchState? = nil,
                tags: TagList? = nil) {
        self.activityStatus = activityStatus
        self.createTime = createTime
        self.spotFleetRequestConfig = spotFleetRequestConfig
        self.spotFleetRequestId = spotFleetRequestId
        self.spotFleetRequestState = spotFleetRequestState
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case activityStatus
        case createTime
        case spotFleetRequestConfig
        case spotFleetRequestId
        case spotFleetRequestState
        case tags = "tagSet"
    }

    public func validate() throws {
        try spotFleetRequestConfig?.validate()
    }
}

public struct SpotFleetRequestConfigData: Codable, Equatable {
    public var allocationStrategy: AllocationStrategy?
    public var clientToken: String?
    public var excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy?
    public var fulfilledCapacity: Double?
    public var iamFleetRole: String
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var instancePoolsToUseCount: Integer?
    public var launchSpecifications: LaunchSpecsList?
    public var launchTemplateConfigs: LaunchTemplateConfigList?
    public var loadBalancersConfig: LoadBalancersConfig?
    public var onDemandAllocationStrategy: OnDemandAllocationStrategy?
    public var onDemandFulfilledCapacity: Double?
    public var onDemandMaxTotalPrice: String?
    public var onDemandTargetCapacity: Integer?
    public var replaceUnhealthyInstances: Boolean?
    public var spotMaintenanceStrategies: SpotMaintenanceStrategies?
    public var spotMaxTotalPrice: String?
    public var spotPrice: String?
    public var tagSpecifications: TagSpecificationList?
    public var targetCapacity: Integer
    public var terminateInstancesWithExpiration: Boolean?
    public var type: FleetType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(allocationStrategy: AllocationStrategy? = nil,
                clientToken: String? = nil,
                excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy? = nil,
                fulfilledCapacity: Double? = nil,
                iamFleetRole: String,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                instancePoolsToUseCount: Integer? = nil,
                launchSpecifications: LaunchSpecsList? = nil,
                launchTemplateConfigs: LaunchTemplateConfigList? = nil,
                loadBalancersConfig: LoadBalancersConfig? = nil,
                onDemandAllocationStrategy: OnDemandAllocationStrategy? = nil,
                onDemandFulfilledCapacity: Double? = nil,
                onDemandMaxTotalPrice: String? = nil,
                onDemandTargetCapacity: Integer? = nil,
                replaceUnhealthyInstances: Boolean? = nil,
                spotMaintenanceStrategies: SpotMaintenanceStrategies? = nil,
                spotMaxTotalPrice: String? = nil,
                spotPrice: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                targetCapacity: Integer,
                terminateInstancesWithExpiration: Boolean? = nil,
                type: FleetType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.allocationStrategy = allocationStrategy
        self.clientToken = clientToken
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.fulfilledCapacity = fulfilledCapacity
        self.iamFleetRole = iamFleetRole
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.instancePoolsToUseCount = instancePoolsToUseCount
        self.launchSpecifications = launchSpecifications
        self.launchTemplateConfigs = launchTemplateConfigs
        self.loadBalancersConfig = loadBalancersConfig
        self.onDemandAllocationStrategy = onDemandAllocationStrategy
        self.onDemandFulfilledCapacity = onDemandFulfilledCapacity
        self.onDemandMaxTotalPrice = onDemandMaxTotalPrice
        self.onDemandTargetCapacity = onDemandTargetCapacity
        self.replaceUnhealthyInstances = replaceUnhealthyInstances
        self.spotMaintenanceStrategies = spotMaintenanceStrategies
        self.spotMaxTotalPrice = spotMaxTotalPrice
        self.spotPrice = spotPrice
        self.tagSpecifications = tagSpecifications
        self.targetCapacity = targetCapacity
        self.terminateInstancesWithExpiration = terminateInstancesWithExpiration
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy
        case clientToken
        case excessCapacityTerminationPolicy
        case fulfilledCapacity
        case iamFleetRole
        case instanceInterruptionBehavior
        case instancePoolsToUseCount
        case launchSpecifications
        case launchTemplateConfigs
        case loadBalancersConfig
        case onDemandAllocationStrategy
        case onDemandFulfilledCapacity
        case onDemandMaxTotalPrice
        case onDemandTargetCapacity
        case replaceUnhealthyInstances
        case spotMaintenanceStrategies
        case spotMaxTotalPrice
        case spotPrice
        case tagSpecifications = "TagSpecification"
        case targetCapacity
        case terminateInstancesWithExpiration
        case type
        case validFrom
        case validUntil
    }

    public func validate() throws {
        try loadBalancersConfig?.validate()
        try spotMaintenanceStrategies?.validate()
    }
}

public struct SpotFleetTagSpecification: Codable, Equatable {
    public var resourceType: ResourceType?
    public var tags: TagList?

    public init(resourceType: ResourceType? = nil,
                tags: TagList? = nil) {
        self.resourceType = resourceType
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case resourceType
        case tags = "tag"
    }

    public func validate() throws {
    }
}

public struct SpotInstanceRequest: Codable, Equatable {
    public var actualBlockHourlyPrice: String?
    public var availabilityZoneGroup: String?
    public var blockDurationMinutes: Integer?
    public var createTime: DateTime?
    public var fault: SpotInstanceStateFault?
    public var instanceId: InstanceId?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var launchGroup: String?
    public var launchSpecification: LaunchSpecification?
    public var launchedAvailabilityZone: String?
    public var productDescription: RIProductDescription?
    public var spotInstanceRequestId: String?
    public var spotPrice: String?
    public var state: SpotInstanceState?
    public var status: SpotInstanceStatus?
    public var tags: TagList?
    public var type: SpotInstanceType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(actualBlockHourlyPrice: String? = nil,
                availabilityZoneGroup: String? = nil,
                blockDurationMinutes: Integer? = nil,
                createTime: DateTime? = nil,
                fault: SpotInstanceStateFault? = nil,
                instanceId: InstanceId? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                launchGroup: String? = nil,
                launchSpecification: LaunchSpecification? = nil,
                launchedAvailabilityZone: String? = nil,
                productDescription: RIProductDescription? = nil,
                spotInstanceRequestId: String? = nil,
                spotPrice: String? = nil,
                state: SpotInstanceState? = nil,
                status: SpotInstanceStatus? = nil,
                tags: TagList? = nil,
                type: SpotInstanceType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.actualBlockHourlyPrice = actualBlockHourlyPrice
        self.availabilityZoneGroup = availabilityZoneGroup
        self.blockDurationMinutes = blockDurationMinutes
        self.createTime = createTime
        self.fault = fault
        self.instanceId = instanceId
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.launchGroup = launchGroup
        self.launchSpecification = launchSpecification
        self.launchedAvailabilityZone = launchedAvailabilityZone
        self.productDescription = productDescription
        self.spotInstanceRequestId = spotInstanceRequestId
        self.spotPrice = spotPrice
        self.state = state
        self.status = status
        self.tags = tags
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case actualBlockHourlyPrice
        case availabilityZoneGroup
        case blockDurationMinutes
        case createTime
        case fault
        case instanceId
        case instanceInterruptionBehavior
        case launchGroup
        case launchSpecification
        case launchedAvailabilityZone
        case productDescription
        case spotInstanceRequestId
        case spotPrice
        case state
        case status
        case tags = "tagSet"
        case type
        case validFrom
        case validUntil
    }

    public func validate() throws {
        try fault?.validate()
        try launchSpecification?.validate()
        try status?.validate()
    }
}

public struct SpotInstanceStateFault: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct SpotInstanceStatus: Codable, Equatable {
    public var code: String?
    public var message: String?
    public var updateTime: DateTime?

    public init(code: String? = nil,
                message: String? = nil,
                updateTime: DateTime? = nil) {
        self.code = code
        self.message = message
        self.updateTime = updateTime
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
        case updateTime
    }

    public func validate() throws {
    }
}

public struct SpotMaintenanceStrategies: Codable, Equatable {
    public var capacityRebalance: SpotCapacityRebalance?

    public init(capacityRebalance: SpotCapacityRebalance? = nil) {
        self.capacityRebalance = capacityRebalance
    }

    enum CodingKeys: String, CodingKey {
        case capacityRebalance
    }

    public func validate() throws {
        try capacityRebalance?.validate()
    }
}

public struct SpotMarketOptions: Codable, Equatable {
    public var blockDurationMinutes: Integer?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var maxPrice: String?
    public var spotInstanceType: SpotInstanceType?
    public var validUntil: DateTime?

    public init(blockDurationMinutes: Integer? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                maxPrice: String? = nil,
                spotInstanceType: SpotInstanceType? = nil,
                validUntil: DateTime? = nil) {
        self.blockDurationMinutes = blockDurationMinutes
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.maxPrice = maxPrice
        self.spotInstanceType = spotInstanceType
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case blockDurationMinutes = "BlockDurationMinutes"
        case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
        case maxPrice = "MaxPrice"
        case spotInstanceType = "SpotInstanceType"
        case validUntil = "ValidUntil"
    }

    public func validate() throws {
    }
}

public struct SpotOptions: Codable, Equatable {
    public var allocationStrategy: SpotAllocationStrategy?
    public var instanceInterruptionBehavior: SpotInstanceInterruptionBehavior?
    public var instancePoolsToUseCount: Integer?
    public var maintenanceStrategies: FleetSpotMaintenanceStrategies?
    public var maxTotalPrice: String?
    public var minTargetCapacity: Integer?
    public var singleAvailabilityZone: Boolean?
    public var singleInstanceType: Boolean?

    public init(allocationStrategy: SpotAllocationStrategy? = nil,
                instanceInterruptionBehavior: SpotInstanceInterruptionBehavior? = nil,
                instancePoolsToUseCount: Integer? = nil,
                maintenanceStrategies: FleetSpotMaintenanceStrategies? = nil,
                maxTotalPrice: String? = nil,
                minTargetCapacity: Integer? = nil,
                singleAvailabilityZone: Boolean? = nil,
                singleInstanceType: Boolean? = nil) {
        self.allocationStrategy = allocationStrategy
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.instancePoolsToUseCount = instancePoolsToUseCount
        self.maintenanceStrategies = maintenanceStrategies
        self.maxTotalPrice = maxTotalPrice
        self.minTargetCapacity = minTargetCapacity
        self.singleAvailabilityZone = singleAvailabilityZone
        self.singleInstanceType = singleInstanceType
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy
        case instanceInterruptionBehavior
        case instancePoolsToUseCount
        case maintenanceStrategies
        case maxTotalPrice
        case minTargetCapacity
        case singleAvailabilityZone
        case singleInstanceType
    }

    public func validate() throws {
        try maintenanceStrategies?.validate()
    }
}

public struct SpotOptionsRequest: Codable, Equatable {
    public var allocationStrategy: SpotAllocationStrategy?
    public var instanceInterruptionBehavior: SpotInstanceInterruptionBehavior?
    public var instancePoolsToUseCount: Integer?
    public var maintenanceStrategies: FleetSpotMaintenanceStrategiesRequest?
    public var maxTotalPrice: String?
    public var minTargetCapacity: Integer?
    public var singleAvailabilityZone: Boolean?
    public var singleInstanceType: Boolean?

    public init(allocationStrategy: SpotAllocationStrategy? = nil,
                instanceInterruptionBehavior: SpotInstanceInterruptionBehavior? = nil,
                instancePoolsToUseCount: Integer? = nil,
                maintenanceStrategies: FleetSpotMaintenanceStrategiesRequest? = nil,
                maxTotalPrice: String? = nil,
                minTargetCapacity: Integer? = nil,
                singleAvailabilityZone: Boolean? = nil,
                singleInstanceType: Boolean? = nil) {
        self.allocationStrategy = allocationStrategy
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.instancePoolsToUseCount = instancePoolsToUseCount
        self.maintenanceStrategies = maintenanceStrategies
        self.maxTotalPrice = maxTotalPrice
        self.minTargetCapacity = minTargetCapacity
        self.singleAvailabilityZone = singleAvailabilityZone
        self.singleInstanceType = singleInstanceType
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy = "AllocationStrategy"
        case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
        case instancePoolsToUseCount = "InstancePoolsToUseCount"
        case maintenanceStrategies = "MaintenanceStrategies"
        case maxTotalPrice = "MaxTotalPrice"
        case minTargetCapacity = "MinTargetCapacity"
        case singleAvailabilityZone = "SingleAvailabilityZone"
        case singleInstanceType = "SingleInstanceType"
    }

    public func validate() throws {
        try maintenanceStrategies?.validate()
    }
}

public struct SpotPlacement: Codable, Equatable {
    public var availabilityZone: String?
    public var groupName: String?
    public var tenancy: Tenancy?

    public init(availabilityZone: String? = nil,
                groupName: String? = nil,
                tenancy: Tenancy? = nil) {
        self.availabilityZone = availabilityZone
        self.groupName = groupName
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case groupName
        case tenancy
    }

    public func validate() throws {
    }
}

public struct SpotPrice: Codable, Equatable {
    public var availabilityZone: String?
    public var instanceType: InstanceType?
    public var productDescription: RIProductDescription?
    public var spotPrice: String?
    public var timestamp: DateTime?

    public init(availabilityZone: String? = nil,
                instanceType: InstanceType? = nil,
                productDescription: RIProductDescription? = nil,
                spotPrice: String? = nil,
                timestamp: DateTime? = nil) {
        self.availabilityZone = availabilityZone
        self.instanceType = instanceType
        self.productDescription = productDescription
        self.spotPrice = spotPrice
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case instanceType
        case productDescription
        case spotPrice
        case timestamp
    }

    public func validate() throws {
    }
}

public struct StaleIpPermission: Codable, Equatable {
    public var fromPort: Integer?
    public var ipProtocol: String?
    public var ipRanges: IpRanges?
    public var prefixListIds: PrefixListIdSet?
    public var toPort: Integer?
    public var userIdGroupPairs: UserIdGroupPairSet?

    public init(fromPort: Integer? = nil,
                ipProtocol: String? = nil,
                ipRanges: IpRanges? = nil,
                prefixListIds: PrefixListIdSet? = nil,
                toPort: Integer? = nil,
                userIdGroupPairs: UserIdGroupPairSet? = nil) {
        self.fromPort = fromPort
        self.ipProtocol = ipProtocol
        self.ipRanges = ipRanges
        self.prefixListIds = prefixListIds
        self.toPort = toPort
        self.userIdGroupPairs = userIdGroupPairs
    }

    enum CodingKeys: String, CodingKey {
        case fromPort
        case ipProtocol
        case ipRanges
        case prefixListIds
        case toPort
        case userIdGroupPairs = "groups"
    }

    public func validate() throws {
    }
}

public struct StaleSecurityGroup: Codable, Equatable {
    public var description: String?
    public var groupId: String?
    public var groupName: String?
    public var staleIpPermissions: StaleIpPermissionSet?
    public var staleIpPermissionsEgress: StaleIpPermissionSet?
    public var vpcId: String?

    public init(description: String? = nil,
                groupId: String? = nil,
                groupName: String? = nil,
                staleIpPermissions: StaleIpPermissionSet? = nil,
                staleIpPermissionsEgress: StaleIpPermissionSet? = nil,
                vpcId: String? = nil) {
        self.description = description
        self.groupId = groupId
        self.groupName = groupName
        self.staleIpPermissions = staleIpPermissions
        self.staleIpPermissionsEgress = staleIpPermissionsEgress
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case groupId
        case groupName
        case staleIpPermissions
        case staleIpPermissionsEgress
        case vpcId
    }

    public func validate() throws {
    }
}

public struct StartInstancesRequest: Codable, Equatable {
    public var additionalInfo: String?
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(additionalInfo: String? = nil,
                dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.additionalInfo = additionalInfo
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case additionalInfo
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct StartInstancesResult: Codable, Equatable {
    public var startingInstances: InstanceStateChangeList?

    public init(startingInstances: InstanceStateChangeList? = nil) {
        self.startingInstances = startingInstances
    }

    enum CodingKeys: String, CodingKey {
        case startingInstances = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct StartNetworkInsightsAnalysisRequest: Codable, Equatable {
    public var clientToken: String
    public var dryRun: Boolean?
    public var filterInArns: ArnList?
    public var networkInsightsPathId: NetworkInsightsPathId
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String,
                dryRun: Boolean? = nil,
                filterInArns: ArnList? = nil,
                networkInsightsPathId: NetworkInsightsPathId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.filterInArns = filterInArns
        self.networkInsightsPathId = networkInsightsPathId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case filterInArns = "FilterInArn"
        case networkInsightsPathId = "NetworkInsightsPathId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct StartNetworkInsightsAnalysisResult: Codable, Equatable {
    public var networkInsightsAnalysis: NetworkInsightsAnalysis?

    public init(networkInsightsAnalysis: NetworkInsightsAnalysis? = nil) {
        self.networkInsightsAnalysis = networkInsightsAnalysis
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAnalysis
    }

    public func validate() throws {
        try networkInsightsAnalysis?.validate()
    }
}

public struct StartVpcEndpointServicePrivateDnsVerificationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var serviceId: VpcEndpointServiceId

    public init(dryRun: Boolean? = nil,
                serviceId: VpcEndpointServiceId) {
        self.dryRun = dryRun
        self.serviceId = serviceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case serviceId = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct StartVpcEndpointServicePrivateDnsVerificationResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue = "return"
    }

    public func validate() throws {
    }
}

public struct StateReason: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct StopInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var force: Boolean?
    public var hibernate: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                force: Boolean? = nil,
                hibernate: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.force = force
        self.hibernate = hibernate
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case force
        case hibernate = "Hibernate"
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct StopInstancesResult: Codable, Equatable {
    public var stoppingInstances: InstanceStateChangeList?

    public init(stoppingInstances: InstanceStateChangeList? = nil) {
        self.stoppingInstances = stoppingInstances
    }

    enum CodingKeys: String, CodingKey {
        case stoppingInstances = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct Storage: Codable, Equatable {
    public var s3: S3Storage?

    public init(s3: S3Storage? = nil) {
        self.s3 = s3
    }

    enum CodingKeys: String, CodingKey {
        case s3 = "S3"
    }

    public func validate() throws {
        try s3?.validate()
    }
}

public struct StorageLocation: Codable, Equatable {
    public var bucket: String?
    public var key: String?

    public init(bucket: String? = nil,
                key: String? = nil) {
        self.bucket = bucket
        self.key = key
    }

    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func validate() throws {
    }
}

public struct Subnet: Codable, Equatable {
    public var assignIpv6AddressOnCreation: Boolean?
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var availableIpAddressCount: Integer?
    public var cidrBlock: String?
    public var customerOwnedIpv4Pool: CoipPoolId?
    public var defaultForAz: Boolean?
    public var ipv6CidrBlockAssociationSet: SubnetIpv6CidrBlockAssociationSet?
    public var mapCustomerOwnedIpOnLaunch: Boolean?
    public var mapPublicIpOnLaunch: Boolean?
    public var outpostArn: String?
    public var ownerId: String?
    public var state: SubnetState?
    public var subnetArn: String?
    public var subnetId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(assignIpv6AddressOnCreation: Boolean? = nil,
                availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                availableIpAddressCount: Integer? = nil,
                cidrBlock: String? = nil,
                customerOwnedIpv4Pool: CoipPoolId? = nil,
                defaultForAz: Boolean? = nil,
                ipv6CidrBlockAssociationSet: SubnetIpv6CidrBlockAssociationSet? = nil,
                mapCustomerOwnedIpOnLaunch: Boolean? = nil,
                mapPublicIpOnLaunch: Boolean? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                state: SubnetState? = nil,
                subnetArn: String? = nil,
                subnetId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.availableIpAddressCount = availableIpAddressCount
        self.cidrBlock = cidrBlock
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.defaultForAz = defaultForAz
        self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
        self.mapCustomerOwnedIpOnLaunch = mapCustomerOwnedIpOnLaunch
        self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.state = state
        self.subnetArn = subnetArn
        self.subnetId = subnetId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case assignIpv6AddressOnCreation
        case availabilityZone
        case availabilityZoneId
        case availableIpAddressCount
        case cidrBlock
        case customerOwnedIpv4Pool
        case defaultForAz
        case ipv6CidrBlockAssociationSet
        case mapCustomerOwnedIpOnLaunch
        case mapPublicIpOnLaunch
        case outpostArn
        case ownerId
        case state
        case subnetArn
        case subnetId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct SubnetAssociation: Codable, Equatable {
    public var state: TransitGatewayMulitcastDomainAssociationState?
    public var subnetId: String?

    public init(state: TransitGatewayMulitcastDomainAssociationState? = nil,
                subnetId: String? = nil) {
        self.state = state
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case subnetId
    }

    public func validate() throws {
    }
}

public struct SubnetCidrBlockState: Codable, Equatable {
    public var state: SubnetCidrBlockStateCode?
    public var statusMessage: String?

    public init(state: SubnetCidrBlockStateCode? = nil,
                statusMessage: String? = nil) {
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct SubnetIpv6CidrBlockAssociation: Codable, Equatable {
    public var associationId: String?
    public var ipv6CidrBlock: String?
    public var ipv6CidrBlockState: SubnetCidrBlockState?

    public init(associationId: String? = nil,
                ipv6CidrBlock: String? = nil,
                ipv6CidrBlockState: SubnetCidrBlockState? = nil) {
        self.associationId = associationId
        self.ipv6CidrBlock = ipv6CidrBlock
        self.ipv6CidrBlockState = ipv6CidrBlockState
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case ipv6CidrBlock
        case ipv6CidrBlockState
    }

    public func validate() throws {
        try ipv6CidrBlockState?.validate()
    }
}

public struct SuccessfulInstanceCreditSpecificationItem: Codable, Equatable {
    public var instanceId: String?

    public init(instanceId: String? = nil) {
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
    }

    public func validate() throws {
    }
}

public struct SuccessfulQueuedPurchaseDeletion: Codable, Equatable {
    public var reservedInstancesId: String?

    public init(reservedInstancesId: String? = nil) {
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesId
    }

    public func validate() throws {
    }
}

public struct Tag: Codable, Equatable {
    public var key: String?
    public var value: String?

    public init(key: String? = nil,
                value: String? = nil) {
        self.key = key
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func validate() throws {
    }
}

public struct TagDescription: Codable, Equatable {
    public var key: String?
    public var resourceId: String?
    public var resourceType: ResourceType?
    public var value: String?

    public init(key: String? = nil,
                resourceId: String? = nil,
                resourceType: ResourceType? = nil,
                value: String? = nil) {
        self.key = key
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case key
        case resourceId
        case resourceType
        case value
    }

    public func validate() throws {
    }
}

public struct TagSpecification: Codable, Equatable {
    public var resourceType: ResourceType?
    public var tags: TagList?

    public init(resourceType: ResourceType? = nil,
                tags: TagList? = nil) {
        self.resourceType = resourceType
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case resourceType
        case tags = "Tag"
    }

    public func validate() throws {
    }
}

public struct TargetCapacitySpecification: Codable, Equatable {
    public var defaultTargetCapacityType: DefaultTargetCapacityType?
    public var onDemandTargetCapacity: Integer?
    public var spotTargetCapacity: Integer?
    public var totalTargetCapacity: Integer?

    public init(defaultTargetCapacityType: DefaultTargetCapacityType? = nil,
                onDemandTargetCapacity: Integer? = nil,
                spotTargetCapacity: Integer? = nil,
                totalTargetCapacity: Integer? = nil) {
        self.defaultTargetCapacityType = defaultTargetCapacityType
        self.onDemandTargetCapacity = onDemandTargetCapacity
        self.spotTargetCapacity = spotTargetCapacity
        self.totalTargetCapacity = totalTargetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case defaultTargetCapacityType
        case onDemandTargetCapacity
        case spotTargetCapacity
        case totalTargetCapacity
    }

    public func validate() throws {
    }
}

public struct TargetCapacitySpecificationRequest: Codable, Equatable {
    public var defaultTargetCapacityType: DefaultTargetCapacityType?
    public var onDemandTargetCapacity: Integer?
    public var spotTargetCapacity: Integer?
    public var totalTargetCapacity: Integer

    public init(defaultTargetCapacityType: DefaultTargetCapacityType? = nil,
                onDemandTargetCapacity: Integer? = nil,
                spotTargetCapacity: Integer? = nil,
                totalTargetCapacity: Integer) {
        self.defaultTargetCapacityType = defaultTargetCapacityType
        self.onDemandTargetCapacity = onDemandTargetCapacity
        self.spotTargetCapacity = spotTargetCapacity
        self.totalTargetCapacity = totalTargetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case defaultTargetCapacityType = "DefaultTargetCapacityType"
        case onDemandTargetCapacity = "OnDemandTargetCapacity"
        case spotTargetCapacity = "SpotTargetCapacity"
        case totalTargetCapacity = "TotalTargetCapacity"
    }

    public func validate() throws {
    }
}

public struct TargetConfiguration: Codable, Equatable {
    public var instanceCount: Integer?
    public var offeringId: String?

    public init(instanceCount: Integer? = nil,
                offeringId: String? = nil) {
        self.instanceCount = instanceCount
        self.offeringId = offeringId
    }

    enum CodingKeys: String, CodingKey {
        case instanceCount
        case offeringId
    }

    public func validate() throws {
    }
}

public struct TargetConfigurationRequest: Codable, Equatable {
    public var instanceCount: Integer?
    public var offeringId: ReservedInstancesOfferingId

    public init(instanceCount: Integer? = nil,
                offeringId: ReservedInstancesOfferingId) {
        self.instanceCount = instanceCount
        self.offeringId = offeringId
    }

    enum CodingKeys: String, CodingKey {
        case instanceCount = "InstanceCount"
        case offeringId = "OfferingId"
    }

    public func validate() throws {
    }
}

public struct TargetGroup: Codable, Equatable {
    public var arn: String?

    public init(arn: String? = nil) {
        self.arn = arn
    }

    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func validate() throws {
    }
}

public struct TargetGroupsConfig: Codable, Equatable {
    public var targetGroups: TargetGroups?

    public init(targetGroups: TargetGroups? = nil) {
        self.targetGroups = targetGroups
    }

    enum CodingKeys: String, CodingKey {
        case targetGroups
    }

    public func validate() throws {
        try targetGroups?.validateAsTargetGroups()
    }
}

public struct TargetNetwork: Codable, Equatable {
    public var associationId: String?
    public var clientVpnEndpointId: String?
    public var securityGroups: ValueStringList?
    public var status: AssociationStatus?
    public var targetNetworkId: String?
    public var vpcId: String?

    public init(associationId: String? = nil,
                clientVpnEndpointId: String? = nil,
                securityGroups: ValueStringList? = nil,
                status: AssociationStatus? = nil,
                targetNetworkId: String? = nil,
                vpcId: String? = nil) {
        self.associationId = associationId
        self.clientVpnEndpointId = clientVpnEndpointId
        self.securityGroups = securityGroups
        self.status = status
        self.targetNetworkId = targetNetworkId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case clientVpnEndpointId
        case securityGroups
        case status
        case targetNetworkId
        case vpcId
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct TargetReservationValue: Codable, Equatable {
    public var reservationValue: ReservationValue?
    public var targetConfiguration: TargetConfiguration?

    public init(reservationValue: ReservationValue? = nil,
                targetConfiguration: TargetConfiguration? = nil) {
        self.reservationValue = reservationValue
        self.targetConfiguration = targetConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case reservationValue
        case targetConfiguration
    }

    public func validate() throws {
        try reservationValue?.validate()
        try targetConfiguration?.validate()
    }
}

public struct TerminateClientVpnConnectionsRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var connectionId: VpnConnectionId?
    public var dryRun: Boolean?
    public var username: String?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                connectionId: VpnConnectionId? = nil,
                dryRun: Boolean? = nil,
                username: String? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.connectionId = connectionId
        self.dryRun = dryRun
        self.username = username
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case connectionId = "ConnectionId"
        case dryRun = "DryRun"
        case username = "Username"
    }

    public func validate() throws {
    }
}

public struct TerminateClientVpnConnectionsResult: Codable, Equatable {
    public var clientVpnEndpointId: String?
    public var connectionStatuses: TerminateConnectionStatusSet?
    public var username: String?

    public init(clientVpnEndpointId: String? = nil,
                connectionStatuses: TerminateConnectionStatusSet? = nil,
                username: String? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.connectionStatuses = connectionStatuses
        self.username = username
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId
        case connectionStatuses
        case username
    }

    public func validate() throws {
    }
}

public struct TerminateConnectionStatus: Codable, Equatable {
    public var connectionId: String?
    public var currentStatus: ClientVpnConnectionStatus?
    public var previousStatus: ClientVpnConnectionStatus?

    public init(connectionId: String? = nil,
                currentStatus: ClientVpnConnectionStatus? = nil,
                previousStatus: ClientVpnConnectionStatus? = nil) {
        self.connectionId = connectionId
        self.currentStatus = currentStatus
        self.previousStatus = previousStatus
    }

    enum CodingKeys: String, CodingKey {
        case connectionId
        case currentStatus
        case previousStatus
    }

    public func validate() throws {
        try currentStatus?.validate()
        try previousStatus?.validate()
    }
}

public struct TerminateInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct TerminateInstancesResult: Codable, Equatable {
    public var terminatingInstances: InstanceStateChangeList?

    public init(terminatingInstances: InstanceStateChangeList? = nil) {
        self.terminatingInstances = terminatingInstances
    }

    enum CodingKeys: String, CodingKey {
        case terminatingInstances = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorFilter: Codable, Equatable {
    public var description: String?
    public var egressFilterRules: TrafficMirrorFilterRuleList?
    public var ingressFilterRules: TrafficMirrorFilterRuleList?
    public var networkServices: TrafficMirrorNetworkServiceList?
    public var tags: TagList?
    public var trafficMirrorFilterId: String?

    public init(description: String? = nil,
                egressFilterRules: TrafficMirrorFilterRuleList? = nil,
                ingressFilterRules: TrafficMirrorFilterRuleList? = nil,
                networkServices: TrafficMirrorNetworkServiceList? = nil,
                tags: TagList? = nil,
                trafficMirrorFilterId: String? = nil) {
        self.description = description
        self.egressFilterRules = egressFilterRules
        self.ingressFilterRules = ingressFilterRules
        self.networkServices = networkServices
        self.tags = tags
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case egressFilterRules = "egressFilterRuleSet"
        case ingressFilterRules = "ingressFilterRuleSet"
        case networkServices = "networkServiceSet"
        case tags = "tagSet"
        case trafficMirrorFilterId
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorFilterRule: Codable, Equatable {
    public var description: String?
    public var destinationCidrBlock: String?
    public var destinationPortRange: TrafficMirrorPortRange?
    public var `protocol`: Integer?
    public var ruleAction: TrafficMirrorRuleAction?
    public var ruleNumber: Integer?
    public var sourceCidrBlock: String?
    public var sourcePortRange: TrafficMirrorPortRange?
    public var trafficDirection: TrafficDirection?
    public var trafficMirrorFilterId: String?
    public var trafficMirrorFilterRuleId: String?

    public init(description: String? = nil,
                destinationCidrBlock: String? = nil,
                destinationPortRange: TrafficMirrorPortRange? = nil,
                `protocol`: Integer? = nil,
                ruleAction: TrafficMirrorRuleAction? = nil,
                ruleNumber: Integer? = nil,
                sourceCidrBlock: String? = nil,
                sourcePortRange: TrafficMirrorPortRange? = nil,
                trafficDirection: TrafficDirection? = nil,
                trafficMirrorFilterId: String? = nil,
                trafficMirrorFilterRuleId: String? = nil) {
        self.description = description
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationPortRange = destinationPortRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
        self.sourceCidrBlock = sourceCidrBlock
        self.sourcePortRange = sourcePortRange
        self.trafficDirection = trafficDirection
        self.trafficMirrorFilterId = trafficMirrorFilterId
        self.trafficMirrorFilterRuleId = trafficMirrorFilterRuleId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case destinationCidrBlock
        case destinationPortRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
        case sourceCidrBlock
        case sourcePortRange
        case trafficDirection
        case trafficMirrorFilterId
        case trafficMirrorFilterRuleId
    }

    public func validate() throws {
        try destinationPortRange?.validate()
        try sourcePortRange?.validate()
    }
}

public struct TrafficMirrorPortRange: Codable, Equatable {
    public var fromPort: Integer?
    public var toPort: Integer?

    public init(fromPort: Integer? = nil,
                toPort: Integer? = nil) {
        self.fromPort = fromPort
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case fromPort
        case toPort
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorPortRangeRequest: Codable, Equatable {
    public var fromPort: Integer?
    public var toPort: Integer?

    public init(fromPort: Integer? = nil,
                toPort: Integer? = nil) {
        self.fromPort = fromPort
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case fromPort = "FromPort"
        case toPort = "ToPort"
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorSession: Codable, Equatable {
    public var description: String?
    public var networkInterfaceId: String?
    public var ownerId: String?
    public var packetLength: Integer?
    public var sessionNumber: Integer?
    public var tags: TagList?
    public var trafficMirrorFilterId: String?
    public var trafficMirrorSessionId: String?
    public var trafficMirrorTargetId: String?
    public var virtualNetworkId: Integer?

    public init(description: String? = nil,
                networkInterfaceId: String? = nil,
                ownerId: String? = nil,
                packetLength: Integer? = nil,
                sessionNumber: Integer? = nil,
                tags: TagList? = nil,
                trafficMirrorFilterId: String? = nil,
                trafficMirrorSessionId: String? = nil,
                trafficMirrorTargetId: String? = nil,
                virtualNetworkId: Integer? = nil) {
        self.description = description
        self.networkInterfaceId = networkInterfaceId
        self.ownerId = ownerId
        self.packetLength = packetLength
        self.sessionNumber = sessionNumber
        self.tags = tags
        self.trafficMirrorFilterId = trafficMirrorFilterId
        self.trafficMirrorSessionId = trafficMirrorSessionId
        self.trafficMirrorTargetId = trafficMirrorTargetId
        self.virtualNetworkId = virtualNetworkId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case networkInterfaceId
        case ownerId
        case packetLength
        case sessionNumber
        case tags = "tagSet"
        case trafficMirrorFilterId
        case trafficMirrorSessionId
        case trafficMirrorTargetId
        case virtualNetworkId
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorTarget: Codable, Equatable {
    public var description: String?
    public var networkInterfaceId: String?
    public var networkLoadBalancerArn: String?
    public var ownerId: String?
    public var tags: TagList?
    public var trafficMirrorTargetId: String?
    public var type: TrafficMirrorTargetType?

    public init(description: String? = nil,
                networkInterfaceId: String? = nil,
                networkLoadBalancerArn: String? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil,
                trafficMirrorTargetId: String? = nil,
                type: TrafficMirrorTargetType? = nil) {
        self.description = description
        self.networkInterfaceId = networkInterfaceId
        self.networkLoadBalancerArn = networkLoadBalancerArn
        self.ownerId = ownerId
        self.tags = tags
        self.trafficMirrorTargetId = trafficMirrorTargetId
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case description
        case networkInterfaceId
        case networkLoadBalancerArn
        case ownerId
        case tags = "tagSet"
        case trafficMirrorTargetId
        case type
    }

    public func validate() throws {
    }
}

public struct TransitGateway: Codable, Equatable {
    public var creationTime: DateTime?
    public var description: String?
    public var options: TransitGatewayOptions?
    public var ownerId: String?
    public var state: TransitGatewayState?
    public var tags: TagList?
    public var transitGatewayArn: String?
    public var transitGatewayId: String?

    public init(creationTime: DateTime? = nil,
                description: String? = nil,
                options: TransitGatewayOptions? = nil,
                ownerId: String? = nil,
                state: TransitGatewayState? = nil,
                tags: TagList? = nil,
                transitGatewayArn: String? = nil,
                transitGatewayId: String? = nil) {
        self.creationTime = creationTime
        self.description = description
        self.options = options
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.transitGatewayArn = transitGatewayArn
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case description
        case options
        case ownerId
        case state
        case tags = "tagSet"
        case transitGatewayArn
        case transitGatewayId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct TransitGatewayAssociation: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayAssociationState?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayAssociationState? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.state = state
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case state
        case transitGatewayAttachmentId
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayAttachment: Codable, Equatable {
    public var association: TransitGatewayAttachmentAssociation?
    public var creationTime: DateTime?
    public var resourceId: String?
    public var resourceOwnerId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayAttachmentState?
    public var tags: TagList?
    public var transitGatewayAttachmentId: String?
    public var transitGatewayId: String?
    public var transitGatewayOwnerId: String?

    public init(association: TransitGatewayAttachmentAssociation? = nil,
                creationTime: DateTime? = nil,
                resourceId: String? = nil,
                resourceOwnerId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayAttachmentState? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: String? = nil,
                transitGatewayId: String? = nil,
                transitGatewayOwnerId: String? = nil) {
        self.association = association
        self.creationTime = creationTime
        self.resourceId = resourceId
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
        self.state = state
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayId = transitGatewayId
        self.transitGatewayOwnerId = transitGatewayOwnerId
    }

    enum CodingKeys: String, CodingKey {
        case association
        case creationTime
        case resourceId
        case resourceOwnerId
        case resourceType
        case state
        case tags = "tagSet"
        case transitGatewayAttachmentId
        case transitGatewayId
        case transitGatewayOwnerId
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct TransitGatewayAttachmentAssociation: Codable, Equatable {
    public var state: TransitGatewayAssociationState?
    public var transitGatewayRouteTableId: String?

    public init(state: TransitGatewayAssociationState? = nil,
                transitGatewayRouteTableId: String? = nil) {
        self.state = state
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayAttachmentBgpConfiguration: Codable, Equatable {
    public var bgpStatus: BgpStatus?
    public var peerAddress: String?
    public var peerAsn: Long?
    public var transitGatewayAddress: String?
    public var transitGatewayAsn: Long?

    public init(bgpStatus: BgpStatus? = nil,
                peerAddress: String? = nil,
                peerAsn: Long? = nil,
                transitGatewayAddress: String? = nil,
                transitGatewayAsn: Long? = nil) {
        self.bgpStatus = bgpStatus
        self.peerAddress = peerAddress
        self.peerAsn = peerAsn
        self.transitGatewayAddress = transitGatewayAddress
        self.transitGatewayAsn = transitGatewayAsn
    }

    enum CodingKeys: String, CodingKey {
        case bgpStatus
        case peerAddress
        case peerAsn
        case transitGatewayAddress
        case transitGatewayAsn
    }

    public func validate() throws {
    }
}

public struct TransitGatewayAttachmentPropagation: Codable, Equatable {
    public var state: TransitGatewayPropagationState?
    public var transitGatewayRouteTableId: String?

    public init(state: TransitGatewayPropagationState? = nil,
                transitGatewayRouteTableId: String? = nil) {
        self.state = state
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayConnect: Codable, Equatable {
    public var creationTime: DateTime?
    public var options: TransitGatewayConnectOptions?
    public var state: TransitGatewayAttachmentState?
    public var tags: TagList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayId: TransitGatewayId?
    public var transportTransitGatewayAttachmentId: TransitGatewayAttachmentId?

    public init(creationTime: DateTime? = nil,
                options: TransitGatewayConnectOptions? = nil,
                state: TransitGatewayAttachmentState? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayId: TransitGatewayId? = nil,
                transportTransitGatewayAttachmentId: TransitGatewayAttachmentId? = nil) {
        self.creationTime = creationTime
        self.options = options
        self.state = state
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayId = transitGatewayId
        self.transportTransitGatewayAttachmentId = transportTransitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case options
        case state
        case tags = "tagSet"
        case transitGatewayAttachmentId
        case transitGatewayId
        case transportTransitGatewayAttachmentId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct TransitGatewayConnectOptions: Codable, Equatable {
    public var `protocol`: ProtocolValue?

    public init(`protocol`: ProtocolValue? = nil) {
        self.`protocol` = `protocol`
    }

    enum CodingKeys: String, CodingKey {
        case `protocol` = "protocol"
    }

    public func validate() throws {
    }
}

public struct TransitGatewayConnectPeer: Codable, Equatable {
    public var connectPeerConfiguration: TransitGatewayConnectPeerConfiguration?
    public var creationTime: DateTime?
    public var state: TransitGatewayConnectPeerState?
    public var tags: TagList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayConnectPeerId: TransitGatewayConnectPeerId?

    public init(connectPeerConfiguration: TransitGatewayConnectPeerConfiguration? = nil,
                creationTime: DateTime? = nil,
                state: TransitGatewayConnectPeerState? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayConnectPeerId: TransitGatewayConnectPeerId? = nil) {
        self.connectPeerConfiguration = connectPeerConfiguration
        self.creationTime = creationTime
        self.state = state
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayConnectPeerId = transitGatewayConnectPeerId
    }

    enum CodingKeys: String, CodingKey {
        case connectPeerConfiguration
        case creationTime
        case state
        case tags = "tagSet"
        case transitGatewayAttachmentId
        case transitGatewayConnectPeerId
    }

    public func validate() throws {
        try connectPeerConfiguration?.validate()
    }
}

public struct TransitGatewayConnectPeerConfiguration: Codable, Equatable {
    public var bgpConfigurations: TransitGatewayAttachmentBgpConfigurationList?
    public var insideCidrBlocks: InsideCidrBlocksStringList?
    public var peerAddress: String?
    public var `protocol`: ProtocolValue?
    public var transitGatewayAddress: String?

    public init(bgpConfigurations: TransitGatewayAttachmentBgpConfigurationList? = nil,
                insideCidrBlocks: InsideCidrBlocksStringList? = nil,
                peerAddress: String? = nil,
                `protocol`: ProtocolValue? = nil,
                transitGatewayAddress: String? = nil) {
        self.bgpConfigurations = bgpConfigurations
        self.insideCidrBlocks = insideCidrBlocks
        self.peerAddress = peerAddress
        self.`protocol` = `protocol`
        self.transitGatewayAddress = transitGatewayAddress
    }

    enum CodingKeys: String, CodingKey {
        case bgpConfigurations
        case insideCidrBlocks
        case peerAddress
        case `protocol` = "protocol"
        case transitGatewayAddress
    }

    public func validate() throws {
    }
}

public struct TransitGatewayConnectRequestBgpOptions: Codable, Equatable {
    public var peerAsn: Long?

    public init(peerAsn: Long? = nil) {
        self.peerAsn = peerAsn
    }

    enum CodingKeys: String, CodingKey {
        case peerAsn = "PeerAsn"
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastDeregisteredGroupMembers: Codable, Equatable {
    public var deregisteredNetworkInterfaceIds: ValueStringList?
    public var groupIpAddress: String?
    public var transitGatewayMulticastDomainId: String?

    public init(deregisteredNetworkInterfaceIds: ValueStringList? = nil,
                groupIpAddress: String? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.deregisteredNetworkInterfaceIds = deregisteredNetworkInterfaceIds
        self.groupIpAddress = groupIpAddress
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case deregisteredNetworkInterfaceIds
        case groupIpAddress
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastDeregisteredGroupSources: Codable, Equatable {
    public var deregisteredNetworkInterfaceIds: ValueStringList?
    public var groupIpAddress: String?
    public var transitGatewayMulticastDomainId: String?

    public init(deregisteredNetworkInterfaceIds: ValueStringList? = nil,
                groupIpAddress: String? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.deregisteredNetworkInterfaceIds = deregisteredNetworkInterfaceIds
        self.groupIpAddress = groupIpAddress
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case deregisteredNetworkInterfaceIds
        case groupIpAddress
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastDomain: Codable, Equatable {
    public var creationTime: DateTime?
    public var options: TransitGatewayMulticastDomainOptions?
    public var ownerId: String?
    public var state: TransitGatewayMulticastDomainState?
    public var tags: TagList?
    public var transitGatewayId: String?
    public var transitGatewayMulticastDomainArn: String?
    public var transitGatewayMulticastDomainId: String?

    public init(creationTime: DateTime? = nil,
                options: TransitGatewayMulticastDomainOptions? = nil,
                ownerId: String? = nil,
                state: TransitGatewayMulticastDomainState? = nil,
                tags: TagList? = nil,
                transitGatewayId: String? = nil,
                transitGatewayMulticastDomainArn: String? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.creationTime = creationTime
        self.options = options
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
        self.transitGatewayMulticastDomainArn = transitGatewayMulticastDomainArn
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case options
        case ownerId
        case state
        case tags = "tagSet"
        case transitGatewayId
        case transitGatewayMulticastDomainArn
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct TransitGatewayMulticastDomainAssociation: Codable, Equatable {
    public var resourceId: String?
    public var resourceOwnerId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var subnet: SubnetAssociation?
    public var transitGatewayAttachmentId: String?

    public init(resourceId: String? = nil,
                resourceOwnerId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                subnet: SubnetAssociation? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.resourceId = resourceId
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
        self.subnet = subnet
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceOwnerId
        case resourceType
        case subnet
        case transitGatewayAttachmentId
    }

    public func validate() throws {
        try subnet?.validate()
    }
}

public struct TransitGatewayMulticastDomainAssociations: Codable, Equatable {
    public var resourceId: String?
    public var resourceOwnerId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var subnets: SubnetAssociationList?
    public var transitGatewayAttachmentId: String?
    public var transitGatewayMulticastDomainId: String?

    public init(resourceId: String? = nil,
                resourceOwnerId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                subnets: SubnetAssociationList? = nil,
                transitGatewayAttachmentId: String? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.resourceId = resourceId
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
        self.subnets = subnets
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceOwnerId
        case resourceType
        case subnets
        case transitGatewayAttachmentId
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastDomainOptions: Codable, Equatable {
    public var autoAcceptSharedAssociations: AutoAcceptSharedAssociationsValue?
    public var igmpv2Support: Igmpv2SupportValue?
    public var staticSourcesSupport: StaticSourcesSupportValue?

    public init(autoAcceptSharedAssociations: AutoAcceptSharedAssociationsValue? = nil,
                igmpv2Support: Igmpv2SupportValue? = nil,
                staticSourcesSupport: StaticSourcesSupportValue? = nil) {
        self.autoAcceptSharedAssociations = autoAcceptSharedAssociations
        self.igmpv2Support = igmpv2Support
        self.staticSourcesSupport = staticSourcesSupport
    }

    enum CodingKeys: String, CodingKey {
        case autoAcceptSharedAssociations
        case igmpv2Support
        case staticSourcesSupport
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastGroup: Codable, Equatable {
    public var groupIpAddress: String?
    public var groupMember: Boolean?
    public var groupSource: Boolean?
    public var memberType: MembershipType?
    public var networkInterfaceId: String?
    public var resourceId: String?
    public var resourceOwnerId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var sourceType: MembershipType?
    public var subnetId: String?
    public var transitGatewayAttachmentId: String?

    public init(groupIpAddress: String? = nil,
                groupMember: Boolean? = nil,
                groupSource: Boolean? = nil,
                memberType: MembershipType? = nil,
                networkInterfaceId: String? = nil,
                resourceId: String? = nil,
                resourceOwnerId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                sourceType: MembershipType? = nil,
                subnetId: String? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.groupIpAddress = groupIpAddress
        self.groupMember = groupMember
        self.groupSource = groupSource
        self.memberType = memberType
        self.networkInterfaceId = networkInterfaceId
        self.resourceId = resourceId
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
        self.sourceType = sourceType
        self.subnetId = subnetId
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case groupIpAddress
        case groupMember
        case groupSource
        case memberType
        case networkInterfaceId
        case resourceId
        case resourceOwnerId
        case resourceType
        case sourceType
        case subnetId
        case transitGatewayAttachmentId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastRegisteredGroupMembers: Codable, Equatable {
    public var groupIpAddress: String?
    public var registeredNetworkInterfaceIds: ValueStringList?
    public var transitGatewayMulticastDomainId: String?

    public init(groupIpAddress: String? = nil,
                registeredNetworkInterfaceIds: ValueStringList? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.groupIpAddress = groupIpAddress
        self.registeredNetworkInterfaceIds = registeredNetworkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case groupIpAddress
        case registeredNetworkInterfaceIds
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastRegisteredGroupSources: Codable, Equatable {
    public var groupIpAddress: String?
    public var registeredNetworkInterfaceIds: ValueStringList?
    public var transitGatewayMulticastDomainId: String?

    public init(groupIpAddress: String? = nil,
                registeredNetworkInterfaceIds: ValueStringList? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.groupIpAddress = groupIpAddress
        self.registeredNetworkInterfaceIds = registeredNetworkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case groupIpAddress
        case registeredNetworkInterfaceIds
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayOptions: Codable, Equatable {
    public var amazonSideAsn: Long?
    public var associationDefaultRouteTableId: String?
    public var autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue?
    public var defaultRouteTableAssociation: DefaultRouteTableAssociationValue?
    public var defaultRouteTablePropagation: DefaultRouteTablePropagationValue?
    public var dnsSupport: DnsSupportValue?
    public var multicastSupport: MulticastSupportValue?
    public var propagationDefaultRouteTableId: String?
    public var transitGatewayCidrBlocks: ValueStringList?
    public var vpnEcmpSupport: VpnEcmpSupportValue?

    public init(amazonSideAsn: Long? = nil,
                associationDefaultRouteTableId: String? = nil,
                autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue? = nil,
                defaultRouteTableAssociation: DefaultRouteTableAssociationValue? = nil,
                defaultRouteTablePropagation: DefaultRouteTablePropagationValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                multicastSupport: MulticastSupportValue? = nil,
                propagationDefaultRouteTableId: String? = nil,
                transitGatewayCidrBlocks: ValueStringList? = nil,
                vpnEcmpSupport: VpnEcmpSupportValue? = nil) {
        self.amazonSideAsn = amazonSideAsn
        self.associationDefaultRouteTableId = associationDefaultRouteTableId
        self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
        self.defaultRouteTableAssociation = defaultRouteTableAssociation
        self.defaultRouteTablePropagation = defaultRouteTablePropagation
        self.dnsSupport = dnsSupport
        self.multicastSupport = multicastSupport
        self.propagationDefaultRouteTableId = propagationDefaultRouteTableId
        self.transitGatewayCidrBlocks = transitGatewayCidrBlocks
        self.vpnEcmpSupport = vpnEcmpSupport
    }

    enum CodingKeys: String, CodingKey {
        case amazonSideAsn
        case associationDefaultRouteTableId
        case autoAcceptSharedAttachments
        case defaultRouteTableAssociation
        case defaultRouteTablePropagation
        case dnsSupport
        case multicastSupport
        case propagationDefaultRouteTableId
        case transitGatewayCidrBlocks
        case vpnEcmpSupport
    }

    public func validate() throws {
    }
}

public struct TransitGatewayPeeringAttachment: Codable, Equatable {
    public var accepterTgwInfo: PeeringTgwInfo?
    public var creationTime: DateTime?
    public var requesterTgwInfo: PeeringTgwInfo?
    public var state: TransitGatewayAttachmentState?
    public var status: PeeringAttachmentStatus?
    public var tags: TagList?
    public var transitGatewayAttachmentId: String?

    public init(accepterTgwInfo: PeeringTgwInfo? = nil,
                creationTime: DateTime? = nil,
                requesterTgwInfo: PeeringTgwInfo? = nil,
                state: TransitGatewayAttachmentState? = nil,
                status: PeeringAttachmentStatus? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.accepterTgwInfo = accepterTgwInfo
        self.creationTime = creationTime
        self.requesterTgwInfo = requesterTgwInfo
        self.state = state
        self.status = status
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case accepterTgwInfo
        case creationTime
        case requesterTgwInfo
        case state
        case status
        case tags = "tagSet"
        case transitGatewayAttachmentId
    }

    public func validate() throws {
        try accepterTgwInfo?.validate()
        try requesterTgwInfo?.validate()
        try status?.validate()
    }
}

public struct TransitGatewayPrefixListAttachment: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case transitGatewayAttachmentId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayPrefixListReference: Codable, Equatable {
    public var blackhole: Boolean?
    public var prefixListId: PrefixListResourceId?
    public var prefixListOwnerId: String?
    public var state: TransitGatewayPrefixListReferenceState?
    public var transitGatewayAttachment: TransitGatewayPrefixListAttachment?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId?

    public init(blackhole: Boolean? = nil,
                prefixListId: PrefixListResourceId? = nil,
                prefixListOwnerId: String? = nil,
                state: TransitGatewayPrefixListReferenceState? = nil,
                transitGatewayAttachment: TransitGatewayPrefixListAttachment? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId? = nil) {
        self.blackhole = blackhole
        self.prefixListId = prefixListId
        self.prefixListOwnerId = prefixListOwnerId
        self.state = state
        self.transitGatewayAttachment = transitGatewayAttachment
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole
        case prefixListId
        case prefixListOwnerId
        case state
        case transitGatewayAttachment
        case transitGatewayRouteTableId
    }

    public func validate() throws {
        try transitGatewayAttachment?.validate()
    }
}

public struct TransitGatewayPropagation: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayPropagationState?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: String?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayPropagationState? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: String? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.state = state
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case state
        case transitGatewayAttachmentId
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRequestOptions: Codable, Equatable {
    public var amazonSideAsn: Long?
    public var autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue?
    public var defaultRouteTableAssociation: DefaultRouteTableAssociationValue?
    public var defaultRouteTablePropagation: DefaultRouteTablePropagationValue?
    public var dnsSupport: DnsSupportValue?
    public var multicastSupport: MulticastSupportValue?
    public var transitGatewayCidrBlocks: TransitGatewayCidrBlockStringList?
    public var vpnEcmpSupport: VpnEcmpSupportValue?

    public init(amazonSideAsn: Long? = nil,
                autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue? = nil,
                defaultRouteTableAssociation: DefaultRouteTableAssociationValue? = nil,
                defaultRouteTablePropagation: DefaultRouteTablePropagationValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                multicastSupport: MulticastSupportValue? = nil,
                transitGatewayCidrBlocks: TransitGatewayCidrBlockStringList? = nil,
                vpnEcmpSupport: VpnEcmpSupportValue? = nil) {
        self.amazonSideAsn = amazonSideAsn
        self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
        self.defaultRouteTableAssociation = defaultRouteTableAssociation
        self.defaultRouteTablePropagation = defaultRouteTablePropagation
        self.dnsSupport = dnsSupport
        self.multicastSupport = multicastSupport
        self.transitGatewayCidrBlocks = transitGatewayCidrBlocks
        self.vpnEcmpSupport = vpnEcmpSupport
    }

    enum CodingKeys: String, CodingKey {
        case amazonSideAsn = "AmazonSideAsn"
        case autoAcceptSharedAttachments = "AutoAcceptSharedAttachments"
        case defaultRouteTableAssociation = "DefaultRouteTableAssociation"
        case defaultRouteTablePropagation = "DefaultRouteTablePropagation"
        case dnsSupport = "DnsSupport"
        case multicastSupport = "MulticastSupport"
        case transitGatewayCidrBlocks = "TransitGatewayCidrBlocks"
        case vpnEcmpSupport = "VpnEcmpSupport"
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRoute: Codable, Equatable {
    public var destinationCidrBlock: String?
    public var prefixListId: PrefixListResourceId?
    public var state: TransitGatewayRouteState?
    public var transitGatewayAttachments: TransitGatewayRouteAttachmentList?
    public var type: TransitGatewayRouteType?

    public init(destinationCidrBlock: String? = nil,
                prefixListId: PrefixListResourceId? = nil,
                state: TransitGatewayRouteState? = nil,
                transitGatewayAttachments: TransitGatewayRouteAttachmentList? = nil,
                type: TransitGatewayRouteType? = nil) {
        self.destinationCidrBlock = destinationCidrBlock
        self.prefixListId = prefixListId
        self.state = state
        self.transitGatewayAttachments = transitGatewayAttachments
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock
        case prefixListId
        case state
        case transitGatewayAttachments
        case type
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteAttachment: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var transitGatewayAttachmentId: String?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case transitGatewayAttachmentId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteTable: Codable, Equatable {
    public var creationTime: DateTime?
    public var defaultAssociationRouteTable: Boolean?
    public var defaultPropagationRouteTable: Boolean?
    public var state: TransitGatewayRouteTableState?
    public var tags: TagList?
    public var transitGatewayId: String?
    public var transitGatewayRouteTableId: String?

    public init(creationTime: DateTime? = nil,
                defaultAssociationRouteTable: Boolean? = nil,
                defaultPropagationRouteTable: Boolean? = nil,
                state: TransitGatewayRouteTableState? = nil,
                tags: TagList? = nil,
                transitGatewayId: String? = nil,
                transitGatewayRouteTableId: String? = nil) {
        self.creationTime = creationTime
        self.defaultAssociationRouteTable = defaultAssociationRouteTable
        self.defaultPropagationRouteTable = defaultPropagationRouteTable
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case defaultAssociationRouteTable
        case defaultPropagationRouteTable
        case state
        case tags = "tagSet"
        case transitGatewayId
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteTableAssociation: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayAssociationState?
    public var transitGatewayAttachmentId: String?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayAssociationState? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.state = state
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case state
        case transitGatewayAttachmentId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteTablePropagation: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayPropagationState?
    public var transitGatewayAttachmentId: String?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayPropagationState? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.state = state
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case state
        case transitGatewayAttachmentId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayVpcAttachment: Codable, Equatable {
    public var creationTime: DateTime?
    public var options: TransitGatewayVpcAttachmentOptions?
    public var state: TransitGatewayAttachmentState?
    public var subnetIds: ValueStringList?
    public var tags: TagList?
    public var transitGatewayAttachmentId: String?
    public var transitGatewayId: String?
    public var vpcId: String?
    public var vpcOwnerId: String?

    public init(creationTime: DateTime? = nil,
                options: TransitGatewayVpcAttachmentOptions? = nil,
                state: TransitGatewayAttachmentState? = nil,
                subnetIds: ValueStringList? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: String? = nil,
                transitGatewayId: String? = nil,
                vpcId: String? = nil,
                vpcOwnerId: String? = nil) {
        self.creationTime = creationTime
        self.options = options
        self.state = state
        self.subnetIds = subnetIds
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayId = transitGatewayId
        self.vpcId = vpcId
        self.vpcOwnerId = vpcOwnerId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case options
        case state
        case subnetIds
        case tags = "tagSet"
        case transitGatewayAttachmentId
        case transitGatewayId
        case vpcId
        case vpcOwnerId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct TransitGatewayVpcAttachmentOptions: Codable, Equatable {
    public var applianceModeSupport: ApplianceModeSupportValue?
    public var dnsSupport: DnsSupportValue?
    public var ipv6Support: Ipv6SupportValue?

    public init(applianceModeSupport: ApplianceModeSupportValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                ipv6Support: Ipv6SupportValue? = nil) {
        self.applianceModeSupport = applianceModeSupport
        self.dnsSupport = dnsSupport
        self.ipv6Support = ipv6Support
    }

    enum CodingKeys: String, CodingKey {
        case applianceModeSupport
        case dnsSupport
        case ipv6Support
    }

    public func validate() throws {
    }
}

public struct TunnelOption: Codable, Equatable {
    public var dpdTimeoutAction: String?
    public var dpdTimeoutSeconds: Integer?
    public var ikeVersions: IKEVersionsList?
    public var outsideIpAddress: String?
    public var phase1DHGroupNumbers: Phase1DHGroupNumbersList?
    public var phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsList?
    public var phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsList?
    public var phase1LifetimeSeconds: Integer?
    public var phase2DHGroupNumbers: Phase2DHGroupNumbersList?
    public var phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsList?
    public var phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsList?
    public var phase2LifetimeSeconds: Integer?
    public var preSharedKey: String?
    public var rekeyFuzzPercentage: Integer?
    public var rekeyMarginTimeSeconds: Integer?
    public var replayWindowSize: Integer?
    public var startupAction: String?
    public var tunnelInsideCidr: String?
    public var tunnelInsideIpv6Cidr: String?

    public init(dpdTimeoutAction: String? = nil,
                dpdTimeoutSeconds: Integer? = nil,
                ikeVersions: IKEVersionsList? = nil,
                outsideIpAddress: String? = nil,
                phase1DHGroupNumbers: Phase1DHGroupNumbersList? = nil,
                phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsList? = nil,
                phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsList? = nil,
                phase1LifetimeSeconds: Integer? = nil,
                phase2DHGroupNumbers: Phase2DHGroupNumbersList? = nil,
                phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsList? = nil,
                phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsList? = nil,
                phase2LifetimeSeconds: Integer? = nil,
                preSharedKey: String? = nil,
                rekeyFuzzPercentage: Integer? = nil,
                rekeyMarginTimeSeconds: Integer? = nil,
                replayWindowSize: Integer? = nil,
                startupAction: String? = nil,
                tunnelInsideCidr: String? = nil,
                tunnelInsideIpv6Cidr: String? = nil) {
        self.dpdTimeoutAction = dpdTimeoutAction
        self.dpdTimeoutSeconds = dpdTimeoutSeconds
        self.ikeVersions = ikeVersions
        self.outsideIpAddress = outsideIpAddress
        self.phase1DHGroupNumbers = phase1DHGroupNumbers
        self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
        self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
        self.phase1LifetimeSeconds = phase1LifetimeSeconds
        self.phase2DHGroupNumbers = phase2DHGroupNumbers
        self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
        self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
        self.phase2LifetimeSeconds = phase2LifetimeSeconds
        self.preSharedKey = preSharedKey
        self.rekeyFuzzPercentage = rekeyFuzzPercentage
        self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
        self.replayWindowSize = replayWindowSize
        self.startupAction = startupAction
        self.tunnelInsideCidr = tunnelInsideCidr
        self.tunnelInsideIpv6Cidr = tunnelInsideIpv6Cidr
    }

    enum CodingKeys: String, CodingKey {
        case dpdTimeoutAction
        case dpdTimeoutSeconds
        case ikeVersions = "ikeVersionSet"
        case outsideIpAddress
        case phase1DHGroupNumbers = "phase1DHGroupNumberSet"
        case phase1EncryptionAlgorithms = "phase1EncryptionAlgorithmSet"
        case phase1IntegrityAlgorithms = "phase1IntegrityAlgorithmSet"
        case phase1LifetimeSeconds
        case phase2DHGroupNumbers = "phase2DHGroupNumberSet"
        case phase2EncryptionAlgorithms = "phase2EncryptionAlgorithmSet"
        case phase2IntegrityAlgorithms = "phase2IntegrityAlgorithmSet"
        case phase2LifetimeSeconds
        case preSharedKey
        case rekeyFuzzPercentage
        case rekeyMarginTimeSeconds
        case replayWindowSize
        case startupAction
        case tunnelInsideCidr
        case tunnelInsideIpv6Cidr
    }

    public func validate() throws {
    }
}

public struct UnassignIpv6AddressesRequest: Codable, Equatable {
    public var ipv6Addresses: Ipv6AddressList
    public var networkInterfaceId: NetworkInterfaceId

    public init(ipv6Addresses: Ipv6AddressList,
                networkInterfaceId: NetworkInterfaceId) {
        self.ipv6Addresses = ipv6Addresses
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Addresses
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct UnassignIpv6AddressesResult: Codable, Equatable {
    public var networkInterfaceId: String?
    public var unassignedIpv6Addresses: Ipv6AddressList?

    public init(networkInterfaceId: String? = nil,
                unassignedIpv6Addresses: Ipv6AddressList? = nil) {
        self.networkInterfaceId = networkInterfaceId
        self.unassignedIpv6Addresses = unassignedIpv6Addresses
    }

    enum CodingKeys: String, CodingKey {
        case networkInterfaceId
        case unassignedIpv6Addresses
    }

    public func validate() throws {
    }
}

public struct UnassignPrivateIpAddressesRequest: Codable, Equatable {
    public var networkInterfaceId: NetworkInterfaceId
    public var privateIpAddresses: PrivateIpAddressStringList

    public init(networkInterfaceId: NetworkInterfaceId,
                privateIpAddresses: PrivateIpAddressStringList) {
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddresses = privateIpAddresses
    }

    enum CodingKeys: String, CodingKey {
        case networkInterfaceId
        case privateIpAddresses = "privateIpAddress"
    }

    public func validate() throws {
    }
}

public struct UnmonitorInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct UnmonitorInstancesResult: Codable, Equatable {
    public var instanceMonitorings: InstanceMonitoringList?

    public init(instanceMonitorings: InstanceMonitoringList? = nil) {
        self.instanceMonitorings = instanceMonitorings
    }

    enum CodingKeys: String, CodingKey {
        case instanceMonitorings = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct UnsuccessfulInstanceCreditSpecificationItem: Codable, Equatable {
    public var error: UnsuccessfulInstanceCreditSpecificationItemError?
    public var instanceId: String?

    public init(error: UnsuccessfulInstanceCreditSpecificationItemError? = nil,
                instanceId: String? = nil) {
        self.error = error
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case instanceId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct UnsuccessfulInstanceCreditSpecificationItemError: Codable, Equatable {
    public var code: UnsuccessfulInstanceCreditSpecificationErrorCode?
    public var message: String?

    public init(code: UnsuccessfulInstanceCreditSpecificationErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct UnsuccessfulItem: Codable, Equatable {
    public var error: UnsuccessfulItemError?
    public var resourceId: String?

    public init(error: UnsuccessfulItemError? = nil,
                resourceId: String? = nil) {
        self.error = error
        self.resourceId = resourceId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case resourceId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct UnsuccessfulItemError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct UpdateSecurityGroupRuleDescriptionsEgressRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?
    public var ipPermissions: IpPermissionList

    public init(dryRun: Boolean? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil,
                ipPermissions: IpPermissionList) {
        self.dryRun = dryRun
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
    }

    public func validate() throws {
    }
}

public struct UpdateSecurityGroupRuleDescriptionsEgressResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct UpdateSecurityGroupRuleDescriptionsIngressRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?
    public var ipPermissions: IpPermissionList

    public init(dryRun: Boolean? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil,
                ipPermissions: IpPermissionList) {
        self.dryRun = dryRun
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
    }

    public func validate() throws {
    }
}

public struct UpdateSecurityGroupRuleDescriptionsIngressResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct UserBucket: Codable, Equatable {
    public var s3Bucket: String?
    public var s3Key: String?

    public init(s3Bucket: String? = nil,
                s3Key: String? = nil) {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }

    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func validate() throws {
    }
}

public struct UserBucketDetails: Codable, Equatable {
    public var s3Bucket: String?
    public var s3Key: String?

    public init(s3Bucket: String? = nil,
                s3Key: String? = nil) {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }

    enum CodingKeys: String, CodingKey {
        case s3Bucket
        case s3Key
    }

    public func validate() throws {
    }
}

public struct UserData: Codable, Equatable {
    public var data: String?

    public init(data: String? = nil) {
        self.data = data
    }

    enum CodingKeys: String, CodingKey {
        case data
    }

    public func validate() throws {
    }
}

public struct UserIdGroupPair: Codable, Equatable {
    public var description: String?
    public var groupId: String?
    public var groupName: String?
    public var peeringStatus: String?
    public var userId: String?
    public var vpcId: String?
    public var vpcPeeringConnectionId: String?

    public init(description: String? = nil,
                groupId: String? = nil,
                groupName: String? = nil,
                peeringStatus: String? = nil,
                userId: String? = nil,
                vpcId: String? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.description = description
        self.groupId = groupId
        self.groupName = groupName
        self.peeringStatus = peeringStatus
        self.userId = userId
        self.vpcId = vpcId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case groupId
        case groupName
        case peeringStatus
        case userId
        case vpcId
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct VCpuInfo: Codable, Equatable {
    public var defaultCores: CoreCount?
    public var defaultThreadsPerCore: ThreadsPerCore?
    public var defaultVCpus: VCpuCount?
    public var validCores: CoreCountList?
    public var validThreadsPerCore: ThreadsPerCoreList?

    public init(defaultCores: CoreCount? = nil,
                defaultThreadsPerCore: ThreadsPerCore? = nil,
                defaultVCpus: VCpuCount? = nil,
                validCores: CoreCountList? = nil,
                validThreadsPerCore: ThreadsPerCoreList? = nil) {
        self.defaultCores = defaultCores
        self.defaultThreadsPerCore = defaultThreadsPerCore
        self.defaultVCpus = defaultVCpus
        self.validCores = validCores
        self.validThreadsPerCore = validThreadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case defaultCores
        case defaultThreadsPerCore
        case defaultVCpus
        case validCores
        case validThreadsPerCore
    }

    public func validate() throws {
    }
}

public struct ValidationError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ValidationWarning: Codable, Equatable {
    public var errors: ErrorSet?

    public init(errors: ErrorSet? = nil) {
        self.errors = errors
    }

    enum CodingKeys: String, CodingKey {
        case errors = "errorSet"
    }

    public func validate() throws {
    }
}

public struct VgwTelemetry: Codable, Equatable {
    public var acceptedRouteCount: Integer?
    public var certificateArn: String?
    public var lastStatusChange: DateTime?
    public var outsideIpAddress: String?
    public var status: TelemetryStatus?
    public var statusMessage: String?

    public init(acceptedRouteCount: Integer? = nil,
                certificateArn: String? = nil,
                lastStatusChange: DateTime? = nil,
                outsideIpAddress: String? = nil,
                status: TelemetryStatus? = nil,
                statusMessage: String? = nil) {
        self.acceptedRouteCount = acceptedRouteCount
        self.certificateArn = certificateArn
        self.lastStatusChange = lastStatusChange
        self.outsideIpAddress = outsideIpAddress
        self.status = status
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case acceptedRouteCount
        case certificateArn
        case lastStatusChange
        case outsideIpAddress
        case status
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct Volume: Codable, Equatable {
    public var attachments: VolumeAttachmentList?
    public var availabilityZone: String?
    public var createTime: DateTime?
    public var encrypted: Boolean?
    public var fastRestored: Boolean?
    public var iops: Integer?
    public var kmsKeyId: String?
    public var multiAttachEnabled: Boolean?
    public var outpostArn: String?
    public var size: Integer?
    public var snapshotId: String?
    public var state: VolumeState?
    public var tags: TagList?
    public var throughput: Integer?
    public var volumeId: String?
    public var volumeType: VolumeType?

    public init(attachments: VolumeAttachmentList? = nil,
                availabilityZone: String? = nil,
                createTime: DateTime? = nil,
                encrypted: Boolean? = nil,
                fastRestored: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: String? = nil,
                multiAttachEnabled: Boolean? = nil,
                outpostArn: String? = nil,
                size: Integer? = nil,
                snapshotId: String? = nil,
                state: VolumeState? = nil,
                tags: TagList? = nil,
                throughput: Integer? = nil,
                volumeId: String? = nil,
                volumeType: VolumeType? = nil) {
        self.attachments = attachments
        self.availabilityZone = availabilityZone
        self.createTime = createTime
        self.encrypted = encrypted
        self.fastRestored = fastRestored
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.multiAttachEnabled = multiAttachEnabled
        self.outpostArn = outpostArn
        self.size = size
        self.snapshotId = snapshotId
        self.state = state
        self.tags = tags
        self.throughput = throughput
        self.volumeId = volumeId
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case attachments = "attachmentSet"
        case availabilityZone
        case createTime
        case encrypted
        case fastRestored
        case iops
        case kmsKeyId
        case multiAttachEnabled
        case outpostArn
        case size
        case snapshotId
        case state = "status"
        case tags = "tagSet"
        case throughput
        case volumeId
        case volumeType
    }

    public func validate() throws {
    }
}

public struct VolumeAttachment: Codable, Equatable {
    public var attachTime: DateTime?
    public var deleteOnTermination: Boolean?
    public var device: String?
    public var instanceId: String?
    public var state: VolumeAttachmentState?
    public var volumeId: String?

    public init(attachTime: DateTime? = nil,
                deleteOnTermination: Boolean? = nil,
                device: String? = nil,
                instanceId: String? = nil,
                state: VolumeAttachmentState? = nil,
                volumeId: String? = nil) {
        self.attachTime = attachTime
        self.deleteOnTermination = deleteOnTermination
        self.device = device
        self.instanceId = instanceId
        self.state = state
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case attachTime
        case deleteOnTermination
        case device
        case instanceId
        case state = "status"
        case volumeId
    }

    public func validate() throws {
    }
}

public struct VolumeDetail: Codable, Equatable {
    public var size: Long

    public init(size: Long) {
        self.size = size
    }

    enum CodingKeys: String, CodingKey {
        case size
    }

    public func validate() throws {
    }
}

public struct VolumeModification: Codable, Equatable {
    public var endTime: DateTime?
    public var modificationState: VolumeModificationState?
    public var originalIops: Integer?
    public var originalSize: Integer?
    public var originalThroughput: Integer?
    public var originalVolumeType: VolumeType?
    public var progress: Long?
    public var startTime: DateTime?
    public var statusMessage: String?
    public var targetIops: Integer?
    public var targetSize: Integer?
    public var targetThroughput: Integer?
    public var targetVolumeType: VolumeType?
    public var volumeId: String?

    public init(endTime: DateTime? = nil,
                modificationState: VolumeModificationState? = nil,
                originalIops: Integer? = nil,
                originalSize: Integer? = nil,
                originalThroughput: Integer? = nil,
                originalVolumeType: VolumeType? = nil,
                progress: Long? = nil,
                startTime: DateTime? = nil,
                statusMessage: String? = nil,
                targetIops: Integer? = nil,
                targetSize: Integer? = nil,
                targetThroughput: Integer? = nil,
                targetVolumeType: VolumeType? = nil,
                volumeId: String? = nil) {
        self.endTime = endTime
        self.modificationState = modificationState
        self.originalIops = originalIops
        self.originalSize = originalSize
        self.originalThroughput = originalThroughput
        self.originalVolumeType = originalVolumeType
        self.progress = progress
        self.startTime = startTime
        self.statusMessage = statusMessage
        self.targetIops = targetIops
        self.targetSize = targetSize
        self.targetThroughput = targetThroughput
        self.targetVolumeType = targetVolumeType
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case endTime
        case modificationState
        case originalIops
        case originalSize
        case originalThroughput
        case originalVolumeType
        case progress
        case startTime
        case statusMessage
        case targetIops
        case targetSize
        case targetThroughput
        case targetVolumeType
        case volumeId
    }

    public func validate() throws {
    }
}

public struct VolumeStatusAction: Codable, Equatable {
    public var code: String?
    public var description: String?
    public var eventId: String?
    public var eventType: String?

    public init(code: String? = nil,
                description: String? = nil,
                eventId: String? = nil,
                eventType: String? = nil) {
        self.code = code
        self.description = description
        self.eventId = eventId
        self.eventType = eventType
    }

    enum CodingKeys: String, CodingKey {
        case code
        case description
        case eventId
        case eventType
    }

    public func validate() throws {
    }
}

public struct VolumeStatusAttachmentStatus: Codable, Equatable {
    public var instanceId: String?
    public var ioPerformance: String?

    public init(instanceId: String? = nil,
                ioPerformance: String? = nil) {
        self.instanceId = instanceId
        self.ioPerformance = ioPerformance
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case ioPerformance
    }

    public func validate() throws {
    }
}

public struct VolumeStatusDetails: Codable, Equatable {
    public var name: VolumeStatusName?
    public var status: String?

    public init(name: VolumeStatusName? = nil,
                status: String? = nil) {
        self.name = name
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case name
        case status
    }

    public func validate() throws {
    }
}

public struct VolumeStatusEvent: Codable, Equatable {
    public var description: String?
    public var eventId: String?
    public var eventType: String?
    public var instanceId: String?
    public var notAfter: MillisecondDateTime?
    public var notBefore: MillisecondDateTime?

    public init(description: String? = nil,
                eventId: String? = nil,
                eventType: String? = nil,
                instanceId: String? = nil,
                notAfter: MillisecondDateTime? = nil,
                notBefore: MillisecondDateTime? = nil) {
        self.description = description
        self.eventId = eventId
        self.eventType = eventType
        self.instanceId = instanceId
        self.notAfter = notAfter
        self.notBefore = notBefore
    }

    enum CodingKeys: String, CodingKey {
        case description
        case eventId
        case eventType
        case instanceId
        case notAfter
        case notBefore
    }

    public func validate() throws {
    }
}

public struct VolumeStatusInfo: Codable, Equatable {
    public var details: VolumeStatusDetailsList?
    public var status: VolumeStatusInfoStatus?

    public init(details: VolumeStatusDetailsList? = nil,
                status: VolumeStatusInfoStatus? = nil) {
        self.details = details
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case details
        case status
    }

    public func validate() throws {
    }
}

public struct VolumeStatusItem: Codable, Equatable {
    public var actions: VolumeStatusActionsList?
    public var attachmentStatuses: VolumeStatusAttachmentStatusList?
    public var availabilityZone: String?
    public var events: VolumeStatusEventsList?
    public var outpostArn: String?
    public var volumeId: String?
    public var volumeStatus: VolumeStatusInfo?

    public init(actions: VolumeStatusActionsList? = nil,
                attachmentStatuses: VolumeStatusAttachmentStatusList? = nil,
                availabilityZone: String? = nil,
                events: VolumeStatusEventsList? = nil,
                outpostArn: String? = nil,
                volumeId: String? = nil,
                volumeStatus: VolumeStatusInfo? = nil) {
        self.actions = actions
        self.attachmentStatuses = attachmentStatuses
        self.availabilityZone = availabilityZone
        self.events = events
        self.outpostArn = outpostArn
        self.volumeId = volumeId
        self.volumeStatus = volumeStatus
    }

    enum CodingKeys: String, CodingKey {
        case actions = "actionsSet"
        case attachmentStatuses
        case availabilityZone
        case events = "eventsSet"
        case outpostArn
        case volumeId
        case volumeStatus
    }

    public func validate() throws {
        try volumeStatus?.validate()
    }
}

public struct Vpc: Codable, Equatable {
    public var cidrBlock: String?
    public var cidrBlockAssociationSet: VpcCidrBlockAssociationSet?
    public var dhcpOptionsId: String?
    public var instanceTenancy: Tenancy?
    public var ipv6CidrBlockAssociationSet: VpcIpv6CidrBlockAssociationSet?
    public var isDefault: Boolean?
    public var ownerId: String?
    public var state: VpcState?
    public var tags: TagList?
    public var vpcId: String?

    public init(cidrBlock: String? = nil,
                cidrBlockAssociationSet: VpcCidrBlockAssociationSet? = nil,
                dhcpOptionsId: String? = nil,
                instanceTenancy: Tenancy? = nil,
                ipv6CidrBlockAssociationSet: VpcIpv6CidrBlockAssociationSet? = nil,
                isDefault: Boolean? = nil,
                ownerId: String? = nil,
                state: VpcState? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.cidrBlock = cidrBlock
        self.cidrBlockAssociationSet = cidrBlockAssociationSet
        self.dhcpOptionsId = dhcpOptionsId
        self.instanceTenancy = instanceTenancy
        self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
        self.isDefault = isDefault
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case cidrBlockAssociationSet
        case dhcpOptionsId
        case instanceTenancy
        case ipv6CidrBlockAssociationSet
        case isDefault
        case ownerId
        case state
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct VpcAttachment: Codable, Equatable {
    public var state: AttachmentStatus?
    public var vpcId: String?

    public init(state: AttachmentStatus? = nil,
                vpcId: String? = nil) {
        self.state = state
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case vpcId
    }

    public func validate() throws {
    }
}

public struct VpcCidrBlockAssociation: Codable, Equatable {
    public var associationId: String?
    public var cidrBlock: String?
    public var cidrBlockState: VpcCidrBlockState?

    public init(associationId: String? = nil,
                cidrBlock: String? = nil,
                cidrBlockState: VpcCidrBlockState? = nil) {
        self.associationId = associationId
        self.cidrBlock = cidrBlock
        self.cidrBlockState = cidrBlockState
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case cidrBlock
        case cidrBlockState
    }

    public func validate() throws {
        try cidrBlockState?.validate()
    }
}

public struct VpcCidrBlockState: Codable, Equatable {
    public var state: VpcCidrBlockStateCode?
    public var statusMessage: String?

    public init(state: VpcCidrBlockStateCode? = nil,
                statusMessage: String? = nil) {
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct VpcClassicLink: Codable, Equatable {
    public var classicLinkEnabled: Boolean?
    public var tags: TagList?
    public var vpcId: String?

    public init(classicLinkEnabled: Boolean? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.classicLinkEnabled = classicLinkEnabled
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case classicLinkEnabled
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct VpcEndpoint: Codable, Equatable {
    public var creationTimestamp: MillisecondDateTime?
    public var dnsEntries: DnsEntrySet?
    public var groups: GroupIdentifierSet?
    public var lastError: LastError?
    public var networkInterfaceIds: ValueStringList?
    public var ownerId: String?
    public var policyDocument: String?
    public var privateDnsEnabled: Boolean?
    public var requesterManaged: Boolean?
    public var routeTableIds: ValueStringList?
    public var serviceName: String?
    public var state: State?
    public var subnetIds: ValueStringList?
    public var tags: TagList?
    public var vpcEndpointId: String?
    public var vpcEndpointType: VpcEndpointType?
    public var vpcId: String?

    public init(creationTimestamp: MillisecondDateTime? = nil,
                dnsEntries: DnsEntrySet? = nil,
                groups: GroupIdentifierSet? = nil,
                lastError: LastError? = nil,
                networkInterfaceIds: ValueStringList? = nil,
                ownerId: String? = nil,
                policyDocument: String? = nil,
                privateDnsEnabled: Boolean? = nil,
                requesterManaged: Boolean? = nil,
                routeTableIds: ValueStringList? = nil,
                serviceName: String? = nil,
                state: State? = nil,
                subnetIds: ValueStringList? = nil,
                tags: TagList? = nil,
                vpcEndpointId: String? = nil,
                vpcEndpointType: VpcEndpointType? = nil,
                vpcId: String? = nil) {
        self.creationTimestamp = creationTimestamp
        self.dnsEntries = dnsEntries
        self.groups = groups
        self.lastError = lastError
        self.networkInterfaceIds = networkInterfaceIds
        self.ownerId = ownerId
        self.policyDocument = policyDocument
        self.privateDnsEnabled = privateDnsEnabled
        self.requesterManaged = requesterManaged
        self.routeTableIds = routeTableIds
        self.serviceName = serviceName
        self.state = state
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcEndpointId = vpcEndpointId
        self.vpcEndpointType = vpcEndpointType
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case creationTimestamp
        case dnsEntries = "dnsEntrySet"
        case groups = "groupSet"
        case lastError
        case networkInterfaceIds = "networkInterfaceIdSet"
        case ownerId
        case policyDocument
        case privateDnsEnabled
        case requesterManaged
        case routeTableIds = "routeTableIdSet"
        case serviceName
        case state
        case subnetIds = "subnetIdSet"
        case tags = "tagSet"
        case vpcEndpointId
        case vpcEndpointType
        case vpcId
    }

    public func validate() throws {
        try lastError?.validate()
    }
}

public struct VpcEndpointConnection: Codable, Equatable {
    public var creationTimestamp: MillisecondDateTime?
    public var dnsEntries: DnsEntrySet?
    public var gatewayLoadBalancerArns: ValueStringList?
    public var networkLoadBalancerArns: ValueStringList?
    public var serviceId: String?
    public var vpcEndpointId: String?
    public var vpcEndpointOwner: String?
    public var vpcEndpointState: State?

    public init(creationTimestamp: MillisecondDateTime? = nil,
                dnsEntries: DnsEntrySet? = nil,
                gatewayLoadBalancerArns: ValueStringList? = nil,
                networkLoadBalancerArns: ValueStringList? = nil,
                serviceId: String? = nil,
                vpcEndpointId: String? = nil,
                vpcEndpointOwner: String? = nil,
                vpcEndpointState: State? = nil) {
        self.creationTimestamp = creationTimestamp
        self.dnsEntries = dnsEntries
        self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
        self.networkLoadBalancerArns = networkLoadBalancerArns
        self.serviceId = serviceId
        self.vpcEndpointId = vpcEndpointId
        self.vpcEndpointOwner = vpcEndpointOwner
        self.vpcEndpointState = vpcEndpointState
    }

    enum CodingKeys: String, CodingKey {
        case creationTimestamp
        case dnsEntries = "dnsEntrySet"
        case gatewayLoadBalancerArns = "gatewayLoadBalancerArnSet"
        case networkLoadBalancerArns = "networkLoadBalancerArnSet"
        case serviceId
        case vpcEndpointId
        case vpcEndpointOwner
        case vpcEndpointState
    }

    public func validate() throws {
    }
}

public struct VpcIpv6CidrBlockAssociation: Codable, Equatable {
    public var associationId: String?
    public var ipv6CidrBlock: String?
    public var ipv6CidrBlockState: VpcCidrBlockState?
    public var ipv6Pool: String?
    public var networkBorderGroup: String?

    public init(associationId: String? = nil,
                ipv6CidrBlock: String? = nil,
                ipv6CidrBlockState: VpcCidrBlockState? = nil,
                ipv6Pool: String? = nil,
                networkBorderGroup: String? = nil) {
        self.associationId = associationId
        self.ipv6CidrBlock = ipv6CidrBlock
        self.ipv6CidrBlockState = ipv6CidrBlockState
        self.ipv6Pool = ipv6Pool
        self.networkBorderGroup = networkBorderGroup
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case ipv6CidrBlock
        case ipv6CidrBlockState
        case ipv6Pool
        case networkBorderGroup
    }

    public func validate() throws {
        try ipv6CidrBlockState?.validate()
    }
}

public struct VpcPeeringConnection: Codable, Equatable {
    public var accepterVpcInfo: VpcPeeringConnectionVpcInfo?
    public var expirationTime: DateTime?
    public var requesterVpcInfo: VpcPeeringConnectionVpcInfo?
    public var status: VpcPeeringConnectionStateReason?
    public var tags: TagList?
    public var vpcPeeringConnectionId: String?

    public init(accepterVpcInfo: VpcPeeringConnectionVpcInfo? = nil,
                expirationTime: DateTime? = nil,
                requesterVpcInfo: VpcPeeringConnectionVpcInfo? = nil,
                status: VpcPeeringConnectionStateReason? = nil,
                tags: TagList? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.accepterVpcInfo = accepterVpcInfo
        self.expirationTime = expirationTime
        self.requesterVpcInfo = requesterVpcInfo
        self.status = status
        self.tags = tags
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case accepterVpcInfo
        case expirationTime
        case requesterVpcInfo
        case status
        case tags = "tagSet"
        case vpcPeeringConnectionId
    }

    public func validate() throws {
        try accepterVpcInfo?.validate()
        try requesterVpcInfo?.validate()
        try status?.validate()
    }
}

public struct VpcPeeringConnectionOptionsDescription: Codable, Equatable {
    public var allowDnsResolutionFromRemoteVpc: Boolean?
    public var allowEgressFromLocalClassicLinkToRemoteVpc: Boolean?
    public var allowEgressFromLocalVpcToRemoteClassicLink: Boolean?

    public init(allowDnsResolutionFromRemoteVpc: Boolean? = nil,
                allowEgressFromLocalClassicLinkToRemoteVpc: Boolean? = nil,
                allowEgressFromLocalVpcToRemoteClassicLink: Boolean? = nil) {
        self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
        self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
    }

    enum CodingKeys: String, CodingKey {
        case allowDnsResolutionFromRemoteVpc
        case allowEgressFromLocalClassicLinkToRemoteVpc
        case allowEgressFromLocalVpcToRemoteClassicLink
    }

    public func validate() throws {
    }
}

public struct VpcPeeringConnectionStateReason: Codable, Equatable {
    public var code: VpcPeeringConnectionStateReasonCode?
    public var message: String?

    public init(code: VpcPeeringConnectionStateReasonCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct VpcPeeringConnectionVpcInfo: Codable, Equatable {
    public var cidrBlock: String?
    public var cidrBlockSet: CidrBlockSet?
    public var ipv6CidrBlockSet: Ipv6CidrBlockSet?
    public var ownerId: String?
    public var peeringOptions: VpcPeeringConnectionOptionsDescription?
    public var region: String?
    public var vpcId: String?

    public init(cidrBlock: String? = nil,
                cidrBlockSet: CidrBlockSet? = nil,
                ipv6CidrBlockSet: Ipv6CidrBlockSet? = nil,
                ownerId: String? = nil,
                peeringOptions: VpcPeeringConnectionOptionsDescription? = nil,
                region: String? = nil,
                vpcId: String? = nil) {
        self.cidrBlock = cidrBlock
        self.cidrBlockSet = cidrBlockSet
        self.ipv6CidrBlockSet = ipv6CidrBlockSet
        self.ownerId = ownerId
        self.peeringOptions = peeringOptions
        self.region = region
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case cidrBlockSet
        case ipv6CidrBlockSet
        case ownerId
        case peeringOptions
        case region
        case vpcId
    }

    public func validate() throws {
        try peeringOptions?.validate()
    }
}

public struct VpnConnection: Codable, Equatable {
    public var category: String?
    public var customerGatewayConfiguration: String?
    public var customerGatewayId: String?
    public var options: VpnConnectionOptions?
    public var routes: VpnStaticRouteList?
    public var state: VpnState?
    public var tags: TagList?
    public var transitGatewayId: String?
    public var type: GatewayType?
    public var vgwTelemetry: VgwTelemetryList?
    public var vpnConnectionId: String?
    public var vpnGatewayId: String?

    public init(category: String? = nil,
                customerGatewayConfiguration: String? = nil,
                customerGatewayId: String? = nil,
                options: VpnConnectionOptions? = nil,
                routes: VpnStaticRouteList? = nil,
                state: VpnState? = nil,
                tags: TagList? = nil,
                transitGatewayId: String? = nil,
                type: GatewayType? = nil,
                vgwTelemetry: VgwTelemetryList? = nil,
                vpnConnectionId: String? = nil,
                vpnGatewayId: String? = nil) {
        self.category = category
        self.customerGatewayConfiguration = customerGatewayConfiguration
        self.customerGatewayId = customerGatewayId
        self.options = options
        self.routes = routes
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
        self.type = type
        self.vgwTelemetry = vgwTelemetry
        self.vpnConnectionId = vpnConnectionId
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case category
        case customerGatewayConfiguration
        case customerGatewayId
        case options
        case routes
        case state
        case tags = "tagSet"
        case transitGatewayId
        case type
        case vgwTelemetry
        case vpnConnectionId
        case vpnGatewayId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct VpnConnectionOptions: Codable, Equatable {
    public var enableAcceleration: Boolean?
    public var localIpv4NetworkCidr: String?
    public var localIpv6NetworkCidr: String?
    public var remoteIpv4NetworkCidr: String?
    public var remoteIpv6NetworkCidr: String?
    public var staticRoutesOnly: Boolean?
    public var tunnelInsideIpVersion: TunnelInsideIpVersion?
    public var tunnelOptions: TunnelOptionsList?

    public init(enableAcceleration: Boolean? = nil,
                localIpv4NetworkCidr: String? = nil,
                localIpv6NetworkCidr: String? = nil,
                remoteIpv4NetworkCidr: String? = nil,
                remoteIpv6NetworkCidr: String? = nil,
                staticRoutesOnly: Boolean? = nil,
                tunnelInsideIpVersion: TunnelInsideIpVersion? = nil,
                tunnelOptions: TunnelOptionsList? = nil) {
        self.enableAcceleration = enableAcceleration
        self.localIpv4NetworkCidr = localIpv4NetworkCidr
        self.localIpv6NetworkCidr = localIpv6NetworkCidr
        self.remoteIpv4NetworkCidr = remoteIpv4NetworkCidr
        self.remoteIpv6NetworkCidr = remoteIpv6NetworkCidr
        self.staticRoutesOnly = staticRoutesOnly
        self.tunnelInsideIpVersion = tunnelInsideIpVersion
        self.tunnelOptions = tunnelOptions
    }

    enum CodingKeys: String, CodingKey {
        case enableAcceleration
        case localIpv4NetworkCidr
        case localIpv6NetworkCidr
        case remoteIpv4NetworkCidr
        case remoteIpv6NetworkCidr
        case staticRoutesOnly
        case tunnelInsideIpVersion
        case tunnelOptions = "tunnelOptionSet"
    }

    public func validate() throws {
    }
}

public struct VpnConnectionOptionsSpecification: Codable, Equatable {
    public var enableAcceleration: Boolean?
    public var localIpv4NetworkCidr: String?
    public var localIpv6NetworkCidr: String?
    public var remoteIpv4NetworkCidr: String?
    public var remoteIpv6NetworkCidr: String?
    public var staticRoutesOnly: Boolean?
    public var tunnelInsideIpVersion: TunnelInsideIpVersion?
    public var tunnelOptions: VpnTunnelOptionsSpecificationsList?

    public init(enableAcceleration: Boolean? = nil,
                localIpv4NetworkCidr: String? = nil,
                localIpv6NetworkCidr: String? = nil,
                remoteIpv4NetworkCidr: String? = nil,
                remoteIpv6NetworkCidr: String? = nil,
                staticRoutesOnly: Boolean? = nil,
                tunnelInsideIpVersion: TunnelInsideIpVersion? = nil,
                tunnelOptions: VpnTunnelOptionsSpecificationsList? = nil) {
        self.enableAcceleration = enableAcceleration
        self.localIpv4NetworkCidr = localIpv4NetworkCidr
        self.localIpv6NetworkCidr = localIpv6NetworkCidr
        self.remoteIpv4NetworkCidr = remoteIpv4NetworkCidr
        self.remoteIpv6NetworkCidr = remoteIpv6NetworkCidr
        self.staticRoutesOnly = staticRoutesOnly
        self.tunnelInsideIpVersion = tunnelInsideIpVersion
        self.tunnelOptions = tunnelOptions
    }

    enum CodingKeys: String, CodingKey {
        case enableAcceleration = "EnableAcceleration"
        case localIpv4NetworkCidr = "LocalIpv4NetworkCidr"
        case localIpv6NetworkCidr = "LocalIpv6NetworkCidr"
        case remoteIpv4NetworkCidr = "RemoteIpv4NetworkCidr"
        case remoteIpv6NetworkCidr = "RemoteIpv6NetworkCidr"
        case staticRoutesOnly
        case tunnelInsideIpVersion = "TunnelInsideIpVersion"
        case tunnelOptions = "TunnelOptions"
    }

    public func validate() throws {
    }
}

public struct VpnGateway: Codable, Equatable {
    public var amazonSideAsn: Long?
    public var availabilityZone: String?
    public var state: VpnState?
    public var tags: TagList?
    public var type: GatewayType?
    public var vpcAttachments: VpcAttachmentList?
    public var vpnGatewayId: String?

    public init(amazonSideAsn: Long? = nil,
                availabilityZone: String? = nil,
                state: VpnState? = nil,
                tags: TagList? = nil,
                type: GatewayType? = nil,
                vpcAttachments: VpcAttachmentList? = nil,
                vpnGatewayId: String? = nil) {
        self.amazonSideAsn = amazonSideAsn
        self.availabilityZone = availabilityZone
        self.state = state
        self.tags = tags
        self.type = type
        self.vpcAttachments = vpcAttachments
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case amazonSideAsn
        case availabilityZone
        case state
        case tags = "tagSet"
        case type
        case vpcAttachments = "attachments"
        case vpnGatewayId
    }

    public func validate() throws {
    }
}

public struct VpnStaticRoute: Codable, Equatable {
    public var destinationCidrBlock: String?
    public var source: VpnStaticRouteSource?
    public var state: VpnState?

    public init(destinationCidrBlock: String? = nil,
                source: VpnStaticRouteSource? = nil,
                state: VpnState? = nil) {
        self.destinationCidrBlock = destinationCidrBlock
        self.source = source
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock
        case source
        case state
    }

    public func validate() throws {
    }
}

public struct VpnTunnelOptionsSpecification: Codable, Equatable {
    public var dPDTimeoutAction: String?
    public var dPDTimeoutSeconds: Integer?
    public var iKEVersions: IKEVersionsRequestList?
    public var phase1DHGroupNumbers: Phase1DHGroupNumbersRequestList?
    public var phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsRequestList?
    public var phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsRequestList?
    public var phase1LifetimeSeconds: Integer?
    public var phase2DHGroupNumbers: Phase2DHGroupNumbersRequestList?
    public var phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsRequestList?
    public var phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsRequestList?
    public var phase2LifetimeSeconds: Integer?
    public var preSharedKey: String?
    public var rekeyFuzzPercentage: Integer?
    public var rekeyMarginTimeSeconds: Integer?
    public var replayWindowSize: Integer?
    public var startupAction: String?
    public var tunnelInsideCidr: String?
    public var tunnelInsideIpv6Cidr: String?

    public init(dPDTimeoutAction: String? = nil,
                dPDTimeoutSeconds: Integer? = nil,
                iKEVersions: IKEVersionsRequestList? = nil,
                phase1DHGroupNumbers: Phase1DHGroupNumbersRequestList? = nil,
                phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsRequestList? = nil,
                phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsRequestList? = nil,
                phase1LifetimeSeconds: Integer? = nil,
                phase2DHGroupNumbers: Phase2DHGroupNumbersRequestList? = nil,
                phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsRequestList? = nil,
                phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsRequestList? = nil,
                phase2LifetimeSeconds: Integer? = nil,
                preSharedKey: String? = nil,
                rekeyFuzzPercentage: Integer? = nil,
                rekeyMarginTimeSeconds: Integer? = nil,
                replayWindowSize: Integer? = nil,
                startupAction: String? = nil,
                tunnelInsideCidr: String? = nil,
                tunnelInsideIpv6Cidr: String? = nil) {
        self.dPDTimeoutAction = dPDTimeoutAction
        self.dPDTimeoutSeconds = dPDTimeoutSeconds
        self.iKEVersions = iKEVersions
        self.phase1DHGroupNumbers = phase1DHGroupNumbers
        self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
        self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
        self.phase1LifetimeSeconds = phase1LifetimeSeconds
        self.phase2DHGroupNumbers = phase2DHGroupNumbers
        self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
        self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
        self.phase2LifetimeSeconds = phase2LifetimeSeconds
        self.preSharedKey = preSharedKey
        self.rekeyFuzzPercentage = rekeyFuzzPercentage
        self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
        self.replayWindowSize = replayWindowSize
        self.startupAction = startupAction
        self.tunnelInsideCidr = tunnelInsideCidr
        self.tunnelInsideIpv6Cidr = tunnelInsideIpv6Cidr
    }

    enum CodingKeys: String, CodingKey {
        case dPDTimeoutAction = "DPDTimeoutAction"
        case dPDTimeoutSeconds = "DPDTimeoutSeconds"
        case iKEVersions = "IKEVersion"
        case phase1DHGroupNumbers = "Phase1DHGroupNumber"
        case phase1EncryptionAlgorithms = "Phase1EncryptionAlgorithm"
        case phase1IntegrityAlgorithms = "Phase1IntegrityAlgorithm"
        case phase1LifetimeSeconds = "Phase1LifetimeSeconds"
        case phase2DHGroupNumbers = "Phase2DHGroupNumber"
        case phase2EncryptionAlgorithms = "Phase2EncryptionAlgorithm"
        case phase2IntegrityAlgorithms = "Phase2IntegrityAlgorithm"
        case phase2LifetimeSeconds = "Phase2LifetimeSeconds"
        case preSharedKey = "PreSharedKey"
        case rekeyFuzzPercentage = "RekeyFuzzPercentage"
        case rekeyMarginTimeSeconds = "RekeyMarginTimeSeconds"
        case replayWindowSize = "ReplayWindowSize"
        case startupAction = "StartupAction"
        case tunnelInsideCidr = "TunnelInsideCidr"
        case tunnelInsideIpv6Cidr = "TunnelInsideIpv6Cidr"
    }

    public func validate() throws {
    }
}

public struct WithdrawByoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?

    public init(cidr: String,
                dryRun: Boolean? = nil) {
        self.cidr = cidr
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct WithdrawByoipCidrResult: Codable, Equatable {
    public var byoipCidr: ByoipCidr?

    public init(byoipCidr: ByoipCidr? = nil) {
        self.byoipCidr = byoipCidr
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidr
    }

    public func validate() throws {
        try byoipCidr?.validate()
    }
}
