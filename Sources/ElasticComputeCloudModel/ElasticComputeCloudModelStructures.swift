// Copyright 2018-2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License").
// You may not use this file except in compliance with the License.
// A copy of the License is located at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.
//
// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length line_length identifier_name type_name vertical_parameter_alignment
// swiftlint:disable type_body_length function_body_length generic_type_name cyclomatic_complexity
// -- Generated Code; do not edit --
//
// ElasticComputeCloudModelStructures.swift
// ElasticComputeCloudModel
//

import Foundation

public struct AcceleratorCount: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max
        case min
    }

    public func validate() throws {
    }
}

public struct AcceleratorCountRequest: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func validate() throws {
    }
}

public struct AcceleratorTotalMemoryMiB: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max
        case min
    }

    public func validate() throws {
    }
}

public struct AcceleratorTotalMemoryMiBRequest: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func validate() throws {
    }
}

public struct AcceptAddressTransferRequest: Codable, Equatable {
    public var address: String
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(address: String,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.address = address
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct AcceptAddressTransferResult: Codable, Equatable {
    public var addressTransfer: AddressTransfer?

    public init(addressTransfer: AddressTransfer? = nil) {
        self.addressTransfer = addressTransfer
    }

    enum CodingKeys: String, CodingKey {
        case addressTransfer
    }

    public func validate() throws {
        try addressTransfer?.validate()
    }
}

public struct AcceptReservedInstancesExchangeQuoteRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var reservedInstanceIds: ReservedInstanceIdSet
    public var targetConfigurations: TargetConfigurationRequestSet?

    public init(dryRun: Boolean? = nil,
                reservedInstanceIds: ReservedInstanceIdSet,
                targetConfigurations: TargetConfigurationRequestSet? = nil) {
        self.dryRun = dryRun
        self.reservedInstanceIds = reservedInstanceIds
        self.targetConfigurations = targetConfigurations
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case reservedInstanceIds = "ReservedInstanceId"
        case targetConfigurations = "TargetConfiguration"
    }

    public func validate() throws {
    }
}

public struct AcceptReservedInstancesExchangeQuoteResult: Codable, Equatable {
    public var exchangeId: String?

    public init(exchangeId: String? = nil) {
        self.exchangeId = exchangeId
    }

    enum CodingKeys: String, CodingKey {
        case exchangeId
    }

    public func validate() throws {
    }
}

public struct AcceptTransitGatewayMulticastDomainAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetIds: ValueStringList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                subnetIds: ValueStringList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.subnetIds = subnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case subnetIds = "SubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct AcceptTransitGatewayMulticastDomainAssociationsResult: Codable, Equatable {
    public var associations: TransitGatewayMulticastDomainAssociations?

    public init(associations: TransitGatewayMulticastDomainAssociations? = nil) {
        self.associations = associations
    }

    enum CodingKeys: String, CodingKey {
        case associations
    }

    public func validate() throws {
        try associations?.validate()
    }
}

public struct AcceptTransitGatewayPeeringAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct AcceptTransitGatewayPeeringAttachmentResult: Codable, Equatable {
    public var transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment?

    public init(transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment? = nil) {
        self.transitGatewayPeeringAttachment = transitGatewayPeeringAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPeeringAttachment
    }

    public func validate() throws {
        try transitGatewayPeeringAttachment?.validate()
    }
}

public struct AcceptTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct AcceptTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct AcceptVpcEndpointConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var serviceId: VpcEndpointServiceId
    public var vpcEndpointIds: VpcEndpointIdList

    public init(dryRun: Boolean? = nil,
                serviceId: VpcEndpointServiceId,
                vpcEndpointIds: VpcEndpointIdList) {
        self.dryRun = dryRun
        self.serviceId = serviceId
        self.vpcEndpointIds = vpcEndpointIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case serviceId = "ServiceId"
        case vpcEndpointIds = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct AcceptVpcEndpointConnectionsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct AcceptVpcPeeringConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcPeeringConnectionId: VpcPeeringConnectionIdWithResolver?

    public init(dryRun: Boolean? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionIdWithResolver? = nil) {
        self.dryRun = dryRun
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct AcceptVpcPeeringConnectionResult: Codable, Equatable {
    public var vpcPeeringConnection: VpcPeeringConnection?

    public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
        self.vpcPeeringConnection = vpcPeeringConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpcPeeringConnection
    }

    public func validate() throws {
        try vpcPeeringConnection?.validate()
    }
}

public struct AccessScopeAnalysisFinding: Codable, Equatable {
    public var findingComponents: PathComponentList?
    public var findingId: String?
    public var networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId?
    public var networkInsightsAccessScopeId: NetworkInsightsAccessScopeId?

    public init(findingComponents: PathComponentList? = nil,
                findingId: String? = nil,
                networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId? = nil,
                networkInsightsAccessScopeId: NetworkInsightsAccessScopeId? = nil) {
        self.findingComponents = findingComponents
        self.findingId = findingId
        self.networkInsightsAccessScopeAnalysisId = networkInsightsAccessScopeAnalysisId
        self.networkInsightsAccessScopeId = networkInsightsAccessScopeId
    }

    enum CodingKeys: String, CodingKey {
        case findingComponents = "findingComponentSet"
        case findingId
        case networkInsightsAccessScopeAnalysisId
        case networkInsightsAccessScopeId
    }

    public func validate() throws {
    }
}

public struct AccessScopePath: Codable, Equatable {
    public var destination: PathStatement?
    public var source: PathStatement?
    public var throughResources: ThroughResourcesStatementList?

    public init(destination: PathStatement? = nil,
                source: PathStatement? = nil,
                throughResources: ThroughResourcesStatementList? = nil) {
        self.destination = destination
        self.source = source
        self.throughResources = throughResources
    }

    enum CodingKeys: String, CodingKey {
        case destination
        case source
        case throughResources = "throughResourceSet"
    }

    public func validate() throws {
        try destination?.validate()
        try source?.validate()
    }
}

public struct AccessScopePathRequest: Codable, Equatable {
    public var destination: PathStatementRequest?
    public var source: PathStatementRequest?
    public var throughResources: ThroughResourcesStatementRequestList?

    public init(destination: PathStatementRequest? = nil,
                source: PathStatementRequest? = nil,
                throughResources: ThroughResourcesStatementRequestList? = nil) {
        self.destination = destination
        self.source = source
        self.throughResources = throughResources
    }

    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case source = "Source"
        case throughResources = "ThroughResource"
    }

    public func validate() throws {
        try destination?.validate()
        try source?.validate()
    }
}

public struct AccountAttribute: Codable, Equatable {
    public var attributeName: String?
    public var attributeValues: AccountAttributeValueList?

    public init(attributeName: String? = nil,
                attributeValues: AccountAttributeValueList? = nil) {
        self.attributeName = attributeName
        self.attributeValues = attributeValues
    }

    enum CodingKeys: String, CodingKey {
        case attributeName
        case attributeValues = "attributeValueSet"
    }

    public func validate() throws {
    }
}

public struct AccountAttributeValue: Codable, Equatable {
    public var attributeValue: String?

    public init(attributeValue: String? = nil) {
        self.attributeValue = attributeValue
    }

    enum CodingKeys: String, CodingKey {
        case attributeValue
    }

    public func validate() throws {
    }
}

public struct ActiveInstance: Codable, Equatable {
    public var instanceHealth: InstanceHealthStatus?
    public var instanceId: String?
    public var instanceType: String?
    public var spotInstanceRequestId: String?

    public init(instanceHealth: InstanceHealthStatus? = nil,
                instanceId: String? = nil,
                instanceType: String? = nil,
                spotInstanceRequestId: String? = nil) {
        self.instanceHealth = instanceHealth
        self.instanceId = instanceId
        self.instanceType = instanceType
        self.spotInstanceRequestId = spotInstanceRequestId
    }

    enum CodingKeys: String, CodingKey {
        case instanceHealth
        case instanceId
        case instanceType
        case spotInstanceRequestId
    }

    public func validate() throws {
    }
}

public struct AddIpamOperatingRegion: Codable, Equatable {
    public var regionName: String?

    public init(regionName: String? = nil) {
        self.regionName = regionName
    }

    enum CodingKeys: String, CodingKey {
        case regionName = "RegionName"
    }

    public func validate() throws {
    }
}

public struct AddPrefixListEntry: Codable, Equatable {
    public var cidr: String
    public var description: String?

    public init(cidr: String,
                description: String? = nil) {
        self.cidr = cidr
        self.description = description
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case description = "Description"
    }

    public func validate() throws {
    }
}

public struct AddedPrincipal: Codable, Equatable {
    public var principal: String?
    public var principalType: PrincipalType?
    public var serviceId: String?
    public var servicePermissionId: String?

    public init(principal: String? = nil,
                principalType: PrincipalType? = nil,
                serviceId: String? = nil,
                servicePermissionId: String? = nil) {
        self.principal = principal
        self.principalType = principalType
        self.serviceId = serviceId
        self.servicePermissionId = servicePermissionId
    }

    enum CodingKeys: String, CodingKey {
        case principal
        case principalType
        case serviceId
        case servicePermissionId
    }

    public func validate() throws {
    }
}

public struct AdditionalDetail: Codable, Equatable {
    public var additionalDetailType: String?
    public var component: AnalysisComponent?

    public init(additionalDetailType: String? = nil,
                component: AnalysisComponent? = nil) {
        self.additionalDetailType = additionalDetailType
        self.component = component
    }

    enum CodingKeys: String, CodingKey {
        case additionalDetailType
        case component
    }

    public func validate() throws {
        try component?.validate()
    }
}

public struct Address: Codable, Equatable {
    public var allocationId: String?
    public var associationId: String?
    public var carrierIp: String?
    public var customerOwnedIp: String?
    public var customerOwnedIpv4Pool: String?
    public var domain: DomainType?
    public var instanceId: String?
    public var networkBorderGroup: String?
    public var networkInterfaceId: String?
    public var networkInterfaceOwnerId: String?
    public var privateIpAddress: String?
    public var publicIp: String?
    public var publicIpv4Pool: String?
    public var tags: TagList?

    public init(allocationId: String? = nil,
                associationId: String? = nil,
                carrierIp: String? = nil,
                customerOwnedIp: String? = nil,
                customerOwnedIpv4Pool: String? = nil,
                domain: DomainType? = nil,
                instanceId: String? = nil,
                networkBorderGroup: String? = nil,
                networkInterfaceId: String? = nil,
                networkInterfaceOwnerId: String? = nil,
                privateIpAddress: String? = nil,
                publicIp: String? = nil,
                publicIpv4Pool: String? = nil,
                tags: TagList? = nil) {
        self.allocationId = allocationId
        self.associationId = associationId
        self.carrierIp = carrierIp
        self.customerOwnedIp = customerOwnedIp
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.domain = domain
        self.instanceId = instanceId
        self.networkBorderGroup = networkBorderGroup
        self.networkInterfaceId = networkInterfaceId
        self.networkInterfaceOwnerId = networkInterfaceOwnerId
        self.privateIpAddress = privateIpAddress
        self.publicIp = publicIp
        self.publicIpv4Pool = publicIpv4Pool
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case associationId
        case carrierIp
        case customerOwnedIp
        case customerOwnedIpv4Pool
        case domain
        case instanceId
        case networkBorderGroup
        case networkInterfaceId
        case networkInterfaceOwnerId
        case privateIpAddress
        case publicIp
        case publicIpv4Pool
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct AddressAttribute: Codable, Equatable {
    public var allocationId: AllocationId?
    public var ptrRecord: String?
    public var ptrRecordUpdate: PtrUpdateStatus?
    public var publicIp: PublicIpAddress?

    public init(allocationId: AllocationId? = nil,
                ptrRecord: String? = nil,
                ptrRecordUpdate: PtrUpdateStatus? = nil,
                publicIp: PublicIpAddress? = nil) {
        self.allocationId = allocationId
        self.ptrRecord = ptrRecord
        self.ptrRecordUpdate = ptrRecordUpdate
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case ptrRecord
        case ptrRecordUpdate
        case publicIp
    }

    public func validate() throws {
        try ptrRecordUpdate?.validate()
    }
}

public struct AddressTransfer: Codable, Equatable {
    public var addressTransferStatus: AddressTransferStatus?
    public var allocationId: String?
    public var publicIp: String?
    public var transferAccountId: String?
    public var transferOfferAcceptedTimestamp: MillisecondDateTime?
    public var transferOfferExpirationTimestamp: MillisecondDateTime?

    public init(addressTransferStatus: AddressTransferStatus? = nil,
                allocationId: String? = nil,
                publicIp: String? = nil,
                transferAccountId: String? = nil,
                transferOfferAcceptedTimestamp: MillisecondDateTime? = nil,
                transferOfferExpirationTimestamp: MillisecondDateTime? = nil) {
        self.addressTransferStatus = addressTransferStatus
        self.allocationId = allocationId
        self.publicIp = publicIp
        self.transferAccountId = transferAccountId
        self.transferOfferAcceptedTimestamp = transferOfferAcceptedTimestamp
        self.transferOfferExpirationTimestamp = transferOfferExpirationTimestamp
    }

    enum CodingKeys: String, CodingKey {
        case addressTransferStatus
        case allocationId
        case publicIp
        case transferAccountId
        case transferOfferAcceptedTimestamp
        case transferOfferExpirationTimestamp
    }

    public func validate() throws {
    }
}

public struct AdvertiseByoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?

    public init(cidr: String,
                dryRun: Boolean? = nil) {
        self.cidr = cidr
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct AdvertiseByoipCidrResult: Codable, Equatable {
    public var byoipCidr: ByoipCidr?

    public init(byoipCidr: ByoipCidr? = nil) {
        self.byoipCidr = byoipCidr
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidr
    }

    public func validate() throws {
        try byoipCidr?.validate()
    }
}

public struct AllocateAddressRequest: Codable, Equatable {
    public var address: PublicIpAddress?
    public var customerOwnedIpv4Pool: String?
    public var domain: DomainType?
    public var dryRun: Boolean?
    public var networkBorderGroup: String?
    public var publicIpv4Pool: Ipv4PoolEc2Id?
    public var tagSpecifications: TagSpecificationList?

    public init(address: PublicIpAddress? = nil,
                customerOwnedIpv4Pool: String? = nil,
                domain: DomainType? = nil,
                dryRun: Boolean? = nil,
                networkBorderGroup: String? = nil,
                publicIpv4Pool: Ipv4PoolEc2Id? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.address = address
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.domain = domain
        self.dryRun = dryRun
        self.networkBorderGroup = networkBorderGroup
        self.publicIpv4Pool = publicIpv4Pool
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case domain = "Domain"
        case dryRun
        case networkBorderGroup = "NetworkBorderGroup"
        case publicIpv4Pool = "PublicIpv4Pool"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct AllocateAddressResult: Codable, Equatable {
    public var allocationId: String?
    public var carrierIp: String?
    public var customerOwnedIp: String?
    public var customerOwnedIpv4Pool: String?
    public var domain: DomainType?
    public var networkBorderGroup: String?
    public var publicIp: String?
    public var publicIpv4Pool: String?

    public init(allocationId: String? = nil,
                carrierIp: String? = nil,
                customerOwnedIp: String? = nil,
                customerOwnedIpv4Pool: String? = nil,
                domain: DomainType? = nil,
                networkBorderGroup: String? = nil,
                publicIp: String? = nil,
                publicIpv4Pool: String? = nil) {
        self.allocationId = allocationId
        self.carrierIp = carrierIp
        self.customerOwnedIp = customerOwnedIp
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.domain = domain
        self.networkBorderGroup = networkBorderGroup
        self.publicIp = publicIp
        self.publicIpv4Pool = publicIpv4Pool
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case carrierIp
        case customerOwnedIp
        case customerOwnedIpv4Pool
        case domain
        case networkBorderGroup
        case publicIp
        case publicIpv4Pool
    }

    public func validate() throws {
    }
}

public struct AllocateHostsRequest: Codable, Equatable {
    public var autoPlacement: AutoPlacement?
    public var availabilityZone: String
    public var clientToken: String?
    public var hostRecovery: HostRecovery?
    public var instanceFamily: String?
    public var instanceType: String?
    public var outpostArn: String?
    public var quantity: Integer
    public var tagSpecifications: TagSpecificationList?

    public init(autoPlacement: AutoPlacement? = nil,
                availabilityZone: String,
                clientToken: String? = nil,
                hostRecovery: HostRecovery? = nil,
                instanceFamily: String? = nil,
                instanceType: String? = nil,
                outpostArn: String? = nil,
                quantity: Integer,
                tagSpecifications: TagSpecificationList? = nil) {
        self.autoPlacement = autoPlacement
        self.availabilityZone = availabilityZone
        self.clientToken = clientToken
        self.hostRecovery = hostRecovery
        self.instanceFamily = instanceFamily
        self.instanceType = instanceType
        self.outpostArn = outpostArn
        self.quantity = quantity
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case autoPlacement
        case availabilityZone
        case clientToken
        case hostRecovery = "HostRecovery"
        case instanceFamily = "InstanceFamily"
        case instanceType
        case outpostArn = "OutpostArn"
        case quantity
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct AllocateHostsResult: Codable, Equatable {
    public var hostIds: ResponseHostIdList?

    public init(hostIds: ResponseHostIdList? = nil) {
        self.hostIds = hostIds
    }

    enum CodingKeys: String, CodingKey {
        case hostIds = "hostIdSet"
    }

    public func validate() throws {
    }
}

public struct AllocateIpamPoolCidrRequest: Codable, Equatable {
    public var cidr: String?
    public var clientToken: String?
    public var description: String?
    public var disallowedCidrs: IpamPoolAllocationDisallowedCidrs?
    public var dryRun: Boolean?
    public var ipamPoolId: IpamPoolId
    public var netmaskLength: Integer?
    public var previewNextCidr: Boolean?

    public init(cidr: String? = nil,
                clientToken: String? = nil,
                description: String? = nil,
                disallowedCidrs: IpamPoolAllocationDisallowedCidrs? = nil,
                dryRun: Boolean? = nil,
                ipamPoolId: IpamPoolId,
                netmaskLength: Integer? = nil,
                previewNextCidr: Boolean? = nil) {
        self.cidr = cidr
        self.clientToken = clientToken
        self.description = description
        self.disallowedCidrs = disallowedCidrs
        self.dryRun = dryRun
        self.ipamPoolId = ipamPoolId
        self.netmaskLength = netmaskLength
        self.previewNextCidr = previewNextCidr
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case clientToken = "ClientToken"
        case description = "Description"
        case disallowedCidrs = "DisallowedCidr"
        case dryRun = "DryRun"
        case ipamPoolId = "IpamPoolId"
        case netmaskLength = "NetmaskLength"
        case previewNextCidr = "PreviewNextCidr"
    }

    public func validate() throws {
    }
}

public struct AllocateIpamPoolCidrResult: Codable, Equatable {
    public var ipamPoolAllocation: IpamPoolAllocation?

    public init(ipamPoolAllocation: IpamPoolAllocation? = nil) {
        self.ipamPoolAllocation = ipamPoolAllocation
    }

    enum CodingKeys: String, CodingKey {
        case ipamPoolAllocation
    }

    public func validate() throws {
        try ipamPoolAllocation?.validate()
    }
}

public struct AllowedPrincipal: Codable, Equatable {
    public var principal: String?
    public var principalType: PrincipalType?
    public var serviceId: String?
    public var servicePermissionId: String?
    public var tags: TagList?

    public init(principal: String? = nil,
                principalType: PrincipalType? = nil,
                serviceId: String? = nil,
                servicePermissionId: String? = nil,
                tags: TagList? = nil) {
        self.principal = principal
        self.principalType = principalType
        self.serviceId = serviceId
        self.servicePermissionId = servicePermissionId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case principal
        case principalType
        case serviceId
        case servicePermissionId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct AlternatePathHint: Codable, Equatable {
    public var componentArn: String?
    public var componentId: String?

    public init(componentArn: String? = nil,
                componentId: String? = nil) {
        self.componentArn = componentArn
        self.componentId = componentId
    }

    enum CodingKeys: String, CodingKey {
        case componentArn
        case componentId
    }

    public func validate() throws {
    }
}

public struct AnalysisAclRule: Codable, Equatable {
    public var cidr: String?
    public var egress: Boolean?
    public var portRange: PortRange?
    public var `protocol`: String?
    public var ruleAction: String?
    public var ruleNumber: Integer?

    public init(cidr: String? = nil,
                egress: Boolean? = nil,
                portRange: PortRange? = nil,
                `protocol`: String? = nil,
                ruleAction: String? = nil,
                ruleNumber: Integer? = nil) {
        self.cidr = cidr
        self.egress = egress
        self.portRange = portRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case egress
        case portRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
    }

    public func validate() throws {
        try portRange?.validate()
    }
}

public struct AnalysisComponent: Codable, Equatable {
    public var arn: String?
    public var id: String?
    public var name: String?

    public init(arn: String? = nil,
                id: String? = nil,
                name: String? = nil) {
        self.arn = arn
        self.id = id
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case id
        case name
    }

    public func validate() throws {
    }
}

public struct AnalysisLoadBalancerListener: Codable, Equatable {
    public var instancePort: Port?
    public var loadBalancerPort: Port?

    public init(instancePort: Port? = nil,
                loadBalancerPort: Port? = nil) {
        self.instancePort = instancePort
        self.loadBalancerPort = loadBalancerPort
    }

    enum CodingKeys: String, CodingKey {
        case instancePort
        case loadBalancerPort
    }

    public func validate() throws {
        try instancePort?.validateAsPort()
        try loadBalancerPort?.validateAsPort()
    }
}

public struct AnalysisLoadBalancerTarget: Codable, Equatable {
    public var address: IpAddress?
    public var availabilityZone: String?
    public var instance: AnalysisComponent?
    public var port: Port?

    public init(address: IpAddress? = nil,
                availabilityZone: String? = nil,
                instance: AnalysisComponent? = nil,
                port: Port? = nil) {
        self.address = address
        self.availabilityZone = availabilityZone
        self.instance = instance
        self.port = port
    }

    enum CodingKeys: String, CodingKey {
        case address
        case availabilityZone
        case instance
        case port
    }

    public func validate() throws {
        try address?.validateAsIpAddress()
        try instance?.validate()
        try port?.validateAsPort()
    }
}

public struct AnalysisPacketHeader: Codable, Equatable {
    public var destinationAddresses: IpAddressList?
    public var destinationPortRanges: PortRangeList?
    public var `protocol`: String?
    public var sourceAddresses: IpAddressList?
    public var sourcePortRanges: PortRangeList?

    public init(destinationAddresses: IpAddressList? = nil,
                destinationPortRanges: PortRangeList? = nil,
                `protocol`: String? = nil,
                sourceAddresses: IpAddressList? = nil,
                sourcePortRanges: PortRangeList? = nil) {
        self.destinationAddresses = destinationAddresses
        self.destinationPortRanges = destinationPortRanges
        self.`protocol` = `protocol`
        self.sourceAddresses = sourceAddresses
        self.sourcePortRanges = sourcePortRanges
    }

    enum CodingKeys: String, CodingKey {
        case destinationAddresses = "destinationAddressSet"
        case destinationPortRanges = "destinationPortRangeSet"
        case `protocol` = "protocol"
        case sourceAddresses = "sourceAddressSet"
        case sourcePortRanges = "sourcePortRangeSet"
    }

    public func validate() throws {
    }
}

public struct AnalysisRouteTableRoute: Codable, Equatable {
    public var destinationCidr: String?
    public var destinationPrefixListId: String?
    public var egressOnlyInternetGatewayId: String?
    public var gatewayId: String?
    public var instanceId: String?
    public var natGatewayId: String?
    public var networkInterfaceId: String?
    public var origin: String?
    public var state: String?
    public var transitGatewayId: String?
    public var vpcPeeringConnectionId: String?

    public init(destinationCidr: String? = nil,
                destinationPrefixListId: String? = nil,
                egressOnlyInternetGatewayId: String? = nil,
                gatewayId: String? = nil,
                instanceId: String? = nil,
                natGatewayId: String? = nil,
                networkInterfaceId: String? = nil,
                origin: String? = nil,
                state: String? = nil,
                transitGatewayId: String? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.destinationCidr = destinationCidr
        self.destinationPrefixListId = destinationPrefixListId
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.gatewayId = gatewayId
        self.instanceId = instanceId
        self.natGatewayId = natGatewayId
        self.networkInterfaceId = networkInterfaceId
        self.origin = origin
        self.state = state
        self.transitGatewayId = transitGatewayId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidr
        case destinationPrefixListId
        case egressOnlyInternetGatewayId
        case gatewayId
        case instanceId
        case natGatewayId
        case networkInterfaceId
        case origin
        case state
        case transitGatewayId
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct AnalysisSecurityGroupRule: Codable, Equatable {
    public var cidr: String?
    public var direction: String?
    public var portRange: PortRange?
    public var prefixListId: String?
    public var `protocol`: String?
    public var securityGroupId: String?

    public init(cidr: String? = nil,
                direction: String? = nil,
                portRange: PortRange? = nil,
                prefixListId: String? = nil,
                `protocol`: String? = nil,
                securityGroupId: String? = nil) {
        self.cidr = cidr
        self.direction = direction
        self.portRange = portRange
        self.prefixListId = prefixListId
        self.`protocol` = `protocol`
        self.securityGroupId = securityGroupId
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case direction
        case portRange
        case prefixListId
        case `protocol` = "protocol"
        case securityGroupId
    }

    public func validate() throws {
        try portRange?.validate()
    }
}

public struct ApplySecurityGroupsToClientVpnTargetNetworkRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var securityGroupIds: ClientVpnSecurityGroupIdSet
    public var vpcId: VpcId

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                securityGroupIds: ClientVpnSecurityGroupIdSet,
                vpcId: VpcId) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.securityGroupIds = securityGroupIds
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case securityGroupIds = "SecurityGroupId"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct ApplySecurityGroupsToClientVpnTargetNetworkResult: Codable, Equatable {
    public var securityGroupIds: ClientVpnSecurityGroupIdSet?

    public init(securityGroupIds: ClientVpnSecurityGroupIdSet? = nil) {
        self.securityGroupIds = securityGroupIds
    }

    enum CodingKeys: String, CodingKey {
        case securityGroupIds
    }

    public func validate() throws {
    }
}

public struct AssignIpv6AddressesRequest: Codable, Equatable {
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: Ipv6AddressList?
    public var ipv6PrefixCount: Integer?
    public var ipv6Prefixes: IpPrefixList?
    public var networkInterfaceId: NetworkInterfaceId

    public init(ipv6AddressCount: Integer? = nil,
                ipv6Addresses: Ipv6AddressList? = nil,
                ipv6PrefixCount: Integer? = nil,
                ipv6Prefixes: IpPrefixList? = nil,
                networkInterfaceId: NetworkInterfaceId) {
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.ipv6PrefixCount = ipv6PrefixCount
        self.ipv6Prefixes = ipv6Prefixes
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6AddressCount
        case ipv6Addresses
        case ipv6PrefixCount = "Ipv6PrefixCount"
        case ipv6Prefixes = "Ipv6Prefix"
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct AssignIpv6AddressesResult: Codable, Equatable {
    public var assignedIpv6Addresses: Ipv6AddressList?
    public var assignedIpv6Prefixes: IpPrefixList?
    public var networkInterfaceId: String?

    public init(assignedIpv6Addresses: Ipv6AddressList? = nil,
                assignedIpv6Prefixes: IpPrefixList? = nil,
                networkInterfaceId: String? = nil) {
        self.assignedIpv6Addresses = assignedIpv6Addresses
        self.assignedIpv6Prefixes = assignedIpv6Prefixes
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case assignedIpv6Addresses
        case assignedIpv6Prefixes = "assignedIpv6PrefixSet"
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct AssignPrivateIpAddressesRequest: Codable, Equatable {
    public var allowReassignment: Boolean?
    public var ipv4PrefixCount: Integer?
    public var ipv4Prefixes: IpPrefixList?
    public var networkInterfaceId: NetworkInterfaceId
    public var privateIpAddresses: PrivateIpAddressStringList?
    public var secondaryPrivateIpAddressCount: Integer?

    public init(allowReassignment: Boolean? = nil,
                ipv4PrefixCount: Integer? = nil,
                ipv4Prefixes: IpPrefixList? = nil,
                networkInterfaceId: NetworkInterfaceId,
                privateIpAddresses: PrivateIpAddressStringList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil) {
        self.allowReassignment = allowReassignment
        self.ipv4PrefixCount = ipv4PrefixCount
        self.ipv4Prefixes = ipv4Prefixes
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
    }

    enum CodingKeys: String, CodingKey {
        case allowReassignment
        case ipv4PrefixCount = "Ipv4PrefixCount"
        case ipv4Prefixes = "Ipv4Prefix"
        case networkInterfaceId
        case privateIpAddresses = "privateIpAddress"
        case secondaryPrivateIpAddressCount
    }

    public func validate() throws {
    }
}

public struct AssignPrivateIpAddressesResult: Codable, Equatable {
    public var assignedIpv4Prefixes: Ipv4PrefixesList?
    public var assignedPrivateIpAddresses: AssignedPrivateIpAddressList?
    public var networkInterfaceId: String?

    public init(assignedIpv4Prefixes: Ipv4PrefixesList? = nil,
                assignedPrivateIpAddresses: AssignedPrivateIpAddressList? = nil,
                networkInterfaceId: String? = nil) {
        self.assignedIpv4Prefixes = assignedIpv4Prefixes
        self.assignedPrivateIpAddresses = assignedPrivateIpAddresses
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case assignedIpv4Prefixes = "assignedIpv4PrefixSet"
        case assignedPrivateIpAddresses = "assignedPrivateIpAddressesSet"
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct AssignedPrivateIpAddress: Codable, Equatable {
    public var privateIpAddress: String?

    public init(privateIpAddress: String? = nil) {
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case privateIpAddress
    }

    public func validate() throws {
    }
}

public struct AssociateAddressRequest: Codable, Equatable {
    public var allocationId: AllocationId?
    public var allowReassociation: Boolean?
    public var dryRun: Boolean?
    public var instanceId: InstanceId?
    public var networkInterfaceId: NetworkInterfaceId?
    public var privateIpAddress: String?
    public var publicIp: String?

    public init(allocationId: AllocationId? = nil,
                allowReassociation: Boolean? = nil,
                dryRun: Boolean? = nil,
                instanceId: InstanceId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                privateIpAddress: String? = nil,
                publicIp: String? = nil) {
        self.allocationId = allocationId
        self.allowReassociation = allowReassociation
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case allowReassociation
        case dryRun
        case instanceId = "InstanceId"
        case networkInterfaceId
        case privateIpAddress
        case publicIp = "PublicIp"
    }

    public func validate() throws {
    }
}

public struct AssociateAddressResult: Codable, Equatable {
    public var associationId: String?

    public init(associationId: String? = nil) {
        self.associationId = associationId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
    }

    public func validate() throws {
    }
}

public struct AssociateClientVpnTargetNetworkRequest: Codable, Equatable {
    public var clientToken: String?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var subnetId: SubnetId

    public init(clientToken: String? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                subnetId: SubnetId) {
        self.clientToken = clientToken
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case subnetId = "SubnetId"
    }

    public func validate() throws {
    }
}

public struct AssociateClientVpnTargetNetworkResult: Codable, Equatable {
    public var associationId: String?
    public var status: AssociationStatus?

    public init(associationId: String? = nil,
                status: AssociationStatus? = nil) {
        self.associationId = associationId
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct AssociateDhcpOptionsRequest: Codable, Equatable {
    public var dhcpOptionsId: DefaultingDhcpOptionsId
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(dhcpOptionsId: DefaultingDhcpOptionsId,
                dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.dhcpOptionsId = dhcpOptionsId
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptionsId = "DhcpOptionsId"
        case dryRun
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct AssociateEnclaveCertificateIamRoleRequest: Codable, Equatable {
    public var certificateArn: ResourceArn?
    public var dryRun: Boolean?
    public var roleArn: ResourceArn?

    public init(certificateArn: ResourceArn? = nil,
                dryRun: Boolean? = nil,
                roleArn: ResourceArn? = nil) {
        self.certificateArn = certificateArn
        self.dryRun = dryRun
        self.roleArn = roleArn
    }

    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case dryRun = "DryRun"
        case roleArn = "RoleArn"
    }

    public func validate() throws {
        try certificateArn?.validateAsResourceArn()
        try roleArn?.validateAsResourceArn()
    }
}

public struct AssociateEnclaveCertificateIamRoleResult: Codable, Equatable {
    public var certificateS3BucketName: String?
    public var certificateS3ObjectKey: String?
    public var encryptionKmsKeyId: String?

    public init(certificateS3BucketName: String? = nil,
                certificateS3ObjectKey: String? = nil,
                encryptionKmsKeyId: String? = nil) {
        self.certificateS3BucketName = certificateS3BucketName
        self.certificateS3ObjectKey = certificateS3ObjectKey
        self.encryptionKmsKeyId = encryptionKmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case certificateS3BucketName
        case certificateS3ObjectKey
        case encryptionKmsKeyId
    }

    public func validate() throws {
    }
}

public struct AssociateIamInstanceProfileRequest: Codable, Equatable {
    public var iamInstanceProfile: IamInstanceProfileSpecification
    public var instanceId: InstanceId

    public init(iamInstanceProfile: IamInstanceProfileSpecification,
                instanceId: InstanceId) {
        self.iamInstanceProfile = iamInstanceProfile
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfile = "IamInstanceProfile"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
        try iamInstanceProfile.validate()
    }
}

public struct AssociateIamInstanceProfileResult: Codable, Equatable {
    public var iamInstanceProfileAssociation: IamInstanceProfileAssociation?

    public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
        self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfileAssociation
    }

    public func validate() throws {
        try iamInstanceProfileAssociation?.validate()
    }
}

public struct AssociateInstanceEventWindowRequest: Codable, Equatable {
    public var associationTarget: InstanceEventWindowAssociationRequest
    public var dryRun: Boolean?
    public var instanceEventWindowId: InstanceEventWindowId

    public init(associationTarget: InstanceEventWindowAssociationRequest,
                dryRun: Boolean? = nil,
                instanceEventWindowId: InstanceEventWindowId) {
        self.associationTarget = associationTarget
        self.dryRun = dryRun
        self.instanceEventWindowId = instanceEventWindowId
    }

    enum CodingKeys: String, CodingKey {
        case associationTarget = "AssociationTarget"
        case dryRun = "DryRun"
        case instanceEventWindowId = "InstanceEventWindowId"
    }

    public func validate() throws {
        try associationTarget.validate()
    }
}

public struct AssociateInstanceEventWindowResult: Codable, Equatable {
    public var instanceEventWindow: InstanceEventWindow?

    public init(instanceEventWindow: InstanceEventWindow? = nil) {
        self.instanceEventWindow = instanceEventWindow
    }

    enum CodingKeys: String, CodingKey {
        case instanceEventWindow
    }

    public func validate() throws {
        try instanceEventWindow?.validate()
    }
}

public struct AssociateRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var gatewayId: RouteGatewayId?
    public var routeTableId: RouteTableId
    public var subnetId: SubnetId?

    public init(dryRun: Boolean? = nil,
                gatewayId: RouteGatewayId? = nil,
                routeTableId: RouteTableId,
                subnetId: SubnetId? = nil) {
        self.dryRun = dryRun
        self.gatewayId = gatewayId
        self.routeTableId = routeTableId
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case gatewayId = "GatewayId"
        case routeTableId
        case subnetId
    }

    public func validate() throws {
    }
}

public struct AssociateRouteTableResult: Codable, Equatable {
    public var associationId: String?
    public var associationState: RouteTableAssociationState?

    public init(associationId: String? = nil,
                associationState: RouteTableAssociationState? = nil) {
        self.associationId = associationId
        self.associationState = associationState
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case associationState
    }

    public func validate() throws {
        try associationState?.validate()
    }
}

public struct AssociateSubnetCidrBlockRequest: Codable, Equatable {
    public var ipv6CidrBlock: String
    public var subnetId: SubnetId

    public init(ipv6CidrBlock: String,
                subnetId: SubnetId) {
        self.ipv6CidrBlock = ipv6CidrBlock
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrBlock
        case subnetId
    }

    public func validate() throws {
    }
}

public struct AssociateSubnetCidrBlockResult: Codable, Equatable {
    public var ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation?
    public var subnetId: String?

    public init(ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil,
                subnetId: String? = nil) {
        self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrBlockAssociation
        case subnetId
    }

    public func validate() throws {
        try ipv6CidrBlockAssociation?.validate()
    }
}

public struct AssociateTransitGatewayMulticastDomainRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetIds: TransitGatewaySubnetIdList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                subnetIds: TransitGatewaySubnetIdList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.subnetIds = subnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case subnetIds = "SubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct AssociateTransitGatewayMulticastDomainResult: Codable, Equatable {
    public var associations: TransitGatewayMulticastDomainAssociations?

    public init(associations: TransitGatewayMulticastDomainAssociations? = nil) {
        self.associations = associations
    }

    enum CodingKeys: String, CodingKey {
        case associations
    }

    public func validate() throws {
        try associations?.validate()
    }
}

public struct AssociateTransitGatewayPolicyTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId
    public var transitGatewayPolicyTableId: TransitGatewayPolicyTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId,
                transitGatewayPolicyTableId: TransitGatewayPolicyTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayPolicyTableId = transitGatewayPolicyTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayPolicyTableId = "TransitGatewayPolicyTableId"
    }

    public func validate() throws {
    }
}

public struct AssociateTransitGatewayPolicyTableResult: Codable, Equatable {
    public var association: TransitGatewayPolicyTableAssociation?

    public init(association: TransitGatewayPolicyTableAssociation? = nil) {
        self.association = association
    }

    enum CodingKeys: String, CodingKey {
        case association
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct AssociateTransitGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct AssociateTransitGatewayRouteTableResult: Codable, Equatable {
    public var association: TransitGatewayAssociation?

    public init(association: TransitGatewayAssociation? = nil) {
        self.association = association
    }

    enum CodingKeys: String, CodingKey {
        case association
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct AssociateTrunkInterfaceRequest: Codable, Equatable {
    public var branchInterfaceId: NetworkInterfaceId
    public var clientToken: String?
    public var dryRun: Boolean?
    public var greKey: Integer?
    public var trunkInterfaceId: NetworkInterfaceId
    public var vlanId: Integer?

    public init(branchInterfaceId: NetworkInterfaceId,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                greKey: Integer? = nil,
                trunkInterfaceId: NetworkInterfaceId,
                vlanId: Integer? = nil) {
        self.branchInterfaceId = branchInterfaceId
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.greKey = greKey
        self.trunkInterfaceId = trunkInterfaceId
        self.vlanId = vlanId
    }

    enum CodingKeys: String, CodingKey {
        case branchInterfaceId = "BranchInterfaceId"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case greKey = "GreKey"
        case trunkInterfaceId = "TrunkInterfaceId"
        case vlanId = "VlanId"
    }

    public func validate() throws {
    }
}

public struct AssociateTrunkInterfaceResult: Codable, Equatable {
    public var clientToken: String?
    public var interfaceAssociation: TrunkInterfaceAssociation?

    public init(clientToken: String? = nil,
                interfaceAssociation: TrunkInterfaceAssociation? = nil) {
        self.clientToken = clientToken
        self.interfaceAssociation = interfaceAssociation
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case interfaceAssociation
    }

    public func validate() throws {
        try interfaceAssociation?.validate()
    }
}

public struct AssociateVpcCidrBlockRequest: Codable, Equatable {
    public var amazonProvidedIpv6CidrBlock: Boolean?
    public var cidrBlock: String?
    public var ipv4IpamPoolId: IpamPoolId?
    public var ipv4NetmaskLength: NetmaskLength?
    public var ipv6CidrBlock: String?
    public var ipv6CidrBlockNetworkBorderGroup: String?
    public var ipv6IpamPoolId: IpamPoolId?
    public var ipv6NetmaskLength: NetmaskLength?
    public var ipv6Pool: Ipv6PoolEc2Id?
    public var vpcId: VpcId

    public init(amazonProvidedIpv6CidrBlock: Boolean? = nil,
                cidrBlock: String? = nil,
                ipv4IpamPoolId: IpamPoolId? = nil,
                ipv4NetmaskLength: NetmaskLength? = nil,
                ipv6CidrBlock: String? = nil,
                ipv6CidrBlockNetworkBorderGroup: String? = nil,
                ipv6IpamPoolId: IpamPoolId? = nil,
                ipv6NetmaskLength: NetmaskLength? = nil,
                ipv6Pool: Ipv6PoolEc2Id? = nil,
                vpcId: VpcId) {
        self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
        self.cidrBlock = cidrBlock
        self.ipv4IpamPoolId = ipv4IpamPoolId
        self.ipv4NetmaskLength = ipv4NetmaskLength
        self.ipv6CidrBlock = ipv6CidrBlock
        self.ipv6CidrBlockNetworkBorderGroup = ipv6CidrBlockNetworkBorderGroup
        self.ipv6IpamPoolId = ipv6IpamPoolId
        self.ipv6NetmaskLength = ipv6NetmaskLength
        self.ipv6Pool = ipv6Pool
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case amazonProvidedIpv6CidrBlock
        case cidrBlock = "CidrBlock"
        case ipv4IpamPoolId = "Ipv4IpamPoolId"
        case ipv4NetmaskLength = "Ipv4NetmaskLength"
        case ipv6CidrBlock = "Ipv6CidrBlock"
        case ipv6CidrBlockNetworkBorderGroup = "Ipv6CidrBlockNetworkBorderGroup"
        case ipv6IpamPoolId = "Ipv6IpamPoolId"
        case ipv6NetmaskLength = "Ipv6NetmaskLength"
        case ipv6Pool = "Ipv6Pool"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct AssociateVpcCidrBlockResult: Codable, Equatable {
    public var cidrBlockAssociation: VpcCidrBlockAssociation?
    public var ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation?
    public var vpcId: String?

    public init(cidrBlockAssociation: VpcCidrBlockAssociation? = nil,
                ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil,
                vpcId: String? = nil) {
        self.cidrBlockAssociation = cidrBlockAssociation
        self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlockAssociation
        case ipv6CidrBlockAssociation
        case vpcId
    }

    public func validate() throws {
        try cidrBlockAssociation?.validate()
        try ipv6CidrBlockAssociation?.validate()
    }
}

public struct AssociatedRole: Codable, Equatable {
    public var associatedRoleArn: ResourceArn?
    public var certificateS3BucketName: String?
    public var certificateS3ObjectKey: String?
    public var encryptionKmsKeyId: String?

    public init(associatedRoleArn: ResourceArn? = nil,
                certificateS3BucketName: String? = nil,
                certificateS3ObjectKey: String? = nil,
                encryptionKmsKeyId: String? = nil) {
        self.associatedRoleArn = associatedRoleArn
        self.certificateS3BucketName = certificateS3BucketName
        self.certificateS3ObjectKey = certificateS3ObjectKey
        self.encryptionKmsKeyId = encryptionKmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case associatedRoleArn
        case certificateS3BucketName
        case certificateS3ObjectKey
        case encryptionKmsKeyId
    }

    public func validate() throws {
        try associatedRoleArn?.validateAsResourceArn()
    }
}

public struct AssociatedTargetNetwork: Codable, Equatable {
    public var networkId: String?
    public var networkType: AssociatedNetworkType?

    public init(networkId: String? = nil,
                networkType: AssociatedNetworkType? = nil) {
        self.networkId = networkId
        self.networkType = networkType
    }

    enum CodingKeys: String, CodingKey {
        case networkId
        case networkType
    }

    public func validate() throws {
    }
}

public struct AssociationStatus: Codable, Equatable {
    public var code: AssociationStatusCode?
    public var message: String?

    public init(code: AssociationStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct AthenaIntegration: Codable, Equatable {
    public var integrationResultS3DestinationArn: String
    public var partitionEndDate: MillisecondDateTime?
    public var partitionLoadFrequency: PartitionLoadFrequency
    public var partitionStartDate: MillisecondDateTime?

    public init(integrationResultS3DestinationArn: String,
                partitionEndDate: MillisecondDateTime? = nil,
                partitionLoadFrequency: PartitionLoadFrequency,
                partitionStartDate: MillisecondDateTime? = nil) {
        self.integrationResultS3DestinationArn = integrationResultS3DestinationArn
        self.partitionEndDate = partitionEndDate
        self.partitionLoadFrequency = partitionLoadFrequency
        self.partitionStartDate = partitionStartDate
    }

    enum CodingKeys: String, CodingKey {
        case integrationResultS3DestinationArn = "IntegrationResultS3DestinationArn"
        case partitionEndDate = "PartitionEndDate"
        case partitionLoadFrequency = "PartitionLoadFrequency"
        case partitionStartDate = "PartitionStartDate"
    }

    public func validate() throws {
    }
}

public struct AttachClassicLinkVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groups: GroupIdStringList
    public var instanceId: InstanceId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                groups: GroupIdStringList,
                instanceId: InstanceId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.groups = groups
        self.instanceId = instanceId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case groups = "SecurityGroupId"
        case instanceId
        case vpcId
    }

    public func validate() throws {
    }
}

public struct AttachClassicLinkVpcResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct AttachInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var internetGatewayId: InternetGatewayId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                internetGatewayId: InternetGatewayId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.internetGatewayId = internetGatewayId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case internetGatewayId
        case vpcId
    }

    public func validate() throws {
    }
}

public struct AttachNetworkInterfaceRequest: Codable, Equatable {
    public var deviceIndex: Integer
    public var dryRun: Boolean?
    public var enaSrdSpecification: EnaSrdSpecification?
    public var instanceId: InstanceId
    public var networkCardIndex: Integer?
    public var networkInterfaceId: NetworkInterfaceId

    public init(deviceIndex: Integer,
                dryRun: Boolean? = nil,
                enaSrdSpecification: EnaSrdSpecification? = nil,
                instanceId: InstanceId,
                networkCardIndex: Integer? = nil,
                networkInterfaceId: NetworkInterfaceId) {
        self.deviceIndex = deviceIndex
        self.dryRun = dryRun
        self.enaSrdSpecification = enaSrdSpecification
        self.instanceId = instanceId
        self.networkCardIndex = networkCardIndex
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case deviceIndex
        case dryRun
        case enaSrdSpecification = "EnaSrdSpecification"
        case instanceId
        case networkCardIndex = "NetworkCardIndex"
        case networkInterfaceId
    }

    public func validate() throws {
        try enaSrdSpecification?.validate()
    }
}

public struct AttachNetworkInterfaceResult: Codable, Equatable {
    public var attachmentId: String?
    public var networkCardIndex: Integer?

    public init(attachmentId: String? = nil,
                networkCardIndex: Integer? = nil) {
        self.attachmentId = attachmentId
        self.networkCardIndex = networkCardIndex
    }

    enum CodingKeys: String, CodingKey {
        case attachmentId
        case networkCardIndex
    }

    public func validate() throws {
    }
}

public struct AttachVerifiedAccessTrustProviderRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var verifiedAccessInstanceId: VerifiedAccessInstanceId
    public var verifiedAccessTrustProviderId: VerifiedAccessTrustProviderId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                verifiedAccessInstanceId: VerifiedAccessInstanceId,
                verifiedAccessTrustProviderId: VerifiedAccessTrustProviderId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
        self.verifiedAccessTrustProviderId = verifiedAccessTrustProviderId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case verifiedAccessInstanceId = "VerifiedAccessInstanceId"
        case verifiedAccessTrustProviderId = "VerifiedAccessTrustProviderId"
    }

    public func validate() throws {
    }
}

public struct AttachVerifiedAccessTrustProviderResult: Codable, Equatable {
    public var verifiedAccessInstance: VerifiedAccessInstance?
    public var verifiedAccessTrustProvider: VerifiedAccessTrustProvider?

    public init(verifiedAccessInstance: VerifiedAccessInstance? = nil,
                verifiedAccessTrustProvider: VerifiedAccessTrustProvider? = nil) {
        self.verifiedAccessInstance = verifiedAccessInstance
        self.verifiedAccessTrustProvider = verifiedAccessTrustProvider
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessInstance
        case verifiedAccessTrustProvider
    }

    public func validate() throws {
        try verifiedAccessInstance?.validate()
        try verifiedAccessTrustProvider?.validate()
    }
}

public struct AttachVolumeRequest: Codable, Equatable {
    public var device: String
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var volumeId: VolumeId

    public init(device: String,
                dryRun: Boolean? = nil,
                instanceId: InstanceId,
                volumeId: VolumeId) {
        self.device = device
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case device = "Device"
        case dryRun
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct AttachVpnGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId
    public var vpnGatewayId: VpnGatewayId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId,
                vpnGatewayId: VpnGatewayId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId = "VpcId"
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct AttachVpnGatewayResult: Codable, Equatable {
    public var vpcAttachment: VpcAttachment?

    public init(vpcAttachment: VpcAttachment? = nil) {
        self.vpcAttachment = vpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case vpcAttachment = "attachment"
    }

    public func validate() throws {
        try vpcAttachment?.validate()
    }
}

public struct AttachmentEnaSrdSpecification: Codable, Equatable {
    public var enaSrdEnabled: Boolean?
    public var enaSrdUdpSpecification: AttachmentEnaSrdUdpSpecification?

    public init(enaSrdEnabled: Boolean? = nil,
                enaSrdUdpSpecification: AttachmentEnaSrdUdpSpecification? = nil) {
        self.enaSrdEnabled = enaSrdEnabled
        self.enaSrdUdpSpecification = enaSrdUdpSpecification
    }

    enum CodingKeys: String, CodingKey {
        case enaSrdEnabled
        case enaSrdUdpSpecification
    }

    public func validate() throws {
        try enaSrdUdpSpecification?.validate()
    }
}

public struct AttachmentEnaSrdUdpSpecification: Codable, Equatable {
    public var enaSrdUdpEnabled: Boolean?

    public init(enaSrdUdpEnabled: Boolean? = nil) {
        self.enaSrdUdpEnabled = enaSrdUdpEnabled
    }

    enum CodingKeys: String, CodingKey {
        case enaSrdUdpEnabled
    }

    public func validate() throws {
    }
}

public struct AttributeBooleanValue: Codable, Equatable {
    public var value: Boolean?

    public init(value: Boolean? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct AttributeValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct AuthorizationRule: Codable, Equatable {
    public var accessAll: Boolean?
    public var clientVpnEndpointId: String?
    public var description: String?
    public var destinationCidr: String?
    public var groupId: String?
    public var status: ClientVpnAuthorizationRuleStatus?

    public init(accessAll: Boolean? = nil,
                clientVpnEndpointId: String? = nil,
                description: String? = nil,
                destinationCidr: String? = nil,
                groupId: String? = nil,
                status: ClientVpnAuthorizationRuleStatus? = nil) {
        self.accessAll = accessAll
        self.clientVpnEndpointId = clientVpnEndpointId
        self.description = description
        self.destinationCidr = destinationCidr
        self.groupId = groupId
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case accessAll
        case clientVpnEndpointId
        case description
        case destinationCidr
        case groupId
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct AuthorizeClientVpnIngressRequest: Codable, Equatable {
    public var accessGroupId: String?
    public var authorizeAllGroups: Boolean?
    public var clientToken: String?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var description: String?
    public var dryRun: Boolean?
    public var targetNetworkCidr: String

    public init(accessGroupId: String? = nil,
                authorizeAllGroups: Boolean? = nil,
                clientToken: String? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                description: String? = nil,
                dryRun: Boolean? = nil,
                targetNetworkCidr: String) {
        self.accessGroupId = accessGroupId
        self.authorizeAllGroups = authorizeAllGroups
        self.clientToken = clientToken
        self.clientVpnEndpointId = clientVpnEndpointId
        self.description = description
        self.dryRun = dryRun
        self.targetNetworkCidr = targetNetworkCidr
    }

    enum CodingKeys: String, CodingKey {
        case accessGroupId = "AccessGroupId"
        case authorizeAllGroups = "AuthorizeAllGroups"
        case clientToken = "ClientToken"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case description = "Description"
        case dryRun = "DryRun"
        case targetNetworkCidr = "TargetNetworkCidr"
    }

    public func validate() throws {
    }
}

public struct AuthorizeClientVpnIngressResult: Codable, Equatable {
    public var status: ClientVpnAuthorizationRuleStatus?

    public init(status: ClientVpnAuthorizationRuleStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct AuthorizeSecurityGroupEgressRequest: Codable, Equatable {
    public var cidrIp: String?
    public var dryRun: Boolean?
    public var fromPort: Integer?
    public var groupId: SecurityGroupId
    public var ipPermissions: IpPermissionList?
    public var ipProtocol: String?
    public var sourceSecurityGroupName: String?
    public var sourceSecurityGroupOwnerId: String?
    public var tagSpecifications: TagSpecificationList?
    public var toPort: Integer?

    public init(cidrIp: String? = nil,
                dryRun: Boolean? = nil,
                fromPort: Integer? = nil,
                groupId: SecurityGroupId,
                ipPermissions: IpPermissionList? = nil,
                ipProtocol: String? = nil,
                sourceSecurityGroupName: String? = nil,
                sourceSecurityGroupOwnerId: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                toPort: Integer? = nil) {
        self.cidrIp = cidrIp
        self.dryRun = dryRun
        self.fromPort = fromPort
        self.groupId = groupId
        self.ipPermissions = ipPermissions
        self.ipProtocol = ipProtocol
        self.sourceSecurityGroupName = sourceSecurityGroupName
        self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
        self.tagSpecifications = tagSpecifications
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp
        case dryRun
        case fromPort
        case groupId
        case ipPermissions
        case ipProtocol
        case sourceSecurityGroupName
        case sourceSecurityGroupOwnerId
        case tagSpecifications = "TagSpecification"
        case toPort
    }

    public func validate() throws {
    }
}

public struct AuthorizeSecurityGroupEgressResult: Codable, Equatable {
    public var `return`: Boolean?
    public var securityGroupRules: SecurityGroupRuleList?

    public init(`return`: Boolean? = nil,
                securityGroupRules: SecurityGroupRuleList? = nil) {
        self.`return` = `return`
        self.securityGroupRules = securityGroupRules
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
        case securityGroupRules = "securityGroupRuleSet"
    }

    public func validate() throws {
    }
}

public struct AuthorizeSecurityGroupIngressRequest: Codable, Equatable {
    public var cidrIp: String?
    public var dryRun: Boolean?
    public var fromPort: Integer?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?
    public var ipPermissions: IpPermissionList?
    public var ipProtocol: String?
    public var sourceSecurityGroupName: String?
    public var sourceSecurityGroupOwnerId: String?
    public var tagSpecifications: TagSpecificationList?
    public var toPort: Integer?

    public init(cidrIp: String? = nil,
                dryRun: Boolean? = nil,
                fromPort: Integer? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil,
                ipPermissions: IpPermissionList? = nil,
                ipProtocol: String? = nil,
                sourceSecurityGroupName: String? = nil,
                sourceSecurityGroupOwnerId: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                toPort: Integer? = nil) {
        self.cidrIp = cidrIp
        self.dryRun = dryRun
        self.fromPort = fromPort
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
        self.ipProtocol = ipProtocol
        self.sourceSecurityGroupName = sourceSecurityGroupName
        self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
        self.tagSpecifications = tagSpecifications
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp = "CidrIp"
        case dryRun
        case fromPort = "FromPort"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
        case ipProtocol = "IpProtocol"
        case sourceSecurityGroupName = "SourceSecurityGroupName"
        case sourceSecurityGroupOwnerId = "SourceSecurityGroupOwnerId"
        case tagSpecifications = "TagSpecification"
        case toPort = "ToPort"
    }

    public func validate() throws {
    }
}

public struct AuthorizeSecurityGroupIngressResult: Codable, Equatable {
    public var `return`: Boolean?
    public var securityGroupRules: SecurityGroupRuleList?

    public init(`return`: Boolean? = nil,
                securityGroupRules: SecurityGroupRuleList? = nil) {
        self.`return` = `return`
        self.securityGroupRules = securityGroupRules
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
        case securityGroupRules = "securityGroupRuleSet"
    }

    public func validate() throws {
    }
}

public struct AvailabilityZone: Codable, Equatable {
    public var groupName: String?
    public var messages: AvailabilityZoneMessageList?
    public var networkBorderGroup: String?
    public var optInStatus: AvailabilityZoneOptInStatus?
    public var parentZoneId: String?
    public var parentZoneName: String?
    public var regionName: String?
    public var state: AvailabilityZoneState?
    public var zoneId: String?
    public var zoneName: String?
    public var zoneType: String?

    public init(groupName: String? = nil,
                messages: AvailabilityZoneMessageList? = nil,
                networkBorderGroup: String? = nil,
                optInStatus: AvailabilityZoneOptInStatus? = nil,
                parentZoneId: String? = nil,
                parentZoneName: String? = nil,
                regionName: String? = nil,
                state: AvailabilityZoneState? = nil,
                zoneId: String? = nil,
                zoneName: String? = nil,
                zoneType: String? = nil) {
        self.groupName = groupName
        self.messages = messages
        self.networkBorderGroup = networkBorderGroup
        self.optInStatus = optInStatus
        self.parentZoneId = parentZoneId
        self.parentZoneName = parentZoneName
        self.regionName = regionName
        self.state = state
        self.zoneId = zoneId
        self.zoneName = zoneName
        self.zoneType = zoneType
    }

    enum CodingKeys: String, CodingKey {
        case groupName
        case messages = "messageSet"
        case networkBorderGroup
        case optInStatus
        case parentZoneId
        case parentZoneName
        case regionName
        case state = "zoneState"
        case zoneId
        case zoneName
        case zoneType
    }

    public func validate() throws {
    }
}

public struct AvailabilityZoneMessage: Codable, Equatable {
    public var message: String?

    public init(message: String? = nil) {
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case message
    }

    public func validate() throws {
    }
}

public struct AvailableCapacity: Codable, Equatable {
    public var availableInstanceCapacity: AvailableInstanceCapacityList?
    public var availableVCpus: Integer?

    public init(availableInstanceCapacity: AvailableInstanceCapacityList? = nil,
                availableVCpus: Integer? = nil) {
        self.availableInstanceCapacity = availableInstanceCapacity
        self.availableVCpus = availableVCpus
    }

    enum CodingKeys: String, CodingKey {
        case availableInstanceCapacity
        case availableVCpus
    }

    public func validate() throws {
    }
}

public struct BaselineEbsBandwidthMbps: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max
        case min
    }

    public func validate() throws {
    }
}

public struct BaselineEbsBandwidthMbpsRequest: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func validate() throws {
    }
}

public struct BlobAttributeValue: Codable, Equatable {
    public var value: Blob?

    public init(value: Blob? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct BlockDeviceMapping: Codable, Equatable {
    public var deviceName: String?
    public var ebs: EbsBlockDevice?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: EbsBlockDevice? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct BundleInstanceRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var storage: Storage

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                storage: Storage) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.storage = storage
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId = "InstanceId"
        case storage = "Storage"
    }

    public func validate() throws {
        try storage.validate()
    }
}

public struct BundleInstanceResult: Codable, Equatable {
    public var bundleTask: BundleTask?

    public init(bundleTask: BundleTask? = nil) {
        self.bundleTask = bundleTask
    }

    enum CodingKeys: String, CodingKey {
        case bundleTask = "bundleInstanceTask"
    }

    public func validate() throws {
        try bundleTask?.validate()
    }
}

public struct BundleTask: Codable, Equatable {
    public var bundleId: String?
    public var bundleTaskError: BundleTaskError?
    public var instanceId: String?
    public var progress: String?
    public var startTime: DateTime?
    public var state: BundleTaskState?
    public var storage: Storage?
    public var updateTime: DateTime?

    public init(bundleId: String? = nil,
                bundleTaskError: BundleTaskError? = nil,
                instanceId: String? = nil,
                progress: String? = nil,
                startTime: DateTime? = nil,
                state: BundleTaskState? = nil,
                storage: Storage? = nil,
                updateTime: DateTime? = nil) {
        self.bundleId = bundleId
        self.bundleTaskError = bundleTaskError
        self.instanceId = instanceId
        self.progress = progress
        self.startTime = startTime
        self.state = state
        self.storage = storage
        self.updateTime = updateTime
    }

    enum CodingKeys: String, CodingKey {
        case bundleId
        case bundleTaskError = "error"
        case instanceId
        case progress
        case startTime
        case state
        case storage
        case updateTime
    }

    public func validate() throws {
        try bundleTaskError?.validate()
        try storage?.validate()
    }
}

public struct BundleTaskError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ByoipCidr: Codable, Equatable {
    public var cidr: String?
    public var description: String?
    public var state: ByoipCidrState?
    public var statusMessage: String?

    public init(cidr: String? = nil,
                description: String? = nil,
                state: ByoipCidrState? = nil,
                statusMessage: String? = nil) {
        self.cidr = cidr
        self.description = description
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case description
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct CancelBundleTaskRequest: Codable, Equatable {
    public var bundleId: BundleId
    public var dryRun: Boolean?

    public init(bundleId: BundleId,
                dryRun: Boolean? = nil) {
        self.bundleId = bundleId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct CancelBundleTaskResult: Codable, Equatable {
    public var bundleTask: BundleTask?

    public init(bundleTask: BundleTask? = nil) {
        self.bundleTask = bundleTask
    }

    enum CodingKeys: String, CodingKey {
        case bundleTask = "bundleInstanceTask"
    }

    public func validate() throws {
        try bundleTask?.validate()
    }
}

public struct CancelCapacityReservationFleetError: Codable, Equatable {
    public var code: CancelCapacityReservationFleetErrorCode?
    public var message: CancelCapacityReservationFleetErrorMessage?

    public init(code: CancelCapacityReservationFleetErrorCode? = nil,
                message: CancelCapacityReservationFleetErrorMessage? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct CancelCapacityReservationFleetsRequest: Codable, Equatable {
    public var capacityReservationFleetIds: CapacityReservationFleetIdSet
    public var dryRun: Boolean?

    public init(capacityReservationFleetIds: CapacityReservationFleetIdSet,
                dryRun: Boolean? = nil) {
        self.capacityReservationFleetIds = capacityReservationFleetIds
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationFleetIds = "CapacityReservationFleetId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct CancelCapacityReservationFleetsResult: Codable, Equatable {
    public var failedFleetCancellations: FailedCapacityReservationFleetCancellationResultSet?
    public var successfulFleetCancellations: CapacityReservationFleetCancellationStateSet?

    public init(failedFleetCancellations: FailedCapacityReservationFleetCancellationResultSet? = nil,
                successfulFleetCancellations: CapacityReservationFleetCancellationStateSet? = nil) {
        self.failedFleetCancellations = failedFleetCancellations
        self.successfulFleetCancellations = successfulFleetCancellations
    }

    enum CodingKeys: String, CodingKey {
        case failedFleetCancellations = "failedFleetCancellationSet"
        case successfulFleetCancellations = "successfulFleetCancellationSet"
    }

    public func validate() throws {
    }
}

public struct CancelCapacityReservationRequest: Codable, Equatable {
    public var capacityReservationId: CapacityReservationId
    public var dryRun: Boolean?

    public init(capacityReservationId: CapacityReservationId,
                dryRun: Boolean? = nil) {
        self.capacityReservationId = capacityReservationId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct CancelCapacityReservationResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct CancelConversionRequest: Codable, Equatable {
    public var conversionTaskId: ConversionTaskId
    public var dryRun: Boolean?
    public var reasonMessage: String?

    public init(conversionTaskId: ConversionTaskId,
                dryRun: Boolean? = nil,
                reasonMessage: String? = nil) {
        self.conversionTaskId = conversionTaskId
        self.dryRun = dryRun
        self.reasonMessage = reasonMessage
    }

    enum CodingKeys: String, CodingKey {
        case conversionTaskId
        case dryRun
        case reasonMessage
    }

    public func validate() throws {
    }
}

public struct CancelExportTaskRequest: Codable, Equatable {
    public var exportTaskId: ExportVmTaskId

    public init(exportTaskId: ExportVmTaskId) {
        self.exportTaskId = exportTaskId
    }

    enum CodingKeys: String, CodingKey {
        case exportTaskId
    }

    public func validate() throws {
    }
}

public struct CancelImageLaunchPermissionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct CancelImageLaunchPermissionResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct CancelImportTaskRequest: Codable, Equatable {
    public var cancelReason: String?
    public var dryRun: Boolean?
    public var importTaskId: ImportTaskId?

    public init(cancelReason: String? = nil,
                dryRun: Boolean? = nil,
                importTaskId: ImportTaskId? = nil) {
        self.cancelReason = cancelReason
        self.dryRun = dryRun
        self.importTaskId = importTaskId
    }

    enum CodingKeys: String, CodingKey {
        case cancelReason = "CancelReason"
        case dryRun = "DryRun"
        case importTaskId = "ImportTaskId"
    }

    public func validate() throws {
    }
}

public struct CancelImportTaskResult: Codable, Equatable {
    public var importTaskId: String?
    public var previousState: String?
    public var state: String?

    public init(importTaskId: String? = nil,
                previousState: String? = nil,
                state: String? = nil) {
        self.importTaskId = importTaskId
        self.previousState = previousState
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case importTaskId
        case previousState
        case state
    }

    public func validate() throws {
    }
}

public struct CancelReservedInstancesListingRequest: Codable, Equatable {
    public var reservedInstancesListingId: ReservedInstancesListingId

    public init(reservedInstancesListingId: ReservedInstancesListingId) {
        self.reservedInstancesListingId = reservedInstancesListingId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesListingId
    }

    public func validate() throws {
    }
}

public struct CancelReservedInstancesListingResult: Codable, Equatable {
    public var reservedInstancesListings: ReservedInstancesListingList?

    public init(reservedInstancesListings: ReservedInstancesListingList? = nil) {
        self.reservedInstancesListings = reservedInstancesListings
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesListings = "reservedInstancesListingsSet"
    }

    public func validate() throws {
    }
}

public struct CancelSpotFleetRequestsError: Codable, Equatable {
    public var code: CancelBatchErrorCode?
    public var message: String?

    public init(code: CancelBatchErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct CancelSpotFleetRequestsErrorItem: Codable, Equatable {
    public var error: CancelSpotFleetRequestsError?
    public var spotFleetRequestId: String?

    public init(error: CancelSpotFleetRequestsError? = nil,
                spotFleetRequestId: String? = nil) {
        self.error = error
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case spotFleetRequestId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct CancelSpotFleetRequestsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var spotFleetRequestIds: SpotFleetRequestIdList
    public var terminateInstances: Boolean

    public init(dryRun: Boolean? = nil,
                spotFleetRequestIds: SpotFleetRequestIdList,
                terminateInstances: Boolean) {
        self.dryRun = dryRun
        self.spotFleetRequestIds = spotFleetRequestIds
        self.terminateInstances = terminateInstances
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case spotFleetRequestIds = "spotFleetRequestId"
        case terminateInstances
    }

    public func validate() throws {
    }
}

public struct CancelSpotFleetRequestsResponse: Codable, Equatable {
    public var successfulFleetRequests: CancelSpotFleetRequestsSuccessSet?
    public var unsuccessfulFleetRequests: CancelSpotFleetRequestsErrorSet?

    public init(successfulFleetRequests: CancelSpotFleetRequestsSuccessSet? = nil,
                unsuccessfulFleetRequests: CancelSpotFleetRequestsErrorSet? = nil) {
        self.successfulFleetRequests = successfulFleetRequests
        self.unsuccessfulFleetRequests = unsuccessfulFleetRequests
    }

    enum CodingKeys: String, CodingKey {
        case successfulFleetRequests = "successfulFleetRequestSet"
        case unsuccessfulFleetRequests = "unsuccessfulFleetRequestSet"
    }

    public func validate() throws {
    }
}

public struct CancelSpotFleetRequestsSuccessItem: Codable, Equatable {
    public var currentSpotFleetRequestState: BatchState?
    public var previousSpotFleetRequestState: BatchState?
    public var spotFleetRequestId: String?

    public init(currentSpotFleetRequestState: BatchState? = nil,
                previousSpotFleetRequestState: BatchState? = nil,
                spotFleetRequestId: String? = nil) {
        self.currentSpotFleetRequestState = currentSpotFleetRequestState
        self.previousSpotFleetRequestState = previousSpotFleetRequestState
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case currentSpotFleetRequestState
        case previousSpotFleetRequestState
        case spotFleetRequestId
    }

    public func validate() throws {
    }
}

public struct CancelSpotInstanceRequestsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var spotInstanceRequestIds: SpotInstanceRequestIdList

    public init(dryRun: Boolean? = nil,
                spotInstanceRequestIds: SpotInstanceRequestIdList) {
        self.dryRun = dryRun
        self.spotInstanceRequestIds = spotInstanceRequestIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case spotInstanceRequestIds = "SpotInstanceRequestId"
    }

    public func validate() throws {
    }
}

public struct CancelSpotInstanceRequestsResult: Codable, Equatable {
    public var cancelledSpotInstanceRequests: CancelledSpotInstanceRequestList?

    public init(cancelledSpotInstanceRequests: CancelledSpotInstanceRequestList? = nil) {
        self.cancelledSpotInstanceRequests = cancelledSpotInstanceRequests
    }

    enum CodingKeys: String, CodingKey {
        case cancelledSpotInstanceRequests = "spotInstanceRequestSet"
    }

    public func validate() throws {
    }
}

public struct CancelledSpotInstanceRequest: Codable, Equatable {
    public var spotInstanceRequestId: String?
    public var state: CancelSpotInstanceRequestState?

    public init(spotInstanceRequestId: String? = nil,
                state: CancelSpotInstanceRequestState? = nil) {
        self.spotInstanceRequestId = spotInstanceRequestId
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case spotInstanceRequestId
        case state
    }

    public func validate() throws {
    }
}

public struct CapacityAllocation: Codable, Equatable {
    public var allocationType: AllocationType?
    public var count: Integer?

    public init(allocationType: AllocationType? = nil,
                count: Integer? = nil) {
        self.allocationType = allocationType
        self.count = count
    }

    enum CodingKeys: String, CodingKey {
        case allocationType
        case count
    }

    public func validate() throws {
    }
}

public struct CapacityReservation: Codable, Equatable {
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var availableInstanceCount: Integer?
    public var capacityAllocations: CapacityAllocations?
    public var capacityReservationArn: String?
    public var capacityReservationFleetId: String?
    public var capacityReservationId: String?
    public var createDate: DateTime?
    public var ebsOptimized: Boolean?
    public var endDate: DateTime?
    public var endDateType: EndDateType?
    public var ephemeralStorage: Boolean?
    public var instanceMatchCriteria: InstanceMatchCriteria?
    public var instancePlatform: CapacityReservationInstancePlatform?
    public var instanceType: String?
    public var outpostArn: OutpostArn?
    public var ownerId: String?
    public var placementGroupArn: PlacementGroupArn?
    public var startDate: MillisecondDateTime?
    public var state: CapacityReservationState?
    public var tags: TagList?
    public var tenancy: CapacityReservationTenancy?
    public var totalInstanceCount: Integer?

    public init(availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                availableInstanceCount: Integer? = nil,
                capacityAllocations: CapacityAllocations? = nil,
                capacityReservationArn: String? = nil,
                capacityReservationFleetId: String? = nil,
                capacityReservationId: String? = nil,
                createDate: DateTime? = nil,
                ebsOptimized: Boolean? = nil,
                endDate: DateTime? = nil,
                endDateType: EndDateType? = nil,
                ephemeralStorage: Boolean? = nil,
                instanceMatchCriteria: InstanceMatchCriteria? = nil,
                instancePlatform: CapacityReservationInstancePlatform? = nil,
                instanceType: String? = nil,
                outpostArn: OutpostArn? = nil,
                ownerId: String? = nil,
                placementGroupArn: PlacementGroupArn? = nil,
                startDate: MillisecondDateTime? = nil,
                state: CapacityReservationState? = nil,
                tags: TagList? = nil,
                tenancy: CapacityReservationTenancy? = nil,
                totalInstanceCount: Integer? = nil) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.availableInstanceCount = availableInstanceCount
        self.capacityAllocations = capacityAllocations
        self.capacityReservationArn = capacityReservationArn
        self.capacityReservationFleetId = capacityReservationFleetId
        self.capacityReservationId = capacityReservationId
        self.createDate = createDate
        self.ebsOptimized = ebsOptimized
        self.endDate = endDate
        self.endDateType = endDateType
        self.ephemeralStorage = ephemeralStorage
        self.instanceMatchCriteria = instanceMatchCriteria
        self.instancePlatform = instancePlatform
        self.instanceType = instanceType
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.placementGroupArn = placementGroupArn
        self.startDate = startDate
        self.state = state
        self.tags = tags
        self.tenancy = tenancy
        self.totalInstanceCount = totalInstanceCount
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case availabilityZoneId
        case availableInstanceCount
        case capacityAllocations = "capacityAllocationSet"
        case capacityReservationArn
        case capacityReservationFleetId
        case capacityReservationId
        case createDate
        case ebsOptimized
        case endDate
        case endDateType
        case ephemeralStorage
        case instanceMatchCriteria
        case instancePlatform
        case instanceType
        case outpostArn
        case ownerId
        case placementGroupArn
        case startDate
        case state
        case tags = "tagSet"
        case tenancy
        case totalInstanceCount
    }

    public func validate() throws {
        try outpostArn?.validateAsOutpostArn()
        try placementGroupArn?.validateAsPlacementGroupArn()
    }
}

public struct CapacityReservationFleet: Codable, Equatable {
    public var allocationStrategy: String?
    public var capacityReservationFleetArn: String?
    public var capacityReservationFleetId: CapacityReservationFleetId?
    public var createTime: MillisecondDateTime?
    public var endDate: MillisecondDateTime?
    public var instanceMatchCriteria: FleetInstanceMatchCriteria?
    public var instanceTypeSpecifications: FleetCapacityReservationSet?
    public var state: CapacityReservationFleetState?
    public var tags: TagList?
    public var tenancy: FleetCapacityReservationTenancy?
    public var totalFulfilledCapacity: Double?
    public var totalTargetCapacity: Integer?

    public init(allocationStrategy: String? = nil,
                capacityReservationFleetArn: String? = nil,
                capacityReservationFleetId: CapacityReservationFleetId? = nil,
                createTime: MillisecondDateTime? = nil,
                endDate: MillisecondDateTime? = nil,
                instanceMatchCriteria: FleetInstanceMatchCriteria? = nil,
                instanceTypeSpecifications: FleetCapacityReservationSet? = nil,
                state: CapacityReservationFleetState? = nil,
                tags: TagList? = nil,
                tenancy: FleetCapacityReservationTenancy? = nil,
                totalFulfilledCapacity: Double? = nil,
                totalTargetCapacity: Integer? = nil) {
        self.allocationStrategy = allocationStrategy
        self.capacityReservationFleetArn = capacityReservationFleetArn
        self.capacityReservationFleetId = capacityReservationFleetId
        self.createTime = createTime
        self.endDate = endDate
        self.instanceMatchCriteria = instanceMatchCriteria
        self.instanceTypeSpecifications = instanceTypeSpecifications
        self.state = state
        self.tags = tags
        self.tenancy = tenancy
        self.totalFulfilledCapacity = totalFulfilledCapacity
        self.totalTargetCapacity = totalTargetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy
        case capacityReservationFleetArn
        case capacityReservationFleetId
        case createTime
        case endDate
        case instanceMatchCriteria
        case instanceTypeSpecifications = "instanceTypeSpecificationSet"
        case state
        case tags = "tagSet"
        case tenancy
        case totalFulfilledCapacity
        case totalTargetCapacity
    }

    public func validate() throws {
    }
}

public struct CapacityReservationFleetCancellationState: Codable, Equatable {
    public var capacityReservationFleetId: CapacityReservationFleetId?
    public var currentFleetState: CapacityReservationFleetState?
    public var previousFleetState: CapacityReservationFleetState?

    public init(capacityReservationFleetId: CapacityReservationFleetId? = nil,
                currentFleetState: CapacityReservationFleetState? = nil,
                previousFleetState: CapacityReservationFleetState? = nil) {
        self.capacityReservationFleetId = capacityReservationFleetId
        self.currentFleetState = currentFleetState
        self.previousFleetState = previousFleetState
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationFleetId
        case currentFleetState
        case previousFleetState
    }

    public func validate() throws {
    }
}

public struct CapacityReservationGroup: Codable, Equatable {
    public var groupArn: String?
    public var ownerId: String?

    public init(groupArn: String? = nil,
                ownerId: String? = nil) {
        self.groupArn = groupArn
        self.ownerId = ownerId
    }

    enum CodingKeys: String, CodingKey {
        case groupArn
        case ownerId
    }

    public func validate() throws {
    }
}

public struct CapacityReservationOptions: Codable, Equatable {
    public var usageStrategy: FleetCapacityReservationUsageStrategy?

    public init(usageStrategy: FleetCapacityReservationUsageStrategy? = nil) {
        self.usageStrategy = usageStrategy
    }

    enum CodingKeys: String, CodingKey {
        case usageStrategy
    }

    public func validate() throws {
    }
}

public struct CapacityReservationOptionsRequest: Codable, Equatable {
    public var usageStrategy: FleetCapacityReservationUsageStrategy?

    public init(usageStrategy: FleetCapacityReservationUsageStrategy? = nil) {
        self.usageStrategy = usageStrategy
    }

    enum CodingKeys: String, CodingKey {
        case usageStrategy = "UsageStrategy"
    }

    public func validate() throws {
    }
}

public struct CapacityReservationSpecification: Codable, Equatable {
    public var capacityReservationPreference: CapacityReservationPreference?
    public var capacityReservationTarget: CapacityReservationTarget?

    public init(capacityReservationPreference: CapacityReservationPreference? = nil,
                capacityReservationTarget: CapacityReservationTarget? = nil) {
        self.capacityReservationPreference = capacityReservationPreference
        self.capacityReservationTarget = capacityReservationTarget
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationPreference = "CapacityReservationPreference"
        case capacityReservationTarget = "CapacityReservationTarget"
    }

    public func validate() throws {
        try capacityReservationTarget?.validate()
    }
}

public struct CapacityReservationSpecificationResponse: Codable, Equatable {
    public var capacityReservationPreference: CapacityReservationPreference?
    public var capacityReservationTarget: CapacityReservationTargetResponse?

    public init(capacityReservationPreference: CapacityReservationPreference? = nil,
                capacityReservationTarget: CapacityReservationTargetResponse? = nil) {
        self.capacityReservationPreference = capacityReservationPreference
        self.capacityReservationTarget = capacityReservationTarget
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationPreference
        case capacityReservationTarget
    }

    public func validate() throws {
        try capacityReservationTarget?.validate()
    }
}

public struct CapacityReservationTarget: Codable, Equatable {
    public var capacityReservationId: CapacityReservationId?
    public var capacityReservationResourceGroupArn: String?

    public init(capacityReservationId: CapacityReservationId? = nil,
                capacityReservationResourceGroupArn: String? = nil) {
        self.capacityReservationId = capacityReservationId
        self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case capacityReservationResourceGroupArn = "CapacityReservationResourceGroupArn"
    }

    public func validate() throws {
    }
}

public struct CapacityReservationTargetResponse: Codable, Equatable {
    public var capacityReservationId: String?
    public var capacityReservationResourceGroupArn: String?

    public init(capacityReservationId: String? = nil,
                capacityReservationResourceGroupArn: String? = nil) {
        self.capacityReservationId = capacityReservationId
        self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId
        case capacityReservationResourceGroupArn
    }

    public func validate() throws {
    }
}

public struct CarrierGateway: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId?
    public var ownerId: String?
    public var state: CarrierGatewayState?
    public var tags: TagList?
    public var vpcId: VpcId?

    public init(carrierGatewayId: CarrierGatewayId? = nil,
                ownerId: String? = nil,
                state: CarrierGatewayState? = nil,
                tags: TagList? = nil,
                vpcId: VpcId? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId
        case ownerId
        case state
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct CertificateAuthentication: Codable, Equatable {
    public var clientRootCertificateChain: String?

    public init(clientRootCertificateChain: String? = nil) {
        self.clientRootCertificateChain = clientRootCertificateChain
    }

    enum CodingKeys: String, CodingKey {
        case clientRootCertificateChain
    }

    public func validate() throws {
    }
}

public struct CertificateAuthenticationRequest: Codable, Equatable {
    public var clientRootCertificateChainArn: String?

    public init(clientRootCertificateChainArn: String? = nil) {
        self.clientRootCertificateChainArn = clientRootCertificateChainArn
    }

    enum CodingKeys: String, CodingKey {
        case clientRootCertificateChainArn = "ClientRootCertificateChainArn"
    }

    public func validate() throws {
    }
}

public struct CidrAuthorizationContext: Codable, Equatable {
    public var message: String
    public var signature: String

    public init(message: String,
                signature: String) {
        self.message = message
        self.signature = signature
    }

    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case signature = "Signature"
    }

    public func validate() throws {
    }
}

public struct CidrBlock: Codable, Equatable {
    public var cidrBlock: String?

    public init(cidrBlock: String? = nil) {
        self.cidrBlock = cidrBlock
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
    }

    public func validate() throws {
    }
}

public struct ClassicLinkDnsSupport: Codable, Equatable {
    public var classicLinkDnsSupported: Boolean?
    public var vpcId: String?

    public init(classicLinkDnsSupported: Boolean? = nil,
                vpcId: String? = nil) {
        self.classicLinkDnsSupported = classicLinkDnsSupported
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case classicLinkDnsSupported
        case vpcId
    }

    public func validate() throws {
    }
}

public struct ClassicLinkInstance: Codable, Equatable {
    public var groups: GroupIdentifierList?
    public var instanceId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(groups: GroupIdentifierList? = nil,
                instanceId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.groups = groups
        self.instanceId = instanceId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case groups = "groupSet"
        case instanceId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct ClassicLoadBalancer: Codable, Equatable {
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case name
    }

    public func validate() throws {
    }
}

public struct ClassicLoadBalancersConfig: Codable, Equatable {
    public var classicLoadBalancers: ClassicLoadBalancers?

    public init(classicLoadBalancers: ClassicLoadBalancers? = nil) {
        self.classicLoadBalancers = classicLoadBalancers
    }

    enum CodingKeys: String, CodingKey {
        case classicLoadBalancers
    }

    public func validate() throws {
        try classicLoadBalancers?.validateAsClassicLoadBalancers()
    }
}

public struct ClientCertificateRevocationListStatus: Codable, Equatable {
    public var code: ClientCertificateRevocationListStatusCode?
    public var message: String?

    public init(code: ClientCertificateRevocationListStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientConnectOptions: Codable, Equatable {
    public var enabled: Boolean?
    public var lambdaFunctionArn: String?

    public init(enabled: Boolean? = nil,
                lambdaFunctionArn: String? = nil) {
        self.enabled = enabled
        self.lambdaFunctionArn = lambdaFunctionArn
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case lambdaFunctionArn = "LambdaFunctionArn"
    }

    public func validate() throws {
    }
}

public struct ClientConnectResponseOptions: Codable, Equatable {
    public var enabled: Boolean?
    public var lambdaFunctionArn: String?
    public var status: ClientVpnEndpointAttributeStatus?

    public init(enabled: Boolean? = nil,
                lambdaFunctionArn: String? = nil,
                status: ClientVpnEndpointAttributeStatus? = nil) {
        self.enabled = enabled
        self.lambdaFunctionArn = lambdaFunctionArn
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case enabled
        case lambdaFunctionArn
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct ClientData: Codable, Equatable {
    public var comment: String?
    public var uploadEnd: DateTime?
    public var uploadSize: Double?
    public var uploadStart: DateTime?

    public init(comment: String? = nil,
                uploadEnd: DateTime? = nil,
                uploadSize: Double? = nil,
                uploadStart: DateTime? = nil) {
        self.comment = comment
        self.uploadEnd = uploadEnd
        self.uploadSize = uploadSize
        self.uploadStart = uploadStart
    }

    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case uploadEnd = "UploadEnd"
        case uploadSize = "UploadSize"
        case uploadStart = "UploadStart"
    }

    public func validate() throws {
    }
}

public struct ClientLoginBannerOptions: Codable, Equatable {
    public var bannerText: String?
    public var enabled: Boolean?

    public init(bannerText: String? = nil,
                enabled: Boolean? = nil) {
        self.bannerText = bannerText
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case bannerText = "BannerText"
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct ClientLoginBannerResponseOptions: Codable, Equatable {
    public var bannerText: String?
    public var enabled: Boolean?

    public init(bannerText: String? = nil,
                enabled: Boolean? = nil) {
        self.bannerText = bannerText
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case bannerText
        case enabled
    }

    public func validate() throws {
    }
}

public struct ClientVpnAuthentication: Codable, Equatable {
    public var activeDirectory: DirectoryServiceAuthentication?
    public var federatedAuthentication: FederatedAuthentication?
    public var mutualAuthentication: CertificateAuthentication?
    public var type: ClientVpnAuthenticationType?

    public init(activeDirectory: DirectoryServiceAuthentication? = nil,
                federatedAuthentication: FederatedAuthentication? = nil,
                mutualAuthentication: CertificateAuthentication? = nil,
                type: ClientVpnAuthenticationType? = nil) {
        self.activeDirectory = activeDirectory
        self.federatedAuthentication = federatedAuthentication
        self.mutualAuthentication = mutualAuthentication
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case activeDirectory
        case federatedAuthentication
        case mutualAuthentication
        case type
    }

    public func validate() throws {
        try activeDirectory?.validate()
        try federatedAuthentication?.validate()
        try mutualAuthentication?.validate()
    }
}

public struct ClientVpnAuthenticationRequest: Codable, Equatable {
    public var activeDirectory: DirectoryServiceAuthenticationRequest?
    public var federatedAuthentication: FederatedAuthenticationRequest?
    public var mutualAuthentication: CertificateAuthenticationRequest?
    public var type: ClientVpnAuthenticationType?

    public init(activeDirectory: DirectoryServiceAuthenticationRequest? = nil,
                federatedAuthentication: FederatedAuthenticationRequest? = nil,
                mutualAuthentication: CertificateAuthenticationRequest? = nil,
                type: ClientVpnAuthenticationType? = nil) {
        self.activeDirectory = activeDirectory
        self.federatedAuthentication = federatedAuthentication
        self.mutualAuthentication = mutualAuthentication
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case activeDirectory = "ActiveDirectory"
        case federatedAuthentication = "FederatedAuthentication"
        case mutualAuthentication = "MutualAuthentication"
        case type = "Type"
    }

    public func validate() throws {
        try activeDirectory?.validate()
        try federatedAuthentication?.validate()
        try mutualAuthentication?.validate()
    }
}

public struct ClientVpnAuthorizationRuleStatus: Codable, Equatable {
    public var code: ClientVpnAuthorizationRuleStatusCode?
    public var message: String?

    public init(code: ClientVpnAuthorizationRuleStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientVpnConnection: Codable, Equatable {
    public var clientIp: String?
    public var clientVpnEndpointId: String?
    public var commonName: String?
    public var connectionEndTime: String?
    public var connectionEstablishedTime: String?
    public var connectionId: String?
    public var egressBytes: String?
    public var egressPackets: String?
    public var ingressBytes: String?
    public var ingressPackets: String?
    public var postureComplianceStatuses: ValueStringList?
    public var status: ClientVpnConnectionStatus?
    public var timestamp: String?
    public var username: String?

    public init(clientIp: String? = nil,
                clientVpnEndpointId: String? = nil,
                commonName: String? = nil,
                connectionEndTime: String? = nil,
                connectionEstablishedTime: String? = nil,
                connectionId: String? = nil,
                egressBytes: String? = nil,
                egressPackets: String? = nil,
                ingressBytes: String? = nil,
                ingressPackets: String? = nil,
                postureComplianceStatuses: ValueStringList? = nil,
                status: ClientVpnConnectionStatus? = nil,
                timestamp: String? = nil,
                username: String? = nil) {
        self.clientIp = clientIp
        self.clientVpnEndpointId = clientVpnEndpointId
        self.commonName = commonName
        self.connectionEndTime = connectionEndTime
        self.connectionEstablishedTime = connectionEstablishedTime
        self.connectionId = connectionId
        self.egressBytes = egressBytes
        self.egressPackets = egressPackets
        self.ingressBytes = ingressBytes
        self.ingressPackets = ingressPackets
        self.postureComplianceStatuses = postureComplianceStatuses
        self.status = status
        self.timestamp = timestamp
        self.username = username
    }

    enum CodingKeys: String, CodingKey {
        case clientIp
        case clientVpnEndpointId
        case commonName
        case connectionEndTime
        case connectionEstablishedTime
        case connectionId
        case egressBytes
        case egressPackets
        case ingressBytes
        case ingressPackets
        case postureComplianceStatuses = "postureComplianceStatusSet"
        case status
        case timestamp
        case username
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct ClientVpnConnectionStatus: Codable, Equatable {
    public var code: ClientVpnConnectionStatusCode?
    public var message: String?

    public init(code: ClientVpnConnectionStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientVpnEndpoint: Codable, Equatable {
    public var authenticationOptions: ClientVpnAuthenticationList?
    public var clientCidrBlock: String?
    public var clientConnectOptions: ClientConnectResponseOptions?
    public var clientLoginBannerOptions: ClientLoginBannerResponseOptions?
    public var clientVpnEndpointId: String?
    public var connectionLogOptions: ConnectionLogResponseOptions?
    public var creationTime: String?
    public var deletionTime: String?
    public var description: String?
    public var dnsName: String?
    public var dnsServers: ValueStringList?
    public var securityGroupIds: ClientVpnSecurityGroupIdSet?
    public var selfServicePortalUrl: String?
    public var serverCertificateArn: String?
    public var sessionTimeoutHours: Integer?
    public var splitTunnel: Boolean?
    public var status: ClientVpnEndpointStatus?
    public var tags: TagList?
    public var transportProtocol: TransportProtocol?
    public var vpcId: VpcId?
    public var vpnPort: Integer?
    public var vpnProtocol: VpnProtocol?

    public init(authenticationOptions: ClientVpnAuthenticationList? = nil,
                clientCidrBlock: String? = nil,
                clientConnectOptions: ClientConnectResponseOptions? = nil,
                clientLoginBannerOptions: ClientLoginBannerResponseOptions? = nil,
                clientVpnEndpointId: String? = nil,
                connectionLogOptions: ConnectionLogResponseOptions? = nil,
                creationTime: String? = nil,
                deletionTime: String? = nil,
                description: String? = nil,
                dnsName: String? = nil,
                dnsServers: ValueStringList? = nil,
                securityGroupIds: ClientVpnSecurityGroupIdSet? = nil,
                selfServicePortalUrl: String? = nil,
                serverCertificateArn: String? = nil,
                sessionTimeoutHours: Integer? = nil,
                splitTunnel: Boolean? = nil,
                status: ClientVpnEndpointStatus? = nil,
                tags: TagList? = nil,
                transportProtocol: TransportProtocol? = nil,
                vpcId: VpcId? = nil,
                vpnPort: Integer? = nil,
                vpnProtocol: VpnProtocol? = nil) {
        self.authenticationOptions = authenticationOptions
        self.clientCidrBlock = clientCidrBlock
        self.clientConnectOptions = clientConnectOptions
        self.clientLoginBannerOptions = clientLoginBannerOptions
        self.clientVpnEndpointId = clientVpnEndpointId
        self.connectionLogOptions = connectionLogOptions
        self.creationTime = creationTime
        self.deletionTime = deletionTime
        self.description = description
        self.dnsName = dnsName
        self.dnsServers = dnsServers
        self.securityGroupIds = securityGroupIds
        self.selfServicePortalUrl = selfServicePortalUrl
        self.serverCertificateArn = serverCertificateArn
        self.sessionTimeoutHours = sessionTimeoutHours
        self.splitTunnel = splitTunnel
        self.status = status
        self.tags = tags
        self.transportProtocol = transportProtocol
        self.vpcId = vpcId
        self.vpnPort = vpnPort
        self.vpnProtocol = vpnProtocol
    }

    enum CodingKeys: String, CodingKey {
        case authenticationOptions
        case clientCidrBlock
        case clientConnectOptions
        case clientLoginBannerOptions
        case clientVpnEndpointId
        case connectionLogOptions
        case creationTime
        case deletionTime
        case description
        case dnsName
        case dnsServers = "dnsServer"
        case securityGroupIds = "securityGroupIdSet"
        case selfServicePortalUrl
        case serverCertificateArn
        case sessionTimeoutHours
        case splitTunnel
        case status
        case tags = "tagSet"
        case transportProtocol
        case vpcId
        case vpnPort
        case vpnProtocol
    }

    public func validate() throws {
        try clientConnectOptions?.validate()
        try clientLoginBannerOptions?.validate()
        try connectionLogOptions?.validate()
        try status?.validate()
    }
}

public struct ClientVpnEndpointAttributeStatus: Codable, Equatable {
    public var code: ClientVpnEndpointAttributeStatusCode?
    public var message: String?

    public init(code: ClientVpnEndpointAttributeStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientVpnEndpointStatus: Codable, Equatable {
    public var code: ClientVpnEndpointStatusCode?
    public var message: String?

    public init(code: ClientVpnEndpointStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ClientVpnRoute: Codable, Equatable {
    public var clientVpnEndpointId: String?
    public var description: String?
    public var destinationCidr: String?
    public var origin: String?
    public var status: ClientVpnRouteStatus?
    public var targetSubnet: String?
    public var type: String?

    public init(clientVpnEndpointId: String? = nil,
                description: String? = nil,
                destinationCidr: String? = nil,
                origin: String? = nil,
                status: ClientVpnRouteStatus? = nil,
                targetSubnet: String? = nil,
                type: String? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.description = description
        self.destinationCidr = destinationCidr
        self.origin = origin
        self.status = status
        self.targetSubnet = targetSubnet
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId
        case description
        case destinationCidr
        case origin
        case status
        case targetSubnet
        case type
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct ClientVpnRouteStatus: Codable, Equatable {
    public var code: ClientVpnRouteStatusCode?
    public var message: String?

    public init(code: ClientVpnRouteStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct CloudWatchLogOptions: Codable, Equatable {
    public var logEnabled: Boolean?
    public var logGroupArn: String?
    public var logOutputFormat: String?

    public init(logEnabled: Boolean? = nil,
                logGroupArn: String? = nil,
                logOutputFormat: String? = nil) {
        self.logEnabled = logEnabled
        self.logGroupArn = logGroupArn
        self.logOutputFormat = logOutputFormat
    }

    enum CodingKeys: String, CodingKey {
        case logEnabled
        case logGroupArn
        case logOutputFormat
    }

    public func validate() throws {
    }
}

public struct CloudWatchLogOptionsSpecification: Codable, Equatable {
    public var logEnabled: Boolean?
    public var logGroupArn: CloudWatchLogGroupArn?
    public var logOutputFormat: String?

    public init(logEnabled: Boolean? = nil,
                logGroupArn: CloudWatchLogGroupArn? = nil,
                logOutputFormat: String? = nil) {
        self.logEnabled = logEnabled
        self.logGroupArn = logGroupArn
        self.logOutputFormat = logOutputFormat
    }

    enum CodingKeys: String, CodingKey {
        case logEnabled = "LogEnabled"
        case logGroupArn = "LogGroupArn"
        case logOutputFormat = "LogOutputFormat"
    }

    public func validate() throws {
    }
}

public struct CoipAddressUsage: Codable, Equatable {
    public var allocationId: String?
    public var awsAccountId: String?
    public var awsService: String?
    public var coIp: String?

    public init(allocationId: String? = nil,
                awsAccountId: String? = nil,
                awsService: String? = nil,
                coIp: String? = nil) {
        self.allocationId = allocationId
        self.awsAccountId = awsAccountId
        self.awsService = awsService
        self.coIp = coIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case awsAccountId
        case awsService
        case coIp
    }

    public func validate() throws {
    }
}

public struct CoipCidr: Codable, Equatable {
    public var cidr: String?
    public var coipPoolId: Ipv4PoolCoipId?
    public var localGatewayRouteTableId: String?

    public init(cidr: String? = nil,
                coipPoolId: Ipv4PoolCoipId? = nil,
                localGatewayRouteTableId: String? = nil) {
        self.cidr = cidr
        self.coipPoolId = coipPoolId
        self.localGatewayRouteTableId = localGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case coipPoolId
        case localGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct CoipPool: Codable, Equatable {
    public var localGatewayRouteTableId: LocalGatewayRoutetableId?
    public var poolArn: ResourceArn?
    public var poolCidrs: ValueStringList?
    public var poolId: Ipv4PoolCoipId?
    public var tags: TagList?

    public init(localGatewayRouteTableId: LocalGatewayRoutetableId? = nil,
                poolArn: ResourceArn? = nil,
                poolCidrs: ValueStringList? = nil,
                poolId: Ipv4PoolCoipId? = nil,
                tags: TagList? = nil) {
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.poolArn = poolArn
        self.poolCidrs = poolCidrs
        self.poolId = poolId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableId
        case poolArn
        case poolCidrs = "poolCidrSet"
        case poolId
        case tags = "tagSet"
    }

    public func validate() throws {
        try poolArn?.validateAsResourceArn()
    }
}

public struct ConfirmProductInstanceRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var productCode: String

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                productCode: String) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.productCode = productCode
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId = "InstanceId"
        case productCode = "ProductCode"
    }

    public func validate() throws {
    }
}

public struct ConfirmProductInstanceResult: Codable, Equatable {
    public var ownerId: String?
    public var `return`: Boolean?

    public init(ownerId: String? = nil,
                `return`: Boolean? = nil) {
        self.ownerId = ownerId
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case ownerId
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ConnectionLogOptions: Codable, Equatable {
    public var cloudwatchLogGroup: String?
    public var cloudwatchLogStream: String?
    public var enabled: Boolean?

    public init(cloudwatchLogGroup: String? = nil,
                cloudwatchLogStream: String? = nil,
                enabled: Boolean? = nil) {
        self.cloudwatchLogGroup = cloudwatchLogGroup
        self.cloudwatchLogStream = cloudwatchLogStream
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case cloudwatchLogGroup = "CloudwatchLogGroup"
        case cloudwatchLogStream = "CloudwatchLogStream"
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct ConnectionLogResponseOptions: Codable, Equatable {
    public var cloudwatchLogGroup: String?
    public var cloudwatchLogStream: String?
    public var enabled: Boolean?

    public init(cloudwatchLogGroup: String? = nil,
                cloudwatchLogStream: String? = nil,
                enabled: Boolean? = nil) {
        self.cloudwatchLogGroup = cloudwatchLogGroup
        self.cloudwatchLogStream = cloudwatchLogStream
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case cloudwatchLogGroup = "CloudwatchLogGroup"
        case cloudwatchLogStream = "CloudwatchLogStream"
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct ConnectionNotification: Codable, Equatable {
    public var connectionEvents: ValueStringList?
    public var connectionNotificationArn: String?
    public var connectionNotificationId: String?
    public var connectionNotificationState: ConnectionNotificationState?
    public var connectionNotificationType: ConnectionNotificationType?
    public var serviceId: String?
    public var vpcEndpointId: String?

    public init(connectionEvents: ValueStringList? = nil,
                connectionNotificationArn: String? = nil,
                connectionNotificationId: String? = nil,
                connectionNotificationState: ConnectionNotificationState? = nil,
                connectionNotificationType: ConnectionNotificationType? = nil,
                serviceId: String? = nil,
                vpcEndpointId: String? = nil) {
        self.connectionEvents = connectionEvents
        self.connectionNotificationArn = connectionNotificationArn
        self.connectionNotificationId = connectionNotificationId
        self.connectionNotificationState = connectionNotificationState
        self.connectionNotificationType = connectionNotificationType
        self.serviceId = serviceId
        self.vpcEndpointId = vpcEndpointId
    }

    enum CodingKeys: String, CodingKey {
        case connectionEvents
        case connectionNotificationArn
        case connectionNotificationId
        case connectionNotificationState
        case connectionNotificationType
        case serviceId
        case vpcEndpointId
    }

    public func validate() throws {
    }
}

public struct ConversionTask: Codable, Equatable {
    public var conversionTaskId: String?
    public var expirationTime: String?
    public var importInstance: ImportInstanceTaskDetails?
    public var importVolume: ImportVolumeTaskDetails?
    public var state: ConversionTaskState?
    public var statusMessage: String?
    public var tags: TagList?

    public init(conversionTaskId: String? = nil,
                expirationTime: String? = nil,
                importInstance: ImportInstanceTaskDetails? = nil,
                importVolume: ImportVolumeTaskDetails? = nil,
                state: ConversionTaskState? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.conversionTaskId = conversionTaskId
        self.expirationTime = expirationTime
        self.importInstance = importInstance
        self.importVolume = importVolume
        self.state = state
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case conversionTaskId
        case expirationTime
        case importInstance
        case importVolume
        case state
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try importInstance?.validate()
        try importVolume?.validate()
    }
}

public struct CopyFpgaImageRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var name: String?
    public var sourceFpgaImageId: String
    public var sourceRegion: String

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                name: String? = nil,
                sourceFpgaImageId: String,
                sourceRegion: String) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.name = name
        self.sourceFpgaImageId = sourceFpgaImageId
        self.sourceRegion = sourceRegion
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case name = "Name"
        case sourceFpgaImageId = "SourceFpgaImageId"
        case sourceRegion = "SourceRegion"
    }

    public func validate() throws {
    }
}

public struct CopyFpgaImageResult: Codable, Equatable {
    public var fpgaImageId: String?

    public init(fpgaImageId: String? = nil) {
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImageId
    }

    public func validate() throws {
    }
}

public struct CopyImageRequest: Codable, Equatable {
    public var clientToken: String?
    public var copyImageTags: Boolean?
    public var description: String?
    public var destinationOutpostArn: String?
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var kmsKeyId: KmsKeyId?
    public var name: String
    public var sourceImageId: String
    public var sourceRegion: String

    public init(clientToken: String? = nil,
                copyImageTags: Boolean? = nil,
                description: String? = nil,
                destinationOutpostArn: String? = nil,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                kmsKeyId: KmsKeyId? = nil,
                name: String,
                sourceImageId: String,
                sourceRegion: String) {
        self.clientToken = clientToken
        self.copyImageTags = copyImageTags
        self.description = description
        self.destinationOutpostArn = destinationOutpostArn
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sourceImageId = sourceImageId
        self.sourceRegion = sourceRegion
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case copyImageTags = "CopyImageTags"
        case description = "Description"
        case destinationOutpostArn = "DestinationOutpostArn"
        case dryRun
        case encrypted
        case kmsKeyId
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
    }

    public func validate() throws {
    }
}

public struct CopyImageResult: Codable, Equatable {
    public var imageId: String?

    public init(imageId: String? = nil) {
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case imageId
    }

    public func validate() throws {
    }
}

public struct CopySnapshotRequest: Codable, Equatable {
    public var description: String?
    public var destinationOutpostArn: String?
    public var destinationRegion: String?
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var kmsKeyId: KmsKeyId?
    public var presignedUrl: String?
    public var sourceRegion: String
    public var sourceSnapshotId: String
    public var tagSpecifications: TagSpecificationList?

    public init(description: String? = nil,
                destinationOutpostArn: String? = nil,
                destinationRegion: String? = nil,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                kmsKeyId: KmsKeyId? = nil,
                presignedUrl: String? = nil,
                sourceRegion: String,
                sourceSnapshotId: String,
                tagSpecifications: TagSpecificationList? = nil) {
        self.description = description
        self.destinationOutpostArn = destinationOutpostArn
        self.destinationRegion = destinationRegion
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.presignedUrl = presignedUrl
        self.sourceRegion = sourceRegion
        self.sourceSnapshotId = sourceSnapshotId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case destinationOutpostArn = "DestinationOutpostArn"
        case destinationRegion
        case dryRun
        case encrypted
        case kmsKeyId
        case presignedUrl
        case sourceRegion = "SourceRegion"
        case sourceSnapshotId = "SourceSnapshotId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CopySnapshotResult: Codable, Equatable {
    public var snapshotId: String?
    public var tags: TagList?

    public init(snapshotId: String? = nil,
                tags: TagList? = nil) {
        self.snapshotId = snapshotId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case snapshotId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct CpuOptions: Codable, Equatable {
    public var coreCount: Integer?
    public var threadsPerCore: Integer?

    public init(coreCount: Integer? = nil,
                threadsPerCore: Integer? = nil) {
        self.coreCount = coreCount
        self.threadsPerCore = threadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case coreCount
        case threadsPerCore
    }

    public func validate() throws {
    }
}

public struct CpuOptionsRequest: Codable, Equatable {
    public var coreCount: Integer?
    public var threadsPerCore: Integer?

    public init(coreCount: Integer? = nil,
                threadsPerCore: Integer? = nil) {
        self.coreCount = coreCount
        self.threadsPerCore = threadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case coreCount = "CoreCount"
        case threadsPerCore = "ThreadsPerCore"
    }

    public func validate() throws {
    }
}

public struct CreateCapacityReservationFleetRequest: Codable, Equatable {
    public var allocationStrategy: String?
    public var clientToken: String?
    public var dryRun: Boolean?
    public var endDate: MillisecondDateTime?
    public var instanceMatchCriteria: FleetInstanceMatchCriteria?
    public var instanceTypeSpecifications: ReservationFleetInstanceSpecificationList
    public var tagSpecifications: TagSpecificationList?
    public var tenancy: FleetCapacityReservationTenancy?
    public var totalTargetCapacity: Integer

    public init(allocationStrategy: String? = nil,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                endDate: MillisecondDateTime? = nil,
                instanceMatchCriteria: FleetInstanceMatchCriteria? = nil,
                instanceTypeSpecifications: ReservationFleetInstanceSpecificationList,
                tagSpecifications: TagSpecificationList? = nil,
                tenancy: FleetCapacityReservationTenancy? = nil,
                totalTargetCapacity: Integer) {
        self.allocationStrategy = allocationStrategy
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.endDate = endDate
        self.instanceMatchCriteria = instanceMatchCriteria
        self.instanceTypeSpecifications = instanceTypeSpecifications
        self.tagSpecifications = tagSpecifications
        self.tenancy = tenancy
        self.totalTargetCapacity = totalTargetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy = "AllocationStrategy"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case endDate = "EndDate"
        case instanceMatchCriteria = "InstanceMatchCriteria"
        case instanceTypeSpecifications = "InstanceTypeSpecification"
        case tagSpecifications = "TagSpecification"
        case tenancy = "Tenancy"
        case totalTargetCapacity = "TotalTargetCapacity"
    }

    public func validate() throws {
    }
}

public struct CreateCapacityReservationFleetResult: Codable, Equatable {
    public var allocationStrategy: String?
    public var capacityReservationFleetId: CapacityReservationFleetId?
    public var createTime: MillisecondDateTime?
    public var endDate: MillisecondDateTime?
    public var fleetCapacityReservations: FleetCapacityReservationSet?
    public var instanceMatchCriteria: FleetInstanceMatchCriteria?
    public var state: CapacityReservationFleetState?
    public var tags: TagList?
    public var tenancy: FleetCapacityReservationTenancy?
    public var totalFulfilledCapacity: Double?
    public var totalTargetCapacity: Integer?

    public init(allocationStrategy: String? = nil,
                capacityReservationFleetId: CapacityReservationFleetId? = nil,
                createTime: MillisecondDateTime? = nil,
                endDate: MillisecondDateTime? = nil,
                fleetCapacityReservations: FleetCapacityReservationSet? = nil,
                instanceMatchCriteria: FleetInstanceMatchCriteria? = nil,
                state: CapacityReservationFleetState? = nil,
                tags: TagList? = nil,
                tenancy: FleetCapacityReservationTenancy? = nil,
                totalFulfilledCapacity: Double? = nil,
                totalTargetCapacity: Integer? = nil) {
        self.allocationStrategy = allocationStrategy
        self.capacityReservationFleetId = capacityReservationFleetId
        self.createTime = createTime
        self.endDate = endDate
        self.fleetCapacityReservations = fleetCapacityReservations
        self.instanceMatchCriteria = instanceMatchCriteria
        self.state = state
        self.tags = tags
        self.tenancy = tenancy
        self.totalFulfilledCapacity = totalFulfilledCapacity
        self.totalTargetCapacity = totalTargetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy
        case capacityReservationFleetId
        case createTime
        case endDate
        case fleetCapacityReservations = "fleetCapacityReservationSet"
        case instanceMatchCriteria
        case state
        case tags = "tagSet"
        case tenancy
        case totalFulfilledCapacity
        case totalTargetCapacity
    }

    public func validate() throws {
    }
}

public struct CreateCapacityReservationRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var clientToken: String?
    public var dryRun: Boolean?
    public var ebsOptimized: Boolean?
    public var endDate: DateTime?
    public var endDateType: EndDateType?
    public var ephemeralStorage: Boolean?
    public var instanceCount: Integer
    public var instanceMatchCriteria: InstanceMatchCriteria?
    public var instancePlatform: CapacityReservationInstancePlatform
    public var instanceType: String
    public var outpostArn: OutpostArn?
    public var placementGroupArn: PlacementGroupArn?
    public var tagSpecifications: TagSpecificationList?
    public var tenancy: CapacityReservationTenancy?

    public init(availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                ebsOptimized: Boolean? = nil,
                endDate: DateTime? = nil,
                endDateType: EndDateType? = nil,
                ephemeralStorage: Boolean? = nil,
                instanceCount: Integer,
                instanceMatchCriteria: InstanceMatchCriteria? = nil,
                instancePlatform: CapacityReservationInstancePlatform,
                instanceType: String,
                outpostArn: OutpostArn? = nil,
                placementGroupArn: PlacementGroupArn? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                tenancy: CapacityReservationTenancy? = nil) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.ebsOptimized = ebsOptimized
        self.endDate = endDate
        self.endDateType = endDateType
        self.ephemeralStorage = ephemeralStorage
        self.instanceCount = instanceCount
        self.instanceMatchCriteria = instanceMatchCriteria
        self.instancePlatform = instancePlatform
        self.instanceType = instanceType
        self.outpostArn = outpostArn
        self.placementGroupArn = placementGroupArn
        self.tagSpecifications = tagSpecifications
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case ebsOptimized = "EbsOptimized"
        case endDate = "EndDate"
        case endDateType = "EndDateType"
        case ephemeralStorage = "EphemeralStorage"
        case instanceCount = "InstanceCount"
        case instanceMatchCriteria = "InstanceMatchCriteria"
        case instancePlatform = "InstancePlatform"
        case instanceType = "InstanceType"
        case outpostArn = "OutpostArn"
        case placementGroupArn = "PlacementGroupArn"
        case tagSpecifications = "TagSpecifications"
        case tenancy = "Tenancy"
    }

    public func validate() throws {
        try outpostArn?.validateAsOutpostArn()
        try placementGroupArn?.validateAsPlacementGroupArn()
    }
}

public struct CreateCapacityReservationResult: Codable, Equatable {
    public var capacityReservation: CapacityReservation?

    public init(capacityReservation: CapacityReservation? = nil) {
        self.capacityReservation = capacityReservation
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservation
    }

    public func validate() throws {
        try capacityReservation?.validate()
    }
}

public struct CreateCarrierGatewayRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateCarrierGatewayResult: Codable, Equatable {
    public var carrierGateway: CarrierGateway?

    public init(carrierGateway: CarrierGateway? = nil) {
        self.carrierGateway = carrierGateway
    }

    enum CodingKeys: String, CodingKey {
        case carrierGateway
    }

    public func validate() throws {
        try carrierGateway?.validate()
    }
}

public struct CreateClientVpnEndpointRequest: Codable, Equatable {
    public var authenticationOptions: ClientVpnAuthenticationRequestList
    public var clientCidrBlock: String
    public var clientConnectOptions: ClientConnectOptions?
    public var clientLoginBannerOptions: ClientLoginBannerOptions?
    public var clientToken: String?
    public var connectionLogOptions: ConnectionLogOptions
    public var description: String?
    public var dnsServers: ValueStringList?
    public var dryRun: Boolean?
    public var securityGroupIds: ClientVpnSecurityGroupIdSet?
    public var selfServicePortal: SelfServicePortal?
    public var serverCertificateArn: String
    public var sessionTimeoutHours: Integer?
    public var splitTunnel: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var transportProtocol: TransportProtocol?
    public var vpcId: VpcId?
    public var vpnPort: Integer?

    public init(authenticationOptions: ClientVpnAuthenticationRequestList,
                clientCidrBlock: String,
                clientConnectOptions: ClientConnectOptions? = nil,
                clientLoginBannerOptions: ClientLoginBannerOptions? = nil,
                clientToken: String? = nil,
                connectionLogOptions: ConnectionLogOptions,
                description: String? = nil,
                dnsServers: ValueStringList? = nil,
                dryRun: Boolean? = nil,
                securityGroupIds: ClientVpnSecurityGroupIdSet? = nil,
                selfServicePortal: SelfServicePortal? = nil,
                serverCertificateArn: String,
                sessionTimeoutHours: Integer? = nil,
                splitTunnel: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                transportProtocol: TransportProtocol? = nil,
                vpcId: VpcId? = nil,
                vpnPort: Integer? = nil) {
        self.authenticationOptions = authenticationOptions
        self.clientCidrBlock = clientCidrBlock
        self.clientConnectOptions = clientConnectOptions
        self.clientLoginBannerOptions = clientLoginBannerOptions
        self.clientToken = clientToken
        self.connectionLogOptions = connectionLogOptions
        self.description = description
        self.dnsServers = dnsServers
        self.dryRun = dryRun
        self.securityGroupIds = securityGroupIds
        self.selfServicePortal = selfServicePortal
        self.serverCertificateArn = serverCertificateArn
        self.sessionTimeoutHours = sessionTimeoutHours
        self.splitTunnel = splitTunnel
        self.tagSpecifications = tagSpecifications
        self.transportProtocol = transportProtocol
        self.vpcId = vpcId
        self.vpnPort = vpnPort
    }

    enum CodingKeys: String, CodingKey {
        case authenticationOptions = "Authentication"
        case clientCidrBlock = "ClientCidrBlock"
        case clientConnectOptions = "ClientConnectOptions"
        case clientLoginBannerOptions = "ClientLoginBannerOptions"
        case clientToken = "ClientToken"
        case connectionLogOptions = "ConnectionLogOptions"
        case description = "Description"
        case dnsServers = "DnsServers"
        case dryRun = "DryRun"
        case securityGroupIds = "SecurityGroupId"
        case selfServicePortal = "SelfServicePortal"
        case serverCertificateArn = "ServerCertificateArn"
        case sessionTimeoutHours = "SessionTimeoutHours"
        case splitTunnel = "SplitTunnel"
        case tagSpecifications = "TagSpecification"
        case transportProtocol = "TransportProtocol"
        case vpcId = "VpcId"
        case vpnPort = "VpnPort"
    }

    public func validate() throws {
        try clientConnectOptions?.validate()
        try clientLoginBannerOptions?.validate()
        try connectionLogOptions.validate()
    }
}

public struct CreateClientVpnEndpointResult: Codable, Equatable {
    public var clientVpnEndpointId: String?
    public var dnsName: String?
    public var status: ClientVpnEndpointStatus?

    public init(clientVpnEndpointId: String? = nil,
                dnsName: String? = nil,
                status: ClientVpnEndpointStatus? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dnsName = dnsName
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId
        case dnsName
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct CreateClientVpnRouteRequest: Codable, Equatable {
    public var clientToken: String?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var description: String?
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var targetVpcSubnetId: SubnetId

    public init(clientToken: String? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                description: String? = nil,
                destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                targetVpcSubnetId: SubnetId) {
        self.clientToken = clientToken
        self.clientVpnEndpointId = clientVpnEndpointId
        self.description = description
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.targetVpcSubnetId = targetVpcSubnetId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case targetVpcSubnetId = "TargetVpcSubnetId"
    }

    public func validate() throws {
    }
}

public struct CreateClientVpnRouteResult: Codable, Equatable {
    public var status: ClientVpnRouteStatus?

    public init(status: ClientVpnRouteStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct CreateCoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var coipPoolId: Ipv4PoolCoipId
    public var dryRun: Boolean?

    public init(cidr: String,
                coipPoolId: Ipv4PoolCoipId,
                dryRun: Boolean? = nil) {
        self.cidr = cidr
        self.coipPoolId = coipPoolId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case coipPoolId = "CoipPoolId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct CreateCoipCidrResult: Codable, Equatable {
    public var coipCidr: CoipCidr?

    public init(coipCidr: CoipCidr? = nil) {
        self.coipCidr = coipCidr
    }

    enum CodingKeys: String, CodingKey {
        case coipCidr
    }

    public func validate() throws {
        try coipCidr?.validate()
    }
}

public struct CreateCoipPoolRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateCoipPoolResult: Codable, Equatable {
    public var coipPool: CoipPool?

    public init(coipPool: CoipPool? = nil) {
        self.coipPool = coipPool
    }

    enum CodingKeys: String, CodingKey {
        case coipPool
    }

    public func validate() throws {
        try coipPool?.validate()
    }
}

public struct CreateCustomerGatewayRequest: Codable, Equatable {
    public var bgpAsn: Integer
    public var certificateArn: String?
    public var deviceName: String?
    public var dryRun: Boolean?
    public var ipAddress: String?
    public var publicIp: String?
    public var tagSpecifications: TagSpecificationList?
    public var type: GatewayType

    public init(bgpAsn: Integer,
                certificateArn: String? = nil,
                deviceName: String? = nil,
                dryRun: Boolean? = nil,
                ipAddress: String? = nil,
                publicIp: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                type: GatewayType) {
        self.bgpAsn = bgpAsn
        self.certificateArn = certificateArn
        self.deviceName = deviceName
        self.dryRun = dryRun
        self.ipAddress = ipAddress
        self.publicIp = publicIp
        self.tagSpecifications = tagSpecifications
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case bgpAsn = "BgpAsn"
        case certificateArn = "CertificateArn"
        case deviceName = "DeviceName"
        case dryRun
        case ipAddress = "IpAddress"
        case publicIp = "PublicIp"
        case tagSpecifications = "TagSpecification"
        case type = "Type"
    }

    public func validate() throws {
    }
}

public struct CreateCustomerGatewayResult: Codable, Equatable {
    public var customerGateway: CustomerGateway?

    public init(customerGateway: CustomerGateway? = nil) {
        self.customerGateway = customerGateway
    }

    enum CodingKeys: String, CodingKey {
        case customerGateway
    }

    public func validate() throws {
        try customerGateway?.validate()
    }
}

public struct CreateDefaultSubnetRequest: Codable, Equatable {
    public var availabilityZone: String
    public var dryRun: Boolean?
    public var ipv6Native: Boolean?

    public init(availabilityZone: String,
                dryRun: Boolean? = nil,
                ipv6Native: Boolean? = nil) {
        self.availabilityZone = availabilityZone
        self.dryRun = dryRun
        self.ipv6Native = ipv6Native
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case dryRun = "DryRun"
        case ipv6Native = "Ipv6Native"
    }

    public func validate() throws {
    }
}

public struct CreateDefaultSubnetResult: Codable, Equatable {
    public var subnet: Subnet?

    public init(subnet: Subnet? = nil) {
        self.subnet = subnet
    }

    enum CodingKeys: String, CodingKey {
        case subnet
    }

    public func validate() throws {
        try subnet?.validate()
    }
}

public struct CreateDefaultVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct CreateDefaultVpcResult: Codable, Equatable {
    public var vpc: Vpc?

    public init(vpc: Vpc? = nil) {
        self.vpc = vpc
    }

    enum CodingKeys: String, CodingKey {
        case vpc
    }

    public func validate() throws {
        try vpc?.validate()
    }
}

public struct CreateDhcpOptionsRequest: Codable, Equatable {
    public var dhcpConfigurations: NewDhcpConfigurationList
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(dhcpConfigurations: NewDhcpConfigurationList,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dhcpConfigurations = dhcpConfigurations
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dhcpConfigurations = "dhcpConfiguration"
        case dryRun
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateDhcpOptionsResult: Codable, Equatable {
    public var dhcpOptions: DhcpOptions?

    public init(dhcpOptions: DhcpOptions? = nil) {
        self.dhcpOptions = dhcpOptions
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptions
    }

    public func validate() throws {
        try dhcpOptions?.validate()
    }
}

public struct CreateEgressOnlyInternetGatewayRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateEgressOnlyInternetGatewayResult: Codable, Equatable {
    public var clientToken: String?
    public var egressOnlyInternetGateway: EgressOnlyInternetGateway?

    public init(clientToken: String? = nil,
                egressOnlyInternetGateway: EgressOnlyInternetGateway? = nil) {
        self.clientToken = clientToken
        self.egressOnlyInternetGateway = egressOnlyInternetGateway
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case egressOnlyInternetGateway
    }

    public func validate() throws {
        try egressOnlyInternetGateway?.validate()
    }
}

public struct CreateFleetError: Codable, Equatable {
    public var errorCode: String?
    public var errorMessage: String?
    public var launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse?
    public var lifecycle: InstanceLifecycle?

    public init(errorCode: String? = nil,
                errorMessage: String? = nil,
                launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse? = nil,
                lifecycle: InstanceLifecycle? = nil) {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.launchTemplateAndOverrides = launchTemplateAndOverrides
        self.lifecycle = lifecycle
    }

    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case launchTemplateAndOverrides
        case lifecycle
    }

    public func validate() throws {
        try launchTemplateAndOverrides?.validate()
    }
}

public struct CreateFleetInstance: Codable, Equatable {
    public var instanceIds: InstanceIdsSet?
    public var instanceType: InstanceType?
    public var launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse?
    public var lifecycle: InstanceLifecycle?
    public var platform: PlatformValues?

    public init(instanceIds: InstanceIdsSet? = nil,
                instanceType: InstanceType? = nil,
                launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse? = nil,
                lifecycle: InstanceLifecycle? = nil,
                platform: PlatformValues? = nil) {
        self.instanceIds = instanceIds
        self.instanceType = instanceType
        self.launchTemplateAndOverrides = launchTemplateAndOverrides
        self.lifecycle = lifecycle
        self.platform = platform
    }

    enum CodingKeys: String, CodingKey {
        case instanceIds
        case instanceType
        case launchTemplateAndOverrides
        case lifecycle
        case platform
    }

    public func validate() throws {
        try launchTemplateAndOverrides?.validate()
    }
}

public struct CreateFleetRequest: Codable, Equatable {
    public var clientToken: String?
    public var context: String?
    public var dryRun: Boolean?
    public var excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy?
    public var launchTemplateConfigs: FleetLaunchTemplateConfigListRequest
    public var onDemandOptions: OnDemandOptionsRequest?
    public var replaceUnhealthyInstances: Boolean?
    public var spotOptions: SpotOptionsRequest?
    public var tagSpecifications: TagSpecificationList?
    public var targetCapacitySpecification: TargetCapacitySpecificationRequest
    public var terminateInstancesWithExpiration: Boolean?
    public var type: FleetType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(clientToken: String? = nil,
                context: String? = nil,
                dryRun: Boolean? = nil,
                excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy? = nil,
                launchTemplateConfigs: FleetLaunchTemplateConfigListRequest,
                onDemandOptions: OnDemandOptionsRequest? = nil,
                replaceUnhealthyInstances: Boolean? = nil,
                spotOptions: SpotOptionsRequest? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                targetCapacitySpecification: TargetCapacitySpecificationRequest,
                terminateInstancesWithExpiration: Boolean? = nil,
                type: FleetType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.clientToken = clientToken
        self.context = context
        self.dryRun = dryRun
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.launchTemplateConfigs = launchTemplateConfigs
        self.onDemandOptions = onDemandOptions
        self.replaceUnhealthyInstances = replaceUnhealthyInstances
        self.spotOptions = spotOptions
        self.tagSpecifications = tagSpecifications
        self.targetCapacitySpecification = targetCapacitySpecification
        self.terminateInstancesWithExpiration = terminateInstancesWithExpiration
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case context = "Context"
        case dryRun = "DryRun"
        case excessCapacityTerminationPolicy = "ExcessCapacityTerminationPolicy"
        case launchTemplateConfigs = "LaunchTemplateConfigs"
        case onDemandOptions = "OnDemandOptions"
        case replaceUnhealthyInstances = "ReplaceUnhealthyInstances"
        case spotOptions = "SpotOptions"
        case tagSpecifications = "TagSpecification"
        case targetCapacitySpecification = "TargetCapacitySpecification"
        case terminateInstancesWithExpiration = "TerminateInstancesWithExpiration"
        case type = "Type"
        case validFrom = "ValidFrom"
        case validUntil = "ValidUntil"
    }

    public func validate() throws {
        try launchTemplateConfigs.validateAsFleetLaunchTemplateConfigListRequest()
        try onDemandOptions?.validate()
        try spotOptions?.validate()
        try targetCapacitySpecification.validate()
    }
}

public struct CreateFleetResult: Codable, Equatable {
    public var errors: CreateFleetErrorsSet?
    public var fleetId: FleetId?
    public var instances: CreateFleetInstancesSet?

    public init(errors: CreateFleetErrorsSet? = nil,
                fleetId: FleetId? = nil,
                instances: CreateFleetInstancesSet? = nil) {
        self.errors = errors
        self.fleetId = fleetId
        self.instances = instances
    }

    enum CodingKeys: String, CodingKey {
        case errors = "errorSet"
        case fleetId
        case instances = "fleetInstanceSet"
    }

    public func validate() throws {
    }
}

public struct CreateFlowLogsRequest: Codable, Equatable {
    public var clientToken: String?
    public var deliverCrossAccountRole: String?
    public var deliverLogsPermissionArn: String?
    public var destinationOptions: DestinationOptionsRequest?
    public var dryRun: Boolean?
    public var logDestination: String?
    public var logDestinationType: LogDestinationType?
    public var logFormat: String?
    public var logGroupName: String?
    public var maxAggregationInterval: Integer?
    public var resourceIds: FlowLogResourceIds
    public var resourceType: FlowLogsResourceType
    public var tagSpecifications: TagSpecificationList?
    public var trafficType: TrafficType?

    public init(clientToken: String? = nil,
                deliverCrossAccountRole: String? = nil,
                deliverLogsPermissionArn: String? = nil,
                destinationOptions: DestinationOptionsRequest? = nil,
                dryRun: Boolean? = nil,
                logDestination: String? = nil,
                logDestinationType: LogDestinationType? = nil,
                logFormat: String? = nil,
                logGroupName: String? = nil,
                maxAggregationInterval: Integer? = nil,
                resourceIds: FlowLogResourceIds,
                resourceType: FlowLogsResourceType,
                tagSpecifications: TagSpecificationList? = nil,
                trafficType: TrafficType? = nil) {
        self.clientToken = clientToken
        self.deliverCrossAccountRole = deliverCrossAccountRole
        self.deliverLogsPermissionArn = deliverLogsPermissionArn
        self.destinationOptions = destinationOptions
        self.dryRun = dryRun
        self.logDestination = logDestination
        self.logDestinationType = logDestinationType
        self.logFormat = logFormat
        self.logGroupName = logGroupName
        self.maxAggregationInterval = maxAggregationInterval
        self.resourceIds = resourceIds
        self.resourceType = resourceType
        self.tagSpecifications = tagSpecifications
        self.trafficType = trafficType
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case deliverCrossAccountRole = "DeliverCrossAccountRole"
        case deliverLogsPermissionArn = "DeliverLogsPermissionArn"
        case destinationOptions = "DestinationOptions"
        case dryRun = "DryRun"
        case logDestination = "LogDestination"
        case logDestinationType = "LogDestinationType"
        case logFormat = "LogFormat"
        case logGroupName = "LogGroupName"
        case maxAggregationInterval = "MaxAggregationInterval"
        case resourceIds = "ResourceId"
        case resourceType = "ResourceType"
        case tagSpecifications = "TagSpecification"
        case trafficType = "TrafficType"
    }

    public func validate() throws {
        try destinationOptions?.validate()
    }
}

public struct CreateFlowLogsResult: Codable, Equatable {
    public var clientToken: String?
    public var flowLogIds: ValueStringList?
    public var unsuccessful: UnsuccessfulItemSet?

    public init(clientToken: String? = nil,
                flowLogIds: ValueStringList? = nil,
                unsuccessful: UnsuccessfulItemSet? = nil) {
        self.clientToken = clientToken
        self.flowLogIds = flowLogIds
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case flowLogIds = "flowLogIdSet"
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct CreateFpgaImageRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var inputStorageLocation: StorageLocation
    public var logsStorageLocation: StorageLocation?
    public var name: String?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                inputStorageLocation: StorageLocation,
                logsStorageLocation: StorageLocation? = nil,
                name: String? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.inputStorageLocation = inputStorageLocation
        self.logsStorageLocation = logsStorageLocation
        self.name = name
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case inputStorageLocation = "InputStorageLocation"
        case logsStorageLocation = "LogsStorageLocation"
        case name = "Name"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try inputStorageLocation.validate()
        try logsStorageLocation?.validate()
    }
}

public struct CreateFpgaImageResult: Codable, Equatable {
    public var fpgaImageGlobalId: String?
    public var fpgaImageId: String?

    public init(fpgaImageGlobalId: String? = nil,
                fpgaImageId: String? = nil) {
        self.fpgaImageGlobalId = fpgaImageGlobalId
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImageGlobalId
        case fpgaImageId
    }

    public func validate() throws {
    }
}

public struct CreateImageRequest: Codable, Equatable {
    public var blockDeviceMappings: BlockDeviceMappingRequestList?
    public var description: String?
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var name: String
    public var noReboot: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(blockDeviceMappings: BlockDeviceMappingRequestList? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                instanceId: InstanceId,
                name: String,
                noReboot: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.description = description
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.name = name
        self.noReboot = noReboot
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "blockDeviceMapping"
        case description
        case dryRun
        case instanceId
        case name
        case noReboot
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateImageResult: Codable, Equatable {
    public var imageId: String?

    public init(imageId: String? = nil) {
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case imageId
    }

    public func validate() throws {
    }
}

public struct CreateInstanceEventWindowRequest: Codable, Equatable {
    public var cronExpression: InstanceEventWindowCronExpression?
    public var dryRun: Boolean?
    public var name: String?
    public var tagSpecifications: TagSpecificationList?
    public var timeRanges: InstanceEventWindowTimeRangeRequestSet?

    public init(cronExpression: InstanceEventWindowCronExpression? = nil,
                dryRun: Boolean? = nil,
                name: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                timeRanges: InstanceEventWindowTimeRangeRequestSet? = nil) {
        self.cronExpression = cronExpression
        self.dryRun = dryRun
        self.name = name
        self.tagSpecifications = tagSpecifications
        self.timeRanges = timeRanges
    }

    enum CodingKeys: String, CodingKey {
        case cronExpression = "CronExpression"
        case dryRun = "DryRun"
        case name = "Name"
        case tagSpecifications = "TagSpecification"
        case timeRanges = "TimeRange"
    }

    public func validate() throws {
    }
}

public struct CreateInstanceEventWindowResult: Codable, Equatable {
    public var instanceEventWindow: InstanceEventWindow?

    public init(instanceEventWindow: InstanceEventWindow? = nil) {
        self.instanceEventWindow = instanceEventWindow
    }

    enum CodingKeys: String, CodingKey {
        case instanceEventWindow
    }

    public func validate() throws {
        try instanceEventWindow?.validate()
    }
}

public struct CreateInstanceExportTaskRequest: Codable, Equatable {
    public var description: String?
    public var exportToS3Task: ExportToS3TaskSpecification
    public var instanceId: InstanceId
    public var tagSpecifications: TagSpecificationList?
    public var targetEnvironment: ExportEnvironment

    public init(description: String? = nil,
                exportToS3Task: ExportToS3TaskSpecification,
                instanceId: InstanceId,
                tagSpecifications: TagSpecificationList? = nil,
                targetEnvironment: ExportEnvironment) {
        self.description = description
        self.exportToS3Task = exportToS3Task
        self.instanceId = instanceId
        self.tagSpecifications = tagSpecifications
        self.targetEnvironment = targetEnvironment
    }

    enum CodingKeys: String, CodingKey {
        case description
        case exportToS3Task = "exportToS3"
        case instanceId
        case tagSpecifications = "TagSpecification"
        case targetEnvironment
    }

    public func validate() throws {
        try exportToS3Task.validate()
    }
}

public struct CreateInstanceExportTaskResult: Codable, Equatable {
    public var exportTask: ExportTask?

    public init(exportTask: ExportTask? = nil) {
        self.exportTask = exportTask
    }

    enum CodingKeys: String, CodingKey {
        case exportTask
    }

    public func validate() throws {
        try exportTask?.validate()
    }
}

public struct CreateInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateInternetGatewayResult: Codable, Equatable {
    public var internetGateway: InternetGateway?

    public init(internetGateway: InternetGateway? = nil) {
        self.internetGateway = internetGateway
    }

    enum CodingKeys: String, CodingKey {
        case internetGateway
    }

    public func validate() throws {
        try internetGateway?.validate()
    }
}

public struct CreateIpamPoolRequest: Codable, Equatable {
    public var addressFamily: AddressFamily
    public var allocationDefaultNetmaskLength: IpamNetmaskLength?
    public var allocationMaxNetmaskLength: IpamNetmaskLength?
    public var allocationMinNetmaskLength: IpamNetmaskLength?
    public var allocationResourceTags: RequestIpamResourceTagList?
    public var autoImport: Boolean?
    public var awsService: IpamPoolAwsService?
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var ipamScopeId: IpamScopeId
    public var locale: String?
    public var publiclyAdvertisable: Boolean?
    public var sourceIpamPoolId: IpamPoolId?
    public var tagSpecifications: TagSpecificationList?

    public init(addressFamily: AddressFamily,
                allocationDefaultNetmaskLength: IpamNetmaskLength? = nil,
                allocationMaxNetmaskLength: IpamNetmaskLength? = nil,
                allocationMinNetmaskLength: IpamNetmaskLength? = nil,
                allocationResourceTags: RequestIpamResourceTagList? = nil,
                autoImport: Boolean? = nil,
                awsService: IpamPoolAwsService? = nil,
                clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                ipamScopeId: IpamScopeId,
                locale: String? = nil,
                publiclyAdvertisable: Boolean? = nil,
                sourceIpamPoolId: IpamPoolId? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.addressFamily = addressFamily
        self.allocationDefaultNetmaskLength = allocationDefaultNetmaskLength
        self.allocationMaxNetmaskLength = allocationMaxNetmaskLength
        self.allocationMinNetmaskLength = allocationMinNetmaskLength
        self.allocationResourceTags = allocationResourceTags
        self.autoImport = autoImport
        self.awsService = awsService
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.ipamScopeId = ipamScopeId
        self.locale = locale
        self.publiclyAdvertisable = publiclyAdvertisable
        self.sourceIpamPoolId = sourceIpamPoolId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case addressFamily = "AddressFamily"
        case allocationDefaultNetmaskLength = "AllocationDefaultNetmaskLength"
        case allocationMaxNetmaskLength = "AllocationMaxNetmaskLength"
        case allocationMinNetmaskLength = "AllocationMinNetmaskLength"
        case allocationResourceTags = "AllocationResourceTag"
        case autoImport = "AutoImport"
        case awsService = "AwsService"
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case ipamScopeId = "IpamScopeId"
        case locale = "Locale"
        case publiclyAdvertisable = "PubliclyAdvertisable"
        case sourceIpamPoolId = "SourceIpamPoolId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try allocationDefaultNetmaskLength?.validateAsIpamNetmaskLength()
        try allocationMaxNetmaskLength?.validateAsIpamNetmaskLength()
        try allocationMinNetmaskLength?.validateAsIpamNetmaskLength()
    }
}

public struct CreateIpamPoolResult: Codable, Equatable {
    public var ipamPool: IpamPool?

    public init(ipamPool: IpamPool? = nil) {
        self.ipamPool = ipamPool
    }

    enum CodingKeys: String, CodingKey {
        case ipamPool
    }

    public func validate() throws {
        try ipamPool?.validate()
    }
}

public struct CreateIpamRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var operatingRegions: AddIpamOperatingRegionSet?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                operatingRegions: AddIpamOperatingRegionSet? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.operatingRegions = operatingRegions
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case operatingRegions = "OperatingRegion"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try operatingRegions?.validateAsAddIpamOperatingRegionSet()
    }
}

public struct CreateIpamResult: Codable, Equatable {
    public var ipam: Ipam?

    public init(ipam: Ipam? = nil) {
        self.ipam = ipam
    }

    enum CodingKeys: String, CodingKey {
        case ipam
    }

    public func validate() throws {
        try ipam?.validate()
    }
}

public struct CreateIpamScopeRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var ipamId: IpamId
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                ipamId: IpamId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.ipamId = ipamId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case ipamId = "IpamId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateIpamScopeResult: Codable, Equatable {
    public var ipamScope: IpamScope?

    public init(ipamScope: IpamScope? = nil) {
        self.ipamScope = ipamScope
    }

    enum CodingKeys: String, CodingKey {
        case ipamScope
    }

    public func validate() throws {
        try ipamScope?.validate()
    }
}

public struct CreateKeyPairRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var keyFormat: KeyFormat?
    public var keyName: String
    public var keyType: KeyType?
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                keyFormat: KeyFormat? = nil,
                keyName: String,
                keyType: KeyType? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.keyFormat = keyFormat
        self.keyName = keyName
        self.keyType = keyType
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case keyFormat = "KeyFormat"
        case keyName = "KeyName"
        case keyType = "KeyType"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateLaunchTemplateRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var launchTemplateData: RequestLaunchTemplateData
    public var launchTemplateName: LaunchTemplateName
    public var tagSpecifications: TagSpecificationList?
    public var versionDescription: VersionDescription?

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                launchTemplateData: RequestLaunchTemplateData,
                launchTemplateName: LaunchTemplateName,
                tagSpecifications: TagSpecificationList? = nil,
                versionDescription: VersionDescription? = nil) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.launchTemplateData = launchTemplateData
        self.launchTemplateName = launchTemplateName
        self.tagSpecifications = tagSpecifications
        self.versionDescription = versionDescription
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case launchTemplateData = "LaunchTemplateData"
        case launchTemplateName = "LaunchTemplateName"
        case tagSpecifications = "TagSpecification"
        case versionDescription = "VersionDescription"
    }

    public func validate() throws {
        try launchTemplateData.validate()
        try launchTemplateName.validateAsLaunchTemplateName()
        try versionDescription?.validateAsVersionDescription()
    }
}

public struct CreateLaunchTemplateResult: Codable, Equatable {
    public var launchTemplate: LaunchTemplate?
    public var warning: ValidationWarning?

    public init(launchTemplate: LaunchTemplate? = nil,
                warning: ValidationWarning? = nil) {
        self.launchTemplate = launchTemplate
        self.warning = warning
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplate
        case warning
    }

    public func validate() throws {
        try launchTemplate?.validate()
        try warning?.validate()
    }
}

public struct CreateLaunchTemplateVersionRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var launchTemplateData: RequestLaunchTemplateData
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?
    public var sourceVersion: String?
    public var versionDescription: VersionDescription?

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                launchTemplateData: RequestLaunchTemplateData,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                sourceVersion: String? = nil,
                versionDescription: VersionDescription? = nil) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.launchTemplateData = launchTemplateData
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.sourceVersion = sourceVersion
        self.versionDescription = versionDescription
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case launchTemplateData = "LaunchTemplateData"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case sourceVersion = "SourceVersion"
        case versionDescription = "VersionDescription"
    }

    public func validate() throws {
        try launchTemplateData.validate()
        try launchTemplateName?.validateAsLaunchTemplateName()
        try versionDescription?.validateAsVersionDescription()
    }
}

public struct CreateLaunchTemplateVersionResult: Codable, Equatable {
    public var launchTemplateVersion: LaunchTemplateVersion?
    public var warning: ValidationWarning?

    public init(launchTemplateVersion: LaunchTemplateVersion? = nil,
                warning: ValidationWarning? = nil) {
        self.launchTemplateVersion = launchTemplateVersion
        self.warning = warning
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateVersion
        case warning
    }

    public func validate() throws {
        try launchTemplateVersion?.validate()
        try warning?.validate()
    }
}

public struct CreateLocalGatewayRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId?
    public var networkInterfaceId: NetworkInterfaceId?

    public init(destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil) {
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
        case localGatewayVirtualInterfaceGroupId = "LocalGatewayVirtualInterfaceGroupId"
        case networkInterfaceId = "NetworkInterfaceId"
    }

    public func validate() throws {
    }
}

public struct CreateLocalGatewayRouteResult: Codable, Equatable {
    public var route: LocalGatewayRoute?

    public init(route: LocalGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct CreateLocalGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localGatewayId: LocalGatewayId
    public var mode: LocalGatewayRouteTableMode?
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                localGatewayId: LocalGatewayId,
                mode: LocalGatewayRouteTableMode? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.localGatewayId = localGatewayId
        self.mode = mode
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localGatewayId = "LocalGatewayId"
        case mode = "Mode"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateLocalGatewayRouteTableResult: Codable, Equatable {
    public var localGatewayRouteTable: LocalGatewayRouteTable?

    public init(localGatewayRouteTable: LocalGatewayRouteTable? = nil) {
        self.localGatewayRouteTable = localGatewayRouteTable
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTable
    }

    public func validate() throws {
        try localGatewayRouteTable?.validate()
    }
}

public struct CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
        case localGatewayVirtualInterfaceGroupId = "LocalGatewayVirtualInterfaceGroupId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult: Codable, Equatable {
    public var localGatewayRouteTableVirtualInterfaceGroupAssociation: LocalGatewayRouteTableVirtualInterfaceGroupAssociation?

    public init(localGatewayRouteTableVirtualInterfaceGroupAssociation: LocalGatewayRouteTableVirtualInterfaceGroupAssociation? = nil) {
        self.localGatewayRouteTableVirtualInterfaceGroupAssociation = localGatewayRouteTableVirtualInterfaceGroupAssociation
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVirtualInterfaceGroupAssociation
    }

    public func validate() throws {
        try localGatewayRouteTableVirtualInterfaceGroupAssociation?.validate()
    }
}

public struct CreateLocalGatewayRouteTableVpcAssociationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateLocalGatewayRouteTableVpcAssociationResult: Codable, Equatable {
    public var localGatewayRouteTableVpcAssociation: LocalGatewayRouteTableVpcAssociation?

    public init(localGatewayRouteTableVpcAssociation: LocalGatewayRouteTableVpcAssociation? = nil) {
        self.localGatewayRouteTableVpcAssociation = localGatewayRouteTableVpcAssociation
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVpcAssociation
    }

    public func validate() throws {
        try localGatewayRouteTableVpcAssociation?.validate()
    }
}

public struct CreateManagedPrefixListRequest: Codable, Equatable {
    public var addressFamily: String
    public var clientToken: String?
    public var dryRun: Boolean?
    public var entries: AddPrefixListEntries?
    public var maxEntries: Integer
    public var prefixListName: String
    public var tagSpecifications: TagSpecificationList?

    public init(addressFamily: String,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                entries: AddPrefixListEntries? = nil,
                maxEntries: Integer,
                prefixListName: String,
                tagSpecifications: TagSpecificationList? = nil) {
        self.addressFamily = addressFamily
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.entries = entries
        self.maxEntries = maxEntries
        self.prefixListName = prefixListName
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case addressFamily = "AddressFamily"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case entries = "Entry"
        case maxEntries = "MaxEntries"
        case prefixListName = "PrefixListName"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try entries?.validateAsAddPrefixListEntries()
    }
}

public struct CreateManagedPrefixListResult: Codable, Equatable {
    public var prefixList: ManagedPrefixList?

    public init(prefixList: ManagedPrefixList? = nil) {
        self.prefixList = prefixList
    }

    enum CodingKeys: String, CodingKey {
        case prefixList
    }

    public func validate() throws {
        try prefixList?.validate()
    }
}

public struct CreateNatGatewayRequest: Codable, Equatable {
    public var allocationId: AllocationId?
    public var clientToken: String?
    public var connectivityType: ConnectivityType?
    public var dryRun: Boolean?
    public var privateIpAddress: String?
    public var subnetId: SubnetId
    public var tagSpecifications: TagSpecificationList?

    public init(allocationId: AllocationId? = nil,
                clientToken: String? = nil,
                connectivityType: ConnectivityType? = nil,
                dryRun: Boolean? = nil,
                privateIpAddress: String? = nil,
                subnetId: SubnetId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.allocationId = allocationId
        self.clientToken = clientToken
        self.connectivityType = connectivityType
        self.dryRun = dryRun
        self.privateIpAddress = privateIpAddress
        self.subnetId = subnetId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case clientToken = "ClientToken"
        case connectivityType = "ConnectivityType"
        case dryRun = "DryRun"
        case privateIpAddress = "PrivateIpAddress"
        case subnetId = "SubnetId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateNatGatewayResult: Codable, Equatable {
    public var clientToken: String?
    public var natGateway: NatGateway?

    public init(clientToken: String? = nil,
                natGateway: NatGateway? = nil) {
        self.clientToken = clientToken
        self.natGateway = natGateway
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case natGateway
    }

    public func validate() throws {
        try natGateway?.validate()
    }
}

public struct CreateNetworkAclEntryRequest: Codable, Equatable {
    public var cidrBlock: String?
    public var dryRun: Boolean?
    public var egress: Boolean
    public var icmpTypeCode: IcmpTypeCode?
    public var ipv6CidrBlock: String?
    public var networkAclId: NetworkAclId
    public var portRange: PortRange?
    public var `protocol`: String
    public var ruleAction: RuleAction
    public var ruleNumber: Integer

    public init(cidrBlock: String? = nil,
                dryRun: Boolean? = nil,
                egress: Boolean,
                icmpTypeCode: IcmpTypeCode? = nil,
                ipv6CidrBlock: String? = nil,
                networkAclId: NetworkAclId,
                portRange: PortRange? = nil,
                `protocol`: String,
                ruleAction: RuleAction,
                ruleNumber: Integer) {
        self.cidrBlock = cidrBlock
        self.dryRun = dryRun
        self.egress = egress
        self.icmpTypeCode = icmpTypeCode
        self.ipv6CidrBlock = ipv6CidrBlock
        self.networkAclId = networkAclId
        self.portRange = portRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case dryRun
        case egress
        case icmpTypeCode = "Icmp"
        case ipv6CidrBlock
        case networkAclId
        case portRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
    }

    public func validate() throws {
        try icmpTypeCode?.validate()
        try portRange?.validate()
    }
}

public struct CreateNetworkAclRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case tagSpecifications = "TagSpecification"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct CreateNetworkAclResult: Codable, Equatable {
    public var networkAcl: NetworkAcl?

    public init(networkAcl: NetworkAcl? = nil) {
        self.networkAcl = networkAcl
    }

    enum CodingKeys: String, CodingKey {
        case networkAcl
    }

    public func validate() throws {
        try networkAcl?.validate()
    }
}

public struct CreateNetworkInsightsAccessScopeRequest: Codable, Equatable {
    public var clientToken: String
    public var dryRun: Boolean?
    public var excludePaths: AccessScopePathListRequest?
    public var matchPaths: AccessScopePathListRequest?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String,
                dryRun: Boolean? = nil,
                excludePaths: AccessScopePathListRequest? = nil,
                matchPaths: AccessScopePathListRequest? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.excludePaths = excludePaths
        self.matchPaths = matchPaths
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case excludePaths = "ExcludePath"
        case matchPaths = "MatchPath"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateNetworkInsightsAccessScopeResult: Codable, Equatable {
    public var networkInsightsAccessScope: NetworkInsightsAccessScope?
    public var networkInsightsAccessScopeContent: NetworkInsightsAccessScopeContent?

    public init(networkInsightsAccessScope: NetworkInsightsAccessScope? = nil,
                networkInsightsAccessScopeContent: NetworkInsightsAccessScopeContent? = nil) {
        self.networkInsightsAccessScope = networkInsightsAccessScope
        self.networkInsightsAccessScopeContent = networkInsightsAccessScopeContent
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAccessScope
        case networkInsightsAccessScopeContent
    }

    public func validate() throws {
        try networkInsightsAccessScope?.validate()
        try networkInsightsAccessScopeContent?.validate()
    }
}

public struct CreateNetworkInsightsPathRequest: Codable, Equatable {
    public var clientToken: String
    public var destination: NetworkInsightsResourceId
    public var destinationIp: IpAddress?
    public var destinationPort: Port?
    public var dryRun: Boolean?
    public var `protocol`: Protocol
    public var source: NetworkInsightsResourceId
    public var sourceIp: IpAddress?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String,
                destination: NetworkInsightsResourceId,
                destinationIp: IpAddress? = nil,
                destinationPort: Port? = nil,
                dryRun: Boolean? = nil,
                `protocol`: Protocol,
                source: NetworkInsightsResourceId,
                sourceIp: IpAddress? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.destination = destination
        self.destinationIp = destinationIp
        self.destinationPort = destinationPort
        self.dryRun = dryRun
        self.`protocol` = `protocol`
        self.source = source
        self.sourceIp = sourceIp
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case destination = "Destination"
        case destinationIp = "DestinationIp"
        case destinationPort = "DestinationPort"
        case dryRun = "DryRun"
        case `protocol` = "Protocol"
        case source = "Source"
        case sourceIp = "SourceIp"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try destinationIp?.validateAsIpAddress()
        try destinationPort?.validateAsPort()
        try sourceIp?.validateAsIpAddress()
    }
}

public struct CreateNetworkInsightsPathResult: Codable, Equatable {
    public var networkInsightsPath: NetworkInsightsPath?

    public init(networkInsightsPath: NetworkInsightsPath? = nil) {
        self.networkInsightsPath = networkInsightsPath
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsPath
    }

    public func validate() throws {
        try networkInsightsPath?.validate()
    }
}

public struct CreateNetworkInterfacePermissionRequest: Codable, Equatable {
    public var awsAccountId: String?
    public var awsService: String?
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId
    public var permission: InterfacePermissionType

    public init(awsAccountId: String? = nil,
                awsService: String? = nil,
                dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId,
                permission: InterfacePermissionType) {
        self.awsAccountId = awsAccountId
        self.awsService = awsService
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
        self.permission = permission
    }

    enum CodingKeys: String, CodingKey {
        case awsAccountId = "AwsAccountId"
        case awsService = "AwsService"
        case dryRun = "DryRun"
        case networkInterfaceId = "NetworkInterfaceId"
        case permission = "Permission"
    }

    public func validate() throws {
    }
}

public struct CreateNetworkInterfacePermissionResult: Codable, Equatable {
    public var interfacePermission: NetworkInterfacePermission?

    public init(interfacePermission: NetworkInterfacePermission? = nil) {
        self.interfacePermission = interfacePermission
    }

    enum CodingKeys: String, CodingKey {
        case interfacePermission
    }

    public func validate() throws {
        try interfacePermission?.validate()
    }
}

public struct CreateNetworkInterfaceRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var groups: SecurityGroupIdStringList?
    public var interfaceType: NetworkInterfaceCreationType?
    public var ipv4PrefixCount: Integer?
    public var ipv4Prefixes: Ipv4PrefixList?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var ipv6PrefixCount: Integer?
    public var ipv6Prefixes: Ipv6PrefixList?
    public var privateIpAddress: String?
    public var privateIpAddresses: PrivateIpAddressSpecificationList?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: SubnetId
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                groups: SecurityGroupIdStringList? = nil,
                interfaceType: NetworkInterfaceCreationType? = nil,
                ipv4PrefixCount: Integer? = nil,
                ipv4Prefixes: Ipv4PrefixList? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                ipv6PrefixCount: Integer? = nil,
                ipv6Prefixes: Ipv6PrefixList? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: PrivateIpAddressSpecificationList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: SubnetId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv4PrefixCount = ipv4PrefixCount
        self.ipv4Prefixes = ipv4Prefixes
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.ipv6PrefixCount = ipv6PrefixCount
        self.ipv6Prefixes = ipv6Prefixes
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description
        case dryRun
        case groups = "SecurityGroupId"
        case interfaceType = "InterfaceType"
        case ipv4PrefixCount = "Ipv4PrefixCount"
        case ipv4Prefixes = "Ipv4Prefix"
        case ipv6AddressCount
        case ipv6Addresses
        case ipv6PrefixCount = "Ipv6PrefixCount"
        case ipv6Prefixes = "Ipv6Prefix"
        case privateIpAddress
        case privateIpAddresses
        case secondaryPrivateIpAddressCount
        case subnetId
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateNetworkInterfaceResult: Codable, Equatable {
    public var clientToken: String?
    public var networkInterface: NetworkInterface?

    public init(clientToken: String? = nil,
                networkInterface: NetworkInterface? = nil) {
        self.clientToken = clientToken
        self.networkInterface = networkInterface
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case networkInterface
    }

    public func validate() throws {
        try networkInterface?.validate()
    }
}

public struct CreatePlacementGroupRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupName: String?
    public var partitionCount: Integer?
    public var spreadLevel: SpreadLevel?
    public var strategy: PlacementStrategy?
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                groupName: String? = nil,
                partitionCount: Integer? = nil,
                spreadLevel: SpreadLevel? = nil,
                strategy: PlacementStrategy? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.groupName = groupName
        self.partitionCount = partitionCount
        self.spreadLevel = spreadLevel
        self.strategy = strategy
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case groupName
        case partitionCount = "PartitionCount"
        case spreadLevel = "SpreadLevel"
        case strategy
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreatePlacementGroupResult: Codable, Equatable {
    public var placementGroup: PlacementGroup?

    public init(placementGroup: PlacementGroup? = nil) {
        self.placementGroup = placementGroup
    }

    enum CodingKeys: String, CodingKey {
        case placementGroup
    }

    public func validate() throws {
        try placementGroup?.validate()
    }
}

public struct CreatePublicIpv4PoolRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreatePublicIpv4PoolResult: Codable, Equatable {
    public var poolId: Ipv4PoolEc2Id?

    public init(poolId: Ipv4PoolEc2Id? = nil) {
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case poolId
    }

    public func validate() throws {
    }
}

public struct CreateReplaceRootVolumeTaskRequest: Codable, Equatable {
    public var clientToken: String?
    public var deleteReplacedRootVolume: Boolean?
    public var dryRun: Boolean?
    public var imageId: ImageId?
    public var instanceId: InstanceId
    public var snapshotId: SnapshotId?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                deleteReplacedRootVolume: Boolean? = nil,
                dryRun: Boolean? = nil,
                imageId: ImageId? = nil,
                instanceId: InstanceId,
                snapshotId: SnapshotId? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.deleteReplacedRootVolume = deleteReplacedRootVolume
        self.dryRun = dryRun
        self.imageId = imageId
        self.instanceId = instanceId
        self.snapshotId = snapshotId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case deleteReplacedRootVolume = "DeleteReplacedRootVolume"
        case dryRun = "DryRun"
        case imageId = "ImageId"
        case instanceId = "InstanceId"
        case snapshotId = "SnapshotId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateReplaceRootVolumeTaskResult: Codable, Equatable {
    public var replaceRootVolumeTask: ReplaceRootVolumeTask?

    public init(replaceRootVolumeTask: ReplaceRootVolumeTask? = nil) {
        self.replaceRootVolumeTask = replaceRootVolumeTask
    }

    enum CodingKeys: String, CodingKey {
        case replaceRootVolumeTask
    }

    public func validate() throws {
        try replaceRootVolumeTask?.validate()
    }
}

public struct CreateReservedInstancesListingRequest: Codable, Equatable {
    public var clientToken: String
    public var instanceCount: Integer
    public var priceSchedules: PriceScheduleSpecificationList
    public var reservedInstancesId: ReservationId

    public init(clientToken: String,
                instanceCount: Integer,
                priceSchedules: PriceScheduleSpecificationList,
                reservedInstancesId: ReservationId) {
        self.clientToken = clientToken
        self.instanceCount = instanceCount
        self.priceSchedules = priceSchedules
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case instanceCount
        case priceSchedules
        case reservedInstancesId
    }

    public func validate() throws {
    }
}

public struct CreateReservedInstancesListingResult: Codable, Equatable {
    public var reservedInstancesListings: ReservedInstancesListingList?

    public init(reservedInstancesListings: ReservedInstancesListingList? = nil) {
        self.reservedInstancesListings = reservedInstancesListings
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesListings = "reservedInstancesListingsSet"
    }

    public func validate() throws {
    }
}

public struct CreateRestoreImageTaskRequest: Codable, Equatable {
    public var bucket: String
    public var dryRun: Boolean?
    public var name: String?
    public var objectKey: String
    public var tagSpecifications: TagSpecificationList?

    public init(bucket: String,
                dryRun: Boolean? = nil,
                name: String? = nil,
                objectKey: String,
                tagSpecifications: TagSpecificationList? = nil) {
        self.bucket = bucket
        self.dryRun = dryRun
        self.name = name
        self.objectKey = objectKey
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case dryRun = "DryRun"
        case name = "Name"
        case objectKey = "ObjectKey"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateRestoreImageTaskResult: Codable, Equatable {
    public var imageId: String?

    public init(imageId: String? = nil) {
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case imageId
    }

    public func validate() throws {
    }
}

public struct CreateRouteRequest: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId?
    public var coreNetworkArn: CoreNetworkArn?
    public var destinationCidrBlock: String?
    public var destinationIpv6CidrBlock: String?
    public var destinationPrefixListId: PrefixListResourceId?
    public var dryRun: Boolean?
    public var egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId?
    public var gatewayId: RouteGatewayId?
    public var instanceId: InstanceId?
    public var localGatewayId: LocalGatewayId?
    public var natGatewayId: NatGatewayId?
    public var networkInterfaceId: NetworkInterfaceId?
    public var routeTableId: RouteTableId
    public var transitGatewayId: TransitGatewayId?
    public var vpcEndpointId: VpcEndpointId?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId?

    public init(carrierGatewayId: CarrierGatewayId? = nil,
                coreNetworkArn: CoreNetworkArn? = nil,
                destinationCidrBlock: String? = nil,
                destinationIpv6CidrBlock: String? = nil,
                destinationPrefixListId: PrefixListResourceId? = nil,
                dryRun: Boolean? = nil,
                egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId? = nil,
                gatewayId: RouteGatewayId? = nil,
                instanceId: InstanceId? = nil,
                localGatewayId: LocalGatewayId? = nil,
                natGatewayId: NatGatewayId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                routeTableId: RouteTableId,
                transitGatewayId: TransitGatewayId? = nil,
                vpcEndpointId: VpcEndpointId? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.coreNetworkArn = coreNetworkArn
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        self.destinationPrefixListId = destinationPrefixListId
        self.dryRun = dryRun
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.gatewayId = gatewayId
        self.instanceId = instanceId
        self.localGatewayId = localGatewayId
        self.natGatewayId = natGatewayId
        self.networkInterfaceId = networkInterfaceId
        self.routeTableId = routeTableId
        self.transitGatewayId = transitGatewayId
        self.vpcEndpointId = vpcEndpointId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId = "CarrierGatewayId"
        case coreNetworkArn = "CoreNetworkArn"
        case destinationCidrBlock
        case destinationIpv6CidrBlock
        case destinationPrefixListId = "DestinationPrefixListId"
        case dryRun
        case egressOnlyInternetGatewayId
        case gatewayId
        case instanceId
        case localGatewayId = "LocalGatewayId"
        case natGatewayId
        case networkInterfaceId
        case routeTableId
        case transitGatewayId = "TransitGatewayId"
        case vpcEndpointId = "VpcEndpointId"
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct CreateRouteResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct CreateRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case tagSpecifications = "TagSpecification"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct CreateRouteTableResult: Codable, Equatable {
    public var routeTable: RouteTable?

    public init(routeTable: RouteTable? = nil) {
        self.routeTable = routeTable
    }

    enum CodingKeys: String, CodingKey {
        case routeTable
    }

    public func validate() throws {
        try routeTable?.validate()
    }
}

public struct CreateSecurityGroupRequest: Codable, Equatable {
    public var description: String
    public var dryRun: Boolean?
    public var groupName: String
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId?

    public init(description: String,
                dryRun: Boolean? = nil,
                groupName: String,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId? = nil) {
        self.description = description
        self.dryRun = dryRun
        self.groupName = groupName
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case description = "GroupDescription"
        case dryRun
        case groupName = "GroupName"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateSecurityGroupResult: Codable, Equatable {
    public var groupId: String?
    public var tags: TagList?

    public init(groupId: String? = nil,
                tags: TagList? = nil) {
        self.groupId = groupId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct CreateSnapshotRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var outpostArn: String?
    public var tagSpecifications: TagSpecificationList?
    public var volumeId: VolumeId

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                outpostArn: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                volumeId: VolumeId) {
        self.description = description
        self.dryRun = dryRun
        self.outpostArn = outpostArn
        self.tagSpecifications = tagSpecifications
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun
        case outpostArn = "OutpostArn"
        case tagSpecifications = "TagSpecification"
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct CreateSnapshotsRequest: Codable, Equatable {
    public var copyTagsFromSource: CopyTagsFromSource?
    public var description: String?
    public var dryRun: Boolean?
    public var instanceSpecification: InstanceSpecification
    public var outpostArn: String?
    public var tagSpecifications: TagSpecificationList?

    public init(copyTagsFromSource: CopyTagsFromSource? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                instanceSpecification: InstanceSpecification,
                outpostArn: String? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.copyTagsFromSource = copyTagsFromSource
        self.description = description
        self.dryRun = dryRun
        self.instanceSpecification = instanceSpecification
        self.outpostArn = outpostArn
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case copyTagsFromSource = "CopyTagsFromSource"
        case description = "Description"
        case dryRun = "DryRun"
        case instanceSpecification = "InstanceSpecification"
        case outpostArn = "OutpostArn"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try instanceSpecification.validate()
    }
}

public struct CreateSnapshotsResult: Codable, Equatable {
    public var snapshots: SnapshotSet?

    public init(snapshots: SnapshotSet? = nil) {
        self.snapshots = snapshots
    }

    enum CodingKeys: String, CodingKey {
        case snapshots = "snapshotSet"
    }

    public func validate() throws {
    }
}

public struct CreateSpotDatafeedSubscriptionRequest: Codable, Equatable {
    public var bucket: String
    public var dryRun: Boolean?
    public var prefix: String?

    public init(bucket: String,
                dryRun: Boolean? = nil,
                prefix: String? = nil) {
        self.bucket = bucket
        self.dryRun = dryRun
        self.prefix = prefix
    }

    enum CodingKeys: String, CodingKey {
        case bucket
        case dryRun
        case prefix
    }

    public func validate() throws {
    }
}

public struct CreateSpotDatafeedSubscriptionResult: Codable, Equatable {
    public var spotDatafeedSubscription: SpotDatafeedSubscription?

    public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
        self.spotDatafeedSubscription = spotDatafeedSubscription
    }

    enum CodingKeys: String, CodingKey {
        case spotDatafeedSubscription
    }

    public func validate() throws {
        try spotDatafeedSubscription?.validate()
    }
}

public struct CreateStoreImageTaskRequest: Codable, Equatable {
    public var bucket: String
    public var dryRun: Boolean?
    public var imageId: ImageId
    public var s3ObjectTags: S3ObjectTagList?

    public init(bucket: String,
                dryRun: Boolean? = nil,
                imageId: ImageId,
                s3ObjectTags: S3ObjectTagList? = nil) {
        self.bucket = bucket
        self.dryRun = dryRun
        self.imageId = imageId
        self.s3ObjectTags = s3ObjectTags
    }

    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case dryRun = "DryRun"
        case imageId = "ImageId"
        case s3ObjectTags = "S3ObjectTag"
    }

    public func validate() throws {
    }
}

public struct CreateStoreImageTaskResult: Codable, Equatable {
    public var objectKey: String?

    public init(objectKey: String? = nil) {
        self.objectKey = objectKey
    }

    enum CodingKeys: String, CodingKey {
        case objectKey
    }

    public func validate() throws {
    }
}

public struct CreateSubnetCidrReservationRequest: Codable, Equatable {
    public var cidr: String
    public var description: String?
    public var dryRun: Boolean?
    public var reservationType: SubnetCidrReservationType
    public var subnetId: SubnetId
    public var tagSpecifications: TagSpecificationList?

    public init(cidr: String,
                description: String? = nil,
                dryRun: Boolean? = nil,
                reservationType: SubnetCidrReservationType,
                subnetId: SubnetId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.cidr = cidr
        self.description = description
        self.dryRun = dryRun
        self.reservationType = reservationType
        self.subnetId = subnetId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case description = "Description"
        case dryRun = "DryRun"
        case reservationType = "ReservationType"
        case subnetId = "SubnetId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateSubnetCidrReservationResult: Codable, Equatable {
    public var subnetCidrReservation: SubnetCidrReservation?

    public init(subnetCidrReservation: SubnetCidrReservation? = nil) {
        self.subnetCidrReservation = subnetCidrReservation
    }

    enum CodingKeys: String, CodingKey {
        case subnetCidrReservation
    }

    public func validate() throws {
        try subnetCidrReservation?.validate()
    }
}

public struct CreateSubnetRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var cidrBlock: String?
    public var dryRun: Boolean?
    public var ipv6CidrBlock: String?
    public var ipv6Native: Boolean?
    public var outpostArn: String?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId

    public init(availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                cidrBlock: String? = nil,
                dryRun: Boolean? = nil,
                ipv6CidrBlock: String? = nil,
                ipv6Native: Boolean? = nil,
                outpostArn: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.cidrBlock = cidrBlock
        self.dryRun = dryRun
        self.ipv6CidrBlock = ipv6CidrBlock
        self.ipv6Native = ipv6Native
        self.outpostArn = outpostArn
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case cidrBlock = "CidrBlock"
        case dryRun
        case ipv6CidrBlock = "Ipv6CidrBlock"
        case ipv6Native = "Ipv6Native"
        case outpostArn = "OutpostArn"
        case tagSpecifications = "TagSpecification"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct CreateSubnetResult: Codable, Equatable {
    public var subnet: Subnet?

    public init(subnet: Subnet? = nil) {
        self.subnet = subnet
    }

    enum CodingKeys: String, CodingKey {
        case subnet
    }

    public func validate() throws {
        try subnet?.validate()
    }
}

public struct CreateTagsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var resources: ResourceIdList
    public var tags: TagList

    public init(dryRun: Boolean? = nil,
                resources: ResourceIdList,
                tags: TagList) {
        self.dryRun = dryRun
        self.resources = resources
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case resources = "ResourceId"
        case tags = "Tag"
    }

    public func validate() throws {
    }
}

public struct CreateTrafficMirrorFilterRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateTrafficMirrorFilterResult: Codable, Equatable {
    public var clientToken: String?
    public var trafficMirrorFilter: TrafficMirrorFilter?

    public init(clientToken: String? = nil,
                trafficMirrorFilter: TrafficMirrorFilter? = nil) {
        self.clientToken = clientToken
        self.trafficMirrorFilter = trafficMirrorFilter
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case trafficMirrorFilter
    }

    public func validate() throws {
        try trafficMirrorFilter?.validate()
    }
}

public struct CreateTrafficMirrorFilterRuleRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var destinationCidrBlock: String
    public var destinationPortRange: TrafficMirrorPortRangeRequest?
    public var dryRun: Boolean?
    public var `protocol`: Integer?
    public var ruleAction: TrafficMirrorRuleAction
    public var ruleNumber: Integer
    public var sourceCidrBlock: String
    public var sourcePortRange: TrafficMirrorPortRangeRequest?
    public var trafficDirection: TrafficDirection
    public var trafficMirrorFilterId: TrafficMirrorFilterId

    public init(clientToken: String? = nil,
                description: String? = nil,
                destinationCidrBlock: String,
                destinationPortRange: TrafficMirrorPortRangeRequest? = nil,
                dryRun: Boolean? = nil,
                `protocol`: Integer? = nil,
                ruleAction: TrafficMirrorRuleAction,
                ruleNumber: Integer,
                sourceCidrBlock: String,
                sourcePortRange: TrafficMirrorPortRangeRequest? = nil,
                trafficDirection: TrafficDirection,
                trafficMirrorFilterId: TrafficMirrorFilterId) {
        self.clientToken = clientToken
        self.description = description
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationPortRange = destinationPortRange
        self.dryRun = dryRun
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
        self.sourceCidrBlock = sourceCidrBlock
        self.sourcePortRange = sourcePortRange
        self.trafficDirection = trafficDirection
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationPortRange = "DestinationPortRange"
        case dryRun = "DryRun"
        case `protocol` = "Protocol"
        case ruleAction = "RuleAction"
        case ruleNumber = "RuleNumber"
        case sourceCidrBlock = "SourceCidrBlock"
        case sourcePortRange = "SourcePortRange"
        case trafficDirection = "TrafficDirection"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
    }

    public func validate() throws {
        try destinationPortRange?.validate()
        try sourcePortRange?.validate()
    }
}

public struct CreateTrafficMirrorFilterRuleResult: Codable, Equatable {
    public var clientToken: String?
    public var trafficMirrorFilterRule: TrafficMirrorFilterRule?

    public init(clientToken: String? = nil,
                trafficMirrorFilterRule: TrafficMirrorFilterRule? = nil) {
        self.clientToken = clientToken
        self.trafficMirrorFilterRule = trafficMirrorFilterRule
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case trafficMirrorFilterRule
    }

    public func validate() throws {
        try trafficMirrorFilterRule?.validate()
    }
}

public struct CreateTrafficMirrorSessionRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId
    public var packetLength: Integer?
    public var sessionNumber: Integer
    public var tagSpecifications: TagSpecificationList?
    public var trafficMirrorFilterId: TrafficMirrorFilterId
    public var trafficMirrorTargetId: TrafficMirrorTargetId
    public var virtualNetworkId: Integer?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId,
                packetLength: Integer? = nil,
                sessionNumber: Integer,
                tagSpecifications: TagSpecificationList? = nil,
                trafficMirrorFilterId: TrafficMirrorFilterId,
                trafficMirrorTargetId: TrafficMirrorTargetId,
                virtualNetworkId: Integer? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
        self.packetLength = packetLength
        self.sessionNumber = sessionNumber
        self.tagSpecifications = tagSpecifications
        self.trafficMirrorFilterId = trafficMirrorFilterId
        self.trafficMirrorTargetId = trafficMirrorTargetId
        self.virtualNetworkId = virtualNetworkId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case networkInterfaceId = "NetworkInterfaceId"
        case packetLength = "PacketLength"
        case sessionNumber = "SessionNumber"
        case tagSpecifications = "TagSpecification"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
        case trafficMirrorTargetId = "TrafficMirrorTargetId"
        case virtualNetworkId = "VirtualNetworkId"
    }

    public func validate() throws {
    }
}

public struct CreateTrafficMirrorSessionResult: Codable, Equatable {
    public var clientToken: String?
    public var trafficMirrorSession: TrafficMirrorSession?

    public init(clientToken: String? = nil,
                trafficMirrorSession: TrafficMirrorSession? = nil) {
        self.clientToken = clientToken
        self.trafficMirrorSession = trafficMirrorSession
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case trafficMirrorSession
    }

    public func validate() throws {
        try trafficMirrorSession?.validate()
    }
}

public struct CreateTrafficMirrorTargetRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var gatewayLoadBalancerEndpointId: VpcEndpointId?
    public var networkInterfaceId: NetworkInterfaceId?
    public var networkLoadBalancerArn: String?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                gatewayLoadBalancerEndpointId: VpcEndpointId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                networkLoadBalancerArn: String? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.gatewayLoadBalancerEndpointId = gatewayLoadBalancerEndpointId
        self.networkInterfaceId = networkInterfaceId
        self.networkLoadBalancerArn = networkLoadBalancerArn
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case gatewayLoadBalancerEndpointId = "GatewayLoadBalancerEndpointId"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkLoadBalancerArn = "NetworkLoadBalancerArn"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateTrafficMirrorTargetResult: Codable, Equatable {
    public var clientToken: String?
    public var trafficMirrorTarget: TrafficMirrorTarget?

    public init(clientToken: String? = nil,
                trafficMirrorTarget: TrafficMirrorTarget? = nil) {
        self.clientToken = clientToken
        self.trafficMirrorTarget = trafficMirrorTarget
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case trafficMirrorTarget
    }

    public func validate() throws {
        try trafficMirrorTarget?.validate()
    }
}

public struct CreateTransitGatewayConnectPeerRequest: Codable, Equatable {
    public var bgpOptions: TransitGatewayConnectRequestBgpOptions?
    public var dryRun: Boolean?
    public var insideCidrBlocks: InsideCidrBlocksStringList
    public var peerAddress: String
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayAddress: String?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(bgpOptions: TransitGatewayConnectRequestBgpOptions? = nil,
                dryRun: Boolean? = nil,
                insideCidrBlocks: InsideCidrBlocksStringList,
                peerAddress: String,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayAddress: String? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.bgpOptions = bgpOptions
        self.dryRun = dryRun
        self.insideCidrBlocks = insideCidrBlocks
        self.peerAddress = peerAddress
        self.tagSpecifications = tagSpecifications
        self.transitGatewayAddress = transitGatewayAddress
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case bgpOptions = "BgpOptions"
        case dryRun = "DryRun"
        case insideCidrBlocks = "InsideCidrBlocks"
        case peerAddress = "PeerAddress"
        case tagSpecifications = "TagSpecification"
        case transitGatewayAddress = "TransitGatewayAddress"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
        try bgpOptions?.validate()
    }
}

public struct CreateTransitGatewayConnectPeerResult: Codable, Equatable {
    public var transitGatewayConnectPeer: TransitGatewayConnectPeer?

    public init(transitGatewayConnectPeer: TransitGatewayConnectPeer? = nil) {
        self.transitGatewayConnectPeer = transitGatewayConnectPeer
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayConnectPeer
    }

    public func validate() throws {
        try transitGatewayConnectPeer?.validate()
    }
}

public struct CreateTransitGatewayConnectRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var options: CreateTransitGatewayConnectRequestOptions
    public var tagSpecifications: TagSpecificationList?
    public var transportTransitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                options: CreateTransitGatewayConnectRequestOptions,
                tagSpecifications: TagSpecificationList? = nil,
                transportTransitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.options = options
        self.tagSpecifications = tagSpecifications
        self.transportTransitGatewayAttachmentId = transportTransitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case options = "Options"
        case tagSpecifications = "TagSpecification"
        case transportTransitGatewayAttachmentId = "TransportTransitGatewayAttachmentId"
    }

    public func validate() throws {
        try options.validate()
    }
}

public struct CreateTransitGatewayConnectRequestOptions: Codable, Equatable {
    public var `protocol`: ProtocolValue

    public init(`protocol`: ProtocolValue) {
        self.`protocol` = `protocol`
    }

    enum CodingKeys: String, CodingKey {
        case `protocol` = "Protocol"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayConnectResult: Codable, Equatable {
    public var transitGatewayConnect: TransitGatewayConnect?

    public init(transitGatewayConnect: TransitGatewayConnect? = nil) {
        self.transitGatewayConnect = transitGatewayConnect
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayConnect
    }

    public func validate() throws {
        try transitGatewayConnect?.validate()
    }
}

public struct CreateTransitGatewayMulticastDomainRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var options: CreateTransitGatewayMulticastDomainRequestOptions?
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId

    public init(dryRun: Boolean? = nil,
                options: CreateTransitGatewayMulticastDomainRequestOptions? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId) {
        self.dryRun = dryRun
        self.options = options
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case options = "Options"
        case tagSpecifications = "TagSpecification"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct CreateTransitGatewayMulticastDomainRequestOptions: Codable, Equatable {
    public var autoAcceptSharedAssociations: AutoAcceptSharedAssociationsValue?
    public var igmpv2Support: Igmpv2SupportValue?
    public var staticSourcesSupport: StaticSourcesSupportValue?

    public init(autoAcceptSharedAssociations: AutoAcceptSharedAssociationsValue? = nil,
                igmpv2Support: Igmpv2SupportValue? = nil,
                staticSourcesSupport: StaticSourcesSupportValue? = nil) {
        self.autoAcceptSharedAssociations = autoAcceptSharedAssociations
        self.igmpv2Support = igmpv2Support
        self.staticSourcesSupport = staticSourcesSupport
    }

    enum CodingKeys: String, CodingKey {
        case autoAcceptSharedAssociations = "AutoAcceptSharedAssociations"
        case igmpv2Support = "Igmpv2Support"
        case staticSourcesSupport = "StaticSourcesSupport"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayMulticastDomainResult: Codable, Equatable {
    public var transitGatewayMulticastDomain: TransitGatewayMulticastDomain?

    public init(transitGatewayMulticastDomain: TransitGatewayMulticastDomain? = nil) {
        self.transitGatewayMulticastDomain = transitGatewayMulticastDomain
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayMulticastDomain
    }

    public func validate() throws {
        try transitGatewayMulticastDomain?.validate()
    }
}

public struct CreateTransitGatewayPeeringAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var options: CreateTransitGatewayPeeringAttachmentRequestOptions?
    public var peerAccountId: String
    public var peerRegion: String
    public var peerTransitGatewayId: TransitAssociationGatewayId
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId

    public init(dryRun: Boolean? = nil,
                options: CreateTransitGatewayPeeringAttachmentRequestOptions? = nil,
                peerAccountId: String,
                peerRegion: String,
                peerTransitGatewayId: TransitAssociationGatewayId,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId) {
        self.dryRun = dryRun
        self.options = options
        self.peerAccountId = peerAccountId
        self.peerRegion = peerRegion
        self.peerTransitGatewayId = peerTransitGatewayId
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case options = "Options"
        case peerAccountId = "PeerAccountId"
        case peerRegion = "PeerRegion"
        case peerTransitGatewayId = "PeerTransitGatewayId"
        case tagSpecifications = "TagSpecification"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct CreateTransitGatewayPeeringAttachmentRequestOptions: Codable, Equatable {
    public var dynamicRouting: DynamicRoutingValue?

    public init(dynamicRouting: DynamicRoutingValue? = nil) {
        self.dynamicRouting = dynamicRouting
    }

    enum CodingKeys: String, CodingKey {
        case dynamicRouting = "DynamicRouting"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayPeeringAttachmentResult: Codable, Equatable {
    public var transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment?

    public init(transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment? = nil) {
        self.transitGatewayPeeringAttachment = transitGatewayPeeringAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPeeringAttachment
    }

    public func validate() throws {
        try transitGatewayPeeringAttachment?.validate()
    }
}

public struct CreateTransitGatewayPolicyTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecifications"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayPolicyTableResult: Codable, Equatable {
    public var transitGatewayPolicyTable: TransitGatewayPolicyTable?

    public init(transitGatewayPolicyTable: TransitGatewayPolicyTable? = nil) {
        self.transitGatewayPolicyTable = transitGatewayPolicyTable
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPolicyTable
    }

    public func validate() throws {
        try transitGatewayPolicyTable?.validate()
    }
}

public struct CreateTransitGatewayPrefixListReferenceRequest: Codable, Equatable {
    public var blackhole: Boolean?
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(blackhole: Boolean? = nil,
                dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.blackhole = blackhole
        self.dryRun = dryRun
        self.prefixListId = prefixListId
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole = "Blackhole"
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayPrefixListReferenceResult: Codable, Equatable {
    public var transitGatewayPrefixListReference: TransitGatewayPrefixListReference?

    public init(transitGatewayPrefixListReference: TransitGatewayPrefixListReference? = nil) {
        self.transitGatewayPrefixListReference = transitGatewayPrefixListReference
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPrefixListReference
    }

    public func validate() throws {
        try transitGatewayPrefixListReference?.validate()
    }
}

public struct CreateTransitGatewayRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var options: TransitGatewayRequestOptions?
    public var tagSpecifications: TagSpecificationList?

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                options: TransitGatewayRequestOptions? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.description = description
        self.dryRun = dryRun
        self.options = options
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case options = "Options"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct CreateTransitGatewayResult: Codable, Equatable {
    public var transitGateway: TransitGateway?

    public init(transitGateway: TransitGateway? = nil) {
        self.transitGateway = transitGateway
    }

    enum CodingKeys: String, CodingKey {
        case transitGateway
    }

    public func validate() throws {
        try transitGateway?.validate()
    }
}

public struct CreateTransitGatewayRouteRequest: Codable, Equatable {
    public var blackhole: Boolean?
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(blackhole: Boolean? = nil,
                destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.blackhole = blackhole
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole = "Blackhole"
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayRouteResult: Codable, Equatable {
    public var route: TransitGatewayRoute?

    public init(route: TransitGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct CreateTransitGatewayRouteTableAnnouncementRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var peeringAttachmentId: TransitGatewayAttachmentId
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                peeringAttachmentId: TransitGatewayAttachmentId,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.peeringAttachmentId = peeringAttachmentId
        self.tagSpecifications = tagSpecifications
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case peeringAttachmentId = "PeeringAttachmentId"
        case tagSpecifications = "TagSpecification"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayRouteTableAnnouncementResult: Codable, Equatable {
    public var transitGatewayRouteTableAnnouncement: TransitGatewayRouteTableAnnouncement?

    public init(transitGatewayRouteTableAnnouncement: TransitGatewayRouteTableAnnouncement? = nil) {
        self.transitGatewayRouteTableAnnouncement = transitGatewayRouteTableAnnouncement
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayRouteTableAnnouncement
    }

    public func validate() throws {
        try transitGatewayRouteTableAnnouncement?.validate()
    }
}

public struct CreateTransitGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId

    public init(dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId) {
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecifications"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayRouteTableResult: Codable, Equatable {
    public var transitGatewayRouteTable: TransitGatewayRouteTable?

    public init(transitGatewayRouteTable: TransitGatewayRouteTable? = nil) {
        self.transitGatewayRouteTable = transitGatewayRouteTable
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayRouteTable
    }

    public func validate() throws {
        try transitGatewayRouteTable?.validate()
    }
}

public struct CreateTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var options: CreateTransitGatewayVpcAttachmentRequestOptions?
    public var subnetIds: TransitGatewaySubnetIdList
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                options: CreateTransitGatewayVpcAttachmentRequestOptions? = nil,
                subnetIds: TransitGatewaySubnetIdList,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.options = options
        self.subnetIds = subnetIds
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case options = "Options"
        case subnetIds = "SubnetIds"
        case tagSpecifications = "TagSpecifications"
        case transitGatewayId = "TransitGatewayId"
        case vpcId = "VpcId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct CreateTransitGatewayVpcAttachmentRequestOptions: Codable, Equatable {
    public var applianceModeSupport: ApplianceModeSupportValue?
    public var dnsSupport: DnsSupportValue?
    public var ipv6Support: Ipv6SupportValue?

    public init(applianceModeSupport: ApplianceModeSupportValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                ipv6Support: Ipv6SupportValue? = nil) {
        self.applianceModeSupport = applianceModeSupport
        self.dnsSupport = dnsSupport
        self.ipv6Support = ipv6Support
    }

    enum CodingKeys: String, CodingKey {
        case applianceModeSupport = "ApplianceModeSupport"
        case dnsSupport = "DnsSupport"
        case ipv6Support = "Ipv6Support"
    }

    public func validate() throws {
    }
}

public struct CreateTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct CreateVerifiedAccessEndpointEniOptions: Codable, Equatable {
    public var networkInterfaceId: NetworkInterfaceId?
    public var port: VerifiedAccessEndpointPortNumber?
    public var `protocol`: VerifiedAccessEndpointProtocol?

    public init(networkInterfaceId: NetworkInterfaceId? = nil,
                port: VerifiedAccessEndpointPortNumber? = nil,
                `protocol`: VerifiedAccessEndpointProtocol? = nil) {
        self.networkInterfaceId = networkInterfaceId
        self.port = port
        self.`protocol` = `protocol`
    }

    enum CodingKeys: String, CodingKey {
        case networkInterfaceId = "NetworkInterfaceId"
        case port = "Port"
        case `protocol` = "Protocol"
    }

    public func validate() throws {
        try port?.validateAsVerifiedAccessEndpointPortNumber()
    }
}

public struct CreateVerifiedAccessEndpointLoadBalancerOptions: Codable, Equatable {
    public var loadBalancerArn: LoadBalancerArn?
    public var port: VerifiedAccessEndpointPortNumber?
    public var `protocol`: VerifiedAccessEndpointProtocol?
    public var subnetIds: CreateVerifiedAccessEndpointSubnetIdList?

    public init(loadBalancerArn: LoadBalancerArn? = nil,
                port: VerifiedAccessEndpointPortNumber? = nil,
                `protocol`: VerifiedAccessEndpointProtocol? = nil,
                subnetIds: CreateVerifiedAccessEndpointSubnetIdList? = nil) {
        self.loadBalancerArn = loadBalancerArn
        self.port = port
        self.`protocol` = `protocol`
        self.subnetIds = subnetIds
    }

    enum CodingKeys: String, CodingKey {
        case loadBalancerArn = "LoadBalancerArn"
        case port = "Port"
        case `protocol` = "Protocol"
        case subnetIds = "SubnetId"
    }

    public func validate() throws {
        try port?.validateAsVerifiedAccessEndpointPortNumber()
    }
}

public struct CreateVerifiedAccessEndpointRequest: Codable, Equatable {
    public var applicationDomain: String
    public var attachmentType: VerifiedAccessEndpointAttachmentType
    public var clientToken: String?
    public var description: String?
    public var domainCertificateArn: CertificateArn
    public var dryRun: Boolean?
    public var endpointDomainPrefix: String
    public var endpointType: VerifiedAccessEndpointType
    public var loadBalancerOptions: CreateVerifiedAccessEndpointLoadBalancerOptions?
    public var networkInterfaceOptions: CreateVerifiedAccessEndpointEniOptions?
    public var policyDocument: String?
    public var securityGroupIds: SecurityGroupIdList?
    public var tagSpecifications: TagSpecificationList?
    public var verifiedAccessGroupId: VerifiedAccessGroupId

    public init(applicationDomain: String,
                attachmentType: VerifiedAccessEndpointAttachmentType,
                clientToken: String? = nil,
                description: String? = nil,
                domainCertificateArn: CertificateArn,
                dryRun: Boolean? = nil,
                endpointDomainPrefix: String,
                endpointType: VerifiedAccessEndpointType,
                loadBalancerOptions: CreateVerifiedAccessEndpointLoadBalancerOptions? = nil,
                networkInterfaceOptions: CreateVerifiedAccessEndpointEniOptions? = nil,
                policyDocument: String? = nil,
                securityGroupIds: SecurityGroupIdList? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                verifiedAccessGroupId: VerifiedAccessGroupId) {
        self.applicationDomain = applicationDomain
        self.attachmentType = attachmentType
        self.clientToken = clientToken
        self.description = description
        self.domainCertificateArn = domainCertificateArn
        self.dryRun = dryRun
        self.endpointDomainPrefix = endpointDomainPrefix
        self.endpointType = endpointType
        self.loadBalancerOptions = loadBalancerOptions
        self.networkInterfaceOptions = networkInterfaceOptions
        self.policyDocument = policyDocument
        self.securityGroupIds = securityGroupIds
        self.tagSpecifications = tagSpecifications
        self.verifiedAccessGroupId = verifiedAccessGroupId
    }

    enum CodingKeys: String, CodingKey {
        case applicationDomain = "ApplicationDomain"
        case attachmentType = "AttachmentType"
        case clientToken = "ClientToken"
        case description = "Description"
        case domainCertificateArn = "DomainCertificateArn"
        case dryRun = "DryRun"
        case endpointDomainPrefix = "EndpointDomainPrefix"
        case endpointType = "EndpointType"
        case loadBalancerOptions = "LoadBalancerOptions"
        case networkInterfaceOptions = "NetworkInterfaceOptions"
        case policyDocument = "PolicyDocument"
        case securityGroupIds = "SecurityGroupId"
        case tagSpecifications = "TagSpecification"
        case verifiedAccessGroupId = "VerifiedAccessGroupId"
    }

    public func validate() throws {
        try loadBalancerOptions?.validate()
        try networkInterfaceOptions?.validate()
    }
}

public struct CreateVerifiedAccessEndpointResult: Codable, Equatable {
    public var verifiedAccessEndpoint: VerifiedAccessEndpoint?

    public init(verifiedAccessEndpoint: VerifiedAccessEndpoint? = nil) {
        self.verifiedAccessEndpoint = verifiedAccessEndpoint
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessEndpoint
    }

    public func validate() throws {
        try verifiedAccessEndpoint?.validate()
    }
}

public struct CreateVerifiedAccessGroupRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var policyDocument: String?
    public var tagSpecifications: TagSpecificationList?
    public var verifiedAccessInstanceId: VerifiedAccessInstanceId

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                policyDocument: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                verifiedAccessInstanceId: VerifiedAccessInstanceId) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.policyDocument = policyDocument
        self.tagSpecifications = tagSpecifications
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case policyDocument = "PolicyDocument"
        case tagSpecifications = "TagSpecification"
        case verifiedAccessInstanceId = "VerifiedAccessInstanceId"
    }

    public func validate() throws {
    }
}

public struct CreateVerifiedAccessGroupResult: Codable, Equatable {
    public var verifiedAccessGroup: VerifiedAccessGroup?

    public init(verifiedAccessGroup: VerifiedAccessGroup? = nil) {
        self.verifiedAccessGroup = verifiedAccessGroup
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessGroup
    }

    public func validate() throws {
        try verifiedAccessGroup?.validate()
    }
}

public struct CreateVerifiedAccessInstanceRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateVerifiedAccessInstanceResult: Codable, Equatable {
    public var verifiedAccessInstance: VerifiedAccessInstance?

    public init(verifiedAccessInstance: VerifiedAccessInstance? = nil) {
        self.verifiedAccessInstance = verifiedAccessInstance
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessInstance
    }

    public func validate() throws {
        try verifiedAccessInstance?.validate()
    }
}

public struct CreateVerifiedAccessTrustProviderDeviceOptions: Codable, Equatable {
    public var tenantId: String?

    public init(tenantId: String? = nil) {
        self.tenantId = tenantId
    }

    enum CodingKeys: String, CodingKey {
        case tenantId = "TenantId"
    }

    public func validate() throws {
    }
}

public struct CreateVerifiedAccessTrustProviderOidcOptions: Codable, Equatable {
    public var authorizationEndpoint: String?
    public var clientId: String?
    public var clientSecret: String?
    public var issuer: String?
    public var scope: String?
    public var tokenEndpoint: String?
    public var userInfoEndpoint: String?

    public init(authorizationEndpoint: String? = nil,
                clientId: String? = nil,
                clientSecret: String? = nil,
                issuer: String? = nil,
                scope: String? = nil,
                tokenEndpoint: String? = nil,
                userInfoEndpoint: String? = nil) {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.issuer = issuer
        self.scope = scope
        self.tokenEndpoint = tokenEndpoint
        self.userInfoEndpoint = userInfoEndpoint
    }

    enum CodingKeys: String, CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientId = "ClientId"
        case clientSecret = "ClientSecret"
        case issuer = "Issuer"
        case scope = "Scope"
        case tokenEndpoint = "TokenEndpoint"
        case userInfoEndpoint = "UserInfoEndpoint"
    }

    public func validate() throws {
    }
}

public struct CreateVerifiedAccessTrustProviderRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var deviceOptions: CreateVerifiedAccessTrustProviderDeviceOptions?
    public var deviceTrustProviderType: DeviceTrustProviderType?
    public var dryRun: Boolean?
    public var oidcOptions: CreateVerifiedAccessTrustProviderOidcOptions?
    public var policyReferenceName: String
    public var tagSpecifications: TagSpecificationList?
    public var trustProviderType: TrustProviderType
    public var userTrustProviderType: UserTrustProviderType?

    public init(clientToken: String? = nil,
                description: String? = nil,
                deviceOptions: CreateVerifiedAccessTrustProviderDeviceOptions? = nil,
                deviceTrustProviderType: DeviceTrustProviderType? = nil,
                dryRun: Boolean? = nil,
                oidcOptions: CreateVerifiedAccessTrustProviderOidcOptions? = nil,
                policyReferenceName: String,
                tagSpecifications: TagSpecificationList? = nil,
                trustProviderType: TrustProviderType,
                userTrustProviderType: UserTrustProviderType? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.deviceOptions = deviceOptions
        self.deviceTrustProviderType = deviceTrustProviderType
        self.dryRun = dryRun
        self.oidcOptions = oidcOptions
        self.policyReferenceName = policyReferenceName
        self.tagSpecifications = tagSpecifications
        self.trustProviderType = trustProviderType
        self.userTrustProviderType = userTrustProviderType
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case deviceOptions = "DeviceOptions"
        case deviceTrustProviderType = "DeviceTrustProviderType"
        case dryRun = "DryRun"
        case oidcOptions = "OidcOptions"
        case policyReferenceName = "PolicyReferenceName"
        case tagSpecifications = "TagSpecification"
        case trustProviderType = "TrustProviderType"
        case userTrustProviderType = "UserTrustProviderType"
    }

    public func validate() throws {
        try deviceOptions?.validate()
        try oidcOptions?.validate()
    }
}

public struct CreateVerifiedAccessTrustProviderResult: Codable, Equatable {
    public var verifiedAccessTrustProvider: VerifiedAccessTrustProvider?

    public init(verifiedAccessTrustProvider: VerifiedAccessTrustProvider? = nil) {
        self.verifiedAccessTrustProvider = verifiedAccessTrustProvider
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessTrustProvider
    }

    public func validate() throws {
        try verifiedAccessTrustProvider?.validate()
    }
}

public struct CreateVolumePermission: Codable, Equatable {
    public var group: PermissionGroup?
    public var userId: String?

    public init(group: PermissionGroup? = nil,
                userId: String? = nil) {
        self.group = group
        self.userId = userId
    }

    enum CodingKeys: String, CodingKey {
        case group
        case userId
    }

    public func validate() throws {
    }
}

public struct CreateVolumePermissionModifications: Codable, Equatable {
    public var add: CreateVolumePermissionList?
    public var remove: CreateVolumePermissionList?

    public init(add: CreateVolumePermissionList? = nil,
                remove: CreateVolumePermissionList? = nil) {
        self.add = add
        self.remove = remove
    }

    enum CodingKeys: String, CodingKey {
        case add = "Add"
        case remove = "Remove"
    }

    public func validate() throws {
    }
}

public struct CreateVolumeRequest: Codable, Equatable {
    public var availabilityZone: String
    public var clientToken: String?
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var kmsKeyId: KmsKeyId?
    public var multiAttachEnabled: Boolean?
    public var outpostArn: String?
    public var size: Integer?
    public var snapshotId: SnapshotId?
    public var tagSpecifications: TagSpecificationList?
    public var throughput: Integer?
    public var volumeType: VolumeType?

    public init(availabilityZone: String,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: KmsKeyId? = nil,
                multiAttachEnabled: Boolean? = nil,
                outpostArn: String? = nil,
                size: Integer? = nil,
                snapshotId: SnapshotId? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                throughput: Integer? = nil,
                volumeType: VolumeType? = nil) {
        self.availabilityZone = availabilityZone
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.multiAttachEnabled = multiAttachEnabled
        self.outpostArn = outpostArn
        self.size = size
        self.snapshotId = snapshotId
        self.tagSpecifications = tagSpecifications
        self.throughput = throughput
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case clientToken = "ClientToken"
        case dryRun
        case encrypted
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case multiAttachEnabled = "MultiAttachEnabled"
        case outpostArn = "OutpostArn"
        case size = "Size"
        case snapshotId = "SnapshotId"
        case tagSpecifications = "TagSpecification"
        case throughput = "Throughput"
        case volumeType = "VolumeType"
    }

    public func validate() throws {
    }
}

public struct CreateVpcEndpointConnectionNotificationRequest: Codable, Equatable {
    public var clientToken: String?
    public var connectionEvents: ValueStringList
    public var connectionNotificationArn: String
    public var dryRun: Boolean?
    public var serviceId: VpcEndpointServiceId?
    public var vpcEndpointId: VpcEndpointId?

    public init(clientToken: String? = nil,
                connectionEvents: ValueStringList,
                connectionNotificationArn: String,
                dryRun: Boolean? = nil,
                serviceId: VpcEndpointServiceId? = nil,
                vpcEndpointId: VpcEndpointId? = nil) {
        self.clientToken = clientToken
        self.connectionEvents = connectionEvents
        self.connectionNotificationArn = connectionNotificationArn
        self.dryRun = dryRun
        self.serviceId = serviceId
        self.vpcEndpointId = vpcEndpointId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case connectionEvents = "ConnectionEvents"
        case connectionNotificationArn = "ConnectionNotificationArn"
        case dryRun = "DryRun"
        case serviceId = "ServiceId"
        case vpcEndpointId = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct CreateVpcEndpointConnectionNotificationResult: Codable, Equatable {
    public var clientToken: String?
    public var connectionNotification: ConnectionNotification?

    public init(clientToken: String? = nil,
                connectionNotification: ConnectionNotification? = nil) {
        self.clientToken = clientToken
        self.connectionNotification = connectionNotification
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case connectionNotification
    }

    public func validate() throws {
        try connectionNotification?.validate()
    }
}

public struct CreateVpcEndpointRequest: Codable, Equatable {
    public var clientToken: String?
    public var dnsOptions: DnsOptionsSpecification?
    public var dryRun: Boolean?
    public var ipAddressType: IpAddressType?
    public var policyDocument: String?
    public var privateDnsEnabled: Boolean?
    public var routeTableIds: VpcEndpointRouteTableIdList?
    public var securityGroupIds: VpcEndpointSecurityGroupIdList?
    public var serviceName: String
    public var subnetIds: VpcEndpointSubnetIdList?
    public var tagSpecifications: TagSpecificationList?
    public var vpcEndpointType: VpcEndpointType?
    public var vpcId: VpcId

    public init(clientToken: String? = nil,
                dnsOptions: DnsOptionsSpecification? = nil,
                dryRun: Boolean? = nil,
                ipAddressType: IpAddressType? = nil,
                policyDocument: String? = nil,
                privateDnsEnabled: Boolean? = nil,
                routeTableIds: VpcEndpointRouteTableIdList? = nil,
                securityGroupIds: VpcEndpointSecurityGroupIdList? = nil,
                serviceName: String,
                subnetIds: VpcEndpointSubnetIdList? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcEndpointType: VpcEndpointType? = nil,
                vpcId: VpcId) {
        self.clientToken = clientToken
        self.dnsOptions = dnsOptions
        self.dryRun = dryRun
        self.ipAddressType = ipAddressType
        self.policyDocument = policyDocument
        self.privateDnsEnabled = privateDnsEnabled
        self.routeTableIds = routeTableIds
        self.securityGroupIds = securityGroupIds
        self.serviceName = serviceName
        self.subnetIds = subnetIds
        self.tagSpecifications = tagSpecifications
        self.vpcEndpointType = vpcEndpointType
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dnsOptions = "DnsOptions"
        case dryRun = "DryRun"
        case ipAddressType = "IpAddressType"
        case policyDocument = "PolicyDocument"
        case privateDnsEnabled = "PrivateDnsEnabled"
        case routeTableIds = "RouteTableId"
        case securityGroupIds = "SecurityGroupId"
        case serviceName = "ServiceName"
        case subnetIds = "SubnetId"
        case tagSpecifications = "TagSpecification"
        case vpcEndpointType = "VpcEndpointType"
        case vpcId = "VpcId"
    }

    public func validate() throws {
        try dnsOptions?.validate()
    }
}

public struct CreateVpcEndpointResult: Codable, Equatable {
    public var clientToken: String?
    public var vpcEndpoint: VpcEndpoint?

    public init(clientToken: String? = nil,
                vpcEndpoint: VpcEndpoint? = nil) {
        self.clientToken = clientToken
        self.vpcEndpoint = vpcEndpoint
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case vpcEndpoint
    }

    public func validate() throws {
        try vpcEndpoint?.validate()
    }
}

public struct CreateVpcEndpointServiceConfigurationRequest: Codable, Equatable {
    public var acceptanceRequired: Boolean?
    public var clientToken: String?
    public var dryRun: Boolean?
    public var gatewayLoadBalancerArns: ValueStringList?
    public var networkLoadBalancerArns: ValueStringList?
    public var privateDnsName: String?
    public var supportedIpAddressTypes: ValueStringList?
    public var tagSpecifications: TagSpecificationList?

    public init(acceptanceRequired: Boolean? = nil,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                gatewayLoadBalancerArns: ValueStringList? = nil,
                networkLoadBalancerArns: ValueStringList? = nil,
                privateDnsName: String? = nil,
                supportedIpAddressTypes: ValueStringList? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.acceptanceRequired = acceptanceRequired
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
        self.networkLoadBalancerArns = networkLoadBalancerArns
        self.privateDnsName = privateDnsName
        self.supportedIpAddressTypes = supportedIpAddressTypes
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case acceptanceRequired = "AcceptanceRequired"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case gatewayLoadBalancerArns = "GatewayLoadBalancerArn"
        case networkLoadBalancerArns = "NetworkLoadBalancerArn"
        case privateDnsName = "PrivateDnsName"
        case supportedIpAddressTypes = "SupportedIpAddressType"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateVpcEndpointServiceConfigurationResult: Codable, Equatable {
    public var clientToken: String?
    public var serviceConfiguration: ServiceConfiguration?

    public init(clientToken: String? = nil,
                serviceConfiguration: ServiceConfiguration? = nil) {
        self.clientToken = clientToken
        self.serviceConfiguration = serviceConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case serviceConfiguration
    }

    public func validate() throws {
        try serviceConfiguration?.validate()
    }
}

public struct CreateVpcPeeringConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var peerOwnerId: String?
    public var peerRegion: String?
    public var peerVpcId: String?
    public var tagSpecifications: TagSpecificationList?
    public var vpcId: VpcId?

    public init(dryRun: Boolean? = nil,
                peerOwnerId: String? = nil,
                peerRegion: String? = nil,
                peerVpcId: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                vpcId: VpcId? = nil) {
        self.dryRun = dryRun
        self.peerOwnerId = peerOwnerId
        self.peerRegion = peerRegion
        self.peerVpcId = peerVpcId
        self.tagSpecifications = tagSpecifications
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case peerOwnerId
        case peerRegion = "PeerRegion"
        case peerVpcId
        case tagSpecifications = "TagSpecification"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct CreateVpcPeeringConnectionResult: Codable, Equatable {
    public var vpcPeeringConnection: VpcPeeringConnection?

    public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
        self.vpcPeeringConnection = vpcPeeringConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpcPeeringConnection
    }

    public func validate() throws {
        try vpcPeeringConnection?.validate()
    }
}

public struct CreateVpcRequest: Codable, Equatable {
    public var amazonProvidedIpv6CidrBlock: Boolean?
    public var cidrBlock: String?
    public var dryRun: Boolean?
    public var instanceTenancy: Tenancy?
    public var ipv4IpamPoolId: IpamPoolId?
    public var ipv4NetmaskLength: NetmaskLength?
    public var ipv6CidrBlock: String?
    public var ipv6CidrBlockNetworkBorderGroup: String?
    public var ipv6IpamPoolId: IpamPoolId?
    public var ipv6NetmaskLength: NetmaskLength?
    public var ipv6Pool: Ipv6PoolEc2Id?
    public var tagSpecifications: TagSpecificationList?

    public init(amazonProvidedIpv6CidrBlock: Boolean? = nil,
                cidrBlock: String? = nil,
                dryRun: Boolean? = nil,
                instanceTenancy: Tenancy? = nil,
                ipv4IpamPoolId: IpamPoolId? = nil,
                ipv4NetmaskLength: NetmaskLength? = nil,
                ipv6CidrBlock: String? = nil,
                ipv6CidrBlockNetworkBorderGroup: String? = nil,
                ipv6IpamPoolId: IpamPoolId? = nil,
                ipv6NetmaskLength: NetmaskLength? = nil,
                ipv6Pool: Ipv6PoolEc2Id? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
        self.cidrBlock = cidrBlock
        self.dryRun = dryRun
        self.instanceTenancy = instanceTenancy
        self.ipv4IpamPoolId = ipv4IpamPoolId
        self.ipv4NetmaskLength = ipv4NetmaskLength
        self.ipv6CidrBlock = ipv6CidrBlock
        self.ipv6CidrBlockNetworkBorderGroup = ipv6CidrBlockNetworkBorderGroup
        self.ipv6IpamPoolId = ipv6IpamPoolId
        self.ipv6NetmaskLength = ipv6NetmaskLength
        self.ipv6Pool = ipv6Pool
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case amazonProvidedIpv6CidrBlock
        case cidrBlock = "CidrBlock"
        case dryRun
        case instanceTenancy
        case ipv4IpamPoolId = "Ipv4IpamPoolId"
        case ipv4NetmaskLength = "Ipv4NetmaskLength"
        case ipv6CidrBlock = "Ipv6CidrBlock"
        case ipv6CidrBlockNetworkBorderGroup = "Ipv6CidrBlockNetworkBorderGroup"
        case ipv6IpamPoolId = "Ipv6IpamPoolId"
        case ipv6NetmaskLength = "Ipv6NetmaskLength"
        case ipv6Pool = "Ipv6Pool"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct CreateVpcResult: Codable, Equatable {
    public var vpc: Vpc?

    public init(vpc: Vpc? = nil) {
        self.vpc = vpc
    }

    enum CodingKeys: String, CodingKey {
        case vpc
    }

    public func validate() throws {
        try vpc?.validate()
    }
}

public struct CreateVpnConnectionRequest: Codable, Equatable {
    public var customerGatewayId: CustomerGatewayId
    public var dryRun: Boolean?
    public var options: VpnConnectionOptionsSpecification?
    public var tagSpecifications: TagSpecificationList?
    public var transitGatewayId: TransitGatewayId?
    public var type: String
    public var vpnGatewayId: VpnGatewayId?

    public init(customerGatewayId: CustomerGatewayId,
                dryRun: Boolean? = nil,
                options: VpnConnectionOptionsSpecification? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                transitGatewayId: TransitGatewayId? = nil,
                type: String,
                vpnGatewayId: VpnGatewayId? = nil) {
        self.customerGatewayId = customerGatewayId
        self.dryRun = dryRun
        self.options = options
        self.tagSpecifications = tagSpecifications
        self.transitGatewayId = transitGatewayId
        self.type = type
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case customerGatewayId = "CustomerGatewayId"
        case dryRun
        case options
        case tagSpecifications = "TagSpecification"
        case transitGatewayId = "TransitGatewayId"
        case type = "Type"
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct CreateVpnConnectionResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct CreateVpnConnectionRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var vpnConnectionId: VpnConnectionId

    public init(destinationCidrBlock: String,
                vpnConnectionId: VpnConnectionId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.vpnConnectionId = vpnConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case vpnConnectionId = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct CreateVpnGatewayRequest: Codable, Equatable {
    public var amazonSideAsn: Long?
    public var availabilityZone: String?
    public var dryRun: Boolean?
    public var tagSpecifications: TagSpecificationList?
    public var type: GatewayType

    public init(amazonSideAsn: Long? = nil,
                availabilityZone: String? = nil,
                dryRun: Boolean? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                type: GatewayType) {
        self.amazonSideAsn = amazonSideAsn
        self.availabilityZone = availabilityZone
        self.dryRun = dryRun
        self.tagSpecifications = tagSpecifications
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case amazonSideAsn = "AmazonSideAsn"
        case availabilityZone = "AvailabilityZone"
        case dryRun
        case tagSpecifications = "TagSpecification"
        case type = "Type"
    }

    public func validate() throws {
    }
}

public struct CreateVpnGatewayResult: Codable, Equatable {
    public var vpnGateway: VpnGateway?

    public init(vpnGateway: VpnGateway? = nil) {
        self.vpnGateway = vpnGateway
    }

    enum CodingKeys: String, CodingKey {
        case vpnGateway
    }

    public func validate() throws {
        try vpnGateway?.validate()
    }
}

public struct CreditSpecification: Codable, Equatable {
    public var cpuCredits: String?

    public init(cpuCredits: String? = nil) {
        self.cpuCredits = cpuCredits
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits
    }

    public func validate() throws {
    }
}

public struct CreditSpecificationRequest: Codable, Equatable {
    public var cpuCredits: String

    public init(cpuCredits: String) {
        self.cpuCredits = cpuCredits
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits = "CpuCredits"
    }

    public func validate() throws {
    }
}

public struct CustomerGateway: Codable, Equatable {
    public var bgpAsn: String?
    public var certificateArn: String?
    public var customerGatewayId: String?
    public var deviceName: String?
    public var ipAddress: String?
    public var state: String?
    public var tags: TagList?
    public var type: String?

    public init(bgpAsn: String? = nil,
                certificateArn: String? = nil,
                customerGatewayId: String? = nil,
                deviceName: String? = nil,
                ipAddress: String? = nil,
                state: String? = nil,
                tags: TagList? = nil,
                type: String? = nil) {
        self.bgpAsn = bgpAsn
        self.certificateArn = certificateArn
        self.customerGatewayId = customerGatewayId
        self.deviceName = deviceName
        self.ipAddress = ipAddress
        self.state = state
        self.tags = tags
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case bgpAsn
        case certificateArn
        case customerGatewayId
        case deviceName
        case ipAddress
        case state
        case tags = "tagSet"
        case type
    }

    public func validate() throws {
    }
}

public struct DataQuery: Codable, Equatable {
    public var destination: String?
    public var id: String?
    public var metric: MetricType?
    public var period: PeriodType?
    public var source: String?
    public var statistic: StatisticType?

    public init(destination: String? = nil,
                id: String? = nil,
                metric: MetricType? = nil,
                period: PeriodType? = nil,
                source: String? = nil,
                statistic: StatisticType? = nil) {
        self.destination = destination
        self.id = id
        self.metric = metric
        self.period = period
        self.source = source
        self.statistic = statistic
    }

    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case id = "Id"
        case metric = "Metric"
        case period = "Period"
        case source = "Source"
        case statistic = "Statistic"
    }

    public func validate() throws {
    }
}

public struct DataResponse: Codable, Equatable {
    public var destination: String?
    public var id: String?
    public var metric: MetricType?
    public var metricPoints: MetricPoints?
    public var period: PeriodType?
    public var source: String?
    public var statistic: StatisticType?

    public init(destination: String? = nil,
                id: String? = nil,
                metric: MetricType? = nil,
                metricPoints: MetricPoints? = nil,
                period: PeriodType? = nil,
                source: String? = nil,
                statistic: StatisticType? = nil) {
        self.destination = destination
        self.id = id
        self.metric = metric
        self.metricPoints = metricPoints
        self.period = period
        self.source = source
        self.statistic = statistic
    }

    enum CodingKeys: String, CodingKey {
        case destination
        case id
        case metric
        case metricPoints = "metricPointSet"
        case period
        case source
        case statistic
    }

    public func validate() throws {
    }
}

public struct DeleteCarrierGatewayRequest: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId
    public var dryRun: Boolean?

    public init(carrierGatewayId: CarrierGatewayId,
                dryRun: Boolean? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId = "CarrierGatewayId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeleteCarrierGatewayResult: Codable, Equatable {
    public var carrierGateway: CarrierGateway?

    public init(carrierGateway: CarrierGateway? = nil) {
        self.carrierGateway = carrierGateway
    }

    enum CodingKeys: String, CodingKey {
        case carrierGateway
    }

    public func validate() throws {
        try carrierGateway?.validate()
    }
}

public struct DeleteClientVpnEndpointRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeleteClientVpnEndpointResult: Codable, Equatable {
    public var status: ClientVpnEndpointStatus?

    public init(status: ClientVpnEndpointStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct DeleteClientVpnRouteRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var targetVpcSubnetId: SubnetId?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                targetVpcSubnetId: SubnetId? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.targetVpcSubnetId = targetVpcSubnetId
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case targetVpcSubnetId = "TargetVpcSubnetId"
    }

    public func validate() throws {
    }
}

public struct DeleteClientVpnRouteResult: Codable, Equatable {
    public var status: ClientVpnRouteStatus?

    public init(status: ClientVpnRouteStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct DeleteCoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var coipPoolId: Ipv4PoolCoipId
    public var dryRun: Boolean?

    public init(cidr: String,
                coipPoolId: Ipv4PoolCoipId,
                dryRun: Boolean? = nil) {
        self.cidr = cidr
        self.coipPoolId = coipPoolId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case coipPoolId = "CoipPoolId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeleteCoipCidrResult: Codable, Equatable {
    public var coipCidr: CoipCidr?

    public init(coipCidr: CoipCidr? = nil) {
        self.coipCidr = coipCidr
    }

    enum CodingKeys: String, CodingKey {
        case coipCidr
    }

    public func validate() throws {
        try coipCidr?.validate()
    }
}

public struct DeleteCoipPoolRequest: Codable, Equatable {
    public var coipPoolId: Ipv4PoolCoipId
    public var dryRun: Boolean?

    public init(coipPoolId: Ipv4PoolCoipId,
                dryRun: Boolean? = nil) {
        self.coipPoolId = coipPoolId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case coipPoolId = "CoipPoolId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeleteCoipPoolResult: Codable, Equatable {
    public var coipPool: CoipPool?

    public init(coipPool: CoipPool? = nil) {
        self.coipPool = coipPool
    }

    enum CodingKeys: String, CodingKey {
        case coipPool
    }

    public func validate() throws {
        try coipPool?.validate()
    }
}

public struct DeleteCustomerGatewayRequest: Codable, Equatable {
    public var customerGatewayId: CustomerGatewayId
    public var dryRun: Boolean?

    public init(customerGatewayId: CustomerGatewayId,
                dryRun: Boolean? = nil) {
        self.customerGatewayId = customerGatewayId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case customerGatewayId = "CustomerGatewayId"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DeleteDhcpOptionsRequest: Codable, Equatable {
    public var dhcpOptionsId: DhcpOptionsId
    public var dryRun: Boolean?

    public init(dhcpOptionsId: DhcpOptionsId,
                dryRun: Boolean? = nil) {
        self.dhcpOptionsId = dhcpOptionsId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptionsId = "DhcpOptionsId"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DeleteEgressOnlyInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId

    public init(dryRun: Boolean? = nil,
                egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId) {
        self.dryRun = dryRun
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case egressOnlyInternetGatewayId = "EgressOnlyInternetGatewayId"
    }

    public func validate() throws {
    }
}

public struct DeleteEgressOnlyInternetGatewayResult: Codable, Equatable {
    public var returnCode: Boolean?

    public init(returnCode: Boolean? = nil) {
        self.returnCode = returnCode
    }

    enum CodingKeys: String, CodingKey {
        case returnCode
    }

    public func validate() throws {
    }
}

public struct DeleteFleetError: Codable, Equatable {
    public var code: DeleteFleetErrorCode?
    public var message: String?

    public init(code: DeleteFleetErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct DeleteFleetErrorItem: Codable, Equatable {
    public var error: DeleteFleetError?
    public var fleetId: FleetId?

    public init(error: DeleteFleetError? = nil,
                fleetId: FleetId? = nil) {
        self.error = error
        self.fleetId = fleetId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case fleetId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct DeleteFleetSuccessItem: Codable, Equatable {
    public var currentFleetState: FleetStateCode?
    public var fleetId: FleetId?
    public var previousFleetState: FleetStateCode?

    public init(currentFleetState: FleetStateCode? = nil,
                fleetId: FleetId? = nil,
                previousFleetState: FleetStateCode? = nil) {
        self.currentFleetState = currentFleetState
        self.fleetId = fleetId
        self.previousFleetState = previousFleetState
    }

    enum CodingKeys: String, CodingKey {
        case currentFleetState
        case fleetId
        case previousFleetState
    }

    public func validate() throws {
    }
}

public struct DeleteFleetsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var fleetIds: FleetIdSet
    public var terminateInstances: Boolean

    public init(dryRun: Boolean? = nil,
                fleetIds: FleetIdSet,
                terminateInstances: Boolean) {
        self.dryRun = dryRun
        self.fleetIds = fleetIds
        self.terminateInstances = terminateInstances
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case fleetIds = "FleetId"
        case terminateInstances = "TerminateInstances"
    }

    public func validate() throws {
    }
}

public struct DeleteFleetsResult: Codable, Equatable {
    public var successfulFleetDeletions: DeleteFleetSuccessSet?
    public var unsuccessfulFleetDeletions: DeleteFleetErrorSet?

    public init(successfulFleetDeletions: DeleteFleetSuccessSet? = nil,
                unsuccessfulFleetDeletions: DeleteFleetErrorSet? = nil) {
        self.successfulFleetDeletions = successfulFleetDeletions
        self.unsuccessfulFleetDeletions = unsuccessfulFleetDeletions
    }

    enum CodingKeys: String, CodingKey {
        case successfulFleetDeletions = "successfulFleetDeletionSet"
        case unsuccessfulFleetDeletions = "unsuccessfulFleetDeletionSet"
    }

    public func validate() throws {
    }
}

public struct DeleteFlowLogsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var flowLogIds: FlowLogIdList

    public init(dryRun: Boolean? = nil,
                flowLogIds: FlowLogIdList) {
        self.dryRun = dryRun
        self.flowLogIds = flowLogIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case flowLogIds = "FlowLogId"
    }

    public func validate() throws {
    }
}

public struct DeleteFlowLogsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DeleteFpgaImageRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var fpgaImageId: FpgaImageId

    public init(dryRun: Boolean? = nil,
                fpgaImageId: FpgaImageId) {
        self.dryRun = dryRun
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case fpgaImageId = "FpgaImageId"
    }

    public func validate() throws {
    }
}

public struct DeleteFpgaImageResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DeleteInstanceEventWindowRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var forceDelete: Boolean?
    public var instanceEventWindowId: InstanceEventWindowId

    public init(dryRun: Boolean? = nil,
                forceDelete: Boolean? = nil,
                instanceEventWindowId: InstanceEventWindowId) {
        self.dryRun = dryRun
        self.forceDelete = forceDelete
        self.instanceEventWindowId = instanceEventWindowId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case forceDelete = "ForceDelete"
        case instanceEventWindowId = "InstanceEventWindowId"
    }

    public func validate() throws {
    }
}

public struct DeleteInstanceEventWindowResult: Codable, Equatable {
    public var instanceEventWindowState: InstanceEventWindowStateChange?

    public init(instanceEventWindowState: InstanceEventWindowStateChange? = nil) {
        self.instanceEventWindowState = instanceEventWindowState
    }

    enum CodingKeys: String, CodingKey {
        case instanceEventWindowState
    }

    public func validate() throws {
        try instanceEventWindowState?.validate()
    }
}

public struct DeleteInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var internetGatewayId: InternetGatewayId

    public init(dryRun: Boolean? = nil,
                internetGatewayId: InternetGatewayId) {
        self.dryRun = dryRun
        self.internetGatewayId = internetGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case internetGatewayId
    }

    public func validate() throws {
    }
}

public struct DeleteIpamPoolRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var ipamPoolId: IpamPoolId

    public init(dryRun: Boolean? = nil,
                ipamPoolId: IpamPoolId) {
        self.dryRun = dryRun
        self.ipamPoolId = ipamPoolId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case ipamPoolId = "IpamPoolId"
    }

    public func validate() throws {
    }
}

public struct DeleteIpamPoolResult: Codable, Equatable {
    public var ipamPool: IpamPool?

    public init(ipamPool: IpamPool? = nil) {
        self.ipamPool = ipamPool
    }

    enum CodingKeys: String, CodingKey {
        case ipamPool
    }

    public func validate() throws {
        try ipamPool?.validate()
    }
}

public struct DeleteIpamRequest: Codable, Equatable {
    public var cascade: Boolean?
    public var dryRun: Boolean?
    public var ipamId: IpamId

    public init(cascade: Boolean? = nil,
                dryRun: Boolean? = nil,
                ipamId: IpamId) {
        self.cascade = cascade
        self.dryRun = dryRun
        self.ipamId = ipamId
    }

    enum CodingKeys: String, CodingKey {
        case cascade = "Cascade"
        case dryRun = "DryRun"
        case ipamId = "IpamId"
    }

    public func validate() throws {
    }
}

public struct DeleteIpamResult: Codable, Equatable {
    public var ipam: Ipam?

    public init(ipam: Ipam? = nil) {
        self.ipam = ipam
    }

    enum CodingKeys: String, CodingKey {
        case ipam
    }

    public func validate() throws {
        try ipam?.validate()
    }
}

public struct DeleteIpamScopeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var ipamScopeId: IpamScopeId

    public init(dryRun: Boolean? = nil,
                ipamScopeId: IpamScopeId) {
        self.dryRun = dryRun
        self.ipamScopeId = ipamScopeId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case ipamScopeId = "IpamScopeId"
    }

    public func validate() throws {
    }
}

public struct DeleteIpamScopeResult: Codable, Equatable {
    public var ipamScope: IpamScope?

    public init(ipamScope: IpamScope? = nil) {
        self.ipamScope = ipamScope
    }

    enum CodingKeys: String, CodingKey {
        case ipamScope
    }

    public func validate() throws {
        try ipamScope?.validate()
    }
}

public struct DeleteKeyPairRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var keyName: KeyPairName?
    public var keyPairId: KeyPairId?

    public init(dryRun: Boolean? = nil,
                keyName: KeyPairName? = nil,
                keyPairId: KeyPairId? = nil) {
        self.dryRun = dryRun
        self.keyName = keyName
        self.keyPairId = keyPairId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case keyName = "KeyName"
        case keyPairId = "KeyPairId"
    }

    public func validate() throws {
    }
}

public struct DeleteLaunchTemplateRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?

    public init(dryRun: Boolean? = nil,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil) {
        self.dryRun = dryRun
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct DeleteLaunchTemplateResult: Codable, Equatable {
    public var launchTemplate: LaunchTemplate?

    public init(launchTemplate: LaunchTemplate? = nil) {
        self.launchTemplate = launchTemplate
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplate
    }

    public func validate() throws {
        try launchTemplate?.validate()
    }
}

public struct DeleteLaunchTemplateVersionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?
    public var versions: VersionStringList

    public init(dryRun: Boolean? = nil,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                versions: VersionStringList) {
        self.dryRun = dryRun
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.versions = versions
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case versions = "LaunchTemplateVersion"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct DeleteLaunchTemplateVersionsResponseErrorItem: Codable, Equatable {
    public var launchTemplateId: String?
    public var launchTemplateName: String?
    public var responseError: ResponseError?
    public var versionNumber: Long?

    public init(launchTemplateId: String? = nil,
                launchTemplateName: String? = nil,
                responseError: ResponseError? = nil,
                versionNumber: Long? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.responseError = responseError
        self.versionNumber = versionNumber
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId
        case launchTemplateName
        case responseError
        case versionNumber
    }

    public func validate() throws {
        try responseError?.validate()
    }
}

public struct DeleteLaunchTemplateVersionsResponseSuccessItem: Codable, Equatable {
    public var launchTemplateId: String?
    public var launchTemplateName: String?
    public var versionNumber: Long?

    public init(launchTemplateId: String? = nil,
                launchTemplateName: String? = nil,
                versionNumber: Long? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.versionNumber = versionNumber
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId
        case launchTemplateName
        case versionNumber
    }

    public func validate() throws {
    }
}

public struct DeleteLaunchTemplateVersionsResult: Codable, Equatable {
    public var successfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseSuccessSet?
    public var unsuccessfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseErrorSet?

    public init(successfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseSuccessSet? = nil,
                unsuccessfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseErrorSet? = nil) {
        self.successfullyDeletedLaunchTemplateVersions = successfullyDeletedLaunchTemplateVersions
        self.unsuccessfullyDeletedLaunchTemplateVersions = unsuccessfullyDeletedLaunchTemplateVersions
    }

    enum CodingKeys: String, CodingKey {
        case successfullyDeletedLaunchTemplateVersions = "successfullyDeletedLaunchTemplateVersionSet"
        case unsuccessfullyDeletedLaunchTemplateVersions = "unsuccessfullyDeletedLaunchTemplateVersionSet"
    }

    public func validate() throws {
    }
}

public struct DeleteLocalGatewayRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId

    public init(destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteLocalGatewayRouteResult: Codable, Equatable {
    public var route: LocalGatewayRoute?

    public init(route: LocalGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct DeleteLocalGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId

    public init(dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId) {
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteLocalGatewayRouteTableResult: Codable, Equatable {
    public var localGatewayRouteTable: LocalGatewayRouteTable?

    public init(localGatewayRouteTable: LocalGatewayRouteTable? = nil) {
        self.localGatewayRouteTable = localGatewayRouteTable
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTable
    }

    public func validate() throws {
        try localGatewayRouteTable?.validate()
    }
}

public struct DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localGatewayRouteTableVirtualInterfaceGroupAssociationId: LocalGatewayRouteTableVirtualInterfaceGroupAssociationId

    public init(dryRun: Boolean? = nil,
                localGatewayRouteTableVirtualInterfaceGroupAssociationId: LocalGatewayRouteTableVirtualInterfaceGroupAssociationId) {
        self.dryRun = dryRun
        self.localGatewayRouteTableVirtualInterfaceGroupAssociationId = localGatewayRouteTableVirtualInterfaceGroupAssociationId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localGatewayRouteTableVirtualInterfaceGroupAssociationId = "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
    }

    public func validate() throws {
    }
}

public struct DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult: Codable, Equatable {
    public var localGatewayRouteTableVirtualInterfaceGroupAssociation: LocalGatewayRouteTableVirtualInterfaceGroupAssociation?

    public init(localGatewayRouteTableVirtualInterfaceGroupAssociation: LocalGatewayRouteTableVirtualInterfaceGroupAssociation? = nil) {
        self.localGatewayRouteTableVirtualInterfaceGroupAssociation = localGatewayRouteTableVirtualInterfaceGroupAssociation
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVirtualInterfaceGroupAssociation
    }

    public func validate() throws {
        try localGatewayRouteTableVirtualInterfaceGroupAssociation?.validate()
    }
}

public struct DeleteLocalGatewayRouteTableVpcAssociationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localGatewayRouteTableVpcAssociationId: LocalGatewayRouteTableVpcAssociationId

    public init(dryRun: Boolean? = nil,
                localGatewayRouteTableVpcAssociationId: LocalGatewayRouteTableVpcAssociationId) {
        self.dryRun = dryRun
        self.localGatewayRouteTableVpcAssociationId = localGatewayRouteTableVpcAssociationId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localGatewayRouteTableVpcAssociationId = "LocalGatewayRouteTableVpcAssociationId"
    }

    public func validate() throws {
    }
}

public struct DeleteLocalGatewayRouteTableVpcAssociationResult: Codable, Equatable {
    public var localGatewayRouteTableVpcAssociation: LocalGatewayRouteTableVpcAssociation?

    public init(localGatewayRouteTableVpcAssociation: LocalGatewayRouteTableVpcAssociation? = nil) {
        self.localGatewayRouteTableVpcAssociation = localGatewayRouteTableVpcAssociation
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVpcAssociation
    }

    public func validate() throws {
        try localGatewayRouteTableVpcAssociation?.validate()
    }
}

public struct DeleteManagedPrefixListRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId

    public init(dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId) {
        self.dryRun = dryRun
        self.prefixListId = prefixListId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
    }

    public func validate() throws {
    }
}

public struct DeleteManagedPrefixListResult: Codable, Equatable {
    public var prefixList: ManagedPrefixList?

    public init(prefixList: ManagedPrefixList? = nil) {
        self.prefixList = prefixList
    }

    enum CodingKeys: String, CodingKey {
        case prefixList
    }

    public func validate() throws {
        try prefixList?.validate()
    }
}

public struct DeleteNatGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var natGatewayId: NatGatewayId

    public init(dryRun: Boolean? = nil,
                natGatewayId: NatGatewayId) {
        self.dryRun = dryRun
        self.natGatewayId = natGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case natGatewayId = "NatGatewayId"
    }

    public func validate() throws {
    }
}

public struct DeleteNatGatewayResult: Codable, Equatable {
    public var natGatewayId: String?

    public init(natGatewayId: String? = nil) {
        self.natGatewayId = natGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case natGatewayId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkAclEntryRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var egress: Boolean
    public var networkAclId: NetworkAclId
    public var ruleNumber: Integer

    public init(dryRun: Boolean? = nil,
                egress: Boolean,
                networkAclId: NetworkAclId,
                ruleNumber: Integer) {
        self.dryRun = dryRun
        self.egress = egress
        self.networkAclId = networkAclId
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case egress
        case networkAclId
        case ruleNumber
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkAclRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkAclId: NetworkAclId

    public init(dryRun: Boolean? = nil,
                networkAclId: NetworkAclId) {
        self.dryRun = dryRun
        self.networkAclId = networkAclId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case networkAclId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsAccessScopeAnalysisRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId

    public init(dryRun: Boolean? = nil,
                networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId) {
        self.dryRun = dryRun
        self.networkInsightsAccessScopeAnalysisId = networkInsightsAccessScopeAnalysisId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case networkInsightsAccessScopeAnalysisId = "NetworkInsightsAccessScopeAnalysisId"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsAccessScopeAnalysisResult: Codable, Equatable {
    public var networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId?

    public init(networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId? = nil) {
        self.networkInsightsAccessScopeAnalysisId = networkInsightsAccessScopeAnalysisId
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAccessScopeAnalysisId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsAccessScopeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInsightsAccessScopeId: NetworkInsightsAccessScopeId

    public init(dryRun: Boolean? = nil,
                networkInsightsAccessScopeId: NetworkInsightsAccessScopeId) {
        self.dryRun = dryRun
        self.networkInsightsAccessScopeId = networkInsightsAccessScopeId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case networkInsightsAccessScopeId = "NetworkInsightsAccessScopeId"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsAccessScopeResult: Codable, Equatable {
    public var networkInsightsAccessScopeId: NetworkInsightsAccessScopeId?

    public init(networkInsightsAccessScopeId: NetworkInsightsAccessScopeId? = nil) {
        self.networkInsightsAccessScopeId = networkInsightsAccessScopeId
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAccessScopeId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsAnalysisRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInsightsAnalysisId: NetworkInsightsAnalysisId

    public init(dryRun: Boolean? = nil,
                networkInsightsAnalysisId: NetworkInsightsAnalysisId) {
        self.dryRun = dryRun
        self.networkInsightsAnalysisId = networkInsightsAnalysisId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case networkInsightsAnalysisId = "NetworkInsightsAnalysisId"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsAnalysisResult: Codable, Equatable {
    public var networkInsightsAnalysisId: NetworkInsightsAnalysisId?

    public init(networkInsightsAnalysisId: NetworkInsightsAnalysisId? = nil) {
        self.networkInsightsAnalysisId = networkInsightsAnalysisId
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAnalysisId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsPathRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInsightsPathId: NetworkInsightsPathId

    public init(dryRun: Boolean? = nil,
                networkInsightsPathId: NetworkInsightsPathId) {
        self.dryRun = dryRun
        self.networkInsightsPathId = networkInsightsPathId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case networkInsightsPathId = "NetworkInsightsPathId"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInsightsPathResult: Codable, Equatable {
    public var networkInsightsPathId: NetworkInsightsPathId?

    public init(networkInsightsPathId: NetworkInsightsPathId? = nil) {
        self.networkInsightsPathId = networkInsightsPathId
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsPathId
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInterfacePermissionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var force: Boolean?
    public var networkInterfacePermissionId: NetworkInterfacePermissionId

    public init(dryRun: Boolean? = nil,
                force: Boolean? = nil,
                networkInterfacePermissionId: NetworkInterfacePermissionId) {
        self.dryRun = dryRun
        self.force = force
        self.networkInterfacePermissionId = networkInterfacePermissionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case force = "Force"
        case networkInterfacePermissionId = "NetworkInterfacePermissionId"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInterfacePermissionResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DeleteNetworkInterfaceRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId

    public init(dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId) {
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct DeletePlacementGroupRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupName: PlacementGroupName

    public init(dryRun: Boolean? = nil,
                groupName: PlacementGroupName) {
        self.dryRun = dryRun
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case groupName
    }

    public func validate() throws {
    }
}

public struct DeletePublicIpv4PoolRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var poolId: Ipv4PoolEc2Id

    public init(dryRun: Boolean? = nil,
                poolId: Ipv4PoolEc2Id) {
        self.dryRun = dryRun
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case poolId = "PoolId"
    }

    public func validate() throws {
    }
}

public struct DeletePublicIpv4PoolResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue
    }

    public func validate() throws {
    }
}

public struct DeleteQueuedReservedInstancesError: Codable, Equatable {
    public var code: DeleteQueuedReservedInstancesErrorCode?
    public var message: String?

    public init(code: DeleteQueuedReservedInstancesErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct DeleteQueuedReservedInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var reservedInstancesIds: DeleteQueuedReservedInstancesIdList

    public init(dryRun: Boolean? = nil,
                reservedInstancesIds: DeleteQueuedReservedInstancesIdList) {
        self.dryRun = dryRun
        self.reservedInstancesIds = reservedInstancesIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case reservedInstancesIds = "ReservedInstancesId"
    }

    public func validate() throws {
        try reservedInstancesIds.validateAsDeleteQueuedReservedInstancesIdList()
    }
}

public struct DeleteQueuedReservedInstancesResult: Codable, Equatable {
    public var failedQueuedPurchaseDeletions: FailedQueuedPurchaseDeletionSet?
    public var successfulQueuedPurchaseDeletions: SuccessfulQueuedPurchaseDeletionSet?

    public init(failedQueuedPurchaseDeletions: FailedQueuedPurchaseDeletionSet? = nil,
                successfulQueuedPurchaseDeletions: SuccessfulQueuedPurchaseDeletionSet? = nil) {
        self.failedQueuedPurchaseDeletions = failedQueuedPurchaseDeletions
        self.successfulQueuedPurchaseDeletions = successfulQueuedPurchaseDeletions
    }

    enum CodingKeys: String, CodingKey {
        case failedQueuedPurchaseDeletions = "failedQueuedPurchaseDeletionSet"
        case successfulQueuedPurchaseDeletions = "successfulQueuedPurchaseDeletionSet"
    }

    public func validate() throws {
    }
}

public struct DeleteRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String?
    public var destinationIpv6CidrBlock: String?
    public var destinationPrefixListId: PrefixListResourceId?
    public var dryRun: Boolean?
    public var routeTableId: RouteTableId

    public init(destinationCidrBlock: String? = nil,
                destinationIpv6CidrBlock: String? = nil,
                destinationPrefixListId: PrefixListResourceId? = nil,
                dryRun: Boolean? = nil,
                routeTableId: RouteTableId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        self.destinationPrefixListId = destinationPrefixListId
        self.dryRun = dryRun
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock
        case destinationIpv6CidrBlock
        case destinationPrefixListId = "DestinationPrefixListId"
        case dryRun
        case routeTableId
    }

    public func validate() throws {
    }
}

public struct DeleteRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var routeTableId: RouteTableId

    public init(dryRun: Boolean? = nil,
                routeTableId: RouteTableId) {
        self.dryRun = dryRun
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case routeTableId
    }

    public func validate() throws {
    }
}

public struct DeleteSecurityGroupRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?

    public init(dryRun: Boolean? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil) {
        self.dryRun = dryRun
        self.groupId = groupId
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case groupId = "GroupId"
        case groupName = "GroupName"
    }

    public func validate() throws {
    }
}

public struct DeleteSnapshotRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var snapshotId: SnapshotId

    public init(dryRun: Boolean? = nil,
                snapshotId: SnapshotId) {
        self.dryRun = dryRun
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case snapshotId = "SnapshotId"
    }

    public func validate() throws {
    }
}

public struct DeleteSpotDatafeedSubscriptionRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DeleteSubnetCidrReservationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetCidrReservationId: SubnetCidrReservationId

    public init(dryRun: Boolean? = nil,
                subnetCidrReservationId: SubnetCidrReservationId) {
        self.dryRun = dryRun
        self.subnetCidrReservationId = subnetCidrReservationId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case subnetCidrReservationId = "SubnetCidrReservationId"
    }

    public func validate() throws {
    }
}

public struct DeleteSubnetCidrReservationResult: Codable, Equatable {
    public var deletedSubnetCidrReservation: SubnetCidrReservation?

    public init(deletedSubnetCidrReservation: SubnetCidrReservation? = nil) {
        self.deletedSubnetCidrReservation = deletedSubnetCidrReservation
    }

    enum CodingKeys: String, CodingKey {
        case deletedSubnetCidrReservation
    }

    public func validate() throws {
        try deletedSubnetCidrReservation?.validate()
    }
}

public struct DeleteSubnetRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetId: SubnetId

    public init(dryRun: Boolean? = nil,
                subnetId: SubnetId) {
        self.dryRun = dryRun
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case subnetId = "SubnetId"
    }

    public func validate() throws {
    }
}

public struct DeleteTagsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var resources: ResourceIdList
    public var tags: TagList?

    public init(dryRun: Boolean? = nil,
                resources: ResourceIdList,
                tags: TagList? = nil) {
        self.dryRun = dryRun
        self.resources = resources
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case resources = "resourceId"
        case tags = "tag"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorFilterRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var trafficMirrorFilterId: TrafficMirrorFilterId

    public init(dryRun: Boolean? = nil,
                trafficMirrorFilterId: TrafficMirrorFilterId) {
        self.dryRun = dryRun
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorFilterResult: Codable, Equatable {
    public var trafficMirrorFilterId: String?

    public init(trafficMirrorFilterId: String? = nil) {
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorFilterId
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorFilterRuleRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var trafficMirrorFilterRuleId: TrafficMirrorFilterRuleId

    public init(dryRun: Boolean? = nil,
                trafficMirrorFilterRuleId: TrafficMirrorFilterRuleId) {
        self.dryRun = dryRun
        self.trafficMirrorFilterRuleId = trafficMirrorFilterRuleId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case trafficMirrorFilterRuleId = "TrafficMirrorFilterRuleId"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorFilterRuleResult: Codable, Equatable {
    public var trafficMirrorFilterRuleId: String?

    public init(trafficMirrorFilterRuleId: String? = nil) {
        self.trafficMirrorFilterRuleId = trafficMirrorFilterRuleId
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorFilterRuleId
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorSessionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var trafficMirrorSessionId: TrafficMirrorSessionId

    public init(dryRun: Boolean? = nil,
                trafficMirrorSessionId: TrafficMirrorSessionId) {
        self.dryRun = dryRun
        self.trafficMirrorSessionId = trafficMirrorSessionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case trafficMirrorSessionId = "TrafficMirrorSessionId"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorSessionResult: Codable, Equatable {
    public var trafficMirrorSessionId: String?

    public init(trafficMirrorSessionId: String? = nil) {
        self.trafficMirrorSessionId = trafficMirrorSessionId
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorSessionId
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorTargetRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var trafficMirrorTargetId: TrafficMirrorTargetId

    public init(dryRun: Boolean? = nil,
                trafficMirrorTargetId: TrafficMirrorTargetId) {
        self.dryRun = dryRun
        self.trafficMirrorTargetId = trafficMirrorTargetId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case trafficMirrorTargetId = "TrafficMirrorTargetId"
    }

    public func validate() throws {
    }
}

public struct DeleteTrafficMirrorTargetResult: Codable, Equatable {
    public var trafficMirrorTargetId: String?

    public init(trafficMirrorTargetId: String? = nil) {
        self.trafficMirrorTargetId = trafficMirrorTargetId
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorTargetId
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayConnectPeerRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayConnectPeerId: TransitGatewayConnectPeerId

    public init(dryRun: Boolean? = nil,
                transitGatewayConnectPeerId: TransitGatewayConnectPeerId) {
        self.dryRun = dryRun
        self.transitGatewayConnectPeerId = transitGatewayConnectPeerId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayConnectPeerId = "TransitGatewayConnectPeerId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayConnectPeerResult: Codable, Equatable {
    public var transitGatewayConnectPeer: TransitGatewayConnectPeer?

    public init(transitGatewayConnectPeer: TransitGatewayConnectPeer? = nil) {
        self.transitGatewayConnectPeer = transitGatewayConnectPeer
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayConnectPeer
    }

    public func validate() throws {
        try transitGatewayConnectPeer?.validate()
    }
}

public struct DeleteTransitGatewayConnectRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayConnectResult: Codable, Equatable {
    public var transitGatewayConnect: TransitGatewayConnect?

    public init(transitGatewayConnect: TransitGatewayConnect? = nil) {
        self.transitGatewayConnect = transitGatewayConnect
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayConnect
    }

    public func validate() throws {
        try transitGatewayConnect?.validate()
    }
}

public struct DeleteTransitGatewayMulticastDomainRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId

    public init(dryRun: Boolean? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId) {
        self.dryRun = dryRun
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayMulticastDomainResult: Codable, Equatable {
    public var transitGatewayMulticastDomain: TransitGatewayMulticastDomain?

    public init(transitGatewayMulticastDomain: TransitGatewayMulticastDomain? = nil) {
        self.transitGatewayMulticastDomain = transitGatewayMulticastDomain
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayMulticastDomain
    }

    public func validate() throws {
        try transitGatewayMulticastDomain?.validate()
    }
}

public struct DeleteTransitGatewayPeeringAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayPeeringAttachmentResult: Codable, Equatable {
    public var transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment?

    public init(transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment? = nil) {
        self.transitGatewayPeeringAttachment = transitGatewayPeeringAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPeeringAttachment
    }

    public func validate() throws {
        try transitGatewayPeeringAttachment?.validate()
    }
}

public struct DeleteTransitGatewayPolicyTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayPolicyTableId: TransitGatewayPolicyTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayPolicyTableId: TransitGatewayPolicyTableId) {
        self.dryRun = dryRun
        self.transitGatewayPolicyTableId = transitGatewayPolicyTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayPolicyTableId = "TransitGatewayPolicyTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayPolicyTableResult: Codable, Equatable {
    public var transitGatewayPolicyTable: TransitGatewayPolicyTable?

    public init(transitGatewayPolicyTable: TransitGatewayPolicyTable? = nil) {
        self.transitGatewayPolicyTable = transitGatewayPolicyTable
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPolicyTable
    }

    public func validate() throws {
        try transitGatewayPolicyTable?.validate()
    }
}

public struct DeleteTransitGatewayPrefixListReferenceRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.prefixListId = prefixListId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayPrefixListReferenceResult: Codable, Equatable {
    public var transitGatewayPrefixListReference: TransitGatewayPrefixListReference?

    public init(transitGatewayPrefixListReference: TransitGatewayPrefixListReference? = nil) {
        self.transitGatewayPrefixListReference = transitGatewayPrefixListReference
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPrefixListReference
    }

    public func validate() throws {
        try transitGatewayPrefixListReference?.validate()
    }
}

public struct DeleteTransitGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayId: TransitGatewayId

    public init(dryRun: Boolean? = nil,
                transitGatewayId: TransitGatewayId) {
        self.dryRun = dryRun
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayResult: Codable, Equatable {
    public var transitGateway: TransitGateway?

    public init(transitGateway: TransitGateway? = nil) {
        self.transitGateway = transitGateway
    }

    enum CodingKeys: String, CodingKey {
        case transitGateway
    }

    public func validate() throws {
        try transitGateway?.validate()
    }
}

public struct DeleteTransitGatewayRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayRouteResult: Codable, Equatable {
    public var route: TransitGatewayRoute?

    public init(route: TransitGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct DeleteTransitGatewayRouteTableAnnouncementRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId

    public init(dryRun: Boolean? = nil,
                transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId) {
        self.dryRun = dryRun
        self.transitGatewayRouteTableAnnouncementId = transitGatewayRouteTableAnnouncementId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayRouteTableAnnouncementId = "TransitGatewayRouteTableAnnouncementId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayRouteTableAnnouncementResult: Codable, Equatable {
    public var transitGatewayRouteTableAnnouncement: TransitGatewayRouteTableAnnouncement?

    public init(transitGatewayRouteTableAnnouncement: TransitGatewayRouteTableAnnouncement? = nil) {
        self.transitGatewayRouteTableAnnouncement = transitGatewayRouteTableAnnouncement
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayRouteTableAnnouncement
    }

    public func validate() throws {
        try transitGatewayRouteTableAnnouncement?.validate()
    }
}

public struct DeleteTransitGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayRouteTableResult: Codable, Equatable {
    public var transitGatewayRouteTable: TransitGatewayRouteTable?

    public init(transitGatewayRouteTable: TransitGatewayRouteTable? = nil) {
        self.transitGatewayRouteTable = transitGatewayRouteTable
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayRouteTable
    }

    public func validate() throws {
        try transitGatewayRouteTable?.validate()
    }
}

public struct DeleteTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct DeleteTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct DeleteVerifiedAccessEndpointRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var verifiedAccessEndpointId: VerifiedAccessEndpointId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                verifiedAccessEndpointId: VerifiedAccessEndpointId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.verifiedAccessEndpointId = verifiedAccessEndpointId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case verifiedAccessEndpointId = "VerifiedAccessEndpointId"
    }

    public func validate() throws {
    }
}

public struct DeleteVerifiedAccessEndpointResult: Codable, Equatable {
    public var verifiedAccessEndpoint: VerifiedAccessEndpoint?

    public init(verifiedAccessEndpoint: VerifiedAccessEndpoint? = nil) {
        self.verifiedAccessEndpoint = verifiedAccessEndpoint
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessEndpoint
    }

    public func validate() throws {
        try verifiedAccessEndpoint?.validate()
    }
}

public struct DeleteVerifiedAccessGroupRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var verifiedAccessGroupId: VerifiedAccessGroupId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                verifiedAccessGroupId: VerifiedAccessGroupId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.verifiedAccessGroupId = verifiedAccessGroupId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case verifiedAccessGroupId = "VerifiedAccessGroupId"
    }

    public func validate() throws {
    }
}

public struct DeleteVerifiedAccessGroupResult: Codable, Equatable {
    public var verifiedAccessGroup: VerifiedAccessGroup?

    public init(verifiedAccessGroup: VerifiedAccessGroup? = nil) {
        self.verifiedAccessGroup = verifiedAccessGroup
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessGroup
    }

    public func validate() throws {
        try verifiedAccessGroup?.validate()
    }
}

public struct DeleteVerifiedAccessInstanceRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var verifiedAccessInstanceId: VerifiedAccessInstanceId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                verifiedAccessInstanceId: VerifiedAccessInstanceId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case verifiedAccessInstanceId = "VerifiedAccessInstanceId"
    }

    public func validate() throws {
    }
}

public struct DeleteVerifiedAccessInstanceResult: Codable, Equatable {
    public var verifiedAccessInstance: VerifiedAccessInstance?

    public init(verifiedAccessInstance: VerifiedAccessInstance? = nil) {
        self.verifiedAccessInstance = verifiedAccessInstance
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessInstance
    }

    public func validate() throws {
        try verifiedAccessInstance?.validate()
    }
}

public struct DeleteVerifiedAccessTrustProviderRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var verifiedAccessTrustProviderId: VerifiedAccessTrustProviderId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                verifiedAccessTrustProviderId: VerifiedAccessTrustProviderId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.verifiedAccessTrustProviderId = verifiedAccessTrustProviderId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case verifiedAccessTrustProviderId = "VerifiedAccessTrustProviderId"
    }

    public func validate() throws {
    }
}

public struct DeleteVerifiedAccessTrustProviderResult: Codable, Equatable {
    public var verifiedAccessTrustProvider: VerifiedAccessTrustProvider?

    public init(verifiedAccessTrustProvider: VerifiedAccessTrustProvider? = nil) {
        self.verifiedAccessTrustProvider = verifiedAccessTrustProvider
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessTrustProvider
    }

    public func validate() throws {
        try verifiedAccessTrustProvider?.validate()
    }
}

public struct DeleteVolumeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var volumeId: VolumeId

    public init(dryRun: Boolean? = nil,
                volumeId: VolumeId) {
        self.dryRun = dryRun
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointConnectionNotificationsRequest: Codable, Equatable {
    public var connectionNotificationIds: ConnectionNotificationIdsList
    public var dryRun: Boolean?

    public init(connectionNotificationIds: ConnectionNotificationIdsList,
                dryRun: Boolean? = nil) {
        self.connectionNotificationIds = connectionNotificationIds
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case connectionNotificationIds = "ConnectionNotificationId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointConnectionNotificationsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointServiceConfigurationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var serviceIds: VpcEndpointServiceIdList

    public init(dryRun: Boolean? = nil,
                serviceIds: VpcEndpointServiceIdList) {
        self.dryRun = dryRun
        self.serviceIds = serviceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case serviceIds = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointServiceConfigurationsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcEndpointIds: VpcEndpointIdList

    public init(dryRun: Boolean? = nil,
                vpcEndpointIds: VpcEndpointIdList) {
        self.dryRun = dryRun
        self.vpcEndpointIds = vpcEndpointIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case vpcEndpointIds = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcEndpointsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DeleteVpcPeeringConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId

    public init(dryRun: Boolean? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId) {
        self.dryRun = dryRun
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct DeleteVpcPeeringConnectionResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DeleteVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpnConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpnConnectionId: VpnConnectionId

    public init(dryRun: Boolean? = nil,
                vpnConnectionId: VpnConnectionId) {
        self.dryRun = dryRun
        self.vpnConnectionId = vpnConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpnConnectionId = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpnConnectionRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var vpnConnectionId: VpnConnectionId

    public init(destinationCidrBlock: String,
                vpnConnectionId: VpnConnectionId) {
        self.destinationCidrBlock = destinationCidrBlock
        self.vpnConnectionId = vpnConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case vpnConnectionId = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct DeleteVpnGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpnGatewayId: VpnGatewayId

    public init(dryRun: Boolean? = nil,
                vpnGatewayId: VpnGatewayId) {
        self.dryRun = dryRun
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct DeprovisionByoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?

    public init(cidr: String,
                dryRun: Boolean? = nil) {
        self.cidr = cidr
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DeprovisionByoipCidrResult: Codable, Equatable {
    public var byoipCidr: ByoipCidr?

    public init(byoipCidr: ByoipCidr? = nil) {
        self.byoipCidr = byoipCidr
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidr
    }

    public func validate() throws {
        try byoipCidr?.validate()
    }
}

public struct DeprovisionIpamPoolCidrRequest: Codable, Equatable {
    public var cidr: String?
    public var dryRun: Boolean?
    public var ipamPoolId: IpamPoolId

    public init(cidr: String? = nil,
                dryRun: Boolean? = nil,
                ipamPoolId: IpamPoolId) {
        self.cidr = cidr
        self.dryRun = dryRun
        self.ipamPoolId = ipamPoolId
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
        case ipamPoolId = "IpamPoolId"
    }

    public func validate() throws {
    }
}

public struct DeprovisionIpamPoolCidrResult: Codable, Equatable {
    public var ipamPoolCidr: IpamPoolCidr?

    public init(ipamPoolCidr: IpamPoolCidr? = nil) {
        self.ipamPoolCidr = ipamPoolCidr
    }

    enum CodingKeys: String, CodingKey {
        case ipamPoolCidr
    }

    public func validate() throws {
        try ipamPoolCidr?.validate()
    }
}

public struct DeprovisionPublicIpv4PoolCidrRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?
    public var poolId: Ipv4PoolEc2Id

    public init(cidr: String,
                dryRun: Boolean? = nil,
                poolId: Ipv4PoolEc2Id) {
        self.cidr = cidr
        self.dryRun = dryRun
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
        case poolId = "PoolId"
    }

    public func validate() throws {
    }
}

public struct DeprovisionPublicIpv4PoolCidrResult: Codable, Equatable {
    public var deprovisionedAddresses: DeprovisionedAddressSet?
    public var poolId: Ipv4PoolEc2Id?

    public init(deprovisionedAddresses: DeprovisionedAddressSet? = nil,
                poolId: Ipv4PoolEc2Id? = nil) {
        self.deprovisionedAddresses = deprovisionedAddresses
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case deprovisionedAddresses = "deprovisionedAddressSet"
        case poolId
    }

    public func validate() throws {
    }
}

public struct DeregisterImageRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct DeregisterInstanceEventNotificationAttributesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceTagAttribute: DeregisterInstanceTagAttributeRequest?

    public init(dryRun: Boolean? = nil,
                instanceTagAttribute: DeregisterInstanceTagAttributeRequest? = nil) {
        self.dryRun = dryRun
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceTagAttribute = "InstanceTagAttribute"
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct DeregisterInstanceEventNotificationAttributesResult: Codable, Equatable {
    public var instanceTagAttribute: InstanceTagNotificationAttribute?

    public init(instanceTagAttribute: InstanceTagNotificationAttribute? = nil) {
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case instanceTagAttribute
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct DeregisterInstanceTagAttributeRequest: Codable, Equatable {
    public var includeAllTagsOfInstance: Boolean?
    public var instanceTagKeys: InstanceTagKeySet?

    public init(includeAllTagsOfInstance: Boolean? = nil,
                instanceTagKeys: InstanceTagKeySet? = nil) {
        self.includeAllTagsOfInstance = includeAllTagsOfInstance
        self.instanceTagKeys = instanceTagKeys
    }

    enum CodingKeys: String, CodingKey {
        case includeAllTagsOfInstance = "IncludeAllTagsOfInstance"
        case instanceTagKeys = "InstanceTagKey"
    }

    public func validate() throws {
    }
}

public struct DeregisterTransitGatewayMulticastGroupMembersRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupIpAddress: String?
    public var networkInterfaceIds: TransitGatewayNetworkInterfaceIdList?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                groupIpAddress: String? = nil,
                networkInterfaceIds: TransitGatewayNetworkInterfaceIdList? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.groupIpAddress = groupIpAddress
        self.networkInterfaceIds = networkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupIpAddress = "GroupIpAddress"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct DeregisterTransitGatewayMulticastGroupMembersResult: Codable, Equatable {
    public var deregisteredMulticastGroupMembers: TransitGatewayMulticastDeregisteredGroupMembers?

    public init(deregisteredMulticastGroupMembers: TransitGatewayMulticastDeregisteredGroupMembers? = nil) {
        self.deregisteredMulticastGroupMembers = deregisteredMulticastGroupMembers
    }

    enum CodingKeys: String, CodingKey {
        case deregisteredMulticastGroupMembers
    }

    public func validate() throws {
        try deregisteredMulticastGroupMembers?.validate()
    }
}

public struct DeregisterTransitGatewayMulticastGroupSourcesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupIpAddress: String?
    public var networkInterfaceIds: TransitGatewayNetworkInterfaceIdList?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                groupIpAddress: String? = nil,
                networkInterfaceIds: TransitGatewayNetworkInterfaceIdList? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.groupIpAddress = groupIpAddress
        self.networkInterfaceIds = networkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupIpAddress = "GroupIpAddress"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct DeregisterTransitGatewayMulticastGroupSourcesResult: Codable, Equatable {
    public var deregisteredMulticastGroupSources: TransitGatewayMulticastDeregisteredGroupSources?

    public init(deregisteredMulticastGroupSources: TransitGatewayMulticastDeregisteredGroupSources? = nil) {
        self.deregisteredMulticastGroupSources = deregisteredMulticastGroupSources
    }

    enum CodingKeys: String, CodingKey {
        case deregisteredMulticastGroupSources
    }

    public func validate() throws {
        try deregisteredMulticastGroupSources?.validate()
    }
}

public struct DescribeAccountAttributesRequest: Codable, Equatable {
    public var attributeNames: AccountAttributeNameStringList?
    public var dryRun: Boolean?

    public init(attributeNames: AccountAttributeNameStringList? = nil,
                dryRun: Boolean? = nil) {
        self.attributeNames = attributeNames
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case attributeNames = "attributeName"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DescribeAccountAttributesResult: Codable, Equatable {
    public var accountAttributes: AccountAttributeList?

    public init(accountAttributes: AccountAttributeList? = nil) {
        self.accountAttributes = accountAttributes
    }

    enum CodingKeys: String, CodingKey {
        case accountAttributes = "accountAttributeSet"
    }

    public func validate() throws {
    }
}

public struct DescribeAddressTransfersRequest: Codable, Equatable {
    public var allocationIds: AllocationIdList?
    public var dryRun: Boolean?
    public var maxResults: DescribeAddressTransfersMaxResults?
    public var nextToken: String?

    public init(allocationIds: AllocationIdList? = nil,
                dryRun: Boolean? = nil,
                maxResults: DescribeAddressTransfersMaxResults? = nil,
                nextToken: String? = nil) {
        self.allocationIds = allocationIds
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case allocationIds = "AllocationId"
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeAddressTransfersMaxResults()
    }
}

public struct DescribeAddressTransfersResult: Codable, Equatable {
    public var addressTransfers: AddressTransferList?
    public var nextToken: String?

    public init(addressTransfers: AddressTransferList? = nil,
                nextToken: String? = nil) {
        self.addressTransfers = addressTransfers
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case addressTransfers = "addressTransferSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeAddressesAttributeRequest: Codable, Equatable {
    public var allocationIds: AllocationIds?
    public var attribute: AddressAttributeName?
    public var dryRun: Boolean?
    public var maxResults: AddressMaxResults?
    public var nextToken: NextToken?

    public init(allocationIds: AllocationIds? = nil,
                attribute: AddressAttributeName? = nil,
                dryRun: Boolean? = nil,
                maxResults: AddressMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.allocationIds = allocationIds
        self.attribute = attribute
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case allocationIds = "AllocationId"
        case attribute = "Attribute"
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsAddressMaxResults()
    }
}

public struct DescribeAddressesAttributeResult: Codable, Equatable {
    public var addresses: AddressSet?
    public var nextToken: NextToken?

    public init(addresses: AddressSet? = nil,
                nextToken: NextToken? = nil) {
        self.addresses = addresses
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case addresses = "addressSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeAddressesRequest: Codable, Equatable {
    public var allocationIds: AllocationIdList?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var publicIps: PublicIpStringList?

    public init(allocationIds: AllocationIdList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                publicIps: PublicIpStringList? = nil) {
        self.allocationIds = allocationIds
        self.dryRun = dryRun
        self.filters = filters
        self.publicIps = publicIps
    }

    enum CodingKeys: String, CodingKey {
        case allocationIds = "AllocationId"
        case dryRun
        case filters = "Filter"
        case publicIps = "PublicIp"
    }

    public func validate() throws {
    }
}

public struct DescribeAddressesResult: Codable, Equatable {
    public var addresses: AddressList?

    public init(addresses: AddressList? = nil) {
        self.addresses = addresses
    }

    enum CodingKeys: String, CodingKey {
        case addresses = "addressesSet"
    }

    public func validate() throws {
    }
}

public struct DescribeAggregateIdFormatRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DescribeAggregateIdFormatResult: Codable, Equatable {
    public var statuses: IdFormatList?
    public var useLongIdsAggregated: Boolean?

    public init(statuses: IdFormatList? = nil,
                useLongIdsAggregated: Boolean? = nil) {
        self.statuses = statuses
        self.useLongIdsAggregated = useLongIdsAggregated
    }

    enum CodingKeys: String, CodingKey {
        case statuses = "statusSet"
        case useLongIdsAggregated
    }

    public func validate() throws {
    }
}

public struct DescribeAvailabilityZonesRequest: Codable, Equatable {
    public var allAvailabilityZones: Boolean?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var zoneIds: ZoneIdStringList?
    public var zoneNames: ZoneNameStringList?

    public init(allAvailabilityZones: Boolean? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                zoneIds: ZoneIdStringList? = nil,
                zoneNames: ZoneNameStringList? = nil) {
        self.allAvailabilityZones = allAvailabilityZones
        self.dryRun = dryRun
        self.filters = filters
        self.zoneIds = zoneIds
        self.zoneNames = zoneNames
    }

    enum CodingKeys: String, CodingKey {
        case allAvailabilityZones = "AllAvailabilityZones"
        case dryRun
        case filters = "Filter"
        case zoneIds = "ZoneId"
        case zoneNames = "ZoneName"
    }

    public func validate() throws {
    }
}

public struct DescribeAvailabilityZonesResult: Codable, Equatable {
    public var availabilityZones: AvailabilityZoneList?

    public init(availabilityZones: AvailabilityZoneList? = nil) {
        self.availabilityZones = availabilityZones
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZones = "availabilityZoneInfo"
    }

    public func validate() throws {
    }
}

public struct DescribeAwsNetworkPerformanceMetricSubscriptionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: MaxResultsParam?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: MaxResultsParam? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsMaxResultsParam()
    }
}

public struct DescribeAwsNetworkPerformanceMetricSubscriptionsResult: Codable, Equatable {
    public var nextToken: String?
    public var subscriptions: SubscriptionList?

    public init(nextToken: String? = nil,
                subscriptions: SubscriptionList? = nil) {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case subscriptions = "subscriptionSet"
    }

    public func validate() throws {
    }
}

public struct DescribeBundleTasksRequest: Codable, Equatable {
    public var bundleIds: BundleIdStringList?
    public var dryRun: Boolean?
    public var filters: FilterList?

    public init(bundleIds: BundleIdStringList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil) {
        self.bundleIds = bundleIds
        self.dryRun = dryRun
        self.filters = filters
    }

    enum CodingKeys: String, CodingKey {
        case bundleIds = "BundleId"
        case dryRun
        case filters = "Filter"
    }

    public func validate() throws {
    }
}

public struct DescribeBundleTasksResult: Codable, Equatable {
    public var bundleTasks: BundleTaskList?

    public init(bundleTasks: BundleTaskList? = nil) {
        self.bundleTasks = bundleTasks
    }

    enum CodingKeys: String, CodingKey {
        case bundleTasks = "bundleInstanceTasksSet"
    }

    public func validate() throws {
    }
}

public struct DescribeByoipCidrsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: DescribeByoipCidrsMaxResults
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                maxResults: DescribeByoipCidrsMaxResults,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults.validateAsDescribeByoipCidrsMaxResults()
    }
}

public struct DescribeByoipCidrsResult: Codable, Equatable {
    public var byoipCidrs: ByoipCidrSet?
    public var nextToken: String?

    public init(byoipCidrs: ByoipCidrSet? = nil,
                nextToken: String? = nil) {
        self.byoipCidrs = byoipCidrs
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidrs = "byoipCidrSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeCapacityReservationFleetsRequest: Codable, Equatable {
    public var capacityReservationFleetIds: CapacityReservationFleetIdSet?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeCapacityReservationFleetsMaxResults?
    public var nextToken: String?

    public init(capacityReservationFleetIds: CapacityReservationFleetIdSet? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeCapacityReservationFleetsMaxResults? = nil,
                nextToken: String? = nil) {
        self.capacityReservationFleetIds = capacityReservationFleetIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationFleetIds = "CapacityReservationFleetId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeCapacityReservationFleetsMaxResults()
    }
}

public struct DescribeCapacityReservationFleetsResult: Codable, Equatable {
    public var capacityReservationFleets: CapacityReservationFleetSet?
    public var nextToken: String?

    public init(capacityReservationFleets: CapacityReservationFleetSet? = nil,
                nextToken: String? = nil) {
        self.capacityReservationFleets = capacityReservationFleets
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationFleets = "capacityReservationFleetSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeCapacityReservationsRequest: Codable, Equatable {
    public var capacityReservationIds: CapacityReservationIdSet?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeCapacityReservationsMaxResults?
    public var nextToken: String?

    public init(capacityReservationIds: CapacityReservationIdSet? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeCapacityReservationsMaxResults? = nil,
                nextToken: String? = nil) {
        self.capacityReservationIds = capacityReservationIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationIds = "CapacityReservationId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeCapacityReservationsMaxResults()
    }
}

public struct DescribeCapacityReservationsResult: Codable, Equatable {
    public var capacityReservations: CapacityReservationSet?
    public var nextToken: String?

    public init(capacityReservations: CapacityReservationSet? = nil,
                nextToken: String? = nil) {
        self.capacityReservations = capacityReservations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservations = "capacityReservationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeCarrierGatewaysRequest: Codable, Equatable {
    public var carrierGatewayIds: CarrierGatewayIdSet?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: CarrierGatewayMaxResults?
    public var nextToken: String?

    public init(carrierGatewayIds: CarrierGatewayIdSet? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: CarrierGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.carrierGatewayIds = carrierGatewayIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayIds = "CarrierGatewayId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsCarrierGatewayMaxResults()
    }
}

public struct DescribeCarrierGatewaysResult: Codable, Equatable {
    public var carrierGateways: CarrierGatewaySet?
    public var nextToken: String?

    public init(carrierGateways: CarrierGatewaySet? = nil,
                nextToken: String? = nil) {
        self.carrierGateways = carrierGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case carrierGateways = "carrierGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClassicLinkInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var instanceIds: InstanceIdStringList?
    public var maxResults: DescribeClassicLinkInstancesMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                instanceIds: InstanceIdStringList? = nil,
                maxResults: DescribeClassicLinkInstancesMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case instanceIds = "InstanceId"
        case maxResults
        case nextToken
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClassicLinkInstancesMaxResults()
    }
}

public struct DescribeClassicLinkInstancesResult: Codable, Equatable {
    public var instances: ClassicLinkInstanceList?
    public var nextToken: String?

    public init(instances: ClassicLinkInstanceList? = nil,
                nextToken: String? = nil) {
        self.instances = instances
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instances = "instancesSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnAuthorizationRulesRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnAuthorizationRulesMaxResults?
    public var nextToken: NextToken?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnAuthorizationRulesMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnAuthorizationRulesMaxResults()
    }
}

public struct DescribeClientVpnAuthorizationRulesResult: Codable, Equatable {
    public var authorizationRules: AuthorizationRuleSet?
    public var nextToken: NextToken?

    public init(authorizationRules: AuthorizationRuleSet? = nil,
                nextToken: NextToken? = nil) {
        self.authorizationRules = authorizationRules
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case authorizationRules = "authorizationRule"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnConnectionsRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnConnectionsMaxResults?
    public var nextToken: NextToken?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnConnectionsMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnConnectionsMaxResults()
    }
}

public struct DescribeClientVpnConnectionsResult: Codable, Equatable {
    public var connections: ClientVpnConnectionSet?
    public var nextToken: NextToken?

    public init(connections: ClientVpnConnectionSet? = nil,
                nextToken: NextToken? = nil) {
        self.connections = connections
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case connections
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnEndpointsRequest: Codable, Equatable {
    public var clientVpnEndpointIds: ClientVpnEndpointIdList?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnEndpointMaxResults?
    public var nextToken: NextToken?

    public init(clientVpnEndpointIds: ClientVpnEndpointIdList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnEndpointMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpointIds = clientVpnEndpointIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointIds = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnEndpointMaxResults()
    }
}

public struct DescribeClientVpnEndpointsResult: Codable, Equatable {
    public var clientVpnEndpoints: EndpointSet?
    public var nextToken: NextToken?

    public init(clientVpnEndpoints: EndpointSet? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpoints = clientVpnEndpoints
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpoints = "clientVpnEndpoint"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnRoutesRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnRoutesMaxResults?
    public var nextToken: NextToken?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnRoutesMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnRoutesMaxResults()
    }
}

public struct DescribeClientVpnRoutesResult: Codable, Equatable {
    public var nextToken: NextToken?
    public var routes: ClientVpnRouteSet?

    public init(nextToken: NextToken? = nil,
                routes: ClientVpnRouteSet? = nil) {
        self.nextToken = nextToken
        self.routes = routes
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case routes
    }

    public func validate() throws {
    }
}

public struct DescribeClientVpnTargetNetworksRequest: Codable, Equatable {
    public var associationIds: ValueStringList?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeClientVpnTargetNetworksMaxResults?
    public var nextToken: NextToken?

    public init(associationIds: ValueStringList? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeClientVpnTargetNetworksMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.associationIds = associationIds
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case associationIds = "AssociationIds"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeClientVpnTargetNetworksMaxResults()
    }
}

public struct DescribeClientVpnTargetNetworksResult: Codable, Equatable {
    public var clientVpnTargetNetworks: TargetNetworkSet?
    public var nextToken: NextToken?

    public init(clientVpnTargetNetworks: TargetNetworkSet? = nil,
                nextToken: NextToken? = nil) {
        self.clientVpnTargetNetworks = clientVpnTargetNetworks
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnTargetNetworks
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeCoipPoolsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: CoipPoolMaxResults?
    public var nextToken: String?
    public var poolIds: CoipPoolIdSet?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: CoipPoolMaxResults? = nil,
                nextToken: String? = nil,
                poolIds: CoipPoolIdSet? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolIds = poolIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsCoipPoolMaxResults()
    }
}

public struct DescribeCoipPoolsResult: Codable, Equatable {
    public var coipPools: CoipPoolSet?
    public var nextToken: String?

    public init(coipPools: CoipPoolSet? = nil,
                nextToken: String? = nil) {
        self.coipPools = coipPools
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case coipPools = "coipPoolSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeConversionTasksRequest: Codable, Equatable {
    public var conversionTaskIds: ConversionIdStringList?
    public var dryRun: Boolean?

    public init(conversionTaskIds: ConversionIdStringList? = nil,
                dryRun: Boolean? = nil) {
        self.conversionTaskIds = conversionTaskIds
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case conversionTaskIds = "conversionTaskId"
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DescribeConversionTasksResult: Codable, Equatable {
    public var conversionTasks: DescribeConversionTaskList?

    public init(conversionTasks: DescribeConversionTaskList? = nil) {
        self.conversionTasks = conversionTasks
    }

    enum CodingKeys: String, CodingKey {
        case conversionTasks
    }

    public func validate() throws {
    }
}

public struct DescribeCustomerGatewaysRequest: Codable, Equatable {
    public var customerGatewayIds: CustomerGatewayIdStringList?
    public var dryRun: Boolean?
    public var filters: FilterList?

    public init(customerGatewayIds: CustomerGatewayIdStringList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil) {
        self.customerGatewayIds = customerGatewayIds
        self.dryRun = dryRun
        self.filters = filters
    }

    enum CodingKeys: String, CodingKey {
        case customerGatewayIds = "CustomerGatewayId"
        case dryRun
        case filters = "Filter"
    }

    public func validate() throws {
    }
}

public struct DescribeCustomerGatewaysResult: Codable, Equatable {
    public var customerGateways: CustomerGatewayList?

    public init(customerGateways: CustomerGatewayList? = nil) {
        self.customerGateways = customerGateways
    }

    enum CodingKeys: String, CodingKey {
        case customerGateways = "customerGatewaySet"
    }

    public func validate() throws {
    }
}

public struct DescribeDhcpOptionsRequest: Codable, Equatable {
    public var dhcpOptionsIds: DhcpOptionsIdStringList?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeDhcpOptionsMaxResults?
    public var nextToken: String?

    public init(dhcpOptionsIds: DhcpOptionsIdStringList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeDhcpOptionsMaxResults? = nil,
                nextToken: String? = nil) {
        self.dhcpOptionsIds = dhcpOptionsIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptionsIds = "DhcpOptionsId"
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeDhcpOptionsMaxResults()
    }
}

public struct DescribeDhcpOptionsResult: Codable, Equatable {
    public var dhcpOptions: DhcpOptionsList?
    public var nextToken: String?

    public init(dhcpOptions: DhcpOptionsList? = nil,
                nextToken: String? = nil) {
        self.dhcpOptions = dhcpOptions
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dhcpOptions = "dhcpOptionsSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeEgressOnlyInternetGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var egressOnlyInternetGatewayIds: EgressOnlyInternetGatewayIdList?
    public var filters: FilterList?
    public var maxResults: DescribeEgressOnlyInternetGatewaysMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                egressOnlyInternetGatewayIds: EgressOnlyInternetGatewayIdList? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeEgressOnlyInternetGatewaysMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.egressOnlyInternetGatewayIds = egressOnlyInternetGatewayIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case egressOnlyInternetGatewayIds = "EgressOnlyInternetGatewayId"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeEgressOnlyInternetGatewaysMaxResults()
    }
}

public struct DescribeEgressOnlyInternetGatewaysResult: Codable, Equatable {
    public var egressOnlyInternetGateways: EgressOnlyInternetGatewayList?
    public var nextToken: String?

    public init(egressOnlyInternetGateways: EgressOnlyInternetGatewayList? = nil,
                nextToken: String? = nil) {
        self.egressOnlyInternetGateways = egressOnlyInternetGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case egressOnlyInternetGateways = "egressOnlyInternetGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeElasticGpusRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var elasticGpuIds: ElasticGpuIdSet?
    public var filters: FilterList?
    public var maxResults: DescribeElasticGpusMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                elasticGpuIds: ElasticGpuIdSet? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeElasticGpusMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.elasticGpuIds = elasticGpuIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case elasticGpuIds = "ElasticGpuId"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeElasticGpusMaxResults()
    }
}

public struct DescribeElasticGpusResult: Codable, Equatable {
    public var elasticGpuSet: ElasticGpuSet?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(elasticGpuSet: ElasticGpuSet? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.elasticGpuSet = elasticGpuSet
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case elasticGpuSet
        case maxResults
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeExportImageTasksRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var exportImageTaskIds: ExportImageTaskIdList?
    public var filters: FilterList?
    public var maxResults: DescribeExportImageTasksMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                exportImageTaskIds: ExportImageTaskIdList? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeExportImageTasksMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.exportImageTaskIds = exportImageTaskIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case exportImageTaskIds = "ExportImageTaskId"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeExportImageTasksMaxResults()
    }
}

public struct DescribeExportImageTasksResult: Codable, Equatable {
    public var exportImageTasks: ExportImageTaskList?
    public var nextToken: NextToken?

    public init(exportImageTasks: ExportImageTaskList? = nil,
                nextToken: NextToken? = nil) {
        self.exportImageTasks = exportImageTasks
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case exportImageTasks = "exportImageTaskSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeExportTasksRequest: Codable, Equatable {
    public var exportTaskIds: ExportTaskIdStringList?
    public var filters: FilterList?

    public init(exportTaskIds: ExportTaskIdStringList? = nil,
                filters: FilterList? = nil) {
        self.exportTaskIds = exportTaskIds
        self.filters = filters
    }

    enum CodingKeys: String, CodingKey {
        case exportTaskIds = "exportTaskId"
        case filters = "Filter"
    }

    public func validate() throws {
    }
}

public struct DescribeExportTasksResult: Codable, Equatable {
    public var exportTasks: ExportTaskList?

    public init(exportTasks: ExportTaskList? = nil) {
        self.exportTasks = exportTasks
    }

    enum CodingKeys: String, CodingKey {
        case exportTasks = "exportTaskSet"
    }

    public func validate() throws {
    }
}

public struct DescribeFastLaunchImagesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var imageIds: FastLaunchImageIdList?
    public var maxResults: DescribeFastLaunchImagesRequestMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                imageIds: FastLaunchImageIdList? = nil,
                maxResults: DescribeFastLaunchImagesRequestMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case imageIds = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeFastLaunchImagesRequestMaxResults()
    }
}

public struct DescribeFastLaunchImagesResult: Codable, Equatable {
    public var fastLaunchImages: DescribeFastLaunchImagesSuccessSet?
    public var nextToken: NextToken?

    public init(fastLaunchImages: DescribeFastLaunchImagesSuccessSet? = nil,
                nextToken: NextToken? = nil) {
        self.fastLaunchImages = fastLaunchImages
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case fastLaunchImages = "fastLaunchImageSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeFastLaunchImagesSuccessItem: Codable, Equatable {
    public var imageId: ImageId?
    public var launchTemplate: FastLaunchLaunchTemplateSpecificationResponse?
    public var maxParallelLaunches: Integer?
    public var ownerId: String?
    public var resourceType: FastLaunchResourceType?
    public var snapshotConfiguration: FastLaunchSnapshotConfigurationResponse?
    public var state: FastLaunchStateCode?
    public var stateTransitionReason: String?
    public var stateTransitionTime: MillisecondDateTime?

    public init(imageId: ImageId? = nil,
                launchTemplate: FastLaunchLaunchTemplateSpecificationResponse? = nil,
                maxParallelLaunches: Integer? = nil,
                ownerId: String? = nil,
                resourceType: FastLaunchResourceType? = nil,
                snapshotConfiguration: FastLaunchSnapshotConfigurationResponse? = nil,
                state: FastLaunchStateCode? = nil,
                stateTransitionReason: String? = nil,
                stateTransitionTime: MillisecondDateTime? = nil) {
        self.imageId = imageId
        self.launchTemplate = launchTemplate
        self.maxParallelLaunches = maxParallelLaunches
        self.ownerId = ownerId
        self.resourceType = resourceType
        self.snapshotConfiguration = snapshotConfiguration
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.stateTransitionTime = stateTransitionTime
    }

    enum CodingKeys: String, CodingKey {
        case imageId
        case launchTemplate
        case maxParallelLaunches
        case ownerId
        case resourceType
        case snapshotConfiguration
        case state
        case stateTransitionReason
        case stateTransitionTime
    }

    public func validate() throws {
        try launchTemplate?.validate()
        try snapshotConfiguration?.validate()
    }
}

public struct DescribeFastSnapshotRestoreSuccessItem: Codable, Equatable {
    public var availabilityZone: String?
    public var disabledTime: MillisecondDateTime?
    public var disablingTime: MillisecondDateTime?
    public var enabledTime: MillisecondDateTime?
    public var enablingTime: MillisecondDateTime?
    public var optimizingTime: MillisecondDateTime?
    public var ownerAlias: String?
    public var ownerId: String?
    public var snapshotId: String?
    public var state: FastSnapshotRestoreStateCode?
    public var stateTransitionReason: String?

    public init(availabilityZone: String? = nil,
                disabledTime: MillisecondDateTime? = nil,
                disablingTime: MillisecondDateTime? = nil,
                enabledTime: MillisecondDateTime? = nil,
                enablingTime: MillisecondDateTime? = nil,
                optimizingTime: MillisecondDateTime? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                snapshotId: String? = nil,
                state: FastSnapshotRestoreStateCode? = nil,
                stateTransitionReason: String? = nil) {
        self.availabilityZone = availabilityZone
        self.disabledTime = disabledTime
        self.disablingTime = disablingTime
        self.enabledTime = enabledTime
        self.enablingTime = enablingTime
        self.optimizingTime = optimizingTime
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.snapshotId = snapshotId
        self.state = state
        self.stateTransitionReason = stateTransitionReason
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case disabledTime
        case disablingTime
        case enabledTime
        case enablingTime
        case optimizingTime
        case ownerAlias
        case ownerId
        case snapshotId
        case state
        case stateTransitionReason
    }

    public func validate() throws {
    }
}

public struct DescribeFastSnapshotRestoresRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeFastSnapshotRestoresMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeFastSnapshotRestoresMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeFastSnapshotRestoresMaxResults()
    }
}

public struct DescribeFastSnapshotRestoresResult: Codable, Equatable {
    public var fastSnapshotRestores: DescribeFastSnapshotRestoreSuccessSet?
    public var nextToken: NextToken?

    public init(fastSnapshotRestores: DescribeFastSnapshotRestoreSuccessSet? = nil,
                nextToken: NextToken? = nil) {
        self.fastSnapshotRestores = fastSnapshotRestores
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case fastSnapshotRestores = "fastSnapshotRestoreSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeFleetError: Codable, Equatable {
    public var errorCode: String?
    public var errorMessage: String?
    public var launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse?
    public var lifecycle: InstanceLifecycle?

    public init(errorCode: String? = nil,
                errorMessage: String? = nil,
                launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse? = nil,
                lifecycle: InstanceLifecycle? = nil) {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.launchTemplateAndOverrides = launchTemplateAndOverrides
        self.lifecycle = lifecycle
    }

    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case launchTemplateAndOverrides
        case lifecycle
    }

    public func validate() throws {
        try launchTemplateAndOverrides?.validate()
    }
}

public struct DescribeFleetHistoryRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var eventType: FleetEventType?
    public var fleetId: FleetId
    public var maxResults: Integer?
    public var nextToken: String?
    public var startTime: DateTime

    public init(dryRun: Boolean? = nil,
                eventType: FleetEventType? = nil,
                fleetId: FleetId,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                startTime: DateTime) {
        self.dryRun = dryRun
        self.eventType = eventType
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case eventType = "EventType"
        case fleetId = "FleetId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func validate() throws {
    }
}

public struct DescribeFleetHistoryResult: Codable, Equatable {
    public var fleetId: FleetId?
    public var historyRecords: HistoryRecordSet?
    public var lastEvaluatedTime: DateTime?
    public var nextToken: String?
    public var startTime: DateTime?

    public init(fleetId: FleetId? = nil,
                historyRecords: HistoryRecordSet? = nil,
                lastEvaluatedTime: DateTime? = nil,
                nextToken: String? = nil,
                startTime: DateTime? = nil) {
        self.fleetId = fleetId
        self.historyRecords = historyRecords
        self.lastEvaluatedTime = lastEvaluatedTime
        self.nextToken = nextToken
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case fleetId
        case historyRecords = "historyRecordSet"
        case lastEvaluatedTime
        case nextToken
        case startTime
    }

    public func validate() throws {
    }
}

public struct DescribeFleetInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var fleetId: FleetId
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                fleetId: FleetId,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case fleetId = "FleetId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeFleetInstancesResult: Codable, Equatable {
    public var activeInstances: ActiveInstanceSet?
    public var fleetId: FleetId?
    public var nextToken: String?

    public init(activeInstances: ActiveInstanceSet? = nil,
                fleetId: FleetId? = nil,
                nextToken: String? = nil) {
        self.activeInstances = activeInstances
        self.fleetId = fleetId
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case activeInstances = "activeInstanceSet"
        case fleetId
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeFleetsInstances: Codable, Equatable {
    public var instanceIds: InstanceIdsSet?
    public var instanceType: InstanceType?
    public var launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse?
    public var lifecycle: InstanceLifecycle?
    public var platform: PlatformValues?

    public init(instanceIds: InstanceIdsSet? = nil,
                instanceType: InstanceType? = nil,
                launchTemplateAndOverrides: LaunchTemplateAndOverridesResponse? = nil,
                lifecycle: InstanceLifecycle? = nil,
                platform: PlatformValues? = nil) {
        self.instanceIds = instanceIds
        self.instanceType = instanceType
        self.launchTemplateAndOverrides = launchTemplateAndOverrides
        self.lifecycle = lifecycle
        self.platform = platform
    }

    enum CodingKeys: String, CodingKey {
        case instanceIds
        case instanceType
        case launchTemplateAndOverrides
        case lifecycle
        case platform
    }

    public func validate() throws {
        try launchTemplateAndOverrides?.validate()
    }
}

public struct DescribeFleetsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var fleetIds: FleetIdSet?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                fleetIds: FleetIdSet? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.fleetIds = fleetIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case fleetIds = "FleetId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeFleetsResult: Codable, Equatable {
    public var fleets: FleetSet?
    public var nextToken: String?

    public init(fleets: FleetSet? = nil,
                nextToken: String? = nil) {
        self.fleets = fleets
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case fleets = "fleetSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeFlowLogsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filter: FilterList?
    public var flowLogIds: FlowLogIdList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filter: FilterList? = nil,
                flowLogIds: FlowLogIdList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filter = filter
        self.flowLogIds = flowLogIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filter = "Filter"
        case flowLogIds = "FlowLogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeFlowLogsResult: Codable, Equatable {
    public var flowLogs: FlowLogSet?
    public var nextToken: String?

    public init(flowLogs: FlowLogSet? = nil,
                nextToken: String? = nil) {
        self.flowLogs = flowLogs
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case flowLogs = "flowLogSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeFpgaImageAttributeRequest: Codable, Equatable {
    public var attribute: FpgaImageAttributeName
    public var dryRun: Boolean?
    public var fpgaImageId: FpgaImageId

    public init(attribute: FpgaImageAttributeName,
                dryRun: Boolean? = nil,
                fpgaImageId: FpgaImageId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun = "DryRun"
        case fpgaImageId = "FpgaImageId"
    }

    public func validate() throws {
    }
}

public struct DescribeFpgaImageAttributeResult: Codable, Equatable {
    public var fpgaImageAttribute: FpgaImageAttribute?

    public init(fpgaImageAttribute: FpgaImageAttribute? = nil) {
        self.fpgaImageAttribute = fpgaImageAttribute
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImageAttribute
    }

    public func validate() throws {
        try fpgaImageAttribute?.validate()
    }
}

public struct DescribeFpgaImagesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var fpgaImageIds: FpgaImageIdList?
    public var maxResults: DescribeFpgaImagesMaxResults?
    public var nextToken: NextToken?
    public var owners: OwnerStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                fpgaImageIds: FpgaImageIdList? = nil,
                maxResults: DescribeFpgaImagesMaxResults? = nil,
                nextToken: NextToken? = nil,
                owners: OwnerStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.fpgaImageIds = fpgaImageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owners = owners
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case fpgaImageIds = "FpgaImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case owners = "Owner"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeFpgaImagesMaxResults()
    }
}

public struct DescribeFpgaImagesResult: Codable, Equatable {
    public var fpgaImages: FpgaImageList?
    public var nextToken: NextToken?

    public init(fpgaImages: FpgaImageList? = nil,
                nextToken: NextToken? = nil) {
        self.fpgaImages = fpgaImages
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImages = "fpgaImageSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeHostReservationOfferingsRequest: Codable, Equatable {
    public var filter: FilterList?
    public var maxDuration: Integer?
    public var maxResults: DescribeHostReservationsMaxResults?
    public var minDuration: Integer?
    public var nextToken: String?
    public var offeringId: OfferingId?

    public init(filter: FilterList? = nil,
                maxDuration: Integer? = nil,
                maxResults: DescribeHostReservationsMaxResults? = nil,
                minDuration: Integer? = nil,
                nextToken: String? = nil,
                offeringId: OfferingId? = nil) {
        self.filter = filter
        self.maxDuration = maxDuration
        self.maxResults = maxResults
        self.minDuration = minDuration
        self.nextToken = nextToken
        self.offeringId = offeringId
    }

    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxDuration = "MaxDuration"
        case maxResults = "MaxResults"
        case minDuration = "MinDuration"
        case nextToken = "NextToken"
        case offeringId = "OfferingId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeHostReservationsMaxResults()
    }
}

public struct DescribeHostReservationOfferingsResult: Codable, Equatable {
    public var nextToken: String?
    public var offeringSet: HostOfferingSet?

    public init(nextToken: String? = nil,
                offeringSet: HostOfferingSet? = nil) {
        self.nextToken = nextToken
        self.offeringSet = offeringSet
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case offeringSet
    }

    public func validate() throws {
    }
}

public struct DescribeHostReservationsRequest: Codable, Equatable {
    public var filter: FilterList?
    public var hostReservationIdSet: HostReservationIdSet?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(filter: FilterList? = nil,
                hostReservationIdSet: HostReservationIdSet? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.filter = filter
        self.hostReservationIdSet = hostReservationIdSet
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case hostReservationIdSet = "HostReservationIdSet"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeHostReservationsResult: Codable, Equatable {
    public var hostReservationSet: HostReservationSet?
    public var nextToken: String?

    public init(hostReservationSet: HostReservationSet? = nil,
                nextToken: String? = nil) {
        self.hostReservationSet = hostReservationSet
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case hostReservationSet
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeHostsRequest: Codable, Equatable {
    public var filter: FilterList?
    public var hostIds: RequestHostIdList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(filter: FilterList? = nil,
                hostIds: RequestHostIdList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.filter = filter
        self.hostIds = hostIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case filter
        case hostIds = "hostId"
        case maxResults
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeHostsResult: Codable, Equatable {
    public var hosts: HostList?
    public var nextToken: String?

    public init(hosts: HostList? = nil,
                nextToken: String? = nil) {
        self.hosts = hosts
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case hosts = "hostSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeIamInstanceProfileAssociationsRequest: Codable, Equatable {
    public var associationIds: AssociationIdList?
    public var filters: FilterList?
    public var maxResults: DescribeIamInstanceProfileAssociationsMaxResults?
    public var nextToken: NextToken?

    public init(associationIds: AssociationIdList? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeIamInstanceProfileAssociationsMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.associationIds = associationIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case associationIds = "AssociationId"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeIamInstanceProfileAssociationsMaxResults()
    }
}

public struct DescribeIamInstanceProfileAssociationsResult: Codable, Equatable {
    public var iamInstanceProfileAssociations: IamInstanceProfileAssociationSet?
    public var nextToken: NextToken?

    public init(iamInstanceProfileAssociations: IamInstanceProfileAssociationSet? = nil,
                nextToken: NextToken? = nil) {
        self.iamInstanceProfileAssociations = iamInstanceProfileAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfileAssociations = "iamInstanceProfileAssociationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeIdFormatRequest: Codable, Equatable {
    public var resource: String?

    public init(resource: String? = nil) {
        self.resource = resource
    }

    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
    }

    public func validate() throws {
    }
}

public struct DescribeIdFormatResult: Codable, Equatable {
    public var statuses: IdFormatList?

    public init(statuses: IdFormatList? = nil) {
        self.statuses = statuses
    }

    enum CodingKeys: String, CodingKey {
        case statuses = "statusSet"
    }

    public func validate() throws {
    }
}

public struct DescribeIdentityIdFormatRequest: Codable, Equatable {
    public var principalArn: String
    public var resource: String?

    public init(principalArn: String,
                resource: String? = nil) {
        self.principalArn = principalArn
        self.resource = resource
    }

    enum CodingKeys: String, CodingKey {
        case principalArn
        case resource
    }

    public func validate() throws {
    }
}

public struct DescribeIdentityIdFormatResult: Codable, Equatable {
    public var statuses: IdFormatList?

    public init(statuses: IdFormatList? = nil) {
        self.statuses = statuses
    }

    enum CodingKeys: String, CodingKey {
        case statuses = "statusSet"
    }

    public func validate() throws {
    }
}

public struct DescribeImageAttributeRequest: Codable, Equatable {
    public var attribute: ImageAttributeName
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(attribute: ImageAttributeName,
                dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct DescribeImagesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var executableUsers: ExecutableByStringList?
    public var filters: FilterList?
    public var imageIds: ImageIdStringList?
    public var includeDeprecated: Boolean?
    public var maxResults: Integer?
    public var nextToken: String?
    public var owners: OwnerStringList?

    public init(dryRun: Boolean? = nil,
                executableUsers: ExecutableByStringList? = nil,
                filters: FilterList? = nil,
                imageIds: ImageIdStringList? = nil,
                includeDeprecated: Boolean? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                owners: OwnerStringList? = nil) {
        self.dryRun = dryRun
        self.executableUsers = executableUsers
        self.filters = filters
        self.imageIds = imageIds
        self.includeDeprecated = includeDeprecated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owners = owners
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case executableUsers = "ExecutableBy"
        case filters = "Filter"
        case imageIds = "ImageId"
        case includeDeprecated = "IncludeDeprecated"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case owners = "Owner"
    }

    public func validate() throws {
    }
}

public struct DescribeImagesResult: Codable, Equatable {
    public var images: ImageList?
    public var nextToken: String?

    public init(images: ImageList? = nil,
                nextToken: String? = nil) {
        self.images = images
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case images = "imagesSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeImportImageTasksRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var importTaskIds: ImportTaskIdList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                importTaskIds: ImportTaskIdList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.importTaskIds = importTaskIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filters"
        case importTaskIds = "ImportTaskId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeImportImageTasksResult: Codable, Equatable {
    public var importImageTasks: ImportImageTaskList?
    public var nextToken: String?

    public init(importImageTasks: ImportImageTaskList? = nil,
                nextToken: String? = nil) {
        self.importImageTasks = importImageTasks
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case importImageTasks = "importImageTaskSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeImportSnapshotTasksRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var importTaskIds: ImportSnapshotTaskIdList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                importTaskIds: ImportSnapshotTaskIdList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.importTaskIds = importTaskIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filters"
        case importTaskIds = "ImportTaskId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeImportSnapshotTasksResult: Codable, Equatable {
    public var importSnapshotTasks: ImportSnapshotTaskList?
    public var nextToken: String?

    public init(importSnapshotTasks: ImportSnapshotTaskList? = nil,
                nextToken: String? = nil) {
        self.importSnapshotTasks = importSnapshotTasks
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case importSnapshotTasks = "importSnapshotTaskSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceAttributeRequest: Codable, Equatable {
    public var attribute: InstanceAttributeName
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(attribute: InstanceAttributeName,
                dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case attribute
        case dryRun
        case instanceId
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceCreditSpecificationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var instanceIds: InstanceIdStringList?
    public var maxResults: DescribeInstanceCreditSpecificationsMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                instanceIds: InstanceIdStringList? = nil,
                maxResults: DescribeInstanceCreditSpecificationsMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case instanceIds = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeInstanceCreditSpecificationsMaxResults()
    }
}

public struct DescribeInstanceCreditSpecificationsResult: Codable, Equatable {
    public var instanceCreditSpecifications: InstanceCreditSpecificationList?
    public var nextToken: String?

    public init(instanceCreditSpecifications: InstanceCreditSpecificationList? = nil,
                nextToken: String? = nil) {
        self.instanceCreditSpecifications = instanceCreditSpecifications
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceCreditSpecifications = "instanceCreditSpecificationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceEventNotificationAttributesRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceEventNotificationAttributesResult: Codable, Equatable {
    public var instanceTagAttribute: InstanceTagNotificationAttribute?

    public init(instanceTagAttribute: InstanceTagNotificationAttribute? = nil) {
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case instanceTagAttribute
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct DescribeInstanceEventWindowsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var instanceEventWindowIds: InstanceEventWindowIdSet?
    public var maxResults: ResultRange?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                instanceEventWindowIds: InstanceEventWindowIdSet? = nil,
                maxResults: ResultRange? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.instanceEventWindowIds = instanceEventWindowIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case instanceEventWindowIds = "InstanceEventWindowId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsResultRange()
    }
}

public struct DescribeInstanceEventWindowsResult: Codable, Equatable {
    public var instanceEventWindows: InstanceEventWindowSet?
    public var nextToken: String?

    public init(instanceEventWindows: InstanceEventWindowSet? = nil,
                nextToken: String? = nil) {
        self.instanceEventWindows = instanceEventWindows
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceEventWindows = "instanceEventWindowSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceStatusRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var includeAllInstances: Boolean?
    public var instanceIds: InstanceIdStringList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                includeAllInstances: Boolean? = nil,
                instanceIds: InstanceIdStringList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.includeAllInstances = includeAllInstances
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case includeAllInstances
        case instanceIds = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceStatusResult: Codable, Equatable {
    public var instanceStatuses: InstanceStatusList?
    public var nextToken: String?

    public init(instanceStatuses: InstanceStatusList? = nil,
                nextToken: String? = nil) {
        self.instanceStatuses = instanceStatuses
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceStatuses = "instanceStatusSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceTypeOfferingsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var locationType: LocationType?
    public var maxResults: DITOMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                locationType: LocationType? = nil,
                maxResults: DITOMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.locationType = locationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case locationType = "LocationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDITOMaxResults()
    }
}

public struct DescribeInstanceTypeOfferingsResult: Codable, Equatable {
    public var instanceTypeOfferings: InstanceTypeOfferingsList?
    public var nextToken: NextToken?

    public init(instanceTypeOfferings: InstanceTypeOfferingsList? = nil,
                nextToken: NextToken? = nil) {
        self.instanceTypeOfferings = instanceTypeOfferings
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceTypeOfferings = "instanceTypeOfferingSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstanceTypesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var instanceTypes: RequestInstanceTypeList?
    public var maxResults: DITMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                instanceTypes: RequestInstanceTypeList? = nil,
                maxResults: DITMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.instanceTypes = instanceTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case instanceTypes = "InstanceType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try instanceTypes?.validateAsRequestInstanceTypeList()
        try maxResults?.validateAsDITMaxResults()
    }
}

public struct DescribeInstanceTypesResult: Codable, Equatable {
    public var instanceTypes: InstanceTypeInfoList?
    public var nextToken: NextToken?

    public init(instanceTypes: InstanceTypeInfoList? = nil,
                nextToken: NextToken? = nil) {
        self.instanceTypes = instanceTypes
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceTypes = "instanceTypeSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var instanceIds: InstanceIdStringList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                instanceIds: InstanceIdStringList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case instanceIds = "InstanceId"
        case maxResults
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeInstancesResult: Codable, Equatable {
    public var nextToken: String?
    public var reservations: ReservationList?

    public init(nextToken: String? = nil,
                reservations: ReservationList? = nil) {
        self.nextToken = nextToken
        self.reservations = reservations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case reservations = "reservationSet"
    }

    public func validate() throws {
    }
}

public struct DescribeInternetGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var internetGatewayIds: InternetGatewayIdList?
    public var maxResults: DescribeInternetGatewaysMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                internetGatewayIds: InternetGatewayIdList? = nil,
                maxResults: DescribeInternetGatewaysMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.internetGatewayIds = internetGatewayIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case internetGatewayIds = "internetGatewayId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeInternetGatewaysMaxResults()
    }
}

public struct DescribeInternetGatewaysResult: Codable, Equatable {
    public var internetGateways: InternetGatewayList?
    public var nextToken: String?

    public init(internetGateways: InternetGatewayList? = nil,
                nextToken: String? = nil) {
        self.internetGateways = internetGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case internetGateways = "internetGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeIpamPoolsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var ipamPoolIds: ValueStringList?
    public var maxResults: IpamMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                ipamPoolIds: ValueStringList? = nil,
                maxResults: IpamMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.ipamPoolIds = ipamPoolIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case ipamPoolIds = "IpamPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsIpamMaxResults()
    }
}

public struct DescribeIpamPoolsResult: Codable, Equatable {
    public var ipamPools: IpamPoolSet?
    public var nextToken: NextToken?

    public init(ipamPools: IpamPoolSet? = nil,
                nextToken: NextToken? = nil) {
        self.ipamPools = ipamPools
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipamPools = "ipamPoolSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeIpamScopesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var ipamScopeIds: ValueStringList?
    public var maxResults: IpamMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                ipamScopeIds: ValueStringList? = nil,
                maxResults: IpamMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.ipamScopeIds = ipamScopeIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case ipamScopeIds = "IpamScopeId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsIpamMaxResults()
    }
}

public struct DescribeIpamScopesResult: Codable, Equatable {
    public var ipamScopes: IpamScopeSet?
    public var nextToken: NextToken?

    public init(ipamScopes: IpamScopeSet? = nil,
                nextToken: NextToken? = nil) {
        self.ipamScopes = ipamScopes
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipamScopes = "ipamScopeSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeIpamsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var ipamIds: ValueStringList?
    public var maxResults: IpamMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                ipamIds: ValueStringList? = nil,
                maxResults: IpamMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.ipamIds = ipamIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case ipamIds = "IpamId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsIpamMaxResults()
    }
}

public struct DescribeIpamsResult: Codable, Equatable {
    public var ipams: IpamSet?
    public var nextToken: NextToken?

    public init(ipams: IpamSet? = nil,
                nextToken: NextToken? = nil) {
        self.ipams = ipams
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipams = "ipamSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeIpv6PoolsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Ipv6PoolMaxResults?
    public var nextToken: NextToken?
    public var poolIds: Ipv6PoolIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Ipv6PoolMaxResults? = nil,
                nextToken: NextToken? = nil,
                poolIds: Ipv6PoolIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolIds = poolIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsIpv6PoolMaxResults()
    }
}

public struct DescribeIpv6PoolsResult: Codable, Equatable {
    public var ipv6Pools: Ipv6PoolSet?
    public var nextToken: NextToken?

    public init(ipv6Pools: Ipv6PoolSet? = nil,
                nextToken: NextToken? = nil) {
        self.ipv6Pools = ipv6Pools
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Pools = "ipv6PoolSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeKeyPairsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var includePublicKey: Boolean?
    public var keyNames: KeyNameStringList?
    public var keyPairIds: KeyPairIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                includePublicKey: Boolean? = nil,
                keyNames: KeyNameStringList? = nil,
                keyPairIds: KeyPairIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.includePublicKey = includePublicKey
        self.keyNames = keyNames
        self.keyPairIds = keyPairIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case includePublicKey = "IncludePublicKey"
        case keyNames = "KeyName"
        case keyPairIds = "KeyPairId"
    }

    public func validate() throws {
    }
}

public struct DescribeKeyPairsResult: Codable, Equatable {
    public var keyPairs: KeyPairList?

    public init(keyPairs: KeyPairList? = nil) {
        self.keyPairs = keyPairs
    }

    enum CodingKeys: String, CodingKey {
        case keyPairs = "keySet"
    }

    public func validate() throws {
    }
}

public struct DescribeLaunchTemplateVersionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?
    public var maxResults: Integer?
    public var maxVersion: String?
    public var minVersion: String?
    public var nextToken: String?
    public var versions: VersionStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                maxResults: Integer? = nil,
                maxVersion: String? = nil,
                minVersion: String? = nil,
                nextToken: String? = nil,
                versions: VersionStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.maxResults = maxResults
        self.maxVersion = maxVersion
        self.minVersion = minVersion
        self.nextToken = nextToken
        self.versions = versions
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case maxResults = "MaxResults"
        case maxVersion = "MaxVersion"
        case minVersion = "MinVersion"
        case nextToken = "NextToken"
        case versions = "LaunchTemplateVersion"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct DescribeLaunchTemplateVersionsResult: Codable, Equatable {
    public var launchTemplateVersions: LaunchTemplateVersionSet?
    public var nextToken: String?

    public init(launchTemplateVersions: LaunchTemplateVersionSet? = nil,
                nextToken: String? = nil) {
        self.launchTemplateVersions = launchTemplateVersions
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateVersions = "launchTemplateVersionSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLaunchTemplatesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var launchTemplateIds: LaunchTemplateIdStringList?
    public var launchTemplateNames: LaunchTemplateNameStringList?
    public var maxResults: DescribeLaunchTemplatesMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                launchTemplateIds: LaunchTemplateIdStringList? = nil,
                launchTemplateNames: LaunchTemplateNameStringList? = nil,
                maxResults: DescribeLaunchTemplatesMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.launchTemplateIds = launchTemplateIds
        self.launchTemplateNames = launchTemplateNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case launchTemplateIds = "LaunchTemplateId"
        case launchTemplateNames = "LaunchTemplateName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeLaunchTemplatesMaxResults()
    }
}

public struct DescribeLaunchTemplatesResult: Codable, Equatable {
    public var launchTemplates: LaunchTemplateSet?
    public var nextToken: String?

    public init(launchTemplates: LaunchTemplateSet? = nil,
                nextToken: String? = nil) {
        self.launchTemplates = launchTemplates
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplates
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayRouteTableVirtualInterfaceGroupAssociationIds: LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayRouteTableVirtualInterfaceGroupAssociationIds: LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayRouteTableVirtualInterfaceGroupAssociationIds = localGatewayRouteTableVirtualInterfaceGroupAssociationIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayRouteTableVirtualInterfaceGroupAssociationIds = "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult: Codable, Equatable {
    public var localGatewayRouteTableVirtualInterfaceGroupAssociations: LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet?
    public var nextToken: String?

    public init(localGatewayRouteTableVirtualInterfaceGroupAssociations: LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayRouteTableVirtualInterfaceGroupAssociations = localGatewayRouteTableVirtualInterfaceGroupAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVirtualInterfaceGroupAssociations = "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayRouteTableVpcAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayRouteTableVpcAssociationIds: LocalGatewayRouteTableVpcAssociationIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayRouteTableVpcAssociationIds: LocalGatewayRouteTableVpcAssociationIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayRouteTableVpcAssociationIds = localGatewayRouteTableVpcAssociationIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayRouteTableVpcAssociationIds = "LocalGatewayRouteTableVpcAssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayRouteTableVpcAssociationsResult: Codable, Equatable {
    public var localGatewayRouteTableVpcAssociations: LocalGatewayRouteTableVpcAssociationSet?
    public var nextToken: String?

    public init(localGatewayRouteTableVpcAssociations: LocalGatewayRouteTableVpcAssociationSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayRouteTableVpcAssociations = localGatewayRouteTableVpcAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTableVpcAssociations = "localGatewayRouteTableVpcAssociationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayRouteTablesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayRouteTableIds: LocalGatewayRouteTableIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayRouteTableIds: LocalGatewayRouteTableIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayRouteTableIds = localGatewayRouteTableIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayRouteTableIds = "LocalGatewayRouteTableId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayRouteTablesResult: Codable, Equatable {
    public var localGatewayRouteTables: LocalGatewayRouteTableSet?
    public var nextToken: String?

    public init(localGatewayRouteTables: LocalGatewayRouteTableSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayRouteTables = localGatewayRouteTables
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayRouteTables = "localGatewayRouteTableSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayVirtualInterfaceGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayVirtualInterfaceGroupIds: LocalGatewayVirtualInterfaceGroupIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayVirtualInterfaceGroupIds: LocalGatewayVirtualInterfaceGroupIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayVirtualInterfaceGroupIds = localGatewayVirtualInterfaceGroupIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayVirtualInterfaceGroupIds = "LocalGatewayVirtualInterfaceGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayVirtualInterfaceGroupsResult: Codable, Equatable {
    public var localGatewayVirtualInterfaceGroups: LocalGatewayVirtualInterfaceGroupSet?
    public var nextToken: String?

    public init(localGatewayVirtualInterfaceGroups: LocalGatewayVirtualInterfaceGroupSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayVirtualInterfaceGroups = localGatewayVirtualInterfaceGroups
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayVirtualInterfaceGroups = "localGatewayVirtualInterfaceGroupSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewayVirtualInterfacesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayVirtualInterfaceIds: LocalGatewayVirtualInterfaceIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayVirtualInterfaceIds: LocalGatewayVirtualInterfaceIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayVirtualInterfaceIds = localGatewayVirtualInterfaceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayVirtualInterfaceIds = "LocalGatewayVirtualInterfaceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewayVirtualInterfacesResult: Codable, Equatable {
    public var localGatewayVirtualInterfaces: LocalGatewayVirtualInterfaceSet?
    public var nextToken: String?

    public init(localGatewayVirtualInterfaces: LocalGatewayVirtualInterfaceSet? = nil,
                nextToken: String? = nil) {
        self.localGatewayVirtualInterfaces = localGatewayVirtualInterfaces
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayVirtualInterfaces = "localGatewayVirtualInterfaceSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeLocalGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayIds: LocalGatewayIdSet?
    public var maxResults: LocalGatewayMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayIds: LocalGatewayIdSet? = nil,
                maxResults: LocalGatewayMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayIds = localGatewayIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayIds = "LocalGatewayId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsLocalGatewayMaxResults()
    }
}

public struct DescribeLocalGatewaysResult: Codable, Equatable {
    public var localGateways: LocalGatewaySet?
    public var nextToken: String?

    public init(localGateways: LocalGatewaySet? = nil,
                nextToken: String? = nil) {
        self.localGateways = localGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case localGateways = "localGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeManagedPrefixListsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: PrefixListMaxResults?
    public var nextToken: NextToken?
    public var prefixListIds: ValueStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: PrefixListMaxResults? = nil,
                nextToken: NextToken? = nil,
                prefixListIds: ValueStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.prefixListIds = prefixListIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case prefixListIds = "PrefixListId"
    }

    public func validate() throws {
        try maxResults?.validateAsPrefixListMaxResults()
    }
}

public struct DescribeManagedPrefixListsResult: Codable, Equatable {
    public var nextToken: NextToken?
    public var prefixLists: ManagedPrefixListSet?

    public init(nextToken: NextToken? = nil,
                prefixLists: ManagedPrefixListSet? = nil) {
        self.nextToken = nextToken
        self.prefixLists = prefixLists
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case prefixLists = "prefixListSet"
    }

    public func validate() throws {
    }
}

public struct DescribeMovingAddressesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeMovingAddressesMaxResults?
    public var nextToken: String?
    public var publicIps: ValueStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeMovingAddressesMaxResults? = nil,
                nextToken: String? = nil,
                publicIps: ValueStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.publicIps = publicIps
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "filter"
        case maxResults
        case nextToken
        case publicIps = "publicIp"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeMovingAddressesMaxResults()
    }
}

public struct DescribeMovingAddressesResult: Codable, Equatable {
    public var movingAddressStatuses: MovingAddressStatusSet?
    public var nextToken: String?

    public init(movingAddressStatuses: MovingAddressStatusSet? = nil,
                nextToken: String? = nil) {
        self.movingAddressStatuses = movingAddressStatuses
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case movingAddressStatuses = "movingAddressStatusSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNatGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filter: FilterList?
    public var maxResults: DescribeNatGatewaysMaxResults?
    public var natGatewayIds: NatGatewayIdStringList?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filter: FilterList? = nil,
                maxResults: DescribeNatGatewaysMaxResults? = nil,
                natGatewayIds: NatGatewayIdStringList? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filter = filter
        self.maxResults = maxResults
        self.natGatewayIds = natGatewayIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case natGatewayIds = "NatGatewayId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeNatGatewaysMaxResults()
    }
}

public struct DescribeNatGatewaysResult: Codable, Equatable {
    public var natGateways: NatGatewayList?
    public var nextToken: String?

    public init(natGateways: NatGatewayList? = nil,
                nextToken: String? = nil) {
        self.natGateways = natGateways
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case natGateways = "natGatewaySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkAclsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeNetworkAclsMaxResults?
    public var networkAclIds: NetworkAclIdStringList?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeNetworkAclsMaxResults? = nil,
                networkAclIds: NetworkAclIdStringList? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkAclIds = networkAclIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkAclIds = "NetworkAclId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeNetworkAclsMaxResults()
    }
}

public struct DescribeNetworkAclsResult: Codable, Equatable {
    public var networkAcls: NetworkAclList?
    public var nextToken: String?

    public init(networkAcls: NetworkAclList? = nil,
                nextToken: String? = nil) {
        self.networkAcls = networkAcls
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkAcls = "networkAclSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInsightsAccessScopeAnalysesRequest: Codable, Equatable {
    public var analysisStartTimeBegin: MillisecondDateTime?
    public var analysisStartTimeEnd: MillisecondDateTime?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: NetworkInsightsMaxResults?
    public var networkInsightsAccessScopeAnalysisIds: NetworkInsightsAccessScopeAnalysisIdList?
    public var networkInsightsAccessScopeId: NetworkInsightsAccessScopeId?
    public var nextToken: NextToken?

    public init(analysisStartTimeBegin: MillisecondDateTime? = nil,
                analysisStartTimeEnd: MillisecondDateTime? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: NetworkInsightsMaxResults? = nil,
                networkInsightsAccessScopeAnalysisIds: NetworkInsightsAccessScopeAnalysisIdList? = nil,
                networkInsightsAccessScopeId: NetworkInsightsAccessScopeId? = nil,
                nextToken: NextToken? = nil) {
        self.analysisStartTimeBegin = analysisStartTimeBegin
        self.analysisStartTimeEnd = analysisStartTimeEnd
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkInsightsAccessScopeAnalysisIds = networkInsightsAccessScopeAnalysisIds
        self.networkInsightsAccessScopeId = networkInsightsAccessScopeId
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case analysisStartTimeBegin = "AnalysisStartTimeBegin"
        case analysisStartTimeEnd = "AnalysisStartTimeEnd"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkInsightsAccessScopeAnalysisIds = "NetworkInsightsAccessScopeAnalysisId"
        case networkInsightsAccessScopeId = "NetworkInsightsAccessScopeId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsNetworkInsightsMaxResults()
    }
}

public struct DescribeNetworkInsightsAccessScopeAnalysesResult: Codable, Equatable {
    public var networkInsightsAccessScopeAnalyses: NetworkInsightsAccessScopeAnalysisList?
    public var nextToken: String?

    public init(networkInsightsAccessScopeAnalyses: NetworkInsightsAccessScopeAnalysisList? = nil,
                nextToken: String? = nil) {
        self.networkInsightsAccessScopeAnalyses = networkInsightsAccessScopeAnalyses
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAccessScopeAnalyses = "networkInsightsAccessScopeAnalysisSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInsightsAccessScopesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: NetworkInsightsMaxResults?
    public var networkInsightsAccessScopeIds: NetworkInsightsAccessScopeIdList?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: NetworkInsightsMaxResults? = nil,
                networkInsightsAccessScopeIds: NetworkInsightsAccessScopeIdList? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkInsightsAccessScopeIds = networkInsightsAccessScopeIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkInsightsAccessScopeIds = "NetworkInsightsAccessScopeId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsNetworkInsightsMaxResults()
    }
}

public struct DescribeNetworkInsightsAccessScopesResult: Codable, Equatable {
    public var networkInsightsAccessScopes: NetworkInsightsAccessScopeList?
    public var nextToken: String?

    public init(networkInsightsAccessScopes: NetworkInsightsAccessScopeList? = nil,
                nextToken: String? = nil) {
        self.networkInsightsAccessScopes = networkInsightsAccessScopes
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAccessScopes = "networkInsightsAccessScopeSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInsightsAnalysesRequest: Codable, Equatable {
    public var analysisEndTime: MillisecondDateTime?
    public var analysisStartTime: MillisecondDateTime?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: NetworkInsightsMaxResults?
    public var networkInsightsAnalysisIds: NetworkInsightsAnalysisIdList?
    public var networkInsightsPathId: NetworkInsightsPathId?
    public var nextToken: NextToken?

    public init(analysisEndTime: MillisecondDateTime? = nil,
                analysisStartTime: MillisecondDateTime? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: NetworkInsightsMaxResults? = nil,
                networkInsightsAnalysisIds: NetworkInsightsAnalysisIdList? = nil,
                networkInsightsPathId: NetworkInsightsPathId? = nil,
                nextToken: NextToken? = nil) {
        self.analysisEndTime = analysisEndTime
        self.analysisStartTime = analysisStartTime
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkInsightsAnalysisIds = networkInsightsAnalysisIds
        self.networkInsightsPathId = networkInsightsPathId
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case analysisEndTime = "AnalysisEndTime"
        case analysisStartTime = "AnalysisStartTime"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkInsightsAnalysisIds = "NetworkInsightsAnalysisId"
        case networkInsightsPathId = "NetworkInsightsPathId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsNetworkInsightsMaxResults()
    }
}

public struct DescribeNetworkInsightsAnalysesResult: Codable, Equatable {
    public var networkInsightsAnalyses: NetworkInsightsAnalysisList?
    public var nextToken: String?

    public init(networkInsightsAnalyses: NetworkInsightsAnalysisList? = nil,
                nextToken: String? = nil) {
        self.networkInsightsAnalyses = networkInsightsAnalyses
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAnalyses = "networkInsightsAnalysisSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInsightsPathsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: NetworkInsightsMaxResults?
    public var networkInsightsPathIds: NetworkInsightsPathIdList?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: NetworkInsightsMaxResults? = nil,
                networkInsightsPathIds: NetworkInsightsPathIdList? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkInsightsPathIds = networkInsightsPathIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkInsightsPathIds = "NetworkInsightsPathId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsNetworkInsightsMaxResults()
    }
}

public struct DescribeNetworkInsightsPathsResult: Codable, Equatable {
    public var networkInsightsPaths: NetworkInsightsPathList?
    public var nextToken: String?

    public init(networkInsightsPaths: NetworkInsightsPathList? = nil,
                nextToken: String? = nil) {
        self.networkInsightsPaths = networkInsightsPaths
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsPaths = "networkInsightsPathSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInterfaceAttributeRequest: Codable, Equatable {
    public var attribute: NetworkInterfaceAttribute?
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId

    public init(attribute: NetworkInterfaceAttribute? = nil,
                dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case attribute
        case dryRun
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInterfaceAttributeResult: Codable, Equatable {
    public var attachment: NetworkInterfaceAttachment?
    public var description: AttributeValue?
    public var groups: GroupIdentifierList?
    public var networkInterfaceId: String?
    public var sourceDestCheck: AttributeBooleanValue?

    public init(attachment: NetworkInterfaceAttachment? = nil,
                description: AttributeValue? = nil,
                groups: GroupIdentifierList? = nil,
                networkInterfaceId: String? = nil,
                sourceDestCheck: AttributeBooleanValue? = nil) {
        self.attachment = attachment
        self.description = description
        self.groups = groups
        self.networkInterfaceId = networkInterfaceId
        self.sourceDestCheck = sourceDestCheck
    }

    enum CodingKeys: String, CodingKey {
        case attachment
        case description
        case groups = "groupSet"
        case networkInterfaceId
        case sourceDestCheck
    }

    public func validate() throws {
        try attachment?.validate()
        try description?.validate()
        try sourceDestCheck?.validate()
    }
}

public struct DescribeNetworkInterfacePermissionsRequest: Codable, Equatable {
    public var filters: FilterList?
    public var maxResults: DescribeNetworkInterfacePermissionsMaxResults?
    public var networkInterfacePermissionIds: NetworkInterfacePermissionIdList?
    public var nextToken: String?

    public init(filters: FilterList? = nil,
                maxResults: DescribeNetworkInterfacePermissionsMaxResults? = nil,
                networkInterfacePermissionIds: NetworkInterfacePermissionIdList? = nil,
                nextToken: String? = nil) {
        self.filters = filters
        self.maxResults = maxResults
        self.networkInterfacePermissionIds = networkInterfacePermissionIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case filters = "Filter"
        case maxResults = "MaxResults"
        case networkInterfacePermissionIds = "NetworkInterfacePermissionId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeNetworkInterfacePermissionsMaxResults()
    }
}

public struct DescribeNetworkInterfacePermissionsResult: Codable, Equatable {
    public var networkInterfacePermissions: NetworkInterfacePermissionList?
    public var nextToken: String?

    public init(networkInterfacePermissions: NetworkInterfacePermissionList? = nil,
                nextToken: String? = nil) {
        self.networkInterfacePermissions = networkInterfacePermissions
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInterfacePermissions
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeNetworkInterfacesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeNetworkInterfacesMaxResults?
    public var networkInterfaceIds: NetworkInterfaceIdList?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeNetworkInterfacesMaxResults? = nil,
                networkInterfaceIds: NetworkInterfaceIdList? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.networkInterfaceIds = networkInterfaceIds
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "filter"
        case maxResults = "MaxResults"
        case networkInterfaceIds = "NetworkInterfaceId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeNetworkInterfacesMaxResults()
    }
}

public struct DescribeNetworkInterfacesResult: Codable, Equatable {
    public var networkInterfaces: NetworkInterfaceList?
    public var nextToken: String?

    public init(networkInterfaces: NetworkInterfaceList? = nil,
                nextToken: String? = nil) {
        self.networkInterfaces = networkInterfaces
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case networkInterfaces = "networkInterfaceSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribePlacementGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var groupIds: PlacementGroupIdStringList?
    public var groupNames: PlacementGroupStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                groupIds: PlacementGroupIdStringList? = nil,
                groupNames: PlacementGroupStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.groupIds = groupIds
        self.groupNames = groupNames
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case groupIds = "GroupId"
        case groupNames = "groupName"
    }

    public func validate() throws {
    }
}

public struct DescribePlacementGroupsResult: Codable, Equatable {
    public var placementGroups: PlacementGroupList?

    public init(placementGroups: PlacementGroupList? = nil) {
        self.placementGroups = placementGroups
    }

    enum CodingKeys: String, CodingKey {
        case placementGroups = "placementGroupSet"
    }

    public func validate() throws {
    }
}

public struct DescribePrefixListsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var prefixListIds: PrefixListResourceIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                prefixListIds: PrefixListResourceIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.prefixListIds = prefixListIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case prefixListIds = "PrefixListId"
    }

    public func validate() throws {
    }
}

public struct DescribePrefixListsResult: Codable, Equatable {
    public var nextToken: String?
    public var prefixLists: PrefixListSet?

    public init(nextToken: String? = nil,
                prefixLists: PrefixListSet? = nil) {
        self.nextToken = nextToken
        self.prefixLists = prefixLists
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case prefixLists = "prefixListSet"
    }

    public func validate() throws {
    }
}

public struct DescribePrincipalIdFormatRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: DescribePrincipalIdFormatMaxResults?
    public var nextToken: String?
    public var resources: ResourceList?

    public init(dryRun: Boolean? = nil,
                maxResults: DescribePrincipalIdFormatMaxResults? = nil,
                nextToken: String? = nil,
                resources: ResourceList? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resources = resources
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resources = "Resource"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribePrincipalIdFormatMaxResults()
    }
}

public struct DescribePrincipalIdFormatResult: Codable, Equatable {
    public var nextToken: String?
    public var principals: PrincipalIdFormatList?

    public init(nextToken: String? = nil,
                principals: PrincipalIdFormatList? = nil) {
        self.nextToken = nextToken
        self.principals = principals
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case principals = "principalSet"
    }

    public func validate() throws {
    }
}

public struct DescribePublicIpv4PoolsRequest: Codable, Equatable {
    public var filters: FilterList?
    public var maxResults: PoolMaxResults?
    public var nextToken: NextToken?
    public var poolIds: PublicIpv4PoolIdStringList?

    public init(filters: FilterList? = nil,
                maxResults: PoolMaxResults? = nil,
                nextToken: NextToken? = nil,
                poolIds: PublicIpv4PoolIdStringList? = nil) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolIds = poolIds
    }

    enum CodingKeys: String, CodingKey {
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsPoolMaxResults()
    }
}

public struct DescribePublicIpv4PoolsResult: Codable, Equatable {
    public var nextToken: String?
    public var publicIpv4Pools: PublicIpv4PoolSet?

    public init(nextToken: String? = nil,
                publicIpv4Pools: PublicIpv4PoolSet? = nil) {
        self.nextToken = nextToken
        self.publicIpv4Pools = publicIpv4Pools
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case publicIpv4Pools = "publicIpv4PoolSet"
    }

    public func validate() throws {
    }
}

public struct DescribeRegionsRequest: Codable, Equatable {
    public var allRegions: Boolean?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var regionNames: RegionNameStringList?

    public init(allRegions: Boolean? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                regionNames: RegionNameStringList? = nil) {
        self.allRegions = allRegions
        self.dryRun = dryRun
        self.filters = filters
        self.regionNames = regionNames
    }

    enum CodingKeys: String, CodingKey {
        case allRegions = "AllRegions"
        case dryRun
        case filters = "Filter"
        case regionNames = "RegionName"
    }

    public func validate() throws {
    }
}

public struct DescribeRegionsResult: Codable, Equatable {
    public var regions: RegionList?

    public init(regions: RegionList? = nil) {
        self.regions = regions
    }

    enum CodingKeys: String, CodingKey {
        case regions = "regionInfo"
    }

    public func validate() throws {
    }
}

public struct DescribeReplaceRootVolumeTasksRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeReplaceRootVolumeTasksMaxResults?
    public var nextToken: NextToken?
    public var replaceRootVolumeTaskIds: ReplaceRootVolumeTaskIds?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeReplaceRootVolumeTasksMaxResults? = nil,
                nextToken: NextToken? = nil,
                replaceRootVolumeTaskIds: ReplaceRootVolumeTaskIds? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replaceRootVolumeTaskIds = replaceRootVolumeTaskIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case replaceRootVolumeTaskIds = "ReplaceRootVolumeTaskId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeReplaceRootVolumeTasksMaxResults()
    }
}

public struct DescribeReplaceRootVolumeTasksResult: Codable, Equatable {
    public var nextToken: String?
    public var replaceRootVolumeTasks: ReplaceRootVolumeTasks?

    public init(nextToken: String? = nil,
                replaceRootVolumeTasks: ReplaceRootVolumeTasks? = nil) {
        self.nextToken = nextToken
        self.replaceRootVolumeTasks = replaceRootVolumeTasks
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case replaceRootVolumeTasks = "replaceRootVolumeTaskSet"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesListingsRequest: Codable, Equatable {
    public var filters: FilterList?
    public var reservedInstancesId: ReservationId?
    public var reservedInstancesListingId: ReservedInstancesListingId?

    public init(filters: FilterList? = nil,
                reservedInstancesId: ReservationId? = nil,
                reservedInstancesListingId: ReservedInstancesListingId? = nil) {
        self.filters = filters
        self.reservedInstancesId = reservedInstancesId
        self.reservedInstancesListingId = reservedInstancesListingId
    }

    enum CodingKeys: String, CodingKey {
        case filters = "Filter"
        case reservedInstancesId
        case reservedInstancesListingId
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesListingsResult: Codable, Equatable {
    public var reservedInstancesListings: ReservedInstancesListingList?

    public init(reservedInstancesListings: ReservedInstancesListingList? = nil) {
        self.reservedInstancesListings = reservedInstancesListings
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesListings = "reservedInstancesListingsSet"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesModificationsRequest: Codable, Equatable {
    public var filters: FilterList?
    public var nextToken: String?
    public var reservedInstancesModificationIds: ReservedInstancesModificationIdStringList?

    public init(filters: FilterList? = nil,
                nextToken: String? = nil,
                reservedInstancesModificationIds: ReservedInstancesModificationIdStringList? = nil) {
        self.filters = filters
        self.nextToken = nextToken
        self.reservedInstancesModificationIds = reservedInstancesModificationIds
    }

    enum CodingKeys: String, CodingKey {
        case filters = "Filter"
        case nextToken
        case reservedInstancesModificationIds = "ReservedInstancesModificationId"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesModificationsResult: Codable, Equatable {
    public var nextToken: String?
    public var reservedInstancesModifications: ReservedInstancesModificationList?

    public init(nextToken: String? = nil,
                reservedInstancesModifications: ReservedInstancesModificationList? = nil) {
        self.nextToken = nextToken
        self.reservedInstancesModifications = reservedInstancesModifications
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case reservedInstancesModifications = "reservedInstancesModificationsSet"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesOfferingsRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var includeMarketplace: Boolean?
    public var instanceTenancy: Tenancy?
    public var instanceType: InstanceType?
    public var maxDuration: Long?
    public var maxInstanceCount: Integer?
    public var maxResults: Integer?
    public var minDuration: Long?
    public var nextToken: String?
    public var offeringClass: OfferingClassType?
    public var offeringType: OfferingTypeValues?
    public var productDescription: RIProductDescription?
    public var reservedInstancesOfferingIds: ReservedInstancesOfferingIdStringList?

    public init(availabilityZone: String? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                includeMarketplace: Boolean? = nil,
                instanceTenancy: Tenancy? = nil,
                instanceType: InstanceType? = nil,
                maxDuration: Long? = nil,
                maxInstanceCount: Integer? = nil,
                maxResults: Integer? = nil,
                minDuration: Long? = nil,
                nextToken: String? = nil,
                offeringClass: OfferingClassType? = nil,
                offeringType: OfferingTypeValues? = nil,
                productDescription: RIProductDescription? = nil,
                reservedInstancesOfferingIds: ReservedInstancesOfferingIdStringList? = nil) {
        self.availabilityZone = availabilityZone
        self.dryRun = dryRun
        self.filters = filters
        self.includeMarketplace = includeMarketplace
        self.instanceTenancy = instanceTenancy
        self.instanceType = instanceType
        self.maxDuration = maxDuration
        self.maxInstanceCount = maxInstanceCount
        self.maxResults = maxResults
        self.minDuration = minDuration
        self.nextToken = nextToken
        self.offeringClass = offeringClass
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.reservedInstancesOfferingIds = reservedInstancesOfferingIds
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case dryRun
        case filters = "Filter"
        case includeMarketplace = "IncludeMarketplace"
        case instanceTenancy
        case instanceType = "InstanceType"
        case maxDuration = "MaxDuration"
        case maxInstanceCount = "MaxInstanceCount"
        case maxResults
        case minDuration = "MinDuration"
        case nextToken
        case offeringClass = "OfferingClass"
        case offeringType
        case productDescription = "ProductDescription"
        case reservedInstancesOfferingIds = "ReservedInstancesOfferingId"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesOfferingsResult: Codable, Equatable {
    public var nextToken: String?
    public var reservedInstancesOfferings: ReservedInstancesOfferingList?

    public init(nextToken: String? = nil,
                reservedInstancesOfferings: ReservedInstancesOfferingList? = nil) {
        self.nextToken = nextToken
        self.reservedInstancesOfferings = reservedInstancesOfferings
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case reservedInstancesOfferings = "reservedInstancesOfferingsSet"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var offeringClass: OfferingClassType?
    public var offeringType: OfferingTypeValues?
    public var reservedInstancesIds: ReservedInstancesIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                offeringClass: OfferingClassType? = nil,
                offeringType: OfferingTypeValues? = nil,
                reservedInstancesIds: ReservedInstancesIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.offeringClass = offeringClass
        self.offeringType = offeringType
        self.reservedInstancesIds = reservedInstancesIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case offeringClass = "OfferingClass"
        case offeringType
        case reservedInstancesIds = "ReservedInstancesId"
    }

    public func validate() throws {
    }
}

public struct DescribeReservedInstancesResult: Codable, Equatable {
    public var reservedInstances: ReservedInstancesList?

    public init(reservedInstances: ReservedInstancesList? = nil) {
        self.reservedInstances = reservedInstances
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstances = "reservedInstancesSet"
    }

    public func validate() throws {
    }
}

public struct DescribeRouteTablesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeRouteTablesMaxResults?
    public var nextToken: String?
    public var routeTableIds: RouteTableIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeRouteTablesMaxResults? = nil,
                nextToken: String? = nil,
                routeTableIds: RouteTableIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routeTableIds = routeTableIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case routeTableIds = "RouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeRouteTablesMaxResults()
    }
}

public struct DescribeRouteTablesResult: Codable, Equatable {
    public var nextToken: String?
    public var routeTables: RouteTableList?

    public init(nextToken: String? = nil,
                routeTables: RouteTableList? = nil) {
        self.nextToken = nextToken
        self.routeTables = routeTables
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case routeTables = "routeTableSet"
    }

    public func validate() throws {
    }
}

public struct DescribeScheduledInstanceAvailabilityRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var firstSlotStartTimeRange: SlotDateTimeRangeRequest
    public var maxResults: DescribeScheduledInstanceAvailabilityMaxResults?
    public var maxSlotDurationInHours: Integer?
    public var minSlotDurationInHours: Integer?
    public var nextToken: String?
    public var recurrence: ScheduledInstanceRecurrenceRequest

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                firstSlotStartTimeRange: SlotDateTimeRangeRequest,
                maxResults: DescribeScheduledInstanceAvailabilityMaxResults? = nil,
                maxSlotDurationInHours: Integer? = nil,
                minSlotDurationInHours: Integer? = nil,
                nextToken: String? = nil,
                recurrence: ScheduledInstanceRecurrenceRequest) {
        self.dryRun = dryRun
        self.filters = filters
        self.firstSlotStartTimeRange = firstSlotStartTimeRange
        self.maxResults = maxResults
        self.maxSlotDurationInHours = maxSlotDurationInHours
        self.minSlotDurationInHours = minSlotDurationInHours
        self.nextToken = nextToken
        self.recurrence = recurrence
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case firstSlotStartTimeRange = "FirstSlotStartTimeRange"
        case maxResults = "MaxResults"
        case maxSlotDurationInHours = "MaxSlotDurationInHours"
        case minSlotDurationInHours = "MinSlotDurationInHours"
        case nextToken = "NextToken"
        case recurrence = "Recurrence"
    }

    public func validate() throws {
        try firstSlotStartTimeRange.validate()
        try maxResults?.validateAsDescribeScheduledInstanceAvailabilityMaxResults()
        try recurrence.validate()
    }
}

public struct DescribeScheduledInstanceAvailabilityResult: Codable, Equatable {
    public var nextToken: String?
    public var scheduledInstanceAvailabilitySet: ScheduledInstanceAvailabilitySet?

    public init(nextToken: String? = nil,
                scheduledInstanceAvailabilitySet: ScheduledInstanceAvailabilitySet? = nil) {
        self.nextToken = nextToken
        self.scheduledInstanceAvailabilitySet = scheduledInstanceAvailabilitySet
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case scheduledInstanceAvailabilitySet
    }

    public func validate() throws {
    }
}

public struct DescribeScheduledInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var scheduledInstanceIds: ScheduledInstanceIdRequestSet?
    public var slotStartTimeRange: SlotStartTimeRangeRequest?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                scheduledInstanceIds: ScheduledInstanceIdRequestSet? = nil,
                slotStartTimeRange: SlotStartTimeRangeRequest? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scheduledInstanceIds = scheduledInstanceIds
        self.slotStartTimeRange = slotStartTimeRange
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scheduledInstanceIds = "ScheduledInstanceId"
        case slotStartTimeRange = "SlotStartTimeRange"
    }

    public func validate() throws {
        try slotStartTimeRange?.validate()
    }
}

public struct DescribeScheduledInstancesResult: Codable, Equatable {
    public var nextToken: String?
    public var scheduledInstanceSet: ScheduledInstanceSet?

    public init(nextToken: String? = nil,
                scheduledInstanceSet: ScheduledInstanceSet? = nil) {
        self.nextToken = nextToken
        self.scheduledInstanceSet = scheduledInstanceSet
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case scheduledInstanceSet
    }

    public func validate() throws {
    }
}

public struct DescribeSecurityGroupReferencesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupId: GroupIds

    public init(dryRun: Boolean? = nil,
                groupId: GroupIds) {
        self.dryRun = dryRun
        self.groupId = groupId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupId = "GroupId"
    }

    public func validate() throws {
    }
}

public struct DescribeSecurityGroupReferencesResult: Codable, Equatable {
    public var securityGroupReferenceSet: SecurityGroupReferences?

    public init(securityGroupReferenceSet: SecurityGroupReferences? = nil) {
        self.securityGroupReferenceSet = securityGroupReferenceSet
    }

    enum CodingKeys: String, CodingKey {
        case securityGroupReferenceSet
    }

    public func validate() throws {
    }
}

public struct DescribeSecurityGroupRulesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeSecurityGroupRulesMaxResults?
    public var nextToken: String?
    public var securityGroupRuleIds: SecurityGroupRuleIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeSecurityGroupRulesMaxResults? = nil,
                nextToken: String? = nil,
                securityGroupRuleIds: SecurityGroupRuleIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityGroupRuleIds = securityGroupRuleIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case securityGroupRuleIds = "SecurityGroupRuleId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeSecurityGroupRulesMaxResults()
    }
}

public struct DescribeSecurityGroupRulesResult: Codable, Equatable {
    public var nextToken: String?
    public var securityGroupRules: SecurityGroupRuleList?

    public init(nextToken: String? = nil,
                securityGroupRules: SecurityGroupRuleList? = nil) {
        self.nextToken = nextToken
        self.securityGroupRules = securityGroupRules
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case securityGroupRules = "securityGroupRuleSet"
    }

    public func validate() throws {
    }
}

public struct DescribeSecurityGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var groupIds: GroupIdStringList?
    public var groupNames: GroupNameStringList?
    public var maxResults: DescribeSecurityGroupsMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                groupIds: GroupIdStringList? = nil,
                groupNames: GroupNameStringList? = nil,
                maxResults: DescribeSecurityGroupsMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.groupIds = groupIds
        self.groupNames = groupNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case groupIds = "GroupId"
        case groupNames = "GroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeSecurityGroupsMaxResults()
    }
}

public struct DescribeSecurityGroupsResult: Codable, Equatable {
    public var nextToken: String?
    public var securityGroups: SecurityGroupList?

    public init(nextToken: String? = nil,
                securityGroups: SecurityGroupList? = nil) {
        self.nextToken = nextToken
        self.securityGroups = securityGroups
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case securityGroups = "securityGroupInfo"
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotAttributeRequest: Codable, Equatable {
    public var attribute: SnapshotAttributeName
    public var dryRun: Boolean?
    public var snapshotId: SnapshotId

    public init(attribute: SnapshotAttributeName,
                dryRun: Boolean? = nil,
                snapshotId: SnapshotId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case snapshotId = "SnapshotId"
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotAttributeResult: Codable, Equatable {
    public var createVolumePermissions: CreateVolumePermissionList?
    public var productCodes: ProductCodeList?
    public var snapshotId: String?

    public init(createVolumePermissions: CreateVolumePermissionList? = nil,
                productCodes: ProductCodeList? = nil,
                snapshotId: String? = nil) {
        self.createVolumePermissions = createVolumePermissions
        self.productCodes = productCodes
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case createVolumePermissions = "createVolumePermission"
        case productCodes
        case snapshotId
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotTierStatusRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeSnapshotTierStatusMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeSnapshotTierStatusMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotTierStatusResult: Codable, Equatable {
    public var nextToken: String?
    public var snapshotTierStatuses: SnapshotTierStatusSet?

    public init(nextToken: String? = nil,
                snapshotTierStatuses: SnapshotTierStatusSet? = nil) {
        self.nextToken = nextToken
        self.snapshotTierStatuses = snapshotTierStatuses
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case snapshotTierStatuses = "snapshotTierStatusSet"
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var ownerIds: OwnerStringList?
    public var restorableByUserIds: RestorableByStringList?
    public var snapshotIds: SnapshotIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                ownerIds: OwnerStringList? = nil,
                restorableByUserIds: RestorableByStringList? = nil,
                snapshotIds: SnapshotIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerIds = ownerIds
        self.restorableByUserIds = restorableByUserIds
        self.snapshotIds = snapshotIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case ownerIds = "Owner"
        case restorableByUserIds = "RestorableBy"
        case snapshotIds = "SnapshotId"
    }

    public func validate() throws {
    }
}

public struct DescribeSnapshotsResult: Codable, Equatable {
    public var nextToken: String?
    public var snapshots: SnapshotList?

    public init(nextToken: String? = nil,
                snapshots: SnapshotList? = nil) {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case snapshots = "snapshotSet"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotDatafeedSubscriptionRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DescribeSpotDatafeedSubscriptionResult: Codable, Equatable {
    public var spotDatafeedSubscription: SpotDatafeedSubscription?

    public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
        self.spotDatafeedSubscription = spotDatafeedSubscription
    }

    enum CodingKeys: String, CodingKey {
        case spotDatafeedSubscription
    }

    public func validate() throws {
        try spotDatafeedSubscription?.validate()
    }
}

public struct DescribeSpotFleetInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: DescribeSpotFleetInstancesMaxResults?
    public var nextToken: String?
    public var spotFleetRequestId: SpotFleetRequestId

    public init(dryRun: Boolean? = nil,
                maxResults: DescribeSpotFleetInstancesMaxResults? = nil,
                nextToken: String? = nil,
                spotFleetRequestId: SpotFleetRequestId) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case maxResults
        case nextToken
        case spotFleetRequestId
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeSpotFleetInstancesMaxResults()
    }
}

public struct DescribeSpotFleetInstancesResponse: Codable, Equatable {
    public var activeInstances: ActiveInstanceSet?
    public var nextToken: String?
    public var spotFleetRequestId: String?

    public init(activeInstances: ActiveInstanceSet? = nil,
                nextToken: String? = nil,
                spotFleetRequestId: String? = nil) {
        self.activeInstances = activeInstances
        self.nextToken = nextToken
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case activeInstances = "activeInstanceSet"
        case nextToken
        case spotFleetRequestId
    }

    public func validate() throws {
    }
}

public struct DescribeSpotFleetRequestHistoryRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var eventType: EventType?
    public var maxResults: DescribeSpotFleetRequestHistoryMaxResults?
    public var nextToken: String?
    public var spotFleetRequestId: SpotFleetRequestId
    public var startTime: DateTime

    public init(dryRun: Boolean? = nil,
                eventType: EventType? = nil,
                maxResults: DescribeSpotFleetRequestHistoryMaxResults? = nil,
                nextToken: String? = nil,
                spotFleetRequestId: SpotFleetRequestId,
                startTime: DateTime) {
        self.dryRun = dryRun
        self.eventType = eventType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spotFleetRequestId = spotFleetRequestId
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case eventType
        case maxResults
        case nextToken
        case spotFleetRequestId
        case startTime
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeSpotFleetRequestHistoryMaxResults()
    }
}

public struct DescribeSpotFleetRequestHistoryResponse: Codable, Equatable {
    public var historyRecords: HistoryRecords?
    public var lastEvaluatedTime: DateTime?
    public var nextToken: String?
    public var spotFleetRequestId: String?
    public var startTime: DateTime?

    public init(historyRecords: HistoryRecords? = nil,
                lastEvaluatedTime: DateTime? = nil,
                nextToken: String? = nil,
                spotFleetRequestId: String? = nil,
                startTime: DateTime? = nil) {
        self.historyRecords = historyRecords
        self.lastEvaluatedTime = lastEvaluatedTime
        self.nextToken = nextToken
        self.spotFleetRequestId = spotFleetRequestId
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case historyRecords = "historyRecordSet"
        case lastEvaluatedTime
        case nextToken
        case spotFleetRequestId
        case startTime
    }

    public func validate() throws {
    }
}

public struct DescribeSpotFleetRequestsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: Integer?
    public var nextToken: String?
    public var spotFleetRequestIds: SpotFleetRequestIdList?

    public init(dryRun: Boolean? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                spotFleetRequestIds: SpotFleetRequestIdList? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spotFleetRequestIds = spotFleetRequestIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case maxResults
        case nextToken
        case spotFleetRequestIds = "spotFleetRequestId"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotFleetRequestsResponse: Codable, Equatable {
    public var nextToken: String?
    public var spotFleetRequestConfigs: SpotFleetRequestConfigSet?

    public init(nextToken: String? = nil,
                spotFleetRequestConfigs: SpotFleetRequestConfigSet? = nil) {
        self.nextToken = nextToken
        self.spotFleetRequestConfigs = spotFleetRequestConfigs
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case spotFleetRequestConfigs = "spotFleetRequestConfigSet"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotInstanceRequestsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var spotInstanceRequestIds: SpotInstanceRequestIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                spotInstanceRequestIds: SpotInstanceRequestIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spotInstanceRequestIds = spotInstanceRequestIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case spotInstanceRequestIds = "SpotInstanceRequestId"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotInstanceRequestsResult: Codable, Equatable {
    public var nextToken: String?
    public var spotInstanceRequests: SpotInstanceRequestList?

    public init(nextToken: String? = nil,
                spotInstanceRequests: SpotInstanceRequestList? = nil) {
        self.nextToken = nextToken
        self.spotInstanceRequests = spotInstanceRequests
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case spotInstanceRequests = "spotInstanceRequestSet"
    }

    public func validate() throws {
    }
}

public struct DescribeSpotPriceHistoryRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var dryRun: Boolean?
    public var endTime: DateTime?
    public var filters: FilterList?
    public var instanceTypes: InstanceTypeList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var productDescriptions: ProductDescriptionList?
    public var startTime: DateTime?

    public init(availabilityZone: String? = nil,
                dryRun: Boolean? = nil,
                endTime: DateTime? = nil,
                filters: FilterList? = nil,
                instanceTypes: InstanceTypeList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                productDescriptions: ProductDescriptionList? = nil,
                startTime: DateTime? = nil) {
        self.availabilityZone = availabilityZone
        self.dryRun = dryRun
        self.endTime = endTime
        self.filters = filters
        self.instanceTypes = instanceTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productDescriptions = productDescriptions
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case dryRun
        case endTime
        case filters = "Filter"
        case instanceTypes = "InstanceType"
        case maxResults
        case nextToken
        case productDescriptions = "ProductDescription"
        case startTime
    }

    public func validate() throws {
    }
}

public struct DescribeSpotPriceHistoryResult: Codable, Equatable {
    public var nextToken: String?
    public var spotPriceHistory: SpotPriceHistoryList?

    public init(nextToken: String? = nil,
                spotPriceHistory: SpotPriceHistoryList? = nil) {
        self.nextToken = nextToken
        self.spotPriceHistory = spotPriceHistory
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case spotPriceHistory = "spotPriceHistorySet"
    }

    public func validate() throws {
    }
}

public struct DescribeStaleSecurityGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: DescribeStaleSecurityGroupsMaxResults?
    public var nextToken: DescribeStaleSecurityGroupsNextToken?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                maxResults: DescribeStaleSecurityGroupsMaxResults? = nil,
                nextToken: DescribeStaleSecurityGroupsNextToken? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcId = "VpcId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeStaleSecurityGroupsMaxResults()
        try nextToken?.validateAsDescribeStaleSecurityGroupsNextToken()
    }
}

public struct DescribeStaleSecurityGroupsResult: Codable, Equatable {
    public var nextToken: String?
    public var staleSecurityGroupSet: StaleSecurityGroupSet?

    public init(nextToken: String? = nil,
                staleSecurityGroupSet: StaleSecurityGroupSet? = nil) {
        self.nextToken = nextToken
        self.staleSecurityGroupSet = staleSecurityGroupSet
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case staleSecurityGroupSet
    }

    public func validate() throws {
    }
}

public struct DescribeStoreImageTasksRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var imageIds: ImageIdList?
    public var maxResults: DescribeStoreImageTasksRequestMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                imageIds: ImageIdList? = nil,
                maxResults: DescribeStoreImageTasksRequestMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case imageIds = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeStoreImageTasksRequestMaxResults()
    }
}

public struct DescribeStoreImageTasksResult: Codable, Equatable {
    public var nextToken: String?
    public var storeImageTaskResults: StoreImageTaskResultSet?

    public init(nextToken: String? = nil,
                storeImageTaskResults: StoreImageTaskResultSet? = nil) {
        self.nextToken = nextToken
        self.storeImageTaskResults = storeImageTaskResults
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case storeImageTaskResults = "storeImageTaskResultSet"
    }

    public func validate() throws {
    }
}

public struct DescribeSubnetsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeSubnetsMaxResults?
    public var nextToken: String?
    public var subnetIds: SubnetIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeSubnetsMaxResults? = nil,
                nextToken: String? = nil,
                subnetIds: SubnetIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subnetIds = subnetIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetIds = "SubnetId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeSubnetsMaxResults()
    }
}

public struct DescribeSubnetsResult: Codable, Equatable {
    public var nextToken: String?
    public var subnets: SubnetList?

    public init(nextToken: String? = nil,
                subnets: SubnetList? = nil) {
        self.nextToken = nextToken
        self.subnets = subnets
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case subnets = "subnetSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTagsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeTagsResult: Codable, Equatable {
    public var nextToken: String?
    public var tags: TagDescriptionList?

    public init(nextToken: String? = nil,
                tags: TagDescriptionList? = nil) {
        self.nextToken = nextToken
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTrafficMirrorFiltersRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TrafficMirroringMaxResults?
    public var nextToken: NextToken?
    public var trafficMirrorFilterIds: TrafficMirrorFilterIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TrafficMirroringMaxResults? = nil,
                nextToken: NextToken? = nil,
                trafficMirrorFilterIds: TrafficMirrorFilterIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trafficMirrorFilterIds = trafficMirrorFilterIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case trafficMirrorFilterIds = "TrafficMirrorFilterId"
    }

    public func validate() throws {
        try maxResults?.validateAsTrafficMirroringMaxResults()
    }
}

public struct DescribeTrafficMirrorFiltersResult: Codable, Equatable {
    public var nextToken: String?
    public var trafficMirrorFilters: TrafficMirrorFilterSet?

    public init(nextToken: String? = nil,
                trafficMirrorFilters: TrafficMirrorFilterSet? = nil) {
        self.nextToken = nextToken
        self.trafficMirrorFilters = trafficMirrorFilters
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case trafficMirrorFilters = "trafficMirrorFilterSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTrafficMirrorSessionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TrafficMirroringMaxResults?
    public var nextToken: NextToken?
    public var trafficMirrorSessionIds: TrafficMirrorSessionIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TrafficMirroringMaxResults? = nil,
                nextToken: NextToken? = nil,
                trafficMirrorSessionIds: TrafficMirrorSessionIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trafficMirrorSessionIds = trafficMirrorSessionIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case trafficMirrorSessionIds = "TrafficMirrorSessionId"
    }

    public func validate() throws {
        try maxResults?.validateAsTrafficMirroringMaxResults()
    }
}

public struct DescribeTrafficMirrorSessionsResult: Codable, Equatable {
    public var nextToken: String?
    public var trafficMirrorSessions: TrafficMirrorSessionSet?

    public init(nextToken: String? = nil,
                trafficMirrorSessions: TrafficMirrorSessionSet? = nil) {
        self.nextToken = nextToken
        self.trafficMirrorSessions = trafficMirrorSessions
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case trafficMirrorSessions = "trafficMirrorSessionSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTrafficMirrorTargetsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TrafficMirroringMaxResults?
    public var nextToken: NextToken?
    public var trafficMirrorTargetIds: TrafficMirrorTargetIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TrafficMirroringMaxResults? = nil,
                nextToken: NextToken? = nil,
                trafficMirrorTargetIds: TrafficMirrorTargetIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trafficMirrorTargetIds = trafficMirrorTargetIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case trafficMirrorTargetIds = "TrafficMirrorTargetId"
    }

    public func validate() throws {
        try maxResults?.validateAsTrafficMirroringMaxResults()
    }
}

public struct DescribeTrafficMirrorTargetsResult: Codable, Equatable {
    public var nextToken: String?
    public var trafficMirrorTargets: TrafficMirrorTargetSet?

    public init(nextToken: String? = nil,
                trafficMirrorTargets: TrafficMirrorTargetSet? = nil) {
        self.nextToken = nextToken
        self.trafficMirrorTargets = trafficMirrorTargets
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case trafficMirrorTargets = "trafficMirrorTargetSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayAttachmentsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentIds = transitGatewayAttachmentIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentIds = "TransitGatewayAttachmentIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayAttachmentsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayAttachments: TransitGatewayAttachmentList?

    public init(nextToken: String? = nil,
                transitGatewayAttachments: TransitGatewayAttachmentList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayAttachments = transitGatewayAttachments
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayAttachments
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayConnectPeersRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayConnectPeerIds: TransitGatewayConnectPeerIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayConnectPeerIds: TransitGatewayConnectPeerIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayConnectPeerIds = transitGatewayConnectPeerIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayConnectPeerIds = "TransitGatewayConnectPeerIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayConnectPeersResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayConnectPeers: TransitGatewayConnectPeerList?

    public init(nextToken: String? = nil,
                transitGatewayConnectPeers: TransitGatewayConnectPeerList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayConnectPeers = transitGatewayConnectPeers
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayConnectPeers = "transitGatewayConnectPeerSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayConnectsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentIds = transitGatewayAttachmentIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentIds = "TransitGatewayAttachmentIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayConnectsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayConnects: TransitGatewayConnectList?

    public init(nextToken: String? = nil,
                transitGatewayConnects: TransitGatewayConnectList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayConnects = transitGatewayConnects
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayConnects = "transitGatewayConnectSet"
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayMulticastDomainsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayMulticastDomainIds: TransitGatewayMulticastDomainIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayMulticastDomainIds: TransitGatewayMulticastDomainIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayMulticastDomainIds = transitGatewayMulticastDomainIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayMulticastDomainIds = "TransitGatewayMulticastDomainIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayMulticastDomainsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayMulticastDomains: TransitGatewayMulticastDomainList?

    public init(nextToken: String? = nil,
                transitGatewayMulticastDomains: TransitGatewayMulticastDomainList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayMulticastDomains = transitGatewayMulticastDomains
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayMulticastDomains
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayPeeringAttachmentsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentIds = transitGatewayAttachmentIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentIds = "TransitGatewayAttachmentIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayPeeringAttachmentsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayPeeringAttachments: TransitGatewayPeeringAttachmentList?

    public init(nextToken: String? = nil,
                transitGatewayPeeringAttachments: TransitGatewayPeeringAttachmentList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayPeeringAttachments = transitGatewayPeeringAttachments
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayPeeringAttachments
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayPolicyTablesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayPolicyTableIds: TransitGatewayPolicyTableIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayPolicyTableIds: TransitGatewayPolicyTableIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayPolicyTableIds = transitGatewayPolicyTableIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayPolicyTableIds = "TransitGatewayPolicyTableIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayPolicyTablesResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayPolicyTables: TransitGatewayPolicyTableList?

    public init(nextToken: String? = nil,
                transitGatewayPolicyTables: TransitGatewayPolicyTableList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayPolicyTables = transitGatewayPolicyTables
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayPolicyTables
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayRouteTableAnnouncementsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayRouteTableAnnouncementIds: TransitGatewayRouteTableAnnouncementIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayRouteTableAnnouncementIds: TransitGatewayRouteTableAnnouncementIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayRouteTableAnnouncementIds = transitGatewayRouteTableAnnouncementIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayRouteTableAnnouncementIds = "TransitGatewayRouteTableAnnouncementIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayRouteTableAnnouncementsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayRouteTableAnnouncements: TransitGatewayRouteTableAnnouncementList?

    public init(nextToken: String? = nil,
                transitGatewayRouteTableAnnouncements: TransitGatewayRouteTableAnnouncementList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayRouteTableAnnouncements = transitGatewayRouteTableAnnouncements
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayRouteTableAnnouncements
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayRouteTablesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayRouteTableIds: TransitGatewayRouteTableIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayRouteTableIds: TransitGatewayRouteTableIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayRouteTableIds = transitGatewayRouteTableIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayRouteTableIds = "TransitGatewayRouteTableIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayRouteTablesResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayRouteTables: TransitGatewayRouteTableList?

    public init(nextToken: String? = nil,
                transitGatewayRouteTables: TransitGatewayRouteTableList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayRouteTables = transitGatewayRouteTables
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayRouteTables
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewayVpcAttachmentsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentIds: TransitGatewayAttachmentIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentIds = transitGatewayAttachmentIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentIds = "TransitGatewayAttachmentIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewayVpcAttachmentsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayVpcAttachments: TransitGatewayVpcAttachmentList?

    public init(nextToken: String? = nil,
                transitGatewayVpcAttachments: TransitGatewayVpcAttachmentList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayVpcAttachments = transitGatewayVpcAttachments
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayVpcAttachments
    }

    public func validate() throws {
    }
}

public struct DescribeTransitGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayIds: TransitGatewayIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayIds: TransitGatewayIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayIds = transitGatewayIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayIds = "TransitGatewayIds"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct DescribeTransitGatewaysResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGateways: TransitGatewayList?

    public init(nextToken: String? = nil,
                transitGateways: TransitGatewayList? = nil) {
        self.nextToken = nextToken
        self.transitGateways = transitGateways
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGateways = "transitGatewaySet"
    }

    public func validate() throws {
    }
}

public struct DescribeTrunkInterfaceAssociationsRequest: Codable, Equatable {
    public var associationIds: TrunkInterfaceAssociationIdList?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeTrunkInterfaceAssociationsMaxResults?
    public var nextToken: String?

    public init(associationIds: TrunkInterfaceAssociationIdList? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeTrunkInterfaceAssociationsMaxResults? = nil,
                nextToken: String? = nil) {
        self.associationIds = associationIds
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case associationIds = "AssociationId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeTrunkInterfaceAssociationsMaxResults()
    }
}

public struct DescribeTrunkInterfaceAssociationsResult: Codable, Equatable {
    public var interfaceAssociations: TrunkInterfaceAssociationList?
    public var nextToken: String?

    public init(interfaceAssociations: TrunkInterfaceAssociationList? = nil,
                nextToken: String? = nil) {
        self.interfaceAssociations = interfaceAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case interfaceAssociations = "interfaceAssociationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeVerifiedAccessEndpointsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeVerifiedAccessEndpointsMaxResults?
    public var nextToken: NextToken?
    public var verifiedAccessEndpointIds: VerifiedAccessEndpointIdList?
    public var verifiedAccessGroupId: VerifiedAccessGroupId?
    public var verifiedAccessInstanceId: VerifiedAccessInstanceId?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeVerifiedAccessEndpointsMaxResults? = nil,
                nextToken: NextToken? = nil,
                verifiedAccessEndpointIds: VerifiedAccessEndpointIdList? = nil,
                verifiedAccessGroupId: VerifiedAccessGroupId? = nil,
                verifiedAccessInstanceId: VerifiedAccessInstanceId? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.verifiedAccessEndpointIds = verifiedAccessEndpointIds
        self.verifiedAccessGroupId = verifiedAccessGroupId
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case verifiedAccessEndpointIds = "VerifiedAccessEndpointId"
        case verifiedAccessGroupId = "VerifiedAccessGroupId"
        case verifiedAccessInstanceId = "VerifiedAccessInstanceId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVerifiedAccessEndpointsMaxResults()
    }
}

public struct DescribeVerifiedAccessEndpointsResult: Codable, Equatable {
    public var nextToken: NextToken?
    public var verifiedAccessEndpoints: VerifiedAccessEndpointList?

    public init(nextToken: NextToken? = nil,
                verifiedAccessEndpoints: VerifiedAccessEndpointList? = nil) {
        self.nextToken = nextToken
        self.verifiedAccessEndpoints = verifiedAccessEndpoints
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case verifiedAccessEndpoints = "verifiedAccessEndpointSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVerifiedAccessGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeVerifiedAccessGroupMaxResults?
    public var nextToken: NextToken?
    public var verifiedAccessGroupIds: VerifiedAccessGroupIdList?
    public var verifiedAccessInstanceId: VerifiedAccessInstanceId?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeVerifiedAccessGroupMaxResults? = nil,
                nextToken: NextToken? = nil,
                verifiedAccessGroupIds: VerifiedAccessGroupIdList? = nil,
                verifiedAccessInstanceId: VerifiedAccessInstanceId? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.verifiedAccessGroupIds = verifiedAccessGroupIds
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case verifiedAccessGroupIds = "VerifiedAccessGroupId"
        case verifiedAccessInstanceId = "VerifiedAccessInstanceId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVerifiedAccessGroupMaxResults()
    }
}

public struct DescribeVerifiedAccessGroupsResult: Codable, Equatable {
    public var nextToken: NextToken?
    public var verifiedAccessGroups: VerifiedAccessGroupList?

    public init(nextToken: NextToken? = nil,
                verifiedAccessGroups: VerifiedAccessGroupList? = nil) {
        self.nextToken = nextToken
        self.verifiedAccessGroups = verifiedAccessGroups
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case verifiedAccessGroups = "verifiedAccessGroupSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVerifiedAccessInstanceLoggingConfigurationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeVerifiedAccessInstanceLoggingConfigurationsMaxResults?
    public var nextToken: NextToken?
    public var verifiedAccessInstanceIds: VerifiedAccessInstanceIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeVerifiedAccessInstanceLoggingConfigurationsMaxResults? = nil,
                nextToken: NextToken? = nil,
                verifiedAccessInstanceIds: VerifiedAccessInstanceIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.verifiedAccessInstanceIds = verifiedAccessInstanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case verifiedAccessInstanceIds = "VerifiedAccessInstanceId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVerifiedAccessInstanceLoggingConfigurationsMaxResults()
    }
}

public struct DescribeVerifiedAccessInstanceLoggingConfigurationsResult: Codable, Equatable {
    public var loggingConfigurations: VerifiedAccessInstanceLoggingConfigurationList?
    public var nextToken: NextToken?

    public init(loggingConfigurations: VerifiedAccessInstanceLoggingConfigurationList? = nil,
                nextToken: NextToken? = nil) {
        self.loggingConfigurations = loggingConfigurations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case loggingConfigurations = "loggingConfigurationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeVerifiedAccessInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeVerifiedAccessInstancesMaxResults?
    public var nextToken: NextToken?
    public var verifiedAccessInstanceIds: VerifiedAccessInstanceIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeVerifiedAccessInstancesMaxResults? = nil,
                nextToken: NextToken? = nil,
                verifiedAccessInstanceIds: VerifiedAccessInstanceIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.verifiedAccessInstanceIds = verifiedAccessInstanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case verifiedAccessInstanceIds = "VerifiedAccessInstanceId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVerifiedAccessInstancesMaxResults()
    }
}

public struct DescribeVerifiedAccessInstancesResult: Codable, Equatable {
    public var nextToken: NextToken?
    public var verifiedAccessInstances: VerifiedAccessInstanceList?

    public init(nextToken: NextToken? = nil,
                verifiedAccessInstances: VerifiedAccessInstanceList? = nil) {
        self.nextToken = nextToken
        self.verifiedAccessInstances = verifiedAccessInstances
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case verifiedAccessInstances = "verifiedAccessInstanceSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVerifiedAccessTrustProvidersRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeVerifiedAccessTrustProvidersMaxResults?
    public var nextToken: NextToken?
    public var verifiedAccessTrustProviderIds: VerifiedAccessTrustProviderIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeVerifiedAccessTrustProvidersMaxResults? = nil,
                nextToken: NextToken? = nil,
                verifiedAccessTrustProviderIds: VerifiedAccessTrustProviderIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.verifiedAccessTrustProviderIds = verifiedAccessTrustProviderIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case verifiedAccessTrustProviderIds = "VerifiedAccessTrustProviderId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVerifiedAccessTrustProvidersMaxResults()
    }
}

public struct DescribeVerifiedAccessTrustProvidersResult: Codable, Equatable {
    public var nextToken: NextToken?
    public var verifiedAccessTrustProviders: VerifiedAccessTrustProviderList?

    public init(nextToken: NextToken? = nil,
                verifiedAccessTrustProviders: VerifiedAccessTrustProviderList? = nil) {
        self.nextToken = nextToken
        self.verifiedAccessTrustProviders = verifiedAccessTrustProviders
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case verifiedAccessTrustProviders = "verifiedAccessTrustProviderSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumeAttributeRequest: Codable, Equatable {
    public var attribute: VolumeAttributeName
    public var dryRun: Boolean?
    public var volumeId: VolumeId

    public init(attribute: VolumeAttributeName,
                dryRun: Boolean? = nil,
                volumeId: VolumeId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumeAttributeResult: Codable, Equatable {
    public var autoEnableIO: AttributeBooleanValue?
    public var productCodes: ProductCodeList?
    public var volumeId: String?

    public init(autoEnableIO: AttributeBooleanValue? = nil,
                productCodes: ProductCodeList? = nil,
                volumeId: String? = nil) {
        self.autoEnableIO = autoEnableIO
        self.productCodes = productCodes
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case autoEnableIO
        case productCodes
        case volumeId
    }

    public func validate() throws {
        try autoEnableIO?.validate()
    }
}

public struct DescribeVolumeStatusRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var volumeIds: VolumeIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                volumeIds: VolumeIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.volumeIds = volumeIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case volumeIds = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumeStatusResult: Codable, Equatable {
    public var nextToken: String?
    public var volumeStatuses: VolumeStatusList?

    public init(nextToken: String? = nil,
                volumeStatuses: VolumeStatusList? = nil) {
        self.nextToken = nextToken
        self.volumeStatuses = volumeStatuses
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case volumeStatuses = "volumeStatusSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumesModificationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var volumeIds: VolumeIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                volumeIds: VolumeIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.volumeIds = volumeIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case volumeIds = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumesModificationsResult: Codable, Equatable {
    public var nextToken: String?
    public var volumesModifications: VolumeModificationList?

    public init(nextToken: String? = nil,
                volumesModifications: VolumeModificationList? = nil) {
        self.nextToken = nextToken
        self.volumesModifications = volumesModifications
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case volumesModifications = "volumeModificationSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var volumeIds: VolumeIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                volumeIds: VolumeIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.volumeIds = volumeIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults
        case nextToken
        case volumeIds = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DescribeVolumesResult: Codable, Equatable {
    public var nextToken: String?
    public var volumes: VolumeList?

    public init(nextToken: String? = nil,
                volumes: VolumeList? = nil) {
        self.nextToken = nextToken
        self.volumes = volumes
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case volumes = "volumeSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcAttributeRequest: Codable, Equatable {
    public var attribute: VpcAttributeName
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(attribute: VpcAttributeName,
                dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcAttributeResult: Codable, Equatable {
    public var enableDnsHostnames: AttributeBooleanValue?
    public var enableDnsSupport: AttributeBooleanValue?
    public var enableNetworkAddressUsageMetrics: AttributeBooleanValue?
    public var vpcId: String?

    public init(enableDnsHostnames: AttributeBooleanValue? = nil,
                enableDnsSupport: AttributeBooleanValue? = nil,
                enableNetworkAddressUsageMetrics: AttributeBooleanValue? = nil,
                vpcId: String? = nil) {
        self.enableDnsHostnames = enableDnsHostnames
        self.enableDnsSupport = enableDnsSupport
        self.enableNetworkAddressUsageMetrics = enableNetworkAddressUsageMetrics
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case enableDnsHostnames
        case enableDnsSupport
        case enableNetworkAddressUsageMetrics
        case vpcId
    }

    public func validate() throws {
        try enableDnsHostnames?.validate()
        try enableDnsSupport?.validate()
        try enableNetworkAddressUsageMetrics?.validate()
    }
}

public struct DescribeVpcClassicLinkDnsSupportRequest: Codable, Equatable {
    public var maxResults: DescribeVpcClassicLinkDnsSupportMaxResults?
    public var nextToken: DescribeVpcClassicLinkDnsSupportNextToken?
    public var vpcIds: VpcClassicLinkIdList?

    public init(maxResults: DescribeVpcClassicLinkDnsSupportMaxResults? = nil,
                nextToken: DescribeVpcClassicLinkDnsSupportNextToken? = nil,
                vpcIds: VpcClassicLinkIdList? = nil) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcIds = vpcIds
    }

    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case vpcIds = "VpcIds"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVpcClassicLinkDnsSupportMaxResults()
        try nextToken?.validateAsDescribeVpcClassicLinkDnsSupportNextToken()
    }
}

public struct DescribeVpcClassicLinkDnsSupportResult: Codable, Equatable {
    public var nextToken: DescribeVpcClassicLinkDnsSupportNextToken?
    public var vpcs: ClassicLinkDnsSupportList?

    public init(nextToken: DescribeVpcClassicLinkDnsSupportNextToken? = nil,
                vpcs: ClassicLinkDnsSupportList? = nil) {
        self.nextToken = nextToken
        self.vpcs = vpcs
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcs
    }

    public func validate() throws {
        try nextToken?.validateAsDescribeVpcClassicLinkDnsSupportNextToken()
    }
}

public struct DescribeVpcClassicLinkRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var vpcIds: VpcClassicLinkIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                vpcIds: VpcClassicLinkIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.vpcIds = vpcIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case vpcIds = "VpcId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcClassicLinkResult: Codable, Equatable {
    public var vpcs: VpcClassicLinkList?

    public init(vpcs: VpcClassicLinkList? = nil) {
        self.vpcs = vpcs
    }

    enum CodingKeys: String, CodingKey {
        case vpcs = "vpcSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointConnectionNotificationsRequest: Codable, Equatable {
    public var connectionNotificationId: ConnectionNotificationId?
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(connectionNotificationId: ConnectionNotificationId? = nil,
                dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.connectionNotificationId = connectionNotificationId
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case connectionNotificationId = "ConnectionNotificationId"
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointConnectionNotificationsResult: Codable, Equatable {
    public var connectionNotificationSet: ConnectionNotificationSet?
    public var nextToken: String?

    public init(connectionNotificationSet: ConnectionNotificationSet? = nil,
                nextToken: String? = nil) {
        self.connectionNotificationSet = connectionNotificationSet
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case connectionNotificationSet
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointConnectionsResult: Codable, Equatable {
    public var nextToken: String?
    public var vpcEndpointConnections: VpcEndpointConnectionSet?

    public init(nextToken: String? = nil,
                vpcEndpointConnections: VpcEndpointConnectionSet? = nil) {
        self.nextToken = nextToken
        self.vpcEndpointConnections = vpcEndpointConnections
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcEndpointConnections = "vpcEndpointConnectionSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServiceConfigurationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var serviceIds: VpcEndpointServiceIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                serviceIds: VpcEndpointServiceIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIds = serviceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceIds = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServiceConfigurationsResult: Codable, Equatable {
    public var nextToken: String?
    public var serviceConfigurations: ServiceConfigurationSet?

    public init(nextToken: String? = nil,
                serviceConfigurations: ServiceConfigurationSet? = nil) {
        self.nextToken = nextToken
        self.serviceConfigurations = serviceConfigurations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case serviceConfigurations = "serviceConfigurationSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServicePermissionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var serviceId: VpcEndpointServiceId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                serviceId: VpcEndpointServiceId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServicePermissionsResult: Codable, Equatable {
    public var allowedPrincipals: AllowedPrincipalSet?
    public var nextToken: String?

    public init(allowedPrincipals: AllowedPrincipalSet? = nil,
                nextToken: String? = nil) {
        self.allowedPrincipals = allowedPrincipals
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case allowedPrincipals
        case nextToken
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServicesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var serviceNames: ValueStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                serviceNames: ValueStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceNames = serviceNames
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceNames = "ServiceName"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointServicesResult: Codable, Equatable {
    public var nextToken: String?
    public var serviceDetails: ServiceDetailSet?
    public var serviceNames: ValueStringList?

    public init(nextToken: String? = nil,
                serviceDetails: ServiceDetailSet? = nil,
                serviceNames: ValueStringList? = nil) {
        self.nextToken = nextToken
        self.serviceDetails = serviceDetails
        self.serviceNames = serviceNames
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case serviceDetails = "serviceDetailSet"
        case serviceNames = "serviceNameSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: Integer?
    public var nextToken: String?
    public var vpcEndpointIds: VpcEndpointIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                vpcEndpointIds: VpcEndpointIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcEndpointIds = vpcEndpointIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcEndpointIds = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcEndpointsResult: Codable, Equatable {
    public var nextToken: String?
    public var vpcEndpoints: VpcEndpointSet?

    public init(nextToken: String? = nil,
                vpcEndpoints: VpcEndpointSet? = nil) {
        self.nextToken = nextToken
        self.vpcEndpoints = vpcEndpoints
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcEndpoints = "vpcEndpointSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcPeeringConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeVpcPeeringConnectionsMaxResults?
    public var nextToken: String?
    public var vpcPeeringConnectionIds: VpcPeeringConnectionIdList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeVpcPeeringConnectionsMaxResults? = nil,
                nextToken: String? = nil,
                vpcPeeringConnectionIds: VpcPeeringConnectionIdList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcPeeringConnectionIds = vpcPeeringConnectionIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcPeeringConnectionIds = "VpcPeeringConnectionId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVpcPeeringConnectionsMaxResults()
    }
}

public struct DescribeVpcPeeringConnectionsResult: Codable, Equatable {
    public var nextToken: String?
    public var vpcPeeringConnections: VpcPeeringConnectionList?

    public init(nextToken: String? = nil,
                vpcPeeringConnections: VpcPeeringConnectionList? = nil) {
        self.nextToken = nextToken
        self.vpcPeeringConnections = vpcPeeringConnections
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcPeeringConnections = "vpcPeeringConnectionSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpcsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: DescribeVpcsMaxResults?
    public var nextToken: String?
    public var vpcIds: VpcIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: DescribeVpcsMaxResults? = nil,
                nextToken: String? = nil,
                vpcIds: VpcIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcIds = vpcIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcIds = "VpcId"
    }

    public func validate() throws {
        try maxResults?.validateAsDescribeVpcsMaxResults()
    }
}

public struct DescribeVpcsResult: Codable, Equatable {
    public var nextToken: String?
    public var vpcs: VpcList?

    public init(nextToken: String? = nil,
                vpcs: VpcList? = nil) {
        self.nextToken = nextToken
        self.vpcs = vpcs
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpcs = "vpcSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpnConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var vpnConnectionIds: VpnConnectionIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                vpnConnectionIds: VpnConnectionIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.vpnConnectionIds = vpnConnectionIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case vpnConnectionIds = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpnConnectionsResult: Codable, Equatable {
    public var vpnConnections: VpnConnectionList?

    public init(vpnConnections: VpnConnectionList? = nil) {
        self.vpnConnections = vpnConnections
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnections = "vpnConnectionSet"
    }

    public func validate() throws {
    }
}

public struct DescribeVpnGatewaysRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var vpnGatewayIds: VpnGatewayIdStringList?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                vpnGatewayIds: VpnGatewayIdStringList? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.vpnGatewayIds = vpnGatewayIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case filters = "Filter"
        case vpnGatewayIds = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct DescribeVpnGatewaysResult: Codable, Equatable {
    public var vpnGateways: VpnGatewayList?

    public init(vpnGateways: VpnGatewayList? = nil) {
        self.vpnGateways = vpnGateways
    }

    enum CodingKeys: String, CodingKey {
        case vpnGateways = "vpnGatewaySet"
    }

    public func validate() throws {
    }
}

public struct DestinationOptionsRequest: Codable, Equatable {
    public var fileFormat: DestinationFileFormat?
    public var hiveCompatiblePartitions: Boolean?
    public var perHourPartition: Boolean?

    public init(fileFormat: DestinationFileFormat? = nil,
                hiveCompatiblePartitions: Boolean? = nil,
                perHourPartition: Boolean? = nil) {
        self.fileFormat = fileFormat
        self.hiveCompatiblePartitions = hiveCompatiblePartitions
        self.perHourPartition = perHourPartition
    }

    enum CodingKeys: String, CodingKey {
        case fileFormat = "FileFormat"
        case hiveCompatiblePartitions = "HiveCompatiblePartitions"
        case perHourPartition = "PerHourPartition"
    }

    public func validate() throws {
    }
}

public struct DestinationOptionsResponse: Codable, Equatable {
    public var fileFormat: DestinationFileFormat?
    public var hiveCompatiblePartitions: Boolean?
    public var perHourPartition: Boolean?

    public init(fileFormat: DestinationFileFormat? = nil,
                hiveCompatiblePartitions: Boolean? = nil,
                perHourPartition: Boolean? = nil) {
        self.fileFormat = fileFormat
        self.hiveCompatiblePartitions = hiveCompatiblePartitions
        self.perHourPartition = perHourPartition
    }

    enum CodingKeys: String, CodingKey {
        case fileFormat
        case hiveCompatiblePartitions
        case perHourPartition
    }

    public func validate() throws {
    }
}

public struct DetachClassicLinkVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId
        case vpcId
    }

    public func validate() throws {
    }
}

public struct DetachClassicLinkVpcResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DetachInternetGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var internetGatewayId: InternetGatewayId
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                internetGatewayId: InternetGatewayId,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.internetGatewayId = internetGatewayId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case internetGatewayId
        case vpcId
    }

    public func validate() throws {
    }
}

public struct DetachNetworkInterfaceRequest: Codable, Equatable {
    public var attachmentId: NetworkInterfaceAttachmentId
    public var dryRun: Boolean?
    public var force: Boolean?

    public init(attachmentId: NetworkInterfaceAttachmentId,
                dryRun: Boolean? = nil,
                force: Boolean? = nil) {
        self.attachmentId = attachmentId
        self.dryRun = dryRun
        self.force = force
    }

    enum CodingKeys: String, CodingKey {
        case attachmentId
        case dryRun
        case force
    }

    public func validate() throws {
    }
}

public struct DetachVerifiedAccessTrustProviderRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var verifiedAccessInstanceId: VerifiedAccessInstanceId
    public var verifiedAccessTrustProviderId: VerifiedAccessTrustProviderId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                verifiedAccessInstanceId: VerifiedAccessInstanceId,
                verifiedAccessTrustProviderId: VerifiedAccessTrustProviderId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
        self.verifiedAccessTrustProviderId = verifiedAccessTrustProviderId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case verifiedAccessInstanceId = "VerifiedAccessInstanceId"
        case verifiedAccessTrustProviderId = "VerifiedAccessTrustProviderId"
    }

    public func validate() throws {
    }
}

public struct DetachVerifiedAccessTrustProviderResult: Codable, Equatable {
    public var verifiedAccessInstance: VerifiedAccessInstance?
    public var verifiedAccessTrustProvider: VerifiedAccessTrustProvider?

    public init(verifiedAccessInstance: VerifiedAccessInstance? = nil,
                verifiedAccessTrustProvider: VerifiedAccessTrustProvider? = nil) {
        self.verifiedAccessInstance = verifiedAccessInstance
        self.verifiedAccessTrustProvider = verifiedAccessTrustProvider
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessInstance
        case verifiedAccessTrustProvider
    }

    public func validate() throws {
        try verifiedAccessInstance?.validate()
        try verifiedAccessTrustProvider?.validate()
    }
}

public struct DetachVolumeRequest: Codable, Equatable {
    public var device: String?
    public var dryRun: Boolean?
    public var force: Boolean?
    public var instanceId: InstanceIdForResolver?
    public var volumeId: VolumeIdWithResolver

    public init(device: String? = nil,
                dryRun: Boolean? = nil,
                force: Boolean? = nil,
                instanceId: InstanceIdForResolver? = nil,
                volumeId: VolumeIdWithResolver) {
        self.device = device
        self.dryRun = dryRun
        self.force = force
        self.instanceId = instanceId
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case device = "Device"
        case dryRun
        case force = "Force"
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public func validate() throws {
    }
}

public struct DetachVpnGatewayRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId
    public var vpnGatewayId: VpnGatewayId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId,
                vpnGatewayId: VpnGatewayId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId = "VpcId"
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct DeviceOptions: Codable, Equatable {
    public var tenantId: String?

    public init(tenantId: String? = nil) {
        self.tenantId = tenantId
    }

    enum CodingKeys: String, CodingKey {
        case tenantId
    }

    public func validate() throws {
    }
}

public struct DhcpConfiguration: Codable, Equatable {
    public var key: String?
    public var values: DhcpConfigurationValueList?

    public init(key: String? = nil,
                values: DhcpConfigurationValueList? = nil) {
        self.key = key
        self.values = values
    }

    enum CodingKeys: String, CodingKey {
        case key
        case values = "valueSet"
    }

    public func validate() throws {
    }
}

public struct DhcpOptions: Codable, Equatable {
    public var dhcpConfigurations: DhcpConfigurationList?
    public var dhcpOptionsId: String?
    public var ownerId: String?
    public var tags: TagList?

    public init(dhcpConfigurations: DhcpConfigurationList? = nil,
                dhcpOptionsId: String? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil) {
        self.dhcpConfigurations = dhcpConfigurations
        self.dhcpOptionsId = dhcpOptionsId
        self.ownerId = ownerId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case dhcpConfigurations = "dhcpConfigurationSet"
        case dhcpOptionsId
        case ownerId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct DirectoryServiceAuthentication: Codable, Equatable {
    public var directoryId: String?

    public init(directoryId: String? = nil) {
        self.directoryId = directoryId
    }

    enum CodingKeys: String, CodingKey {
        case directoryId
    }

    public func validate() throws {
    }
}

public struct DirectoryServiceAuthenticationRequest: Codable, Equatable {
    public var directoryId: String?

    public init(directoryId: String? = nil) {
        self.directoryId = directoryId
    }

    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
    }

    public func validate() throws {
    }
}

public struct DisableAddressTransferRequest: Codable, Equatable {
    public var allocationId: AllocationId
    public var dryRun: Boolean?

    public init(allocationId: AllocationId,
                dryRun: Boolean? = nil) {
        self.allocationId = allocationId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DisableAddressTransferResult: Codable, Equatable {
    public var addressTransfer: AddressTransfer?

    public init(addressTransfer: AddressTransfer? = nil) {
        self.addressTransfer = addressTransfer
    }

    enum CodingKeys: String, CodingKey {
        case addressTransfer
    }

    public func validate() throws {
        try addressTransfer?.validate()
    }
}

public struct DisableAwsNetworkPerformanceMetricSubscriptionRequest: Codable, Equatable {
    public var destination: String?
    public var dryRun: Boolean?
    public var metric: MetricType?
    public var source: String?
    public var statistic: StatisticType?

    public init(destination: String? = nil,
                dryRun: Boolean? = nil,
                metric: MetricType? = nil,
                source: String? = nil,
                statistic: StatisticType? = nil) {
        self.destination = destination
        self.dryRun = dryRun
        self.metric = metric
        self.source = source
        self.statistic = statistic
    }

    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case dryRun = "DryRun"
        case metric = "Metric"
        case source = "Source"
        case statistic = "Statistic"
    }

    public func validate() throws {
    }
}

public struct DisableAwsNetworkPerformanceMetricSubscriptionResult: Codable, Equatable {
    public var output: Boolean?

    public init(output: Boolean? = nil) {
        self.output = output
    }

    enum CodingKeys: String, CodingKey {
        case output
    }

    public func validate() throws {
    }
}

public struct DisableEbsEncryptionByDefaultRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DisableEbsEncryptionByDefaultResult: Codable, Equatable {
    public var ebsEncryptionByDefault: Boolean?

    public init(ebsEncryptionByDefault: Boolean? = nil) {
        self.ebsEncryptionByDefault = ebsEncryptionByDefault
    }

    enum CodingKeys: String, CodingKey {
        case ebsEncryptionByDefault
    }

    public func validate() throws {
    }
}

public struct DisableFastLaunchRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var force: Boolean?
    public var imageId: ImageId

    public init(dryRun: Boolean? = nil,
                force: Boolean? = nil,
                imageId: ImageId) {
        self.dryRun = dryRun
        self.force = force
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case force = "Force"
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct DisableFastLaunchResult: Codable, Equatable {
    public var imageId: ImageId?
    public var launchTemplate: FastLaunchLaunchTemplateSpecificationResponse?
    public var maxParallelLaunches: Integer?
    public var ownerId: String?
    public var resourceType: FastLaunchResourceType?
    public var snapshotConfiguration: FastLaunchSnapshotConfigurationResponse?
    public var state: FastLaunchStateCode?
    public var stateTransitionReason: String?
    public var stateTransitionTime: MillisecondDateTime?

    public init(imageId: ImageId? = nil,
                launchTemplate: FastLaunchLaunchTemplateSpecificationResponse? = nil,
                maxParallelLaunches: Integer? = nil,
                ownerId: String? = nil,
                resourceType: FastLaunchResourceType? = nil,
                snapshotConfiguration: FastLaunchSnapshotConfigurationResponse? = nil,
                state: FastLaunchStateCode? = nil,
                stateTransitionReason: String? = nil,
                stateTransitionTime: MillisecondDateTime? = nil) {
        self.imageId = imageId
        self.launchTemplate = launchTemplate
        self.maxParallelLaunches = maxParallelLaunches
        self.ownerId = ownerId
        self.resourceType = resourceType
        self.snapshotConfiguration = snapshotConfiguration
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.stateTransitionTime = stateTransitionTime
    }

    enum CodingKeys: String, CodingKey {
        case imageId
        case launchTemplate
        case maxParallelLaunches
        case ownerId
        case resourceType
        case snapshotConfiguration
        case state
        case stateTransitionReason
        case stateTransitionTime
    }

    public func validate() throws {
        try launchTemplate?.validate()
        try snapshotConfiguration?.validate()
    }
}

public struct DisableFastSnapshotRestoreErrorItem: Codable, Equatable {
    public var fastSnapshotRestoreStateErrors: DisableFastSnapshotRestoreStateErrorSet?
    public var snapshotId: String?

    public init(fastSnapshotRestoreStateErrors: DisableFastSnapshotRestoreStateErrorSet? = nil,
                snapshotId: String? = nil) {
        self.fastSnapshotRestoreStateErrors = fastSnapshotRestoreStateErrors
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case fastSnapshotRestoreStateErrors = "fastSnapshotRestoreStateErrorSet"
        case snapshotId
    }

    public func validate() throws {
    }
}

public struct DisableFastSnapshotRestoreStateError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct DisableFastSnapshotRestoreStateErrorItem: Codable, Equatable {
    public var availabilityZone: String?
    public var error: DisableFastSnapshotRestoreStateError?

    public init(availabilityZone: String? = nil,
                error: DisableFastSnapshotRestoreStateError? = nil) {
        self.availabilityZone = availabilityZone
        self.error = error
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case error
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct DisableFastSnapshotRestoreSuccessItem: Codable, Equatable {
    public var availabilityZone: String?
    public var disabledTime: MillisecondDateTime?
    public var disablingTime: MillisecondDateTime?
    public var enabledTime: MillisecondDateTime?
    public var enablingTime: MillisecondDateTime?
    public var optimizingTime: MillisecondDateTime?
    public var ownerAlias: String?
    public var ownerId: String?
    public var snapshotId: String?
    public var state: FastSnapshotRestoreStateCode?
    public var stateTransitionReason: String?

    public init(availabilityZone: String? = nil,
                disabledTime: MillisecondDateTime? = nil,
                disablingTime: MillisecondDateTime? = nil,
                enabledTime: MillisecondDateTime? = nil,
                enablingTime: MillisecondDateTime? = nil,
                optimizingTime: MillisecondDateTime? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                snapshotId: String? = nil,
                state: FastSnapshotRestoreStateCode? = nil,
                stateTransitionReason: String? = nil) {
        self.availabilityZone = availabilityZone
        self.disabledTime = disabledTime
        self.disablingTime = disablingTime
        self.enabledTime = enabledTime
        self.enablingTime = enablingTime
        self.optimizingTime = optimizingTime
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.snapshotId = snapshotId
        self.state = state
        self.stateTransitionReason = stateTransitionReason
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case disabledTime
        case disablingTime
        case enabledTime
        case enablingTime
        case optimizingTime
        case ownerAlias
        case ownerId
        case snapshotId
        case state
        case stateTransitionReason
    }

    public func validate() throws {
    }
}

public struct DisableFastSnapshotRestoresRequest: Codable, Equatable {
    public var availabilityZones: AvailabilityZoneStringList
    public var dryRun: Boolean?
    public var sourceSnapshotIds: SnapshotIdStringList

    public init(availabilityZones: AvailabilityZoneStringList,
                dryRun: Boolean? = nil,
                sourceSnapshotIds: SnapshotIdStringList) {
        self.availabilityZones = availabilityZones
        self.dryRun = dryRun
        self.sourceSnapshotIds = sourceSnapshotIds
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZone"
        case dryRun = "DryRun"
        case sourceSnapshotIds = "SourceSnapshotId"
    }

    public func validate() throws {
    }
}

public struct DisableFastSnapshotRestoresResult: Codable, Equatable {
    public var successful: DisableFastSnapshotRestoreSuccessSet?
    public var unsuccessful: DisableFastSnapshotRestoreErrorSet?

    public init(successful: DisableFastSnapshotRestoreSuccessSet? = nil,
                unsuccessful: DisableFastSnapshotRestoreErrorSet? = nil) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case successful
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct DisableImageDeprecationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct DisableImageDeprecationResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DisableIpamOrganizationAdminAccountRequest: Codable, Equatable {
    public var delegatedAdminAccountId: String
    public var dryRun: Boolean?

    public init(delegatedAdminAccountId: String,
                dryRun: Boolean? = nil) {
        self.delegatedAdminAccountId = delegatedAdminAccountId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case delegatedAdminAccountId = "DelegatedAdminAccountId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DisableIpamOrganizationAdminAccountResult: Codable, Equatable {
    public var success: Boolean?

    public init(success: Boolean? = nil) {
        self.success = success
    }

    enum CodingKeys: String, CodingKey {
        case success
    }

    public func validate() throws {
    }
}

public struct DisableSerialConsoleAccessRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DisableSerialConsoleAccessResult: Codable, Equatable {
    public var serialConsoleAccessEnabled: Boolean?

    public init(serialConsoleAccessEnabled: Boolean? = nil) {
        self.serialConsoleAccessEnabled = serialConsoleAccessEnabled
    }

    enum CodingKeys: String, CodingKey {
        case serialConsoleAccessEnabled
    }

    public func validate() throws {
    }
}

public struct DisableTransitGatewayRouteTablePropagationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableAnnouncementId = transitGatewayRouteTableAnnouncementId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableAnnouncementId = "TransitGatewayRouteTableAnnouncementId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DisableTransitGatewayRouteTablePropagationResult: Codable, Equatable {
    public var propagation: TransitGatewayPropagation?

    public init(propagation: TransitGatewayPropagation? = nil) {
        self.propagation = propagation
    }

    enum CodingKeys: String, CodingKey {
        case propagation
    }

    public func validate() throws {
        try propagation?.validate()
    }
}

public struct DisableVgwRoutePropagationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var gatewayId: VpnGatewayId
    public var routeTableId: RouteTableId

    public init(dryRun: Boolean? = nil,
                gatewayId: VpnGatewayId,
                routeTableId: RouteTableId) {
        self.dryRun = dryRun
        self.gatewayId = gatewayId
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
    }

    public func validate() throws {
    }
}

public struct DisableVpcClassicLinkDnsSupportRequest: Codable, Equatable {
    public var vpcId: VpcId?

    public init(vpcId: VpcId? = nil) {
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct DisableVpcClassicLinkDnsSupportResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DisableVpcClassicLinkRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId
    }

    public func validate() throws {
    }
}

public struct DisableVpcClassicLinkResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DisassociateAddressRequest: Codable, Equatable {
    public var associationId: ElasticIpAssociationId?
    public var dryRun: Boolean?
    public var publicIp: String?

    public init(associationId: ElasticIpAssociationId? = nil,
                dryRun: Boolean? = nil,
                publicIp: String? = nil) {
        self.associationId = associationId
        self.dryRun = dryRun
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case dryRun
        case publicIp = "PublicIp"
    }

    public func validate() throws {
    }
}

public struct DisassociateClientVpnTargetNetworkRequest: Codable, Equatable {
    public var associationId: ClientVpnAssociationId
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(associationId: ClientVpnAssociationId,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.associationId = associationId
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DisassociateClientVpnTargetNetworkResult: Codable, Equatable {
    public var associationId: String?
    public var status: AssociationStatus?

    public init(associationId: String? = nil,
                status: AssociationStatus? = nil) {
        self.associationId = associationId
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct DisassociateEnclaveCertificateIamRoleRequest: Codable, Equatable {
    public var certificateArn: ResourceArn?
    public var dryRun: Boolean?
    public var roleArn: ResourceArn?

    public init(certificateArn: ResourceArn? = nil,
                dryRun: Boolean? = nil,
                roleArn: ResourceArn? = nil) {
        self.certificateArn = certificateArn
        self.dryRun = dryRun
        self.roleArn = roleArn
    }

    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case dryRun = "DryRun"
        case roleArn = "RoleArn"
    }

    public func validate() throws {
        try certificateArn?.validateAsResourceArn()
        try roleArn?.validateAsResourceArn()
    }
}

public struct DisassociateEnclaveCertificateIamRoleResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DisassociateIamInstanceProfileRequest: Codable, Equatable {
    public var associationId: IamInstanceProfileAssociationId

    public init(associationId: IamInstanceProfileAssociationId) {
        self.associationId = associationId
    }

    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
    }

    public func validate() throws {
    }
}

public struct DisassociateIamInstanceProfileResult: Codable, Equatable {
    public var iamInstanceProfileAssociation: IamInstanceProfileAssociation?

    public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
        self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfileAssociation
    }

    public func validate() throws {
        try iamInstanceProfileAssociation?.validate()
    }
}

public struct DisassociateInstanceEventWindowRequest: Codable, Equatable {
    public var associationTarget: InstanceEventWindowDisassociationRequest
    public var dryRun: Boolean?
    public var instanceEventWindowId: InstanceEventWindowId

    public init(associationTarget: InstanceEventWindowDisassociationRequest,
                dryRun: Boolean? = nil,
                instanceEventWindowId: InstanceEventWindowId) {
        self.associationTarget = associationTarget
        self.dryRun = dryRun
        self.instanceEventWindowId = instanceEventWindowId
    }

    enum CodingKeys: String, CodingKey {
        case associationTarget = "AssociationTarget"
        case dryRun = "DryRun"
        case instanceEventWindowId = "InstanceEventWindowId"
    }

    public func validate() throws {
        try associationTarget.validate()
    }
}

public struct DisassociateInstanceEventWindowResult: Codable, Equatable {
    public var instanceEventWindow: InstanceEventWindow?

    public init(instanceEventWindow: InstanceEventWindow? = nil) {
        self.instanceEventWindow = instanceEventWindow
    }

    enum CodingKeys: String, CodingKey {
        case instanceEventWindow
    }

    public func validate() throws {
        try instanceEventWindow?.validate()
    }
}

public struct DisassociateRouteTableRequest: Codable, Equatable {
    public var associationId: RouteTableAssociationId
    public var dryRun: Boolean?

    public init(associationId: RouteTableAssociationId,
                dryRun: Boolean? = nil) {
        self.associationId = associationId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case dryRun
    }

    public func validate() throws {
    }
}

public struct DisassociateSubnetCidrBlockRequest: Codable, Equatable {
    public var associationId: SubnetCidrAssociationId

    public init(associationId: SubnetCidrAssociationId) {
        self.associationId = associationId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
    }

    public func validate() throws {
    }
}

public struct DisassociateSubnetCidrBlockResult: Codable, Equatable {
    public var ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation?
    public var subnetId: String?

    public init(ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil,
                subnetId: String? = nil) {
        self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrBlockAssociation
        case subnetId
    }

    public func validate() throws {
        try ipv6CidrBlockAssociation?.validate()
    }
}

public struct DisassociateTransitGatewayMulticastDomainRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetIds: TransitGatewaySubnetIdList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                subnetIds: TransitGatewaySubnetIdList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.subnetIds = subnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case subnetIds = "SubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct DisassociateTransitGatewayMulticastDomainResult: Codable, Equatable {
    public var associations: TransitGatewayMulticastDomainAssociations?

    public init(associations: TransitGatewayMulticastDomainAssociations? = nil) {
        self.associations = associations
    }

    enum CodingKeys: String, CodingKey {
        case associations
    }

    public func validate() throws {
        try associations?.validate()
    }
}

public struct DisassociateTransitGatewayPolicyTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId
    public var transitGatewayPolicyTableId: TransitGatewayPolicyTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId,
                transitGatewayPolicyTableId: TransitGatewayPolicyTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayPolicyTableId = transitGatewayPolicyTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayPolicyTableId = "TransitGatewayPolicyTableId"
    }

    public func validate() throws {
    }
}

public struct DisassociateTransitGatewayPolicyTableResult: Codable, Equatable {
    public var association: TransitGatewayPolicyTableAssociation?

    public init(association: TransitGatewayPolicyTableAssociation? = nil) {
        self.association = association
    }

    enum CodingKeys: String, CodingKey {
        case association
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct DisassociateTransitGatewayRouteTableRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct DisassociateTransitGatewayRouteTableResult: Codable, Equatable {
    public var association: TransitGatewayAssociation?

    public init(association: TransitGatewayAssociation? = nil) {
        self.association = association
    }

    enum CodingKeys: String, CodingKey {
        case association
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct DisassociateTrunkInterfaceRequest: Codable, Equatable {
    public var associationId: TrunkInterfaceAssociationId
    public var clientToken: String?
    public var dryRun: Boolean?

    public init(associationId: TrunkInterfaceAssociationId,
                clientToken: String? = nil,
                dryRun: Boolean? = nil) {
        self.associationId = associationId
        self.clientToken = clientToken
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct DisassociateTrunkInterfaceResult: Codable, Equatable {
    public var clientToken: String?
    public var `return`: Boolean?

    public init(clientToken: String? = nil,
                `return`: Boolean? = nil) {
        self.clientToken = clientToken
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct DisassociateVpcCidrBlockRequest: Codable, Equatable {
    public var associationId: VpcCidrAssociationId

    public init(associationId: VpcCidrAssociationId) {
        self.associationId = associationId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
    }

    public func validate() throws {
    }
}

public struct DisassociateVpcCidrBlockResult: Codable, Equatable {
    public var cidrBlockAssociation: VpcCidrBlockAssociation?
    public var ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation?
    public var vpcId: String?

    public init(cidrBlockAssociation: VpcCidrBlockAssociation? = nil,
                ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil,
                vpcId: String? = nil) {
        self.cidrBlockAssociation = cidrBlockAssociation
        self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlockAssociation
        case ipv6CidrBlockAssociation
        case vpcId
    }

    public func validate() throws {
        try cidrBlockAssociation?.validate()
        try ipv6CidrBlockAssociation?.validate()
    }
}

public struct DiskImage: Codable, Equatable {
    public var description: String?
    public var image: DiskImageDetail?
    public var volume: VolumeDetail?

    public init(description: String? = nil,
                image: DiskImageDetail? = nil,
                volume: VolumeDetail? = nil) {
        self.description = description
        self.image = image
        self.volume = volume
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case image = "Image"
        case volume = "Volume"
    }

    public func validate() throws {
        try image?.validate()
        try volume?.validate()
    }
}

public struct DiskImageDescription: Codable, Equatable {
    public var checksum: String?
    public var format: DiskImageFormat?
    public var importManifestUrl: String?
    public var size: Long?

    public init(checksum: String? = nil,
                format: DiskImageFormat? = nil,
                importManifestUrl: String? = nil,
                size: Long? = nil) {
        self.checksum = checksum
        self.format = format
        self.importManifestUrl = importManifestUrl
        self.size = size
    }

    enum CodingKeys: String, CodingKey {
        case checksum
        case format
        case importManifestUrl
        case size
    }

    public func validate() throws {
    }
}

public struct DiskImageDetail: Codable, Equatable {
    public var bytes: Long
    public var format: DiskImageFormat
    public var importManifestUrl: String

    public init(bytes: Long,
                format: DiskImageFormat,
                importManifestUrl: String) {
        self.bytes = bytes
        self.format = format
        self.importManifestUrl = importManifestUrl
    }

    enum CodingKeys: String, CodingKey {
        case bytes
        case format
        case importManifestUrl
    }

    public func validate() throws {
    }
}

public struct DiskImageVolumeDescription: Codable, Equatable {
    public var id: String?
    public var size: Long?

    public init(id: String? = nil,
                size: Long? = nil) {
        self.id = id
        self.size = size
    }

    enum CodingKeys: String, CodingKey {
        case id
        case size
    }

    public func validate() throws {
    }
}

public struct DiskInfo: Codable, Equatable {
    public var count: DiskCount?
    public var sizeInGB: DiskSize?
    public var type: DiskType?

    public init(count: DiskCount? = nil,
                sizeInGB: DiskSize? = nil,
                type: DiskType? = nil) {
        self.count = count
        self.sizeInGB = sizeInGB
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case count
        case sizeInGB
        case type
    }

    public func validate() throws {
    }
}

public struct DnsEntry: Codable, Equatable {
    public var dnsName: String?
    public var hostedZoneId: String?

    public init(dnsName: String? = nil,
                hostedZoneId: String? = nil) {
        self.dnsName = dnsName
        self.hostedZoneId = hostedZoneId
    }

    enum CodingKeys: String, CodingKey {
        case dnsName
        case hostedZoneId
    }

    public func validate() throws {
    }
}

public struct DnsOptions: Codable, Equatable {
    public var dnsRecordIpType: DnsRecordIpType?

    public init(dnsRecordIpType: DnsRecordIpType? = nil) {
        self.dnsRecordIpType = dnsRecordIpType
    }

    enum CodingKeys: String, CodingKey {
        case dnsRecordIpType
    }

    public func validate() throws {
    }
}

public struct DnsOptionsSpecification: Codable, Equatable {
    public var dnsRecordIpType: DnsRecordIpType?

    public init(dnsRecordIpType: DnsRecordIpType? = nil) {
        self.dnsRecordIpType = dnsRecordIpType
    }

    enum CodingKeys: String, CodingKey {
        case dnsRecordIpType = "DnsRecordIpType"
    }

    public func validate() throws {
    }
}

public struct DnsServersOptionsModifyStructure: Codable, Equatable {
    public var customDnsServers: ValueStringList?
    public var enabled: Boolean?

    public init(customDnsServers: ValueStringList? = nil,
                enabled: Boolean? = nil) {
        self.customDnsServers = customDnsServers
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case customDnsServers = "CustomDnsServers"
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct EbsBlockDevice: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var kmsKeyId: String?
    public var outpostArn: String?
    public var snapshotId: SnapshotId?
    public var throughput: Integer?
    public var volumeSize: Integer?
    public var volumeType: VolumeType?

    public init(deleteOnTermination: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: String? = nil,
                outpostArn: String? = nil,
                snapshotId: SnapshotId? = nil,
                throughput: Integer? = nil,
                volumeSize: Integer? = nil,
                volumeType: VolumeType? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.outpostArn = outpostArn
        self.snapshotId = snapshotId
        self.throughput = throughput
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination
        case encrypted
        case iops
        case kmsKeyId
        case outpostArn
        case snapshotId
        case throughput
        case volumeSize
        case volumeType
    }

    public func validate() throws {
    }
}

public struct EbsInfo: Codable, Equatable {
    public var ebsOptimizedInfo: EbsOptimizedInfo?
    public var ebsOptimizedSupport: EbsOptimizedSupport?
    public var encryptionSupport: EbsEncryptionSupport?
    public var nvmeSupport: EbsNvmeSupport?

    public init(ebsOptimizedInfo: EbsOptimizedInfo? = nil,
                ebsOptimizedSupport: EbsOptimizedSupport? = nil,
                encryptionSupport: EbsEncryptionSupport? = nil,
                nvmeSupport: EbsNvmeSupport? = nil) {
        self.ebsOptimizedInfo = ebsOptimizedInfo
        self.ebsOptimizedSupport = ebsOptimizedSupport
        self.encryptionSupport = encryptionSupport
        self.nvmeSupport = nvmeSupport
    }

    enum CodingKeys: String, CodingKey {
        case ebsOptimizedInfo
        case ebsOptimizedSupport
        case encryptionSupport
        case nvmeSupport
    }

    public func validate() throws {
        try ebsOptimizedInfo?.validate()
    }
}

public struct EbsInstanceBlockDevice: Codable, Equatable {
    public var attachTime: DateTime?
    public var deleteOnTermination: Boolean?
    public var status: AttachmentStatus?
    public var volumeId: String?

    public init(attachTime: DateTime? = nil,
                deleteOnTermination: Boolean? = nil,
                status: AttachmentStatus? = nil,
                volumeId: String? = nil) {
        self.attachTime = attachTime
        self.deleteOnTermination = deleteOnTermination
        self.status = status
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case attachTime
        case deleteOnTermination
        case status
        case volumeId
    }

    public func validate() throws {
    }
}

public struct EbsInstanceBlockDeviceSpecification: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var volumeId: VolumeId?

    public init(deleteOnTermination: Boolean? = nil,
                volumeId: VolumeId? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination
        case volumeId
    }

    public func validate() throws {
    }
}

public struct EbsOptimizedInfo: Codable, Equatable {
    public var baselineBandwidthInMbps: BaselineBandwidthInMbps?
    public var baselineIops: BaselineIops?
    public var baselineThroughputInMBps: BaselineThroughputInMBps?
    public var maximumBandwidthInMbps: MaximumBandwidthInMbps?
    public var maximumIops: MaximumIops?
    public var maximumThroughputInMBps: MaximumThroughputInMBps?

    public init(baselineBandwidthInMbps: BaselineBandwidthInMbps? = nil,
                baselineIops: BaselineIops? = nil,
                baselineThroughputInMBps: BaselineThroughputInMBps? = nil,
                maximumBandwidthInMbps: MaximumBandwidthInMbps? = nil,
                maximumIops: MaximumIops? = nil,
                maximumThroughputInMBps: MaximumThroughputInMBps? = nil) {
        self.baselineBandwidthInMbps = baselineBandwidthInMbps
        self.baselineIops = baselineIops
        self.baselineThroughputInMBps = baselineThroughputInMBps
        self.maximumBandwidthInMbps = maximumBandwidthInMbps
        self.maximumIops = maximumIops
        self.maximumThroughputInMBps = maximumThroughputInMBps
    }

    enum CodingKeys: String, CodingKey {
        case baselineBandwidthInMbps
        case baselineIops
        case baselineThroughputInMBps
        case maximumBandwidthInMbps
        case maximumIops
        case maximumThroughputInMBps
    }

    public func validate() throws {
    }
}

public struct EfaInfo: Codable, Equatable {
    public var maximumEfaInterfaces: MaximumEfaInterfaces?

    public init(maximumEfaInterfaces: MaximumEfaInterfaces? = nil) {
        self.maximumEfaInterfaces = maximumEfaInterfaces
    }

    enum CodingKeys: String, CodingKey {
        case maximumEfaInterfaces
    }

    public func validate() throws {
    }
}

public struct EgressOnlyInternetGateway: Codable, Equatable {
    public var attachments: InternetGatewayAttachmentList?
    public var egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId?
    public var tags: TagList?

    public init(attachments: InternetGatewayAttachmentList? = nil,
                egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId? = nil,
                tags: TagList? = nil) {
        self.attachments = attachments
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case attachments = "attachmentSet"
        case egressOnlyInternetGatewayId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct ElasticGpuAssociation: Codable, Equatable {
    public var elasticGpuAssociationId: String?
    public var elasticGpuAssociationState: String?
    public var elasticGpuAssociationTime: String?
    public var elasticGpuId: ElasticGpuId?

    public init(elasticGpuAssociationId: String? = nil,
                elasticGpuAssociationState: String? = nil,
                elasticGpuAssociationTime: String? = nil,
                elasticGpuId: ElasticGpuId? = nil) {
        self.elasticGpuAssociationId = elasticGpuAssociationId
        self.elasticGpuAssociationState = elasticGpuAssociationState
        self.elasticGpuAssociationTime = elasticGpuAssociationTime
        self.elasticGpuId = elasticGpuId
    }

    enum CodingKeys: String, CodingKey {
        case elasticGpuAssociationId
        case elasticGpuAssociationState
        case elasticGpuAssociationTime
        case elasticGpuId
    }

    public func validate() throws {
    }
}

public struct ElasticGpuHealth: Codable, Equatable {
    public var status: ElasticGpuStatus?

    public init(status: ElasticGpuStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
    }
}

public struct ElasticGpuSpecification: Codable, Equatable {
    public var type: String

    public init(type: String) {
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func validate() throws {
    }
}

public struct ElasticGpuSpecificationResponse: Codable, Equatable {
    public var type: String?

    public init(type: String? = nil) {
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case type
    }

    public func validate() throws {
    }
}

public struct ElasticGpus: Codable, Equatable {
    public var availabilityZone: String?
    public var elasticGpuHealth: ElasticGpuHealth?
    public var elasticGpuId: String?
    public var elasticGpuState: ElasticGpuState?
    public var elasticGpuType: String?
    public var instanceId: String?
    public var tags: TagList?

    public init(availabilityZone: String? = nil,
                elasticGpuHealth: ElasticGpuHealth? = nil,
                elasticGpuId: String? = nil,
                elasticGpuState: ElasticGpuState? = nil,
                elasticGpuType: String? = nil,
                instanceId: String? = nil,
                tags: TagList? = nil) {
        self.availabilityZone = availabilityZone
        self.elasticGpuHealth = elasticGpuHealth
        self.elasticGpuId = elasticGpuId
        self.elasticGpuState = elasticGpuState
        self.elasticGpuType = elasticGpuType
        self.instanceId = instanceId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case elasticGpuHealth
        case elasticGpuId
        case elasticGpuState
        case elasticGpuType
        case instanceId
        case tags = "tagSet"
    }

    public func validate() throws {
        try elasticGpuHealth?.validate()
    }
}

public struct ElasticInferenceAccelerator: Codable, Equatable {
    public var count: ElasticInferenceAcceleratorCount?
    public var type: String

    public init(count: ElasticInferenceAcceleratorCount? = nil,
                type: String) {
        self.count = count
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case type = "Type"
    }

    public func validate() throws {
        try count?.validateAsElasticInferenceAcceleratorCount()
    }
}

public struct ElasticInferenceAcceleratorAssociation: Codable, Equatable {
    public var elasticInferenceAcceleratorArn: String?
    public var elasticInferenceAcceleratorAssociationId: String?
    public var elasticInferenceAcceleratorAssociationState: String?
    public var elasticInferenceAcceleratorAssociationTime: DateTime?

    public init(elasticInferenceAcceleratorArn: String? = nil,
                elasticInferenceAcceleratorAssociationId: String? = nil,
                elasticInferenceAcceleratorAssociationState: String? = nil,
                elasticInferenceAcceleratorAssociationTime: DateTime? = nil) {
        self.elasticInferenceAcceleratorArn = elasticInferenceAcceleratorArn
        self.elasticInferenceAcceleratorAssociationId = elasticInferenceAcceleratorAssociationId
        self.elasticInferenceAcceleratorAssociationState = elasticInferenceAcceleratorAssociationState
        self.elasticInferenceAcceleratorAssociationTime = elasticInferenceAcceleratorAssociationTime
    }

    enum CodingKeys: String, CodingKey {
        case elasticInferenceAcceleratorArn
        case elasticInferenceAcceleratorAssociationId
        case elasticInferenceAcceleratorAssociationState
        case elasticInferenceAcceleratorAssociationTime
    }

    public func validate() throws {
    }
}

public struct EnaSrdSpecification: Codable, Equatable {
    public var enaSrdEnabled: Boolean?
    public var enaSrdUdpSpecification: EnaSrdUdpSpecification?

    public init(enaSrdEnabled: Boolean? = nil,
                enaSrdUdpSpecification: EnaSrdUdpSpecification? = nil) {
        self.enaSrdEnabled = enaSrdEnabled
        self.enaSrdUdpSpecification = enaSrdUdpSpecification
    }

    enum CodingKeys: String, CodingKey {
        case enaSrdEnabled = "EnaSrdEnabled"
        case enaSrdUdpSpecification = "EnaSrdUdpSpecification"
    }

    public func validate() throws {
        try enaSrdUdpSpecification?.validate()
    }
}

public struct EnaSrdUdpSpecification: Codable, Equatable {
    public var enaSrdUdpEnabled: Boolean?

    public init(enaSrdUdpEnabled: Boolean? = nil) {
        self.enaSrdUdpEnabled = enaSrdUdpEnabled
    }

    enum CodingKeys: String, CodingKey {
        case enaSrdUdpEnabled = "EnaSrdUdpEnabled"
    }

    public func validate() throws {
    }
}

public struct EnableAddressTransferRequest: Codable, Equatable {
    public var allocationId: AllocationId
    public var dryRun: Boolean?
    public var transferAccountId: String

    public init(allocationId: AllocationId,
                dryRun: Boolean? = nil,
                transferAccountId: String) {
        self.allocationId = allocationId
        self.dryRun = dryRun
        self.transferAccountId = transferAccountId
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case dryRun = "DryRun"
        case transferAccountId = "TransferAccountId"
    }

    public func validate() throws {
    }
}

public struct EnableAddressTransferResult: Codable, Equatable {
    public var addressTransfer: AddressTransfer?

    public init(addressTransfer: AddressTransfer? = nil) {
        self.addressTransfer = addressTransfer
    }

    enum CodingKeys: String, CodingKey {
        case addressTransfer
    }

    public func validate() throws {
        try addressTransfer?.validate()
    }
}

public struct EnableAwsNetworkPerformanceMetricSubscriptionRequest: Codable, Equatable {
    public var destination: String?
    public var dryRun: Boolean?
    public var metric: MetricType?
    public var source: String?
    public var statistic: StatisticType?

    public init(destination: String? = nil,
                dryRun: Boolean? = nil,
                metric: MetricType? = nil,
                source: String? = nil,
                statistic: StatisticType? = nil) {
        self.destination = destination
        self.dryRun = dryRun
        self.metric = metric
        self.source = source
        self.statistic = statistic
    }

    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case dryRun = "DryRun"
        case metric = "Metric"
        case source = "Source"
        case statistic = "Statistic"
    }

    public func validate() throws {
    }
}

public struct EnableAwsNetworkPerformanceMetricSubscriptionResult: Codable, Equatable {
    public var output: Boolean?

    public init(output: Boolean? = nil) {
        self.output = output
    }

    enum CodingKeys: String, CodingKey {
        case output
    }

    public func validate() throws {
    }
}

public struct EnableEbsEncryptionByDefaultRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct EnableEbsEncryptionByDefaultResult: Codable, Equatable {
    public var ebsEncryptionByDefault: Boolean?

    public init(ebsEncryptionByDefault: Boolean? = nil) {
        self.ebsEncryptionByDefault = ebsEncryptionByDefault
    }

    enum CodingKeys: String, CodingKey {
        case ebsEncryptionByDefault
    }

    public func validate() throws {
    }
}

public struct EnableFastLaunchRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var imageId: ImageId
    public var launchTemplate: FastLaunchLaunchTemplateSpecificationRequest?
    public var maxParallelLaunches: Integer?
    public var resourceType: String?
    public var snapshotConfiguration: FastLaunchSnapshotConfigurationRequest?

    public init(dryRun: Boolean? = nil,
                imageId: ImageId,
                launchTemplate: FastLaunchLaunchTemplateSpecificationRequest? = nil,
                maxParallelLaunches: Integer? = nil,
                resourceType: String? = nil,
                snapshotConfiguration: FastLaunchSnapshotConfigurationRequest? = nil) {
        self.dryRun = dryRun
        self.imageId = imageId
        self.launchTemplate = launchTemplate
        self.maxParallelLaunches = maxParallelLaunches
        self.resourceType = resourceType
        self.snapshotConfiguration = snapshotConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case imageId = "ImageId"
        case launchTemplate = "LaunchTemplate"
        case maxParallelLaunches = "MaxParallelLaunches"
        case resourceType = "ResourceType"
        case snapshotConfiguration = "SnapshotConfiguration"
    }

    public func validate() throws {
        try launchTemplate?.validate()
        try snapshotConfiguration?.validate()
    }
}

public struct EnableFastLaunchResult: Codable, Equatable {
    public var imageId: ImageId?
    public var launchTemplate: FastLaunchLaunchTemplateSpecificationResponse?
    public var maxParallelLaunches: Integer?
    public var ownerId: String?
    public var resourceType: FastLaunchResourceType?
    public var snapshotConfiguration: FastLaunchSnapshotConfigurationResponse?
    public var state: FastLaunchStateCode?
    public var stateTransitionReason: String?
    public var stateTransitionTime: MillisecondDateTime?

    public init(imageId: ImageId? = nil,
                launchTemplate: FastLaunchLaunchTemplateSpecificationResponse? = nil,
                maxParallelLaunches: Integer? = nil,
                ownerId: String? = nil,
                resourceType: FastLaunchResourceType? = nil,
                snapshotConfiguration: FastLaunchSnapshotConfigurationResponse? = nil,
                state: FastLaunchStateCode? = nil,
                stateTransitionReason: String? = nil,
                stateTransitionTime: MillisecondDateTime? = nil) {
        self.imageId = imageId
        self.launchTemplate = launchTemplate
        self.maxParallelLaunches = maxParallelLaunches
        self.ownerId = ownerId
        self.resourceType = resourceType
        self.snapshotConfiguration = snapshotConfiguration
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.stateTransitionTime = stateTransitionTime
    }

    enum CodingKeys: String, CodingKey {
        case imageId
        case launchTemplate
        case maxParallelLaunches
        case ownerId
        case resourceType
        case snapshotConfiguration
        case state
        case stateTransitionReason
        case stateTransitionTime
    }

    public func validate() throws {
        try launchTemplate?.validate()
        try snapshotConfiguration?.validate()
    }
}

public struct EnableFastSnapshotRestoreErrorItem: Codable, Equatable {
    public var fastSnapshotRestoreStateErrors: EnableFastSnapshotRestoreStateErrorSet?
    public var snapshotId: String?

    public init(fastSnapshotRestoreStateErrors: EnableFastSnapshotRestoreStateErrorSet? = nil,
                snapshotId: String? = nil) {
        self.fastSnapshotRestoreStateErrors = fastSnapshotRestoreStateErrors
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case fastSnapshotRestoreStateErrors = "fastSnapshotRestoreStateErrorSet"
        case snapshotId
    }

    public func validate() throws {
    }
}

public struct EnableFastSnapshotRestoreStateError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct EnableFastSnapshotRestoreStateErrorItem: Codable, Equatable {
    public var availabilityZone: String?
    public var error: EnableFastSnapshotRestoreStateError?

    public init(availabilityZone: String? = nil,
                error: EnableFastSnapshotRestoreStateError? = nil) {
        self.availabilityZone = availabilityZone
        self.error = error
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case error
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct EnableFastSnapshotRestoreSuccessItem: Codable, Equatable {
    public var availabilityZone: String?
    public var disabledTime: MillisecondDateTime?
    public var disablingTime: MillisecondDateTime?
    public var enabledTime: MillisecondDateTime?
    public var enablingTime: MillisecondDateTime?
    public var optimizingTime: MillisecondDateTime?
    public var ownerAlias: String?
    public var ownerId: String?
    public var snapshotId: String?
    public var state: FastSnapshotRestoreStateCode?
    public var stateTransitionReason: String?

    public init(availabilityZone: String? = nil,
                disabledTime: MillisecondDateTime? = nil,
                disablingTime: MillisecondDateTime? = nil,
                enabledTime: MillisecondDateTime? = nil,
                enablingTime: MillisecondDateTime? = nil,
                optimizingTime: MillisecondDateTime? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                snapshotId: String? = nil,
                state: FastSnapshotRestoreStateCode? = nil,
                stateTransitionReason: String? = nil) {
        self.availabilityZone = availabilityZone
        self.disabledTime = disabledTime
        self.disablingTime = disablingTime
        self.enabledTime = enabledTime
        self.enablingTime = enablingTime
        self.optimizingTime = optimizingTime
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.snapshotId = snapshotId
        self.state = state
        self.stateTransitionReason = stateTransitionReason
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case disabledTime
        case disablingTime
        case enabledTime
        case enablingTime
        case optimizingTime
        case ownerAlias
        case ownerId
        case snapshotId
        case state
        case stateTransitionReason
    }

    public func validate() throws {
    }
}

public struct EnableFastSnapshotRestoresRequest: Codable, Equatable {
    public var availabilityZones: AvailabilityZoneStringList
    public var dryRun: Boolean?
    public var sourceSnapshotIds: SnapshotIdStringList

    public init(availabilityZones: AvailabilityZoneStringList,
                dryRun: Boolean? = nil,
                sourceSnapshotIds: SnapshotIdStringList) {
        self.availabilityZones = availabilityZones
        self.dryRun = dryRun
        self.sourceSnapshotIds = sourceSnapshotIds
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZone"
        case dryRun = "DryRun"
        case sourceSnapshotIds = "SourceSnapshotId"
    }

    public func validate() throws {
    }
}

public struct EnableFastSnapshotRestoresResult: Codable, Equatable {
    public var successful: EnableFastSnapshotRestoreSuccessSet?
    public var unsuccessful: EnableFastSnapshotRestoreErrorSet?

    public init(successful: EnableFastSnapshotRestoreSuccessSet? = nil,
                unsuccessful: EnableFastSnapshotRestoreErrorSet? = nil) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case successful
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct EnableImageDeprecationRequest: Codable, Equatable {
    public var deprecateAt: MillisecondDateTime
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(deprecateAt: MillisecondDateTime,
                dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.deprecateAt = deprecateAt
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case deprecateAt = "DeprecateAt"
        case dryRun = "DryRun"
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct EnableImageDeprecationResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct EnableIpamOrganizationAdminAccountRequest: Codable, Equatable {
    public var delegatedAdminAccountId: String
    public var dryRun: Boolean?

    public init(delegatedAdminAccountId: String,
                dryRun: Boolean? = nil) {
        self.delegatedAdminAccountId = delegatedAdminAccountId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case delegatedAdminAccountId = "DelegatedAdminAccountId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct EnableIpamOrganizationAdminAccountResult: Codable, Equatable {
    public var success: Boolean?

    public init(success: Boolean? = nil) {
        self.success = success
    }

    enum CodingKeys: String, CodingKey {
        case success
    }

    public func validate() throws {
    }
}

public struct EnableReachabilityAnalyzerOrganizationSharingRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct EnableReachabilityAnalyzerOrganizationSharingResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue
    }

    public func validate() throws {
    }
}

public struct EnableSerialConsoleAccessRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct EnableSerialConsoleAccessResult: Codable, Equatable {
    public var serialConsoleAccessEnabled: Boolean?

    public init(serialConsoleAccessEnabled: Boolean? = nil) {
        self.serialConsoleAccessEnabled = serialConsoleAccessEnabled
    }

    enum CodingKeys: String, CodingKey {
        case serialConsoleAccessEnabled
    }

    public func validate() throws {
    }
}

public struct EnableTransitGatewayRouteTablePropagationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableAnnouncementId = transitGatewayRouteTableAnnouncementId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableAnnouncementId = "TransitGatewayRouteTableAnnouncementId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct EnableTransitGatewayRouteTablePropagationResult: Codable, Equatable {
    public var propagation: TransitGatewayPropagation?

    public init(propagation: TransitGatewayPropagation? = nil) {
        self.propagation = propagation
    }

    enum CodingKeys: String, CodingKey {
        case propagation
    }

    public func validate() throws {
        try propagation?.validate()
    }
}

public struct EnableVgwRoutePropagationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var gatewayId: VpnGatewayId
    public var routeTableId: RouteTableId

    public init(dryRun: Boolean? = nil,
                gatewayId: VpnGatewayId,
                routeTableId: RouteTableId) {
        self.dryRun = dryRun
        self.gatewayId = gatewayId
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
    }

    public func validate() throws {
    }
}

public struct EnableVolumeIORequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var volumeId: VolumeId

    public init(dryRun: Boolean? = nil,
                volumeId: VolumeId) {
        self.dryRun = dryRun
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case volumeId
    }

    public func validate() throws {
    }
}

public struct EnableVpcClassicLinkDnsSupportRequest: Codable, Equatable {
    public var vpcId: VpcId?

    public init(vpcId: VpcId? = nil) {
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct EnableVpcClassicLinkDnsSupportResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct EnableVpcClassicLinkRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcId
    }

    public func validate() throws {
    }
}

public struct EnableVpcClassicLinkResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct EnclaveOptions: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct EnclaveOptionsRequest: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct EventInformation: Codable, Equatable {
    public var eventDescription: String?
    public var eventSubType: String?
    public var instanceId: String?

    public init(eventDescription: String? = nil,
                eventSubType: String? = nil,
                instanceId: String? = nil) {
        self.eventDescription = eventDescription
        self.eventSubType = eventSubType
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case eventDescription
        case eventSubType
        case instanceId
    }

    public func validate() throws {
    }
}

public struct Explanation: Codable, Equatable {
    public var acl: AnalysisComponent?
    public var aclRule: AnalysisAclRule?
    public var address: IpAddress?
    public var addresses: IpAddressList?
    public var attachedTo: AnalysisComponent?
    public var availabilityZones: ValueStringList?
    public var cidrs: ValueStringList?
    public var classicLoadBalancerListener: AnalysisLoadBalancerListener?
    public var component: AnalysisComponent?
    public var componentAccount: ComponentAccount?
    public var componentRegion: ComponentRegion?
    public var customerGateway: AnalysisComponent?
    public var destination: AnalysisComponent?
    public var destinationVpc: AnalysisComponent?
    public var direction: String?
    public var elasticLoadBalancerListener: AnalysisComponent?
    public var explanationCode: String?
    public var ingressRouteTable: AnalysisComponent?
    public var internetGateway: AnalysisComponent?
    public var loadBalancerArn: ResourceArn?
    public var loadBalancerListenerPort: Port?
    public var loadBalancerTarget: AnalysisLoadBalancerTarget?
    public var loadBalancerTargetGroup: AnalysisComponent?
    public var loadBalancerTargetGroups: AnalysisComponentList?
    public var loadBalancerTargetPort: Port?
    public var missingComponent: String?
    public var natGateway: AnalysisComponent?
    public var networkInterface: AnalysisComponent?
    public var packetField: String?
    public var port: Port?
    public var portRanges: PortRangeList?
    public var prefixList: AnalysisComponent?
    public var protocols: StringList?
    public var routeTable: AnalysisComponent?
    public var routeTableRoute: AnalysisRouteTableRoute?
    public var securityGroup: AnalysisComponent?
    public var securityGroupRule: AnalysisSecurityGroupRule?
    public var securityGroups: AnalysisComponentList?
    public var sourceVpc: AnalysisComponent?
    public var state: String?
    public var subnet: AnalysisComponent?
    public var subnetRouteTable: AnalysisComponent?
    public var transitGateway: AnalysisComponent?
    public var transitGatewayAttachment: AnalysisComponent?
    public var transitGatewayRouteTable: AnalysisComponent?
    public var transitGatewayRouteTableRoute: TransitGatewayRouteTableRoute?
    public var vpc: AnalysisComponent?
    public var vpcEndpoint: AnalysisComponent?
    public var vpcPeeringConnection: AnalysisComponent?
    public var vpnConnection: AnalysisComponent?
    public var vpnGateway: AnalysisComponent?

    public init(acl: AnalysisComponent? = nil,
                aclRule: AnalysisAclRule? = nil,
                address: IpAddress? = nil,
                addresses: IpAddressList? = nil,
                attachedTo: AnalysisComponent? = nil,
                availabilityZones: ValueStringList? = nil,
                cidrs: ValueStringList? = nil,
                classicLoadBalancerListener: AnalysisLoadBalancerListener? = nil,
                component: AnalysisComponent? = nil,
                componentAccount: ComponentAccount? = nil,
                componentRegion: ComponentRegion? = nil,
                customerGateway: AnalysisComponent? = nil,
                destination: AnalysisComponent? = nil,
                destinationVpc: AnalysisComponent? = nil,
                direction: String? = nil,
                elasticLoadBalancerListener: AnalysisComponent? = nil,
                explanationCode: String? = nil,
                ingressRouteTable: AnalysisComponent? = nil,
                internetGateway: AnalysisComponent? = nil,
                loadBalancerArn: ResourceArn? = nil,
                loadBalancerListenerPort: Port? = nil,
                loadBalancerTarget: AnalysisLoadBalancerTarget? = nil,
                loadBalancerTargetGroup: AnalysisComponent? = nil,
                loadBalancerTargetGroups: AnalysisComponentList? = nil,
                loadBalancerTargetPort: Port? = nil,
                missingComponent: String? = nil,
                natGateway: AnalysisComponent? = nil,
                networkInterface: AnalysisComponent? = nil,
                packetField: String? = nil,
                port: Port? = nil,
                portRanges: PortRangeList? = nil,
                prefixList: AnalysisComponent? = nil,
                protocols: StringList? = nil,
                routeTable: AnalysisComponent? = nil,
                routeTableRoute: AnalysisRouteTableRoute? = nil,
                securityGroup: AnalysisComponent? = nil,
                securityGroupRule: AnalysisSecurityGroupRule? = nil,
                securityGroups: AnalysisComponentList? = nil,
                sourceVpc: AnalysisComponent? = nil,
                state: String? = nil,
                subnet: AnalysisComponent? = nil,
                subnetRouteTable: AnalysisComponent? = nil,
                transitGateway: AnalysisComponent? = nil,
                transitGatewayAttachment: AnalysisComponent? = nil,
                transitGatewayRouteTable: AnalysisComponent? = nil,
                transitGatewayRouteTableRoute: TransitGatewayRouteTableRoute? = nil,
                vpc: AnalysisComponent? = nil,
                vpcEndpoint: AnalysisComponent? = nil,
                vpcPeeringConnection: AnalysisComponent? = nil,
                vpnConnection: AnalysisComponent? = nil,
                vpnGateway: AnalysisComponent? = nil) {
        self.acl = acl
        self.aclRule = aclRule
        self.address = address
        self.addresses = addresses
        self.attachedTo = attachedTo
        self.availabilityZones = availabilityZones
        self.cidrs = cidrs
        self.classicLoadBalancerListener = classicLoadBalancerListener
        self.component = component
        self.componentAccount = componentAccount
        self.componentRegion = componentRegion
        self.customerGateway = customerGateway
        self.destination = destination
        self.destinationVpc = destinationVpc
        self.direction = direction
        self.elasticLoadBalancerListener = elasticLoadBalancerListener
        self.explanationCode = explanationCode
        self.ingressRouteTable = ingressRouteTable
        self.internetGateway = internetGateway
        self.loadBalancerArn = loadBalancerArn
        self.loadBalancerListenerPort = loadBalancerListenerPort
        self.loadBalancerTarget = loadBalancerTarget
        self.loadBalancerTargetGroup = loadBalancerTargetGroup
        self.loadBalancerTargetGroups = loadBalancerTargetGroups
        self.loadBalancerTargetPort = loadBalancerTargetPort
        self.missingComponent = missingComponent
        self.natGateway = natGateway
        self.networkInterface = networkInterface
        self.packetField = packetField
        self.port = port
        self.portRanges = portRanges
        self.prefixList = prefixList
        self.protocols = protocols
        self.routeTable = routeTable
        self.routeTableRoute = routeTableRoute
        self.securityGroup = securityGroup
        self.securityGroupRule = securityGroupRule
        self.securityGroups = securityGroups
        self.sourceVpc = sourceVpc
        self.state = state
        self.subnet = subnet
        self.subnetRouteTable = subnetRouteTable
        self.transitGateway = transitGateway
        self.transitGatewayAttachment = transitGatewayAttachment
        self.transitGatewayRouteTable = transitGatewayRouteTable
        self.transitGatewayRouteTableRoute = transitGatewayRouteTableRoute
        self.vpc = vpc
        self.vpcEndpoint = vpcEndpoint
        self.vpcPeeringConnection = vpcPeeringConnection
        self.vpnConnection = vpnConnection
        self.vpnGateway = vpnGateway
    }

    enum CodingKeys: String, CodingKey {
        case acl
        case aclRule
        case address
        case addresses = "addressSet"
        case attachedTo
        case availabilityZones = "availabilityZoneSet"
        case cidrs = "cidrSet"
        case classicLoadBalancerListener
        case component
        case componentAccount
        case componentRegion
        case customerGateway
        case destination
        case destinationVpc
        case direction
        case elasticLoadBalancerListener
        case explanationCode
        case ingressRouteTable
        case internetGateway
        case loadBalancerArn
        case loadBalancerListenerPort
        case loadBalancerTarget
        case loadBalancerTargetGroup
        case loadBalancerTargetGroups = "loadBalancerTargetGroupSet"
        case loadBalancerTargetPort
        case missingComponent
        case natGateway
        case networkInterface
        case packetField
        case port
        case portRanges = "portRangeSet"
        case prefixList
        case protocols = "protocolSet"
        case routeTable
        case routeTableRoute
        case securityGroup
        case securityGroupRule
        case securityGroups = "securityGroupSet"
        case sourceVpc
        case state
        case subnet
        case subnetRouteTable
        case transitGateway
        case transitGatewayAttachment
        case transitGatewayRouteTable
        case transitGatewayRouteTableRoute
        case vpc
        case vpcEndpoint
        case vpcPeeringConnection
        case vpnConnection
        case vpnGateway
    }

    public func validate() throws {
        try acl?.validate()
        try aclRule?.validate()
        try address?.validateAsIpAddress()
        try attachedTo?.validate()
        try classicLoadBalancerListener?.validate()
        try component?.validate()
        try componentAccount?.validateAsComponentAccount()
        try componentRegion?.validateAsComponentRegion()
        try customerGateway?.validate()
        try destination?.validate()
        try destinationVpc?.validate()
        try elasticLoadBalancerListener?.validate()
        try ingressRouteTable?.validate()
        try internetGateway?.validate()
        try loadBalancerArn?.validateAsResourceArn()
        try loadBalancerListenerPort?.validateAsPort()
        try loadBalancerTarget?.validate()
        try loadBalancerTargetGroup?.validate()
        try loadBalancerTargetPort?.validateAsPort()
        try natGateway?.validate()
        try networkInterface?.validate()
        try port?.validateAsPort()
        try prefixList?.validate()
        try routeTable?.validate()
        try routeTableRoute?.validate()
        try securityGroup?.validate()
        try securityGroupRule?.validate()
        try sourceVpc?.validate()
        try subnet?.validate()
        try subnetRouteTable?.validate()
        try transitGateway?.validate()
        try transitGatewayAttachment?.validate()
        try transitGatewayRouteTable?.validate()
        try transitGatewayRouteTableRoute?.validate()
        try vpc?.validate()
        try vpcEndpoint?.validate()
        try vpcPeeringConnection?.validate()
        try vpnConnection?.validate()
        try vpnGateway?.validate()
    }
}

public struct ExportClientVpnClientCertificateRevocationListRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ExportClientVpnClientCertificateRevocationListResult: Codable, Equatable {
    public var certificateRevocationList: String?
    public var status: ClientCertificateRevocationListStatus?

    public init(certificateRevocationList: String? = nil,
                status: ClientCertificateRevocationListStatus? = nil) {
        self.certificateRevocationList = certificateRevocationList
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case certificateRevocationList
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct ExportClientVpnClientConfigurationRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ExportClientVpnClientConfigurationResult: Codable, Equatable {
    public var clientConfiguration: String?

    public init(clientConfiguration: String? = nil) {
        self.clientConfiguration = clientConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case clientConfiguration
    }

    public func validate() throws {
    }
}

public struct ExportImageRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var diskImageFormat: DiskImageFormat
    public var dryRun: Boolean?
    public var imageId: ImageId
    public var roleName: String?
    public var s3ExportLocation: ExportTaskS3LocationRequest
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                description: String? = nil,
                diskImageFormat: DiskImageFormat,
                dryRun: Boolean? = nil,
                imageId: ImageId,
                roleName: String? = nil,
                s3ExportLocation: ExportTaskS3LocationRequest,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.diskImageFormat = diskImageFormat
        self.dryRun = dryRun
        self.imageId = imageId
        self.roleName = roleName
        self.s3ExportLocation = s3ExportLocation
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case diskImageFormat = "DiskImageFormat"
        case dryRun = "DryRun"
        case imageId = "ImageId"
        case roleName = "RoleName"
        case s3ExportLocation = "S3ExportLocation"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try s3ExportLocation.validate()
    }
}

public struct ExportImageResult: Codable, Equatable {
    public var description: String?
    public var diskImageFormat: DiskImageFormat?
    public var exportImageTaskId: String?
    public var imageId: String?
    public var progress: String?
    public var roleName: String?
    public var s3ExportLocation: ExportTaskS3Location?
    public var status: String?
    public var statusMessage: String?
    public var tags: TagList?

    public init(description: String? = nil,
                diskImageFormat: DiskImageFormat? = nil,
                exportImageTaskId: String? = nil,
                imageId: String? = nil,
                progress: String? = nil,
                roleName: String? = nil,
                s3ExportLocation: ExportTaskS3Location? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.diskImageFormat = diskImageFormat
        self.exportImageTaskId = exportImageTaskId
        self.imageId = imageId
        self.progress = progress
        self.roleName = roleName
        self.s3ExportLocation = s3ExportLocation
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case diskImageFormat
        case exportImageTaskId
        case imageId
        case progress
        case roleName
        case s3ExportLocation
        case status
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try s3ExportLocation?.validate()
    }
}

public struct ExportImageTask: Codable, Equatable {
    public var description: String?
    public var exportImageTaskId: String?
    public var imageId: String?
    public var progress: String?
    public var s3ExportLocation: ExportTaskS3Location?
    public var status: String?
    public var statusMessage: String?
    public var tags: TagList?

    public init(description: String? = nil,
                exportImageTaskId: String? = nil,
                imageId: String? = nil,
                progress: String? = nil,
                s3ExportLocation: ExportTaskS3Location? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.exportImageTaskId = exportImageTaskId
        self.imageId = imageId
        self.progress = progress
        self.s3ExportLocation = s3ExportLocation
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case exportImageTaskId
        case imageId
        case progress
        case s3ExportLocation
        case status
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try s3ExportLocation?.validate()
    }
}

public struct ExportTask: Codable, Equatable {
    public var description: String?
    public var exportTaskId: String?
    public var exportToS3Task: ExportToS3Task?
    public var instanceExportDetails: InstanceExportDetails?
    public var state: ExportTaskState?
    public var statusMessage: String?
    public var tags: TagList?

    public init(description: String? = nil,
                exportTaskId: String? = nil,
                exportToS3Task: ExportToS3Task? = nil,
                instanceExportDetails: InstanceExportDetails? = nil,
                state: ExportTaskState? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.exportTaskId = exportTaskId
        self.exportToS3Task = exportToS3Task
        self.instanceExportDetails = instanceExportDetails
        self.state = state
        self.statusMessage = statusMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case exportTaskId
        case exportToS3Task = "exportToS3"
        case instanceExportDetails = "instanceExport"
        case state
        case statusMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try exportToS3Task?.validate()
        try instanceExportDetails?.validate()
    }
}

public struct ExportTaskS3Location: Codable, Equatable {
    public var s3Bucket: String?
    public var s3Prefix: String?

    public init(s3Bucket: String? = nil,
                s3Prefix: String? = nil) {
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
    }

    enum CodingKeys: String, CodingKey {
        case s3Bucket
        case s3Prefix
    }

    public func validate() throws {
    }
}

public struct ExportTaskS3LocationRequest: Codable, Equatable {
    public var s3Bucket: String
    public var s3Prefix: String?

    public init(s3Bucket: String,
                s3Prefix: String? = nil) {
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
    }

    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
    }

    public func validate() throws {
    }
}

public struct ExportToS3Task: Codable, Equatable {
    public var containerFormat: ContainerFormat?
    public var diskImageFormat: DiskImageFormat?
    public var s3Bucket: String?
    public var s3Key: String?

    public init(containerFormat: ContainerFormat? = nil,
                diskImageFormat: DiskImageFormat? = nil,
                s3Bucket: String? = nil,
                s3Key: String? = nil) {
        self.containerFormat = containerFormat
        self.diskImageFormat = diskImageFormat
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }

    enum CodingKeys: String, CodingKey {
        case containerFormat
        case diskImageFormat
        case s3Bucket
        case s3Key
    }

    public func validate() throws {
    }
}

public struct ExportToS3TaskSpecification: Codable, Equatable {
    public var containerFormat: ContainerFormat?
    public var diskImageFormat: DiskImageFormat?
    public var s3Bucket: String?
    public var s3Prefix: String?

    public init(containerFormat: ContainerFormat? = nil,
                diskImageFormat: DiskImageFormat? = nil,
                s3Bucket: String? = nil,
                s3Prefix: String? = nil) {
        self.containerFormat = containerFormat
        self.diskImageFormat = diskImageFormat
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
    }

    enum CodingKeys: String, CodingKey {
        case containerFormat
        case diskImageFormat
        case s3Bucket
        case s3Prefix
    }

    public func validate() throws {
    }
}

public struct ExportTransitGatewayRoutesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var s3Bucket: String
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                s3Bucket: String,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.s3Bucket = s3Bucket
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case s3Bucket = "S3Bucket"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct ExportTransitGatewayRoutesResult: Codable, Equatable {
    public var s3Location: String?

    public init(s3Location: String? = nil) {
        self.s3Location = s3Location
    }

    enum CodingKeys: String, CodingKey {
        case s3Location
    }

    public func validate() throws {
    }
}

public struct FailedCapacityReservationFleetCancellationResult: Codable, Equatable {
    public var cancelCapacityReservationFleetError: CancelCapacityReservationFleetError?
    public var capacityReservationFleetId: CapacityReservationFleetId?

    public init(cancelCapacityReservationFleetError: CancelCapacityReservationFleetError? = nil,
                capacityReservationFleetId: CapacityReservationFleetId? = nil) {
        self.cancelCapacityReservationFleetError = cancelCapacityReservationFleetError
        self.capacityReservationFleetId = capacityReservationFleetId
    }

    enum CodingKeys: String, CodingKey {
        case cancelCapacityReservationFleetError
        case capacityReservationFleetId
    }

    public func validate() throws {
        try cancelCapacityReservationFleetError?.validate()
    }
}

public struct FailedQueuedPurchaseDeletion: Codable, Equatable {
    public var error: DeleteQueuedReservedInstancesError?
    public var reservedInstancesId: String?

    public init(error: DeleteQueuedReservedInstancesError? = nil,
                reservedInstancesId: String? = nil) {
        self.error = error
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case reservedInstancesId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct FastLaunchLaunchTemplateSpecificationRequest: Codable, Equatable {
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: String?
    public var version: String

    public init(launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: String? = nil,
                version: String) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case version = "Version"
    }

    public func validate() throws {
    }
}

public struct FastLaunchLaunchTemplateSpecificationResponse: Codable, Equatable {
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: String?
    public var version: String?

    public init(launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: String? = nil,
                version: String? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId
        case launchTemplateName
        case version
    }

    public func validate() throws {
    }
}

public struct FastLaunchSnapshotConfigurationRequest: Codable, Equatable {
    public var targetResourceCount: Integer?

    public init(targetResourceCount: Integer? = nil) {
        self.targetResourceCount = targetResourceCount
    }

    enum CodingKeys: String, CodingKey {
        case targetResourceCount = "TargetResourceCount"
    }

    public func validate() throws {
    }
}

public struct FastLaunchSnapshotConfigurationResponse: Codable, Equatable {
    public var targetResourceCount: Integer?

    public init(targetResourceCount: Integer? = nil) {
        self.targetResourceCount = targetResourceCount
    }

    enum CodingKeys: String, CodingKey {
        case targetResourceCount
    }

    public func validate() throws {
    }
}

public struct FederatedAuthentication: Codable, Equatable {
    public var samlProviderArn: String?
    public var selfServiceSamlProviderArn: String?

    public init(samlProviderArn: String? = nil,
                selfServiceSamlProviderArn: String? = nil) {
        self.samlProviderArn = samlProviderArn
        self.selfServiceSamlProviderArn = selfServiceSamlProviderArn
    }

    enum CodingKeys: String, CodingKey {
        case samlProviderArn
        case selfServiceSamlProviderArn
    }

    public func validate() throws {
    }
}

public struct FederatedAuthenticationRequest: Codable, Equatable {
    public var sAMLProviderArn: String?
    public var selfServiceSAMLProviderArn: String?

    public init(sAMLProviderArn: String? = nil,
                selfServiceSAMLProviderArn: String? = nil) {
        self.sAMLProviderArn = sAMLProviderArn
        self.selfServiceSAMLProviderArn = selfServiceSAMLProviderArn
    }

    enum CodingKeys: String, CodingKey {
        case sAMLProviderArn = "SAMLProviderArn"
        case selfServiceSAMLProviderArn = "SelfServiceSAMLProviderArn"
    }

    public func validate() throws {
    }
}

public struct Filter: Codable, Equatable {
    public var name: String?
    public var values: ValueStringList?

    public init(name: String? = nil,
                values: ValueStringList? = nil) {
        self.name = name
        self.values = values
    }

    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Value"
    }

    public func validate() throws {
    }
}

public struct FleetCapacityReservation: Codable, Equatable {
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var capacityReservationId: CapacityReservationId?
    public var createDate: MillisecondDateTime?
    public var ebsOptimized: Boolean?
    public var fulfilledCapacity: Double?
    public var instancePlatform: CapacityReservationInstancePlatform?
    public var instanceType: InstanceType?
    public var priority: IntegerWithConstraints?
    public var totalInstanceCount: Integer?
    public var weight: DoubleWithConstraints?

    public init(availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                capacityReservationId: CapacityReservationId? = nil,
                createDate: MillisecondDateTime? = nil,
                ebsOptimized: Boolean? = nil,
                fulfilledCapacity: Double? = nil,
                instancePlatform: CapacityReservationInstancePlatform? = nil,
                instanceType: InstanceType? = nil,
                priority: IntegerWithConstraints? = nil,
                totalInstanceCount: Integer? = nil,
                weight: DoubleWithConstraints? = nil) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.capacityReservationId = capacityReservationId
        self.createDate = createDate
        self.ebsOptimized = ebsOptimized
        self.fulfilledCapacity = fulfilledCapacity
        self.instancePlatform = instancePlatform
        self.instanceType = instanceType
        self.priority = priority
        self.totalInstanceCount = totalInstanceCount
        self.weight = weight
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case availabilityZoneId
        case capacityReservationId
        case createDate
        case ebsOptimized
        case fulfilledCapacity
        case instancePlatform
        case instanceType
        case priority
        case totalInstanceCount
        case weight
    }

    public func validate() throws {
        try priority?.validateAsIntegerWithConstraints()
        try weight?.validateAsDoubleWithConstraints()
    }
}

public struct FleetData: Codable, Equatable {
    public var activityStatus: FleetActivityStatus?
    public var clientToken: String?
    public var context: String?
    public var createTime: DateTime?
    public var errors: DescribeFleetsErrorSet?
    public var excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy?
    public var fleetId: FleetId?
    public var fleetState: FleetStateCode?
    public var fulfilledCapacity: Double?
    public var fulfilledOnDemandCapacity: Double?
    public var instances: DescribeFleetsInstancesSet?
    public var launchTemplateConfigs: FleetLaunchTemplateConfigList?
    public var onDemandOptions: OnDemandOptions?
    public var replaceUnhealthyInstances: Boolean?
    public var spotOptions: SpotOptions?
    public var tags: TagList?
    public var targetCapacitySpecification: TargetCapacitySpecification?
    public var terminateInstancesWithExpiration: Boolean?
    public var type: FleetType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(activityStatus: FleetActivityStatus? = nil,
                clientToken: String? = nil,
                context: String? = nil,
                createTime: DateTime? = nil,
                errors: DescribeFleetsErrorSet? = nil,
                excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy? = nil,
                fleetId: FleetId? = nil,
                fleetState: FleetStateCode? = nil,
                fulfilledCapacity: Double? = nil,
                fulfilledOnDemandCapacity: Double? = nil,
                instances: DescribeFleetsInstancesSet? = nil,
                launchTemplateConfigs: FleetLaunchTemplateConfigList? = nil,
                onDemandOptions: OnDemandOptions? = nil,
                replaceUnhealthyInstances: Boolean? = nil,
                spotOptions: SpotOptions? = nil,
                tags: TagList? = nil,
                targetCapacitySpecification: TargetCapacitySpecification? = nil,
                terminateInstancesWithExpiration: Boolean? = nil,
                type: FleetType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.activityStatus = activityStatus
        self.clientToken = clientToken
        self.context = context
        self.createTime = createTime
        self.errors = errors
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.fleetId = fleetId
        self.fleetState = fleetState
        self.fulfilledCapacity = fulfilledCapacity
        self.fulfilledOnDemandCapacity = fulfilledOnDemandCapacity
        self.instances = instances
        self.launchTemplateConfigs = launchTemplateConfigs
        self.onDemandOptions = onDemandOptions
        self.replaceUnhealthyInstances = replaceUnhealthyInstances
        self.spotOptions = spotOptions
        self.tags = tags
        self.targetCapacitySpecification = targetCapacitySpecification
        self.terminateInstancesWithExpiration = terminateInstancesWithExpiration
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case activityStatus
        case clientToken
        case context
        case createTime
        case errors = "errorSet"
        case excessCapacityTerminationPolicy
        case fleetId
        case fleetState
        case fulfilledCapacity
        case fulfilledOnDemandCapacity
        case instances = "fleetInstanceSet"
        case launchTemplateConfigs
        case onDemandOptions
        case replaceUnhealthyInstances
        case spotOptions
        case tags = "tagSet"
        case targetCapacitySpecification
        case terminateInstancesWithExpiration
        case type
        case validFrom
        case validUntil
    }

    public func validate() throws {
        try onDemandOptions?.validate()
        try spotOptions?.validate()
        try targetCapacitySpecification?.validate()
    }
}

public struct FleetLaunchTemplateConfig: Codable, Equatable {
    public var launchTemplateSpecification: FleetLaunchTemplateSpecification?
    public var overrides: FleetLaunchTemplateOverridesList?

    public init(launchTemplateSpecification: FleetLaunchTemplateSpecification? = nil,
                overrides: FleetLaunchTemplateOverridesList? = nil) {
        self.launchTemplateSpecification = launchTemplateSpecification
        self.overrides = overrides
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateSpecification
        case overrides
    }

    public func validate() throws {
        try launchTemplateSpecification?.validate()
    }
}

public struct FleetLaunchTemplateConfigRequest: Codable, Equatable {
    public var launchTemplateSpecification: FleetLaunchTemplateSpecificationRequest?
    public var overrides: FleetLaunchTemplateOverridesListRequest?

    public init(launchTemplateSpecification: FleetLaunchTemplateSpecificationRequest? = nil,
                overrides: FleetLaunchTemplateOverridesListRequest? = nil) {
        self.launchTemplateSpecification = launchTemplateSpecification
        self.overrides = overrides
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateSpecification = "LaunchTemplateSpecification"
        case overrides = "Overrides"
    }

    public func validate() throws {
        try launchTemplateSpecification?.validate()
    }
}

public struct FleetLaunchTemplateOverrides: Codable, Equatable {
    public var availabilityZone: String?
    public var imageId: ImageId?
    public var instanceRequirements: InstanceRequirements?
    public var instanceType: InstanceType?
    public var maxPrice: String?
    public var placement: PlacementResponse?
    public var priority: Double?
    public var subnetId: String?
    public var weightedCapacity: Double?

    public init(availabilityZone: String? = nil,
                imageId: ImageId? = nil,
                instanceRequirements: InstanceRequirements? = nil,
                instanceType: InstanceType? = nil,
                maxPrice: String? = nil,
                placement: PlacementResponse? = nil,
                priority: Double? = nil,
                subnetId: String? = nil,
                weightedCapacity: Double? = nil) {
        self.availabilityZone = availabilityZone
        self.imageId = imageId
        self.instanceRequirements = instanceRequirements
        self.instanceType = instanceType
        self.maxPrice = maxPrice
        self.placement = placement
        self.priority = priority
        self.subnetId = subnetId
        self.weightedCapacity = weightedCapacity
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case imageId
        case instanceRequirements
        case instanceType
        case maxPrice
        case placement
        case priority
        case subnetId
        case weightedCapacity
    }

    public func validate() throws {
        try instanceRequirements?.validate()
        try placement?.validate()
    }
}

public struct FleetLaunchTemplateOverridesRequest: Codable, Equatable {
    public var availabilityZone: String?
    public var imageId: ImageId?
    public var instanceRequirements: InstanceRequirementsRequest?
    public var instanceType: InstanceType?
    public var maxPrice: String?
    public var placement: Placement?
    public var priority: Double?
    public var subnetId: SubnetId?
    public var weightedCapacity: Double?

    public init(availabilityZone: String? = nil,
                imageId: ImageId? = nil,
                instanceRequirements: InstanceRequirementsRequest? = nil,
                instanceType: InstanceType? = nil,
                maxPrice: String? = nil,
                placement: Placement? = nil,
                priority: Double? = nil,
                subnetId: SubnetId? = nil,
                weightedCapacity: Double? = nil) {
        self.availabilityZone = availabilityZone
        self.imageId = imageId
        self.instanceRequirements = instanceRequirements
        self.instanceType = instanceType
        self.maxPrice = maxPrice
        self.placement = placement
        self.priority = priority
        self.subnetId = subnetId
        self.weightedCapacity = weightedCapacity
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case imageId = "ImageId"
        case instanceRequirements = "InstanceRequirements"
        case instanceType = "InstanceType"
        case maxPrice = "MaxPrice"
        case placement = "Placement"
        case priority = "Priority"
        case subnetId = "SubnetId"
        case weightedCapacity = "WeightedCapacity"
    }

    public func validate() throws {
        try instanceRequirements?.validate()
        try placement?.validate()
    }
}

public struct FleetLaunchTemplateSpecification: Codable, Equatable {
    public var launchTemplateId: String?
    public var launchTemplateName: LaunchTemplateName?
    public var version: String?

    public init(launchTemplateId: String? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                version: String? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId
        case launchTemplateName
        case version
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct FleetLaunchTemplateSpecificationRequest: Codable, Equatable {
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?
    public var version: String?

    public init(launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                version: String? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case version = "Version"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct FleetSpotCapacityRebalance: Codable, Equatable {
    public var replacementStrategy: FleetReplacementStrategy?
    public var terminationDelay: Integer?

    public init(replacementStrategy: FleetReplacementStrategy? = nil,
                terminationDelay: Integer? = nil) {
        self.replacementStrategy = replacementStrategy
        self.terminationDelay = terminationDelay
    }

    enum CodingKeys: String, CodingKey {
        case replacementStrategy
        case terminationDelay
    }

    public func validate() throws {
    }
}

public struct FleetSpotCapacityRebalanceRequest: Codable, Equatable {
    public var replacementStrategy: FleetReplacementStrategy?
    public var terminationDelay: Integer?

    public init(replacementStrategy: FleetReplacementStrategy? = nil,
                terminationDelay: Integer? = nil) {
        self.replacementStrategy = replacementStrategy
        self.terminationDelay = terminationDelay
    }

    enum CodingKeys: String, CodingKey {
        case replacementStrategy = "ReplacementStrategy"
        case terminationDelay = "TerminationDelay"
    }

    public func validate() throws {
    }
}

public struct FleetSpotMaintenanceStrategies: Codable, Equatable {
    public var capacityRebalance: FleetSpotCapacityRebalance?

    public init(capacityRebalance: FleetSpotCapacityRebalance? = nil) {
        self.capacityRebalance = capacityRebalance
    }

    enum CodingKeys: String, CodingKey {
        case capacityRebalance
    }

    public func validate() throws {
        try capacityRebalance?.validate()
    }
}

public struct FleetSpotMaintenanceStrategiesRequest: Codable, Equatable {
    public var capacityRebalance: FleetSpotCapacityRebalanceRequest?

    public init(capacityRebalance: FleetSpotCapacityRebalanceRequest? = nil) {
        self.capacityRebalance = capacityRebalance
    }

    enum CodingKeys: String, CodingKey {
        case capacityRebalance = "CapacityRebalance"
    }

    public func validate() throws {
        try capacityRebalance?.validate()
    }
}

public struct FlowLog: Codable, Equatable {
    public var creationTime: MillisecondDateTime?
    public var deliverCrossAccountRole: String?
    public var deliverLogsErrorMessage: String?
    public var deliverLogsPermissionArn: String?
    public var deliverLogsStatus: String?
    public var destinationOptions: DestinationOptionsResponse?
    public var flowLogId: String?
    public var flowLogStatus: String?
    public var logDestination: String?
    public var logDestinationType: LogDestinationType?
    public var logFormat: String?
    public var logGroupName: String?
    public var maxAggregationInterval: Integer?
    public var resourceId: String?
    public var tags: TagList?
    public var trafficType: TrafficType?

    public init(creationTime: MillisecondDateTime? = nil,
                deliverCrossAccountRole: String? = nil,
                deliverLogsErrorMessage: String? = nil,
                deliverLogsPermissionArn: String? = nil,
                deliverLogsStatus: String? = nil,
                destinationOptions: DestinationOptionsResponse? = nil,
                flowLogId: String? = nil,
                flowLogStatus: String? = nil,
                logDestination: String? = nil,
                logDestinationType: LogDestinationType? = nil,
                logFormat: String? = nil,
                logGroupName: String? = nil,
                maxAggregationInterval: Integer? = nil,
                resourceId: String? = nil,
                tags: TagList? = nil,
                trafficType: TrafficType? = nil) {
        self.creationTime = creationTime
        self.deliverCrossAccountRole = deliverCrossAccountRole
        self.deliverLogsErrorMessage = deliverLogsErrorMessage
        self.deliverLogsPermissionArn = deliverLogsPermissionArn
        self.deliverLogsStatus = deliverLogsStatus
        self.destinationOptions = destinationOptions
        self.flowLogId = flowLogId
        self.flowLogStatus = flowLogStatus
        self.logDestination = logDestination
        self.logDestinationType = logDestinationType
        self.logFormat = logFormat
        self.logGroupName = logGroupName
        self.maxAggregationInterval = maxAggregationInterval
        self.resourceId = resourceId
        self.tags = tags
        self.trafficType = trafficType
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case deliverCrossAccountRole
        case deliverLogsErrorMessage
        case deliverLogsPermissionArn
        case deliverLogsStatus
        case destinationOptions
        case flowLogId
        case flowLogStatus
        case logDestination
        case logDestinationType
        case logFormat
        case logGroupName
        case maxAggregationInterval
        case resourceId
        case tags = "tagSet"
        case trafficType
    }

    public func validate() throws {
        try destinationOptions?.validate()
    }
}

public struct FpgaDeviceInfo: Codable, Equatable {
    public var count: FpgaDeviceCount?
    public var manufacturer: FpgaDeviceManufacturerName?
    public var memoryInfo: FpgaDeviceMemoryInfo?
    public var name: FpgaDeviceName?

    public init(count: FpgaDeviceCount? = nil,
                manufacturer: FpgaDeviceManufacturerName? = nil,
                memoryInfo: FpgaDeviceMemoryInfo? = nil,
                name: FpgaDeviceName? = nil) {
        self.count = count
        self.manufacturer = manufacturer
        self.memoryInfo = memoryInfo
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case count
        case manufacturer
        case memoryInfo
        case name
    }

    public func validate() throws {
        try memoryInfo?.validate()
    }
}

public struct FpgaDeviceMemoryInfo: Codable, Equatable {
    public var sizeInMiB: FpgaDeviceMemorySize?

    public init(sizeInMiB: FpgaDeviceMemorySize? = nil) {
        self.sizeInMiB = sizeInMiB
    }

    enum CodingKeys: String, CodingKey {
        case sizeInMiB
    }

    public func validate() throws {
    }
}

public struct FpgaImage: Codable, Equatable {
    public var createTime: DateTime?
    public var dataRetentionSupport: Boolean?
    public var description: String?
    public var fpgaImageGlobalId: String?
    public var fpgaImageId: String?
    public var instanceTypes: InstanceTypesList?
    public var name: String?
    public var ownerAlias: String?
    public var ownerId: String?
    public var pciId: PciId?
    public var productCodes: ProductCodeList?
    public var `public`: Boolean?
    public var shellVersion: String?
    public var state: FpgaImageState?
    public var tags: TagList?
    public var updateTime: DateTime?

    public init(createTime: DateTime? = nil,
                dataRetentionSupport: Boolean? = nil,
                description: String? = nil,
                fpgaImageGlobalId: String? = nil,
                fpgaImageId: String? = nil,
                instanceTypes: InstanceTypesList? = nil,
                name: String? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                pciId: PciId? = nil,
                productCodes: ProductCodeList? = nil,
                `public`: Boolean? = nil,
                shellVersion: String? = nil,
                state: FpgaImageState? = nil,
                tags: TagList? = nil,
                updateTime: DateTime? = nil) {
        self.createTime = createTime
        self.dataRetentionSupport = dataRetentionSupport
        self.description = description
        self.fpgaImageGlobalId = fpgaImageGlobalId
        self.fpgaImageId = fpgaImageId
        self.instanceTypes = instanceTypes
        self.name = name
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.pciId = pciId
        self.productCodes = productCodes
        self.`public` = `public`
        self.shellVersion = shellVersion
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }

    enum CodingKeys: String, CodingKey {
        case createTime
        case dataRetentionSupport
        case description
        case fpgaImageGlobalId
        case fpgaImageId
        case instanceTypes
        case name
        case ownerAlias
        case ownerId
        case pciId
        case productCodes
        case `public` = "public"
        case shellVersion
        case state
        case tags
        case updateTime
    }

    public func validate() throws {
        try pciId?.validate()
        try state?.validate()
    }
}

public struct FpgaImageAttribute: Codable, Equatable {
    public var description: String?
    public var fpgaImageId: String?
    public var loadPermissions: LoadPermissionList?
    public var name: String?
    public var productCodes: ProductCodeList?

    public init(description: String? = nil,
                fpgaImageId: String? = nil,
                loadPermissions: LoadPermissionList? = nil,
                name: String? = nil,
                productCodes: ProductCodeList? = nil) {
        self.description = description
        self.fpgaImageId = fpgaImageId
        self.loadPermissions = loadPermissions
        self.name = name
        self.productCodes = productCodes
    }

    enum CodingKeys: String, CodingKey {
        case description
        case fpgaImageId
        case loadPermissions
        case name
        case productCodes
    }

    public func validate() throws {
    }
}

public struct FpgaImageState: Codable, Equatable {
    public var code: FpgaImageStateCode?
    public var message: String?

    public init(code: FpgaImageStateCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct FpgaInfo: Codable, Equatable {
    public var fpgas: FpgaDeviceInfoList?
    public var totalFpgaMemoryInMiB: TotalFpgaMemory?

    public init(fpgas: FpgaDeviceInfoList? = nil,
                totalFpgaMemoryInMiB: TotalFpgaMemory? = nil) {
        self.fpgas = fpgas
        self.totalFpgaMemoryInMiB = totalFpgaMemoryInMiB
    }

    enum CodingKeys: String, CodingKey {
        case fpgas
        case totalFpgaMemoryInMiB
    }

    public func validate() throws {
    }
}

public struct GetAssociatedEnclaveCertificateIamRolesRequest: Codable, Equatable {
    public var certificateArn: ResourceArn?
    public var dryRun: Boolean?

    public init(certificateArn: ResourceArn? = nil,
                dryRun: Boolean? = nil) {
        self.certificateArn = certificateArn
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case dryRun = "DryRun"
    }

    public func validate() throws {
        try certificateArn?.validateAsResourceArn()
    }
}

public struct GetAssociatedEnclaveCertificateIamRolesResult: Codable, Equatable {
    public var associatedRoles: AssociatedRolesList?

    public init(associatedRoles: AssociatedRolesList? = nil) {
        self.associatedRoles = associatedRoles
    }

    enum CodingKeys: String, CodingKey {
        case associatedRoles = "associatedRoleSet"
    }

    public func validate() throws {
    }
}

public struct GetAssociatedIpv6PoolCidrsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: Ipv6PoolMaxResults?
    public var nextToken: NextToken?
    public var poolId: Ipv6PoolEc2Id

    public init(dryRun: Boolean? = nil,
                maxResults: Ipv6PoolMaxResults? = nil,
                nextToken: NextToken? = nil,
                poolId: Ipv6PoolEc2Id) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolId = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsIpv6PoolMaxResults()
    }
}

public struct GetAssociatedIpv6PoolCidrsResult: Codable, Equatable {
    public var ipv6CidrAssociations: Ipv6CidrAssociationSet?
    public var nextToken: String?

    public init(ipv6CidrAssociations: Ipv6CidrAssociationSet? = nil,
                nextToken: String? = nil) {
        self.ipv6CidrAssociations = ipv6CidrAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrAssociations = "ipv6CidrAssociationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetAwsNetworkPerformanceDataRequest: Codable, Equatable {
    public var dataQueries: DataQueries?
    public var dryRun: Boolean?
    public var endTime: MillisecondDateTime?
    public var maxResults: Integer?
    public var nextToken: String?
    public var startTime: MillisecondDateTime?

    public init(dataQueries: DataQueries? = nil,
                dryRun: Boolean? = nil,
                endTime: MillisecondDateTime? = nil,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                startTime: MillisecondDateTime? = nil) {
        self.dataQueries = dataQueries
        self.dryRun = dryRun
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }

    enum CodingKeys: String, CodingKey {
        case dataQueries = "DataQuery"
        case dryRun = "DryRun"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func validate() throws {
    }
}

public struct GetAwsNetworkPerformanceDataResult: Codable, Equatable {
    public var dataResponses: DataResponses?
    public var nextToken: String?

    public init(dataResponses: DataResponses? = nil,
                nextToken: String? = nil) {
        self.dataResponses = dataResponses
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dataResponses = "dataResponseSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetCapacityReservationUsageRequest: Codable, Equatable {
    public var capacityReservationId: CapacityReservationId
    public var dryRun: Boolean?
    public var maxResults: GetCapacityReservationUsageRequestMaxResults?
    public var nextToken: String?

    public init(capacityReservationId: CapacityReservationId,
                dryRun: Boolean? = nil,
                maxResults: GetCapacityReservationUsageRequestMaxResults? = nil,
                nextToken: String? = nil) {
        self.capacityReservationId = capacityReservationId
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsGetCapacityReservationUsageRequestMaxResults()
    }
}

public struct GetCapacityReservationUsageResult: Codable, Equatable {
    public var availableInstanceCount: Integer?
    public var capacityReservationId: String?
    public var instanceType: String?
    public var instanceUsages: InstanceUsageSet?
    public var nextToken: String?
    public var state: CapacityReservationState?
    public var totalInstanceCount: Integer?

    public init(availableInstanceCount: Integer? = nil,
                capacityReservationId: String? = nil,
                instanceType: String? = nil,
                instanceUsages: InstanceUsageSet? = nil,
                nextToken: String? = nil,
                state: CapacityReservationState? = nil,
                totalInstanceCount: Integer? = nil) {
        self.availableInstanceCount = availableInstanceCount
        self.capacityReservationId = capacityReservationId
        self.instanceType = instanceType
        self.instanceUsages = instanceUsages
        self.nextToken = nextToken
        self.state = state
        self.totalInstanceCount = totalInstanceCount
    }

    enum CodingKeys: String, CodingKey {
        case availableInstanceCount
        case capacityReservationId
        case instanceType
        case instanceUsages = "instanceUsageSet"
        case nextToken
        case state
        case totalInstanceCount
    }

    public func validate() throws {
    }
}

public struct GetCoipPoolUsageRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: CoipPoolMaxResults?
    public var nextToken: String?
    public var poolId: Ipv4PoolCoipId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: CoipPoolMaxResults? = nil,
                nextToken: String? = nil,
                poolId: Ipv4PoolCoipId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolId = "PoolId"
    }

    public func validate() throws {
        try maxResults?.validateAsCoipPoolMaxResults()
    }
}

public struct GetCoipPoolUsageResult: Codable, Equatable {
    public var coipAddressUsages: CoipAddressUsageSet?
    public var coipPoolId: String?
    public var localGatewayRouteTableId: String?

    public init(coipAddressUsages: CoipAddressUsageSet? = nil,
                coipPoolId: String? = nil,
                localGatewayRouteTableId: String? = nil) {
        self.coipAddressUsages = coipAddressUsages
        self.coipPoolId = coipPoolId
        self.localGatewayRouteTableId = localGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case coipAddressUsages = "coipAddressUsageSet"
        case coipPoolId
        case localGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct GetConsoleOutputRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var latest: Boolean?

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                latest: Boolean? = nil) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.latest = latest
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId = "InstanceId"
        case latest = "Latest"
    }

    public func validate() throws {
    }
}

public struct GetConsoleOutputResult: Codable, Equatable {
    public var instanceId: String?
    public var output: String?
    public var timestamp: DateTime?

    public init(instanceId: String? = nil,
                output: String? = nil,
                timestamp: DateTime? = nil) {
        self.instanceId = instanceId
        self.output = output
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case output
        case timestamp
    }

    public func validate() throws {
    }
}

public struct GetConsoleScreenshotRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId
    public var wakeUp: Boolean?

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId,
                wakeUp: Boolean? = nil) {
        self.dryRun = dryRun
        self.instanceId = instanceId
        self.wakeUp = wakeUp
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
        case wakeUp = "WakeUp"
    }

    public func validate() throws {
    }
}

public struct GetConsoleScreenshotResult: Codable, Equatable {
    public var imageData: String?
    public var instanceId: String?

    public init(imageData: String? = nil,
                instanceId: String? = nil) {
        self.imageData = imageData
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case imageData
        case instanceId
    }

    public func validate() throws {
    }
}

public struct GetDefaultCreditSpecificationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceFamily: UnlimitedSupportedInstanceFamily

    public init(dryRun: Boolean? = nil,
                instanceFamily: UnlimitedSupportedInstanceFamily) {
        self.dryRun = dryRun
        self.instanceFamily = instanceFamily
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceFamily = "InstanceFamily"
    }

    public func validate() throws {
    }
}

public struct GetDefaultCreditSpecificationResult: Codable, Equatable {
    public var instanceFamilyCreditSpecification: InstanceFamilyCreditSpecification?

    public init(instanceFamilyCreditSpecification: InstanceFamilyCreditSpecification? = nil) {
        self.instanceFamilyCreditSpecification = instanceFamilyCreditSpecification
    }

    enum CodingKeys: String, CodingKey {
        case instanceFamilyCreditSpecification
    }

    public func validate() throws {
        try instanceFamilyCreditSpecification?.validate()
    }
}

public struct GetEbsDefaultKmsKeyIdRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct GetEbsDefaultKmsKeyIdResult: Codable, Equatable {
    public var kmsKeyId: String?

    public init(kmsKeyId: String? = nil) {
        self.kmsKeyId = kmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case kmsKeyId
    }

    public func validate() throws {
    }
}

public struct GetEbsEncryptionByDefaultRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct GetEbsEncryptionByDefaultResult: Codable, Equatable {
    public var ebsEncryptionByDefault: Boolean?

    public init(ebsEncryptionByDefault: Boolean? = nil) {
        self.ebsEncryptionByDefault = ebsEncryptionByDefault
    }

    enum CodingKeys: String, CodingKey {
        case ebsEncryptionByDefault
    }

    public func validate() throws {
    }
}

public struct GetFlowLogsIntegrationTemplateRequest: Codable, Equatable {
    public var configDeliveryS3DestinationArn: String
    public var dryRun: Boolean?
    public var flowLogId: VpcFlowLogId
    public var integrateServices: IntegrateServices

    public init(configDeliveryS3DestinationArn: String,
                dryRun: Boolean? = nil,
                flowLogId: VpcFlowLogId,
                integrateServices: IntegrateServices) {
        self.configDeliveryS3DestinationArn = configDeliveryS3DestinationArn
        self.dryRun = dryRun
        self.flowLogId = flowLogId
        self.integrateServices = integrateServices
    }

    enum CodingKeys: String, CodingKey {
        case configDeliveryS3DestinationArn = "ConfigDeliveryS3DestinationArn"
        case dryRun = "DryRun"
        case flowLogId = "FlowLogId"
        case integrateServices = "IntegrateService"
    }

    public func validate() throws {
        try integrateServices.validate()
    }
}

public struct GetFlowLogsIntegrationTemplateResult: Codable, Equatable {
    public var result: String?

    public init(result: String? = nil) {
        self.result = result
    }

    enum CodingKeys: String, CodingKey {
        case result
    }

    public func validate() throws {
    }
}

public struct GetGroupsForCapacityReservationRequest: Codable, Equatable {
    public var capacityReservationId: CapacityReservationId
    public var dryRun: Boolean?
    public var maxResults: GetGroupsForCapacityReservationRequestMaxResults?
    public var nextToken: String?

    public init(capacityReservationId: CapacityReservationId,
                dryRun: Boolean? = nil,
                maxResults: GetGroupsForCapacityReservationRequestMaxResults? = nil,
                nextToken: String? = nil) {
        self.capacityReservationId = capacityReservationId
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsGetGroupsForCapacityReservationRequestMaxResults()
    }
}

public struct GetGroupsForCapacityReservationResult: Codable, Equatable {
    public var capacityReservationGroups: CapacityReservationGroupSet?
    public var nextToken: String?

    public init(capacityReservationGroups: CapacityReservationGroupSet? = nil,
                nextToken: String? = nil) {
        self.capacityReservationGroups = capacityReservationGroups
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationGroups = "capacityReservationGroupSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetHostReservationPurchasePreviewRequest: Codable, Equatable {
    public var hostIdSet: RequestHostIdSet
    public var offeringId: OfferingId

    public init(hostIdSet: RequestHostIdSet,
                offeringId: OfferingId) {
        self.hostIdSet = hostIdSet
        self.offeringId = offeringId
    }

    enum CodingKeys: String, CodingKey {
        case hostIdSet = "HostIdSet"
        case offeringId = "OfferingId"
    }

    public func validate() throws {
    }
}

public struct GetHostReservationPurchasePreviewResult: Codable, Equatable {
    public var currencyCode: CurrencyCodeValues?
    public var purchase: PurchaseSet?
    public var totalHourlyPrice: String?
    public var totalUpfrontPrice: String?

    public init(currencyCode: CurrencyCodeValues? = nil,
                purchase: PurchaseSet? = nil,
                totalHourlyPrice: String? = nil,
                totalUpfrontPrice: String? = nil) {
        self.currencyCode = currencyCode
        self.purchase = purchase
        self.totalHourlyPrice = totalHourlyPrice
        self.totalUpfrontPrice = totalUpfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case purchase
        case totalHourlyPrice
        case totalUpfrontPrice
    }

    public func validate() throws {
    }
}

public struct GetInstanceTypesFromInstanceRequirementsRequest: Codable, Equatable {
    public var architectureTypes: ArchitectureTypeSet
    public var dryRun: Boolean?
    public var instanceRequirements: InstanceRequirementsRequest
    public var maxResults: Integer?
    public var nextToken: String?
    public var virtualizationTypes: VirtualizationTypeSet

    public init(architectureTypes: ArchitectureTypeSet,
                dryRun: Boolean? = nil,
                instanceRequirements: InstanceRequirementsRequest,
                maxResults: Integer? = nil,
                nextToken: String? = nil,
                virtualizationTypes: VirtualizationTypeSet) {
        self.architectureTypes = architectureTypes
        self.dryRun = dryRun
        self.instanceRequirements = instanceRequirements
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.virtualizationTypes = virtualizationTypes
    }

    enum CodingKeys: String, CodingKey {
        case architectureTypes = "ArchitectureType"
        case dryRun = "DryRun"
        case instanceRequirements = "InstanceRequirements"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case virtualizationTypes = "VirtualizationType"
    }

    public func validate() throws {
        try architectureTypes.validateAsArchitectureTypeSet()
        try instanceRequirements.validate()
        try virtualizationTypes.validateAsVirtualizationTypeSet()
    }
}

public struct GetInstanceTypesFromInstanceRequirementsResult: Codable, Equatable {
    public var instanceTypes: InstanceTypeInfoFromInstanceRequirementsSet?
    public var nextToken: String?

    public init(instanceTypes: InstanceTypeInfoFromInstanceRequirementsSet? = nil,
                nextToken: String? = nil) {
        self.instanceTypes = instanceTypes
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceTypes = "instanceTypeSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetInstanceUefiDataRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct GetInstanceUefiDataResult: Codable, Equatable {
    public var instanceId: InstanceId?
    public var uefiData: String?

    public init(instanceId: InstanceId? = nil,
                uefiData: String? = nil) {
        self.instanceId = instanceId
        self.uefiData = uefiData
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case uefiData
    }

    public func validate() throws {
    }
}

public struct GetIpamAddressHistoryRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?
    public var endTime: MillisecondDateTime?
    public var ipamScopeId: IpamScopeId
    public var maxResults: IpamAddressHistoryMaxResults?
    public var nextToken: NextToken?
    public var startTime: MillisecondDateTime?
    public var vpcId: String?

    public init(cidr: String,
                dryRun: Boolean? = nil,
                endTime: MillisecondDateTime? = nil,
                ipamScopeId: IpamScopeId,
                maxResults: IpamAddressHistoryMaxResults? = nil,
                nextToken: NextToken? = nil,
                startTime: MillisecondDateTime? = nil,
                vpcId: String? = nil) {
        self.cidr = cidr
        self.dryRun = dryRun
        self.endTime = endTime
        self.ipamScopeId = ipamScopeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
        case endTime = "EndTime"
        case ipamScopeId = "IpamScopeId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
        case vpcId = "VpcId"
    }

    public func validate() throws {
        try maxResults?.validateAsIpamAddressHistoryMaxResults()
    }
}

public struct GetIpamAddressHistoryResult: Codable, Equatable {
    public var historyRecords: IpamAddressHistoryRecordSet?
    public var nextToken: NextToken?

    public init(historyRecords: IpamAddressHistoryRecordSet? = nil,
                nextToken: NextToken? = nil) {
        self.historyRecords = historyRecords
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case historyRecords = "historyRecordSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetIpamPoolAllocationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var ipamPoolAllocationId: IpamPoolAllocationId?
    public var ipamPoolId: IpamPoolId
    public var maxResults: GetIpamPoolAllocationsMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                ipamPoolAllocationId: IpamPoolAllocationId? = nil,
                ipamPoolId: IpamPoolId,
                maxResults: GetIpamPoolAllocationsMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.ipamPoolAllocationId = ipamPoolAllocationId
        self.ipamPoolId = ipamPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case ipamPoolAllocationId = "IpamPoolAllocationId"
        case ipamPoolId = "IpamPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsGetIpamPoolAllocationsMaxResults()
    }
}

public struct GetIpamPoolAllocationsResult: Codable, Equatable {
    public var ipamPoolAllocations: IpamPoolAllocationSet?
    public var nextToken: NextToken?

    public init(ipamPoolAllocations: IpamPoolAllocationSet? = nil,
                nextToken: NextToken? = nil) {
        self.ipamPoolAllocations = ipamPoolAllocations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipamPoolAllocations = "ipamPoolAllocationSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetIpamPoolCidrsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var ipamPoolId: IpamPoolId
    public var maxResults: IpamMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                ipamPoolId: IpamPoolId,
                maxResults: IpamMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.ipamPoolId = ipamPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case ipamPoolId = "IpamPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsIpamMaxResults()
    }
}

public struct GetIpamPoolCidrsResult: Codable, Equatable {
    public var ipamPoolCidrs: IpamPoolCidrSet?
    public var nextToken: NextToken?

    public init(ipamPoolCidrs: IpamPoolCidrSet? = nil,
                nextToken: NextToken? = nil) {
        self.ipamPoolCidrs = ipamPoolCidrs
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipamPoolCidrs = "ipamPoolCidrSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetIpamResourceCidrsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var ipamPoolId: IpamPoolId?
    public var ipamScopeId: IpamScopeId
    public var maxResults: IpamMaxResults?
    public var nextToken: NextToken?
    public var resourceId: String?
    public var resourceOwner: String?
    public var resourceTag: RequestIpamResourceTag?
    public var resourceType: IpamResourceType?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                ipamPoolId: IpamPoolId? = nil,
                ipamScopeId: IpamScopeId,
                maxResults: IpamMaxResults? = nil,
                nextToken: NextToken? = nil,
                resourceId: String? = nil,
                resourceOwner: String? = nil,
                resourceTag: RequestIpamResourceTag? = nil,
                resourceType: IpamResourceType? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.ipamPoolId = ipamPoolId
        self.ipamScopeId = ipamScopeId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceOwner = resourceOwner
        self.resourceTag = resourceTag
        self.resourceType = resourceType
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case ipamPoolId = "IpamPoolId"
        case ipamScopeId = "IpamScopeId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
        case resourceOwner = "ResourceOwner"
        case resourceTag = "ResourceTag"
        case resourceType = "ResourceType"
    }

    public func validate() throws {
        try maxResults?.validateAsIpamMaxResults()
        try resourceTag?.validate()
    }
}

public struct GetIpamResourceCidrsResult: Codable, Equatable {
    public var ipamResourceCidrs: IpamResourceCidrSet?
    public var nextToken: NextToken?

    public init(ipamResourceCidrs: IpamResourceCidrSet? = nil,
                nextToken: NextToken? = nil) {
        self.ipamResourceCidrs = ipamResourceCidrs
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case ipamResourceCidrs = "ipamResourceCidrSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetLaunchTemplateDataRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct GetLaunchTemplateDataResult: Codable, Equatable {
    public var launchTemplateData: ResponseLaunchTemplateData?

    public init(launchTemplateData: ResponseLaunchTemplateData? = nil) {
        self.launchTemplateData = launchTemplateData
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateData
    }

    public func validate() throws {
        try launchTemplateData?.validate()
    }
}

public struct GetManagedPrefixListAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: GetManagedPrefixListAssociationsMaxResults?
    public var nextToken: NextToken?
    public var prefixListId: PrefixListResourceId

    public init(dryRun: Boolean? = nil,
                maxResults: GetManagedPrefixListAssociationsMaxResults? = nil,
                nextToken: NextToken? = nil,
                prefixListId: PrefixListResourceId) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.prefixListId = prefixListId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case prefixListId = "PrefixListId"
    }

    public func validate() throws {
        try maxResults?.validateAsGetManagedPrefixListAssociationsMaxResults()
    }
}

public struct GetManagedPrefixListAssociationsResult: Codable, Equatable {
    public var nextToken: String?
    public var prefixListAssociations: PrefixListAssociationSet?

    public init(nextToken: String? = nil,
                prefixListAssociations: PrefixListAssociationSet? = nil) {
        self.nextToken = nextToken
        self.prefixListAssociations = prefixListAssociations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case prefixListAssociations = "prefixListAssociationSet"
    }

    public func validate() throws {
    }
}

public struct GetManagedPrefixListEntriesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: PrefixListMaxResults?
    public var nextToken: NextToken?
    public var prefixListId: PrefixListResourceId
    public var targetVersion: Long?

    public init(dryRun: Boolean? = nil,
                maxResults: PrefixListMaxResults? = nil,
                nextToken: NextToken? = nil,
                prefixListId: PrefixListResourceId,
                targetVersion: Long? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.prefixListId = prefixListId
        self.targetVersion = targetVersion
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case prefixListId = "PrefixListId"
        case targetVersion = "TargetVersion"
    }

    public func validate() throws {
        try maxResults?.validateAsPrefixListMaxResults()
    }
}

public struct GetManagedPrefixListEntriesResult: Codable, Equatable {
    public var entries: PrefixListEntrySet?
    public var nextToken: NextToken?

    public init(entries: PrefixListEntrySet? = nil,
                nextToken: NextToken? = nil) {
        self.entries = entries
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case entries = "entrySet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetNetworkInsightsAccessScopeAnalysisFindingsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: NetworkInsightsMaxResults?
    public var networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                maxResults: NetworkInsightsMaxResults? = nil,
                networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.networkInsightsAccessScopeAnalysisId = networkInsightsAccessScopeAnalysisId
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case networkInsightsAccessScopeAnalysisId = "NetworkInsightsAccessScopeAnalysisId"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsNetworkInsightsMaxResults()
    }
}

public struct GetNetworkInsightsAccessScopeAnalysisFindingsResult: Codable, Equatable {
    public var analysisFindings: AccessScopeAnalysisFindingList?
    public var analysisStatus: AnalysisStatus?
    public var networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId?
    public var nextToken: String?

    public init(analysisFindings: AccessScopeAnalysisFindingList? = nil,
                analysisStatus: AnalysisStatus? = nil,
                networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId? = nil,
                nextToken: String? = nil) {
        self.analysisFindings = analysisFindings
        self.analysisStatus = analysisStatus
        self.networkInsightsAccessScopeAnalysisId = networkInsightsAccessScopeAnalysisId
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case analysisFindings = "analysisFindingSet"
        case analysisStatus
        case networkInsightsAccessScopeAnalysisId
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetNetworkInsightsAccessScopeContentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInsightsAccessScopeId: NetworkInsightsAccessScopeId

    public init(dryRun: Boolean? = nil,
                networkInsightsAccessScopeId: NetworkInsightsAccessScopeId) {
        self.dryRun = dryRun
        self.networkInsightsAccessScopeId = networkInsightsAccessScopeId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case networkInsightsAccessScopeId = "NetworkInsightsAccessScopeId"
    }

    public func validate() throws {
    }
}

public struct GetNetworkInsightsAccessScopeContentResult: Codable, Equatable {
    public var networkInsightsAccessScopeContent: NetworkInsightsAccessScopeContent?

    public init(networkInsightsAccessScopeContent: NetworkInsightsAccessScopeContent? = nil) {
        self.networkInsightsAccessScopeContent = networkInsightsAccessScopeContent
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAccessScopeContent
    }

    public func validate() throws {
        try networkInsightsAccessScopeContent?.validate()
    }
}

public struct GetPasswordDataRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct GetPasswordDataResult: Codable, Equatable {
    public var instanceId: String?
    public var passwordData: String?
    public var timestamp: DateTime?

    public init(instanceId: String? = nil,
                passwordData: String? = nil,
                timestamp: DateTime? = nil) {
        self.instanceId = instanceId
        self.passwordData = passwordData
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case passwordData
        case timestamp
    }

    public func validate() throws {
    }
}

public struct GetReservedInstancesExchangeQuoteRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var reservedInstanceIds: ReservedInstanceIdSet
    public var targetConfigurations: TargetConfigurationRequestSet?

    public init(dryRun: Boolean? = nil,
                reservedInstanceIds: ReservedInstanceIdSet,
                targetConfigurations: TargetConfigurationRequestSet? = nil) {
        self.dryRun = dryRun
        self.reservedInstanceIds = reservedInstanceIds
        self.targetConfigurations = targetConfigurations
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case reservedInstanceIds = "ReservedInstanceId"
        case targetConfigurations = "TargetConfiguration"
    }

    public func validate() throws {
    }
}

public struct GetReservedInstancesExchangeQuoteResult: Codable, Equatable {
    public var currencyCode: String?
    public var isValidExchange: Boolean?
    public var outputReservedInstancesWillExpireAt: DateTime?
    public var paymentDue: String?
    public var reservedInstanceValueRollup: ReservationValue?
    public var reservedInstanceValueSet: ReservedInstanceReservationValueSet?
    public var targetConfigurationValueRollup: ReservationValue?
    public var targetConfigurationValueSet: TargetReservationValueSet?
    public var validationFailureReason: String?

    public init(currencyCode: String? = nil,
                isValidExchange: Boolean? = nil,
                outputReservedInstancesWillExpireAt: DateTime? = nil,
                paymentDue: String? = nil,
                reservedInstanceValueRollup: ReservationValue? = nil,
                reservedInstanceValueSet: ReservedInstanceReservationValueSet? = nil,
                targetConfigurationValueRollup: ReservationValue? = nil,
                targetConfigurationValueSet: TargetReservationValueSet? = nil,
                validationFailureReason: String? = nil) {
        self.currencyCode = currencyCode
        self.isValidExchange = isValidExchange
        self.outputReservedInstancesWillExpireAt = outputReservedInstancesWillExpireAt
        self.paymentDue = paymentDue
        self.reservedInstanceValueRollup = reservedInstanceValueRollup
        self.reservedInstanceValueSet = reservedInstanceValueSet
        self.targetConfigurationValueRollup = targetConfigurationValueRollup
        self.targetConfigurationValueSet = targetConfigurationValueSet
        self.validationFailureReason = validationFailureReason
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case isValidExchange
        case outputReservedInstancesWillExpireAt
        case paymentDue
        case reservedInstanceValueRollup
        case reservedInstanceValueSet
        case targetConfigurationValueRollup
        case targetConfigurationValueSet
        case validationFailureReason
    }

    public func validate() throws {
        try reservedInstanceValueRollup?.validate()
        try targetConfigurationValueRollup?.validate()
    }
}

public struct GetSerialConsoleAccessStatusRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct GetSerialConsoleAccessStatusResult: Codable, Equatable {
    public var serialConsoleAccessEnabled: Boolean?

    public init(serialConsoleAccessEnabled: Boolean? = nil) {
        self.serialConsoleAccessEnabled = serialConsoleAccessEnabled
    }

    enum CodingKeys: String, CodingKey {
        case serialConsoleAccessEnabled
    }

    public func validate() throws {
    }
}

public struct GetSpotPlacementScoresRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceRequirementsWithMetadata: InstanceRequirementsWithMetadataRequest?
    public var instanceTypes: InstanceTypes?
    public var maxResults: SpotPlacementScoresMaxResults?
    public var nextToken: String?
    public var regionNames: RegionNames?
    public var singleAvailabilityZone: Boolean?
    public var targetCapacity: SpotPlacementScoresTargetCapacity
    public var targetCapacityUnitType: TargetCapacityUnitType?

    public init(dryRun: Boolean? = nil,
                instanceRequirementsWithMetadata: InstanceRequirementsWithMetadataRequest? = nil,
                instanceTypes: InstanceTypes? = nil,
                maxResults: SpotPlacementScoresMaxResults? = nil,
                nextToken: String? = nil,
                regionNames: RegionNames? = nil,
                singleAvailabilityZone: Boolean? = nil,
                targetCapacity: SpotPlacementScoresTargetCapacity,
                targetCapacityUnitType: TargetCapacityUnitType? = nil) {
        self.dryRun = dryRun
        self.instanceRequirementsWithMetadata = instanceRequirementsWithMetadata
        self.instanceTypes = instanceTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.regionNames = regionNames
        self.singleAvailabilityZone = singleAvailabilityZone
        self.targetCapacity = targetCapacity
        self.targetCapacityUnitType = targetCapacityUnitType
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceRequirementsWithMetadata = "InstanceRequirementsWithMetadata"
        case instanceTypes = "InstanceType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case regionNames = "RegionName"
        case singleAvailabilityZone = "SingleAvailabilityZone"
        case targetCapacity = "TargetCapacity"
        case targetCapacityUnitType = "TargetCapacityUnitType"
    }

    public func validate() throws {
        try instanceRequirementsWithMetadata?.validate()
        try instanceTypes?.validateAsInstanceTypes()
        try maxResults?.validateAsSpotPlacementScoresMaxResults()
        try regionNames?.validateAsRegionNames()
        try targetCapacity.validateAsSpotPlacementScoresTargetCapacity()
    }
}

public struct GetSpotPlacementScoresResult: Codable, Equatable {
    public var nextToken: String?
    public var spotPlacementScores: SpotPlacementScores?

    public init(nextToken: String? = nil,
                spotPlacementScores: SpotPlacementScores? = nil) {
        self.nextToken = nextToken
        self.spotPlacementScores = spotPlacementScores
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case spotPlacementScores = "spotPlacementScoreSet"
    }

    public func validate() throws {
    }
}

public struct GetSubnetCidrReservationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: GetSubnetCidrReservationsMaxResults?
    public var nextToken: String?
    public var subnetId: SubnetId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: GetSubnetCidrReservationsMaxResults? = nil,
                nextToken: String? = nil,
                subnetId: SubnetId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetId = "SubnetId"
    }

    public func validate() throws {
        try maxResults?.validateAsGetSubnetCidrReservationsMaxResults()
    }
}

public struct GetSubnetCidrReservationsResult: Codable, Equatable {
    public var nextToken: String?
    public var subnetIpv4CidrReservations: SubnetCidrReservationList?
    public var subnetIpv6CidrReservations: SubnetCidrReservationList?

    public init(nextToken: String? = nil,
                subnetIpv4CidrReservations: SubnetCidrReservationList? = nil,
                subnetIpv6CidrReservations: SubnetCidrReservationList? = nil) {
        self.nextToken = nextToken
        self.subnetIpv4CidrReservations = subnetIpv4CidrReservations
        self.subnetIpv6CidrReservations = subnetIpv6CidrReservations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case subnetIpv4CidrReservations = "subnetIpv4CidrReservationSet"
        case subnetIpv6CidrReservations = "subnetIpv6CidrReservationSet"
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayAttachmentPropagationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayAttachmentPropagationsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayAttachmentPropagations: TransitGatewayAttachmentPropagationList?

    public init(nextToken: String? = nil,
                transitGatewayAttachmentPropagations: TransitGatewayAttachmentPropagationList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayAttachmentPropagations = transitGatewayAttachmentPropagations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayAttachmentPropagations
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayMulticastDomainAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayMulticastDomainAssociationsResult: Codable, Equatable {
    public var multicastDomainAssociations: TransitGatewayMulticastDomainAssociationList?
    public var nextToken: String?

    public init(multicastDomainAssociations: TransitGatewayMulticastDomainAssociationList? = nil,
                nextToken: String? = nil) {
        self.multicastDomainAssociations = multicastDomainAssociations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case multicastDomainAssociations
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayPolicyTableAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayPolicyTableId: TransitGatewayPolicyTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayPolicyTableId: TransitGatewayPolicyTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayPolicyTableId = transitGatewayPolicyTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayPolicyTableId = "TransitGatewayPolicyTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayPolicyTableAssociationsResult: Codable, Equatable {
    public var associations: TransitGatewayPolicyTableAssociationList?
    public var nextToken: String?

    public init(associations: TransitGatewayPolicyTableAssociationList? = nil,
                nextToken: String? = nil) {
        self.associations = associations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case associations
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayPolicyTableEntriesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayPolicyTableId: TransitGatewayPolicyTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayPolicyTableId: TransitGatewayPolicyTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayPolicyTableId = transitGatewayPolicyTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayPolicyTableId = "TransitGatewayPolicyTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayPolicyTableEntriesResult: Codable, Equatable {
    public var transitGatewayPolicyTableEntries: TransitGatewayPolicyTableEntryList?

    public init(transitGatewayPolicyTableEntries: TransitGatewayPolicyTableEntryList? = nil) {
        self.transitGatewayPolicyTableEntries = transitGatewayPolicyTableEntries
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPolicyTableEntries
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayPrefixListReferencesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayPrefixListReferencesResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayPrefixListReferences: TransitGatewayPrefixListReferenceSet?

    public init(nextToken: String? = nil,
                transitGatewayPrefixListReferences: TransitGatewayPrefixListReferenceSet? = nil) {
        self.nextToken = nextToken
        self.transitGatewayPrefixListReferences = transitGatewayPrefixListReferences
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayPrefixListReferences = "transitGatewayPrefixListReferenceSet"
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayRouteTableAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayRouteTableAssociationsResult: Codable, Equatable {
    public var associations: TransitGatewayRouteTableAssociationList?
    public var nextToken: String?

    public init(associations: TransitGatewayRouteTableAssociationList? = nil,
                nextToken: String? = nil) {
        self.associations = associations
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case associations
        case nextToken
    }

    public func validate() throws {
    }
}

public struct GetTransitGatewayRouteTablePropagationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct GetTransitGatewayRouteTablePropagationsResult: Codable, Equatable {
    public var nextToken: String?
    public var transitGatewayRouteTablePropagations: TransitGatewayRouteTablePropagationList?

    public init(nextToken: String? = nil,
                transitGatewayRouteTablePropagations: TransitGatewayRouteTablePropagationList? = nil) {
        self.nextToken = nextToken
        self.transitGatewayRouteTablePropagations = transitGatewayRouteTablePropagations
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case transitGatewayRouteTablePropagations
    }

    public func validate() throws {
    }
}

public struct GetVerifiedAccessEndpointPolicyRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var verifiedAccessEndpointId: VerifiedAccessEndpointId

    public init(dryRun: Boolean? = nil,
                verifiedAccessEndpointId: VerifiedAccessEndpointId) {
        self.dryRun = dryRun
        self.verifiedAccessEndpointId = verifiedAccessEndpointId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case verifiedAccessEndpointId = "VerifiedAccessEndpointId"
    }

    public func validate() throws {
    }
}

public struct GetVerifiedAccessEndpointPolicyResult: Codable, Equatable {
    public var policyDocument: String?
    public var policyEnabled: Boolean?

    public init(policyDocument: String? = nil,
                policyEnabled: Boolean? = nil) {
        self.policyDocument = policyDocument
        self.policyEnabled = policyEnabled
    }

    enum CodingKeys: String, CodingKey {
        case policyDocument
        case policyEnabled
    }

    public func validate() throws {
    }
}

public struct GetVerifiedAccessGroupPolicyRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var verifiedAccessGroupId: VerifiedAccessGroupId

    public init(dryRun: Boolean? = nil,
                verifiedAccessGroupId: VerifiedAccessGroupId) {
        self.dryRun = dryRun
        self.verifiedAccessGroupId = verifiedAccessGroupId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case verifiedAccessGroupId = "VerifiedAccessGroupId"
    }

    public func validate() throws {
    }
}

public struct GetVerifiedAccessGroupPolicyResult: Codable, Equatable {
    public var policyDocument: String?
    public var policyEnabled: Boolean?

    public init(policyDocument: String? = nil,
                policyEnabled: Boolean? = nil) {
        self.policyDocument = policyDocument
        self.policyEnabled = policyEnabled
    }

    enum CodingKeys: String, CodingKey {
        case policyDocument
        case policyEnabled
    }

    public func validate() throws {
    }
}

public struct GetVpnConnectionDeviceSampleConfigurationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var internetKeyExchangeVersion: String?
    public var vpnConnectionDeviceTypeId: VpnConnectionDeviceTypeId
    public var vpnConnectionId: VpnConnectionId

    public init(dryRun: Boolean? = nil,
                internetKeyExchangeVersion: String? = nil,
                vpnConnectionDeviceTypeId: VpnConnectionDeviceTypeId,
                vpnConnectionId: VpnConnectionId) {
        self.dryRun = dryRun
        self.internetKeyExchangeVersion = internetKeyExchangeVersion
        self.vpnConnectionDeviceTypeId = vpnConnectionDeviceTypeId
        self.vpnConnectionId = vpnConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case internetKeyExchangeVersion = "InternetKeyExchangeVersion"
        case vpnConnectionDeviceTypeId = "VpnConnectionDeviceTypeId"
        case vpnConnectionId = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct GetVpnConnectionDeviceSampleConfigurationResult: Codable, Equatable {
    public var vpnConnectionDeviceSampleConfiguration: VpnConnectionDeviceSampleConfiguration?

    public init(vpnConnectionDeviceSampleConfiguration: VpnConnectionDeviceSampleConfiguration? = nil) {
        self.vpnConnectionDeviceSampleConfiguration = vpnConnectionDeviceSampleConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnectionDeviceSampleConfiguration
    }

    public func validate() throws {
    }
}

public struct GetVpnConnectionDeviceTypesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: GVCDMaxResults?
    public var nextToken: NextToken?

    public init(dryRun: Boolean? = nil,
                maxResults: GVCDMaxResults? = nil,
                nextToken: NextToken? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsGVCDMaxResults()
    }
}

public struct GetVpnConnectionDeviceTypesResult: Codable, Equatable {
    public var nextToken: NextToken?
    public var vpnConnectionDeviceTypes: VpnConnectionDeviceTypeList?

    public init(nextToken: NextToken? = nil,
                vpnConnectionDeviceTypes: VpnConnectionDeviceTypeList? = nil) {
        self.nextToken = nextToken
        self.vpnConnectionDeviceTypes = vpnConnectionDeviceTypes
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpnConnectionDeviceTypes = "vpnConnectionDeviceTypeSet"
    }

    public func validate() throws {
    }
}

public struct GpuDeviceInfo: Codable, Equatable {
    public var count: GpuDeviceCount?
    public var manufacturer: GpuDeviceManufacturerName?
    public var memoryInfo: GpuDeviceMemoryInfo?
    public var name: GpuDeviceName?

    public init(count: GpuDeviceCount? = nil,
                manufacturer: GpuDeviceManufacturerName? = nil,
                memoryInfo: GpuDeviceMemoryInfo? = nil,
                name: GpuDeviceName? = nil) {
        self.count = count
        self.manufacturer = manufacturer
        self.memoryInfo = memoryInfo
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case count
        case manufacturer
        case memoryInfo
        case name
    }

    public func validate() throws {
        try memoryInfo?.validate()
    }
}

public struct GpuDeviceMemoryInfo: Codable, Equatable {
    public var sizeInMiB: GpuDeviceMemorySize?

    public init(sizeInMiB: GpuDeviceMemorySize? = nil) {
        self.sizeInMiB = sizeInMiB
    }

    enum CodingKeys: String, CodingKey {
        case sizeInMiB
    }

    public func validate() throws {
    }
}

public struct GpuInfo: Codable, Equatable {
    public var gpus: GpuDeviceInfoList?
    public var totalGpuMemoryInMiB: TotalGpuMemory?

    public init(gpus: GpuDeviceInfoList? = nil,
                totalGpuMemoryInMiB: TotalGpuMemory? = nil) {
        self.gpus = gpus
        self.totalGpuMemoryInMiB = totalGpuMemoryInMiB
    }

    enum CodingKeys: String, CodingKey {
        case gpus
        case totalGpuMemoryInMiB
    }

    public func validate() throws {
    }
}

public struct GroupIdentifier: Codable, Equatable {
    public var groupId: String?
    public var groupName: String?

    public init(groupId: String? = nil,
                groupName: String? = nil) {
        self.groupId = groupId
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case groupName
    }

    public func validate() throws {
    }
}

public struct HibernationOptions: Codable, Equatable {
    public var configured: Boolean?

    public init(configured: Boolean? = nil) {
        self.configured = configured
    }

    enum CodingKeys: String, CodingKey {
        case configured
    }

    public func validate() throws {
    }
}

public struct HibernationOptionsRequest: Codable, Equatable {
    public var configured: Boolean?

    public init(configured: Boolean? = nil) {
        self.configured = configured
    }

    enum CodingKeys: String, CodingKey {
        case configured = "Configured"
    }

    public func validate() throws {
    }
}

public struct HistoryRecord: Codable, Equatable {
    public var eventInformation: EventInformation?
    public var eventType: EventType?
    public var timestamp: DateTime?

    public init(eventInformation: EventInformation? = nil,
                eventType: EventType? = nil,
                timestamp: DateTime? = nil) {
        self.eventInformation = eventInformation
        self.eventType = eventType
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case eventInformation
        case eventType
        case timestamp
    }

    public func validate() throws {
        try eventInformation?.validate()
    }
}

public struct HistoryRecordEntry: Codable, Equatable {
    public var eventInformation: EventInformation?
    public var eventType: FleetEventType?
    public var timestamp: DateTime?

    public init(eventInformation: EventInformation? = nil,
                eventType: FleetEventType? = nil,
                timestamp: DateTime? = nil) {
        self.eventInformation = eventInformation
        self.eventType = eventType
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case eventInformation
        case eventType
        case timestamp
    }

    public func validate() throws {
        try eventInformation?.validate()
    }
}

public struct Host: Codable, Equatable {
    public var allocationTime: DateTime?
    public var allowsMultipleInstanceTypes: AllowsMultipleInstanceTypes?
    public var autoPlacement: AutoPlacement?
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var availableCapacity: AvailableCapacity?
    public var clientToken: String?
    public var hostId: String?
    public var hostProperties: HostProperties?
    public var hostRecovery: HostRecovery?
    public var hostReservationId: String?
    public var instances: HostInstanceList?
    public var memberOfServiceLinkedResourceGroup: Boolean?
    public var outpostArn: String?
    public var ownerId: String?
    public var releaseTime: DateTime?
    public var state: AllocationState?
    public var tags: TagList?

    public init(allocationTime: DateTime? = nil,
                allowsMultipleInstanceTypes: AllowsMultipleInstanceTypes? = nil,
                autoPlacement: AutoPlacement? = nil,
                availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                availableCapacity: AvailableCapacity? = nil,
                clientToken: String? = nil,
                hostId: String? = nil,
                hostProperties: HostProperties? = nil,
                hostRecovery: HostRecovery? = nil,
                hostReservationId: String? = nil,
                instances: HostInstanceList? = nil,
                memberOfServiceLinkedResourceGroup: Boolean? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                releaseTime: DateTime? = nil,
                state: AllocationState? = nil,
                tags: TagList? = nil) {
        self.allocationTime = allocationTime
        self.allowsMultipleInstanceTypes = allowsMultipleInstanceTypes
        self.autoPlacement = autoPlacement
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.availableCapacity = availableCapacity
        self.clientToken = clientToken
        self.hostId = hostId
        self.hostProperties = hostProperties
        self.hostRecovery = hostRecovery
        self.hostReservationId = hostReservationId
        self.instances = instances
        self.memberOfServiceLinkedResourceGroup = memberOfServiceLinkedResourceGroup
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.releaseTime = releaseTime
        self.state = state
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case allocationTime
        case allowsMultipleInstanceTypes
        case autoPlacement
        case availabilityZone
        case availabilityZoneId
        case availableCapacity
        case clientToken
        case hostId
        case hostProperties
        case hostRecovery
        case hostReservationId
        case instances
        case memberOfServiceLinkedResourceGroup
        case outpostArn
        case ownerId
        case releaseTime
        case state
        case tags = "tagSet"
    }

    public func validate() throws {
        try availableCapacity?.validate()
        try hostProperties?.validate()
    }
}

public struct HostInstance: Codable, Equatable {
    public var instanceId: String?
    public var instanceType: String?
    public var ownerId: String?

    public init(instanceId: String? = nil,
                instanceType: String? = nil,
                ownerId: String? = nil) {
        self.instanceId = instanceId
        self.instanceType = instanceType
        self.ownerId = ownerId
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case instanceType
        case ownerId
    }

    public func validate() throws {
    }
}

public struct HostOffering: Codable, Equatable {
    public var currencyCode: CurrencyCodeValues?
    public var duration: Integer?
    public var hourlyPrice: String?
    public var instanceFamily: String?
    public var offeringId: OfferingId?
    public var paymentOption: PaymentOption?
    public var upfrontPrice: String?

    public init(currencyCode: CurrencyCodeValues? = nil,
                duration: Integer? = nil,
                hourlyPrice: String? = nil,
                instanceFamily: String? = nil,
                offeringId: OfferingId? = nil,
                paymentOption: PaymentOption? = nil,
                upfrontPrice: String? = nil) {
        self.currencyCode = currencyCode
        self.duration = duration
        self.hourlyPrice = hourlyPrice
        self.instanceFamily = instanceFamily
        self.offeringId = offeringId
        self.paymentOption = paymentOption
        self.upfrontPrice = upfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case duration
        case hourlyPrice
        case instanceFamily
        case offeringId
        case paymentOption
        case upfrontPrice
    }

    public func validate() throws {
    }
}

public struct HostProperties: Codable, Equatable {
    public var cores: Integer?
    public var instanceFamily: String?
    public var instanceType: String?
    public var sockets: Integer?
    public var totalVCpus: Integer?

    public init(cores: Integer? = nil,
                instanceFamily: String? = nil,
                instanceType: String? = nil,
                sockets: Integer? = nil,
                totalVCpus: Integer? = nil) {
        self.cores = cores
        self.instanceFamily = instanceFamily
        self.instanceType = instanceType
        self.sockets = sockets
        self.totalVCpus = totalVCpus
    }

    enum CodingKeys: String, CodingKey {
        case cores
        case instanceFamily
        case instanceType
        case sockets
        case totalVCpus
    }

    public func validate() throws {
    }
}

public struct HostReservation: Codable, Equatable {
    public var count: Integer?
    public var currencyCode: CurrencyCodeValues?
    public var duration: Integer?
    public var end: DateTime?
    public var hostIdSet: ResponseHostIdSet?
    public var hostReservationId: HostReservationId?
    public var hourlyPrice: String?
    public var instanceFamily: String?
    public var offeringId: OfferingId?
    public var paymentOption: PaymentOption?
    public var start: DateTime?
    public var state: ReservationState?
    public var tags: TagList?
    public var upfrontPrice: String?

    public init(count: Integer? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                duration: Integer? = nil,
                end: DateTime? = nil,
                hostIdSet: ResponseHostIdSet? = nil,
                hostReservationId: HostReservationId? = nil,
                hourlyPrice: String? = nil,
                instanceFamily: String? = nil,
                offeringId: OfferingId? = nil,
                paymentOption: PaymentOption? = nil,
                start: DateTime? = nil,
                state: ReservationState? = nil,
                tags: TagList? = nil,
                upfrontPrice: String? = nil) {
        self.count = count
        self.currencyCode = currencyCode
        self.duration = duration
        self.end = end
        self.hostIdSet = hostIdSet
        self.hostReservationId = hostReservationId
        self.hourlyPrice = hourlyPrice
        self.instanceFamily = instanceFamily
        self.offeringId = offeringId
        self.paymentOption = paymentOption
        self.start = start
        self.state = state
        self.tags = tags
        self.upfrontPrice = upfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case count
        case currencyCode
        case duration
        case end
        case hostIdSet
        case hostReservationId
        case hourlyPrice
        case instanceFamily
        case offeringId
        case paymentOption
        case start
        case state
        case tags = "tagSet"
        case upfrontPrice
    }

    public func validate() throws {
    }
}

public struct IKEVersionsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct IKEVersionsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct IamInstanceProfile: Codable, Equatable {
    public var arn: String?
    public var id: String?

    public init(arn: String? = nil,
                id: String? = nil) {
        self.arn = arn
        self.id = id
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case id
    }

    public func validate() throws {
    }
}

public struct IamInstanceProfileAssociation: Codable, Equatable {
    public var associationId: String?
    public var iamInstanceProfile: IamInstanceProfile?
    public var instanceId: String?
    public var state: IamInstanceProfileAssociationState?
    public var timestamp: DateTime?

    public init(associationId: String? = nil,
                iamInstanceProfile: IamInstanceProfile? = nil,
                instanceId: String? = nil,
                state: IamInstanceProfileAssociationState? = nil,
                timestamp: DateTime? = nil) {
        self.associationId = associationId
        self.iamInstanceProfile = iamInstanceProfile
        self.instanceId = instanceId
        self.state = state
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case iamInstanceProfile
        case instanceId
        case state
        case timestamp
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
    }
}

public struct IamInstanceProfileSpecification: Codable, Equatable {
    public var arn: String?
    public var name: String?

    public init(arn: String? = nil,
                name: String? = nil) {
        self.arn = arn
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case name
    }

    public func validate() throws {
    }
}

public struct IcmpTypeCode: Codable, Equatable {
    public var code: Integer?
    public var type: Integer?

    public init(code: Integer? = nil,
                type: Integer? = nil) {
        self.code = code
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case code
        case type
    }

    public func validate() throws {
    }
}

public struct IdFormat: Codable, Equatable {
    public var deadline: DateTime?
    public var resource: String?
    public var useLongIds: Boolean?

    public init(deadline: DateTime? = nil,
                resource: String? = nil,
                useLongIds: Boolean? = nil) {
        self.deadline = deadline
        self.resource = resource
        self.useLongIds = useLongIds
    }

    enum CodingKeys: String, CodingKey {
        case deadline
        case resource
        case useLongIds
    }

    public func validate() throws {
    }
}

public struct Image: Codable, Equatable {
    public var architecture: ArchitectureValues?
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var bootMode: BootModeValues?
    public var creationDate: String?
    public var deprecationTime: String?
    public var description: String?
    public var enaSupport: Boolean?
    public var hypervisor: HypervisorType?
    public var imageId: String?
    public var imageLocation: String?
    public var imageOwnerAlias: String?
    public var imageType: ImageTypeValues?
    public var imdsSupport: ImdsSupportValues?
    public var kernelId: String?
    public var name: String?
    public var ownerId: String?
    public var platform: PlatformValues?
    public var platformDetails: String?
    public var productCodes: ProductCodeList?
    public var `public`: Boolean?
    public var ramdiskId: String?
    public var rootDeviceName: String?
    public var rootDeviceType: DeviceType?
    public var sriovNetSupport: String?
    public var state: ImageState?
    public var stateReason: StateReason?
    public var tags: TagList?
    public var tpmSupport: TpmSupportValues?
    public var usageOperation: String?
    public var virtualizationType: VirtualizationType?

    public init(architecture: ArchitectureValues? = nil,
                blockDeviceMappings: BlockDeviceMappingList? = nil,
                bootMode: BootModeValues? = nil,
                creationDate: String? = nil,
                deprecationTime: String? = nil,
                description: String? = nil,
                enaSupport: Boolean? = nil,
                hypervisor: HypervisorType? = nil,
                imageId: String? = nil,
                imageLocation: String? = nil,
                imageOwnerAlias: String? = nil,
                imageType: ImageTypeValues? = nil,
                imdsSupport: ImdsSupportValues? = nil,
                kernelId: String? = nil,
                name: String? = nil,
                ownerId: String? = nil,
                platform: PlatformValues? = nil,
                platformDetails: String? = nil,
                productCodes: ProductCodeList? = nil,
                `public`: Boolean? = nil,
                ramdiskId: String? = nil,
                rootDeviceName: String? = nil,
                rootDeviceType: DeviceType? = nil,
                sriovNetSupport: String? = nil,
                state: ImageState? = nil,
                stateReason: StateReason? = nil,
                tags: TagList? = nil,
                tpmSupport: TpmSupportValues? = nil,
                usageOperation: String? = nil,
                virtualizationType: VirtualizationType? = nil) {
        self.architecture = architecture
        self.blockDeviceMappings = blockDeviceMappings
        self.bootMode = bootMode
        self.creationDate = creationDate
        self.deprecationTime = deprecationTime
        self.description = description
        self.enaSupport = enaSupport
        self.hypervisor = hypervisor
        self.imageId = imageId
        self.imageLocation = imageLocation
        self.imageOwnerAlias = imageOwnerAlias
        self.imageType = imageType
        self.imdsSupport = imdsSupport
        self.kernelId = kernelId
        self.name = name
        self.ownerId = ownerId
        self.platform = platform
        self.platformDetails = platformDetails
        self.productCodes = productCodes
        self.`public` = `public`
        self.ramdiskId = ramdiskId
        self.rootDeviceName = rootDeviceName
        self.rootDeviceType = rootDeviceType
        self.sriovNetSupport = sriovNetSupport
        self.state = state
        self.stateReason = stateReason
        self.tags = tags
        self.tpmSupport = tpmSupport
        self.usageOperation = usageOperation
        self.virtualizationType = virtualizationType
    }

    enum CodingKeys: String, CodingKey {
        case architecture
        case blockDeviceMappings = "blockDeviceMapping"
        case bootMode
        case creationDate
        case deprecationTime
        case description
        case enaSupport
        case hypervisor
        case imageId
        case imageLocation
        case imageOwnerAlias
        case imageType
        case imdsSupport
        case kernelId
        case name
        case ownerId = "imageOwnerId"
        case platform
        case platformDetails
        case productCodes
        case `public` = "isPublic"
        case ramdiskId
        case rootDeviceName
        case rootDeviceType
        case sriovNetSupport
        case state = "imageState"
        case stateReason
        case tags = "tagSet"
        case tpmSupport
        case usageOperation
        case virtualizationType
    }

    public func validate() throws {
        try stateReason?.validate()
    }
}

public struct ImageAttribute: Codable, Equatable {
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var bootMode: AttributeValue?
    public var description: AttributeValue?
    public var imageId: String?
    public var imdsSupport: AttributeValue?
    public var kernelId: AttributeValue?
    public var lastLaunchedTime: AttributeValue?
    public var launchPermissions: LaunchPermissionList?
    public var productCodes: ProductCodeList?
    public var ramdiskId: AttributeValue?
    public var sriovNetSupport: AttributeValue?
    public var tpmSupport: AttributeValue?
    public var uefiData: AttributeValue?

    public init(blockDeviceMappings: BlockDeviceMappingList? = nil,
                bootMode: AttributeValue? = nil,
                description: AttributeValue? = nil,
                imageId: String? = nil,
                imdsSupport: AttributeValue? = nil,
                kernelId: AttributeValue? = nil,
                lastLaunchedTime: AttributeValue? = nil,
                launchPermissions: LaunchPermissionList? = nil,
                productCodes: ProductCodeList? = nil,
                ramdiskId: AttributeValue? = nil,
                sriovNetSupport: AttributeValue? = nil,
                tpmSupport: AttributeValue? = nil,
                uefiData: AttributeValue? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.bootMode = bootMode
        self.description = description
        self.imageId = imageId
        self.imdsSupport = imdsSupport
        self.kernelId = kernelId
        self.lastLaunchedTime = lastLaunchedTime
        self.launchPermissions = launchPermissions
        self.productCodes = productCodes
        self.ramdiskId = ramdiskId
        self.sriovNetSupport = sriovNetSupport
        self.tpmSupport = tpmSupport
        self.uefiData = uefiData
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "blockDeviceMapping"
        case bootMode
        case description
        case imageId
        case imdsSupport
        case kernelId = "kernel"
        case lastLaunchedTime
        case launchPermissions = "launchPermission"
        case productCodes
        case ramdiskId = "ramdisk"
        case sriovNetSupport
        case tpmSupport
        case uefiData
    }

    public func validate() throws {
        try bootMode?.validate()
        try description?.validate()
        try imdsSupport?.validate()
        try kernelId?.validate()
        try lastLaunchedTime?.validate()
        try ramdiskId?.validate()
        try sriovNetSupport?.validate()
        try tpmSupport?.validate()
        try uefiData?.validate()
    }
}

public struct ImageDiskContainer: Codable, Equatable {
    public var description: String?
    public var deviceName: String?
    public var format: String?
    public var snapshotId: SnapshotId?
    public var url: String?
    public var userBucket: UserBucket?

    public init(description: String? = nil,
                deviceName: String? = nil,
                format: String? = nil,
                snapshotId: SnapshotId? = nil,
                url: String? = nil,
                userBucket: UserBucket? = nil) {
        self.description = description
        self.deviceName = deviceName
        self.format = format
        self.snapshotId = snapshotId
        self.url = url
        self.userBucket = userBucket
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case deviceName = "DeviceName"
        case format = "Format"
        case snapshotId = "SnapshotId"
        case url = "Url"
        case userBucket = "UserBucket"
    }

    public func validate() throws {
        try userBucket?.validate()
    }
}

public struct ImageRecycleBinInfo: Codable, Equatable {
    public var description: String?
    public var imageId: String?
    public var name: String?
    public var recycleBinEnterTime: MillisecondDateTime?
    public var recycleBinExitTime: MillisecondDateTime?

    public init(description: String? = nil,
                imageId: String? = nil,
                name: String? = nil,
                recycleBinEnterTime: MillisecondDateTime? = nil,
                recycleBinExitTime: MillisecondDateTime? = nil) {
        self.description = description
        self.imageId = imageId
        self.name = name
        self.recycleBinEnterTime = recycleBinEnterTime
        self.recycleBinExitTime = recycleBinExitTime
    }

    enum CodingKeys: String, CodingKey {
        case description
        case imageId
        case name
        case recycleBinEnterTime
        case recycleBinExitTime
    }

    public func validate() throws {
    }
}

public struct ImportClientVpnClientCertificateRevocationListRequest: Codable, Equatable {
    public var certificateRevocationList: String
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?

    public init(certificateRevocationList: String,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil) {
        self.certificateRevocationList = certificateRevocationList
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case certificateRevocationList = "CertificateRevocationList"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ImportClientVpnClientCertificateRevocationListResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ImportImageLicenseConfigurationRequest: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func validate() throws {
    }
}

public struct ImportImageLicenseConfigurationResponse: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn
    }

    public func validate() throws {
    }
}

public struct ImportImageRequest: Codable, Equatable {
    public var architecture: String?
    public var bootMode: BootModeValues?
    public var clientData: ClientData?
    public var clientToken: String?
    public var description: String?
    public var diskContainers: ImageDiskContainerList?
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var hypervisor: String?
    public var kmsKeyId: KmsKeyId?
    public var licenseSpecifications: ImportImageLicenseSpecificationListRequest?
    public var licenseType: String?
    public var platform: String?
    public var roleName: String?
    public var tagSpecifications: TagSpecificationList?
    public var usageOperation: String?

    public init(architecture: String? = nil,
                bootMode: BootModeValues? = nil,
                clientData: ClientData? = nil,
                clientToken: String? = nil,
                description: String? = nil,
                diskContainers: ImageDiskContainerList? = nil,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                hypervisor: String? = nil,
                kmsKeyId: KmsKeyId? = nil,
                licenseSpecifications: ImportImageLicenseSpecificationListRequest? = nil,
                licenseType: String? = nil,
                platform: String? = nil,
                roleName: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                usageOperation: String? = nil) {
        self.architecture = architecture
        self.bootMode = bootMode
        self.clientData = clientData
        self.clientToken = clientToken
        self.description = description
        self.diskContainers = diskContainers
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.hypervisor = hypervisor
        self.kmsKeyId = kmsKeyId
        self.licenseSpecifications = licenseSpecifications
        self.licenseType = licenseType
        self.platform = platform
        self.roleName = roleName
        self.tagSpecifications = tagSpecifications
        self.usageOperation = usageOperation
    }

    enum CodingKeys: String, CodingKey {
        case architecture = "Architecture"
        case bootMode = "BootMode"
        case clientData = "ClientData"
        case clientToken = "ClientToken"
        case description = "Description"
        case diskContainers = "DiskContainer"
        case dryRun = "DryRun"
        case encrypted = "Encrypted"
        case hypervisor = "Hypervisor"
        case kmsKeyId = "KmsKeyId"
        case licenseSpecifications = "LicenseSpecifications"
        case licenseType = "LicenseType"
        case platform = "Platform"
        case roleName = "RoleName"
        case tagSpecifications = "TagSpecification"
        case usageOperation = "UsageOperation"
    }

    public func validate() throws {
        try clientData?.validate()
    }
}

public struct ImportImageResult: Codable, Equatable {
    public var architecture: String?
    public var description: String?
    public var encrypted: Boolean?
    public var hypervisor: String?
    public var imageId: String?
    public var importTaskId: ImportImageTaskId?
    public var kmsKeyId: KmsKeyId?
    public var licenseSpecifications: ImportImageLicenseSpecificationListResponse?
    public var licenseType: String?
    public var platform: String?
    public var progress: String?
    public var snapshotDetails: SnapshotDetailList?
    public var status: String?
    public var statusMessage: String?
    public var tags: TagList?
    public var usageOperation: String?

    public init(architecture: String? = nil,
                description: String? = nil,
                encrypted: Boolean? = nil,
                hypervisor: String? = nil,
                imageId: String? = nil,
                importTaskId: ImportImageTaskId? = nil,
                kmsKeyId: KmsKeyId? = nil,
                licenseSpecifications: ImportImageLicenseSpecificationListResponse? = nil,
                licenseType: String? = nil,
                platform: String? = nil,
                progress: String? = nil,
                snapshotDetails: SnapshotDetailList? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil,
                usageOperation: String? = nil) {
        self.architecture = architecture
        self.description = description
        self.encrypted = encrypted
        self.hypervisor = hypervisor
        self.imageId = imageId
        self.importTaskId = importTaskId
        self.kmsKeyId = kmsKeyId
        self.licenseSpecifications = licenseSpecifications
        self.licenseType = licenseType
        self.platform = platform
        self.progress = progress
        self.snapshotDetails = snapshotDetails
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.usageOperation = usageOperation
    }

    enum CodingKeys: String, CodingKey {
        case architecture
        case description
        case encrypted
        case hypervisor
        case imageId
        case importTaskId
        case kmsKeyId
        case licenseSpecifications
        case licenseType
        case platform
        case progress
        case snapshotDetails = "snapshotDetailSet"
        case status
        case statusMessage
        case tags = "tagSet"
        case usageOperation
    }

    public func validate() throws {
    }
}

public struct ImportImageTask: Codable, Equatable {
    public var architecture: String?
    public var bootMode: BootModeValues?
    public var description: String?
    public var encrypted: Boolean?
    public var hypervisor: String?
    public var imageId: String?
    public var importTaskId: String?
    public var kmsKeyId: String?
    public var licenseSpecifications: ImportImageLicenseSpecificationListResponse?
    public var licenseType: String?
    public var platform: String?
    public var progress: String?
    public var snapshotDetails: SnapshotDetailList?
    public var status: String?
    public var statusMessage: String?
    public var tags: TagList?
    public var usageOperation: String?

    public init(architecture: String? = nil,
                bootMode: BootModeValues? = nil,
                description: String? = nil,
                encrypted: Boolean? = nil,
                hypervisor: String? = nil,
                imageId: String? = nil,
                importTaskId: String? = nil,
                kmsKeyId: String? = nil,
                licenseSpecifications: ImportImageLicenseSpecificationListResponse? = nil,
                licenseType: String? = nil,
                platform: String? = nil,
                progress: String? = nil,
                snapshotDetails: SnapshotDetailList? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil,
                usageOperation: String? = nil) {
        self.architecture = architecture
        self.bootMode = bootMode
        self.description = description
        self.encrypted = encrypted
        self.hypervisor = hypervisor
        self.imageId = imageId
        self.importTaskId = importTaskId
        self.kmsKeyId = kmsKeyId
        self.licenseSpecifications = licenseSpecifications
        self.licenseType = licenseType
        self.platform = platform
        self.progress = progress
        self.snapshotDetails = snapshotDetails
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.usageOperation = usageOperation
    }

    enum CodingKeys: String, CodingKey {
        case architecture
        case bootMode
        case description
        case encrypted
        case hypervisor
        case imageId
        case importTaskId
        case kmsKeyId
        case licenseSpecifications
        case licenseType
        case platform
        case progress
        case snapshotDetails = "snapshotDetailSet"
        case status
        case statusMessage
        case tags = "tagSet"
        case usageOperation
    }

    public func validate() throws {
    }
}

public struct ImportInstanceLaunchSpecification: Codable, Equatable {
    public var additionalInfo: String?
    public var architecture: ArchitectureValues?
    public var groupIds: SecurityGroupIdStringList?
    public var groupNames: SecurityGroupStringList?
    public var instanceInitiatedShutdownBehavior: ShutdownBehavior?
    public var instanceType: InstanceType?
    public var monitoring: Boolean?
    public var placement: Placement?
    public var privateIpAddress: String?
    public var subnetId: SubnetId?
    public var userData: UserData?

    public init(additionalInfo: String? = nil,
                architecture: ArchitectureValues? = nil,
                groupIds: SecurityGroupIdStringList? = nil,
                groupNames: SecurityGroupStringList? = nil,
                instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil,
                instanceType: InstanceType? = nil,
                monitoring: Boolean? = nil,
                placement: Placement? = nil,
                privateIpAddress: String? = nil,
                subnetId: SubnetId? = nil,
                userData: UserData? = nil) {
        self.additionalInfo = additionalInfo
        self.architecture = architecture
        self.groupIds = groupIds
        self.groupNames = groupNames
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceType = instanceType
        self.monitoring = monitoring
        self.placement = placement
        self.privateIpAddress = privateIpAddress
        self.subnetId = subnetId
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case additionalInfo
        case architecture
        case groupIds = "GroupId"
        case groupNames = "GroupName"
        case instanceInitiatedShutdownBehavior
        case instanceType
        case monitoring
        case placement
        case privateIpAddress
        case subnetId
        case userData
    }

    public func validate() throws {
        try placement?.validate()
        try userData?.validate()
    }
}

public struct ImportInstanceRequest: Codable, Equatable {
    public var description: String?
    public var diskImages: DiskImageList?
    public var dryRun: Boolean?
    public var launchSpecification: ImportInstanceLaunchSpecification?
    public var platform: PlatformValues

    public init(description: String? = nil,
                diskImages: DiskImageList? = nil,
                dryRun: Boolean? = nil,
                launchSpecification: ImportInstanceLaunchSpecification? = nil,
                platform: PlatformValues) {
        self.description = description
        self.diskImages = diskImages
        self.dryRun = dryRun
        self.launchSpecification = launchSpecification
        self.platform = platform
    }

    enum CodingKeys: String, CodingKey {
        case description
        case diskImages = "diskImage"
        case dryRun
        case launchSpecification
        case platform
    }

    public func validate() throws {
        try launchSpecification?.validate()
    }
}

public struct ImportInstanceResult: Codable, Equatable {
    public var conversionTask: ConversionTask?

    public init(conversionTask: ConversionTask? = nil) {
        self.conversionTask = conversionTask
    }

    enum CodingKeys: String, CodingKey {
        case conversionTask
    }

    public func validate() throws {
        try conversionTask?.validate()
    }
}

public struct ImportInstanceTaskDetails: Codable, Equatable {
    public var description: String?
    public var instanceId: String?
    public var platform: PlatformValues?
    public var volumes: ImportInstanceVolumeDetailSet?

    public init(description: String? = nil,
                instanceId: String? = nil,
                platform: PlatformValues? = nil,
                volumes: ImportInstanceVolumeDetailSet? = nil) {
        self.description = description
        self.instanceId = instanceId
        self.platform = platform
        self.volumes = volumes
    }

    enum CodingKeys: String, CodingKey {
        case description
        case instanceId
        case platform
        case volumes
    }

    public func validate() throws {
    }
}

public struct ImportInstanceVolumeDetailItem: Codable, Equatable {
    public var availabilityZone: String?
    public var bytesConverted: Long?
    public var description: String?
    public var image: DiskImageDescription?
    public var status: String?
    public var statusMessage: String?
    public var volume: DiskImageVolumeDescription?

    public init(availabilityZone: String? = nil,
                bytesConverted: Long? = nil,
                description: String? = nil,
                image: DiskImageDescription? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                volume: DiskImageVolumeDescription? = nil) {
        self.availabilityZone = availabilityZone
        self.bytesConverted = bytesConverted
        self.description = description
        self.image = image
        self.status = status
        self.statusMessage = statusMessage
        self.volume = volume
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case bytesConverted
        case description
        case image
        case status
        case statusMessage
        case volume
    }

    public func validate() throws {
        try image?.validate()
        try volume?.validate()
    }
}

public struct ImportKeyPairRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var keyName: String
    public var publicKeyMaterial: Blob
    public var tagSpecifications: TagSpecificationList?

    public init(dryRun: Boolean? = nil,
                keyName: String,
                publicKeyMaterial: Blob,
                tagSpecifications: TagSpecificationList? = nil) {
        self.dryRun = dryRun
        self.keyName = keyName
        self.publicKeyMaterial = publicKeyMaterial
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case keyName
        case publicKeyMaterial
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct ImportKeyPairResult: Codable, Equatable {
    public var keyFingerprint: String?
    public var keyName: String?
    public var keyPairId: String?
    public var tags: TagList?

    public init(keyFingerprint: String? = nil,
                keyName: String? = nil,
                keyPairId: String? = nil,
                tags: TagList? = nil) {
        self.keyFingerprint = keyFingerprint
        self.keyName = keyName
        self.keyPairId = keyPairId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case keyFingerprint
        case keyName
        case keyPairId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct ImportSnapshotRequest: Codable, Equatable {
    public var clientData: ClientData?
    public var clientToken: String?
    public var description: String?
    public var diskContainer: SnapshotDiskContainer?
    public var dryRun: Boolean?
    public var encrypted: Boolean?
    public var kmsKeyId: KmsKeyId?
    public var roleName: String?
    public var tagSpecifications: TagSpecificationList?

    public init(clientData: ClientData? = nil,
                clientToken: String? = nil,
                description: String? = nil,
                diskContainer: SnapshotDiskContainer? = nil,
                dryRun: Boolean? = nil,
                encrypted: Boolean? = nil,
                kmsKeyId: KmsKeyId? = nil,
                roleName: String? = nil,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientData = clientData
        self.clientToken = clientToken
        self.description = description
        self.diskContainer = diskContainer
        self.dryRun = dryRun
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.roleName = roleName
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientData = "ClientData"
        case clientToken = "ClientToken"
        case description = "Description"
        case diskContainer = "DiskContainer"
        case dryRun = "DryRun"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case roleName = "RoleName"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
        try clientData?.validate()
        try diskContainer?.validate()
    }
}

public struct ImportSnapshotResult: Codable, Equatable {
    public var description: String?
    public var importTaskId: String?
    public var snapshotTaskDetail: SnapshotTaskDetail?
    public var tags: TagList?

    public init(description: String? = nil,
                importTaskId: String? = nil,
                snapshotTaskDetail: SnapshotTaskDetail? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.importTaskId = importTaskId
        self.snapshotTaskDetail = snapshotTaskDetail
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case importTaskId
        case snapshotTaskDetail
        case tags = "tagSet"
    }

    public func validate() throws {
        try snapshotTaskDetail?.validate()
    }
}

public struct ImportSnapshotTask: Codable, Equatable {
    public var description: String?
    public var importTaskId: String?
    public var snapshotTaskDetail: SnapshotTaskDetail?
    public var tags: TagList?

    public init(description: String? = nil,
                importTaskId: String? = nil,
                snapshotTaskDetail: SnapshotTaskDetail? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.importTaskId = importTaskId
        self.snapshotTaskDetail = snapshotTaskDetail
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case importTaskId
        case snapshotTaskDetail
        case tags = "tagSet"
    }

    public func validate() throws {
        try snapshotTaskDetail?.validate()
    }
}

public struct ImportVolumeRequest: Codable, Equatable {
    public var availabilityZone: String
    public var description: String?
    public var dryRun: Boolean?
    public var image: DiskImageDetail
    public var volume: VolumeDetail

    public init(availabilityZone: String,
                description: String? = nil,
                dryRun: Boolean? = nil,
                image: DiskImageDetail,
                volume: VolumeDetail) {
        self.availabilityZone = availabilityZone
        self.description = description
        self.dryRun = dryRun
        self.image = image
        self.volume = volume
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case description
        case dryRun
        case image
        case volume
    }

    public func validate() throws {
        try image.validate()
        try volume.validate()
    }
}

public struct ImportVolumeResult: Codable, Equatable {
    public var conversionTask: ConversionTask?

    public init(conversionTask: ConversionTask? = nil) {
        self.conversionTask = conversionTask
    }

    enum CodingKeys: String, CodingKey {
        case conversionTask
    }

    public func validate() throws {
        try conversionTask?.validate()
    }
}

public struct ImportVolumeTaskDetails: Codable, Equatable {
    public var availabilityZone: String?
    public var bytesConverted: Long?
    public var description: String?
    public var image: DiskImageDescription?
    public var volume: DiskImageVolumeDescription?

    public init(availabilityZone: String? = nil,
                bytesConverted: Long? = nil,
                description: String? = nil,
                image: DiskImageDescription? = nil,
                volume: DiskImageVolumeDescription? = nil) {
        self.availabilityZone = availabilityZone
        self.bytesConverted = bytesConverted
        self.description = description
        self.image = image
        self.volume = volume
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case bytesConverted
        case description
        case image
        case volume
    }

    public func validate() throws {
        try image?.validate()
        try volume?.validate()
    }
}

public struct InferenceAcceleratorInfo: Codable, Equatable {
    public var accelerators: InferenceDeviceInfoList?

    public init(accelerators: InferenceDeviceInfoList? = nil) {
        self.accelerators = accelerators
    }

    enum CodingKeys: String, CodingKey {
        case accelerators
    }

    public func validate() throws {
    }
}

public struct InferenceDeviceInfo: Codable, Equatable {
    public var count: InferenceDeviceCount?
    public var manufacturer: InferenceDeviceManufacturerName?
    public var name: InferenceDeviceName?

    public init(count: InferenceDeviceCount? = nil,
                manufacturer: InferenceDeviceManufacturerName? = nil,
                name: InferenceDeviceName? = nil) {
        self.count = count
        self.manufacturer = manufacturer
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case count
        case manufacturer
        case name
    }

    public func validate() throws {
    }
}

public struct Instance: Codable, Equatable {
    public var amiLaunchIndex: Integer?
    public var architecture: ArchitectureValues?
    public var blockDeviceMappings: InstanceBlockDeviceMappingList?
    public var bootMode: BootModeValues?
    public var capacityReservationId: String?
    public var capacityReservationSpecification: CapacityReservationSpecificationResponse?
    public var clientToken: String?
    public var cpuOptions: CpuOptions?
    public var ebsOptimized: Boolean?
    public var elasticGpuAssociations: ElasticGpuAssociationList?
    public var elasticInferenceAcceleratorAssociations: ElasticInferenceAcceleratorAssociationList?
    public var enaSupport: Boolean?
    public var enclaveOptions: EnclaveOptions?
    public var hibernationOptions: HibernationOptions?
    public var hypervisor: HypervisorType?
    public var iamInstanceProfile: IamInstanceProfile?
    public var imageId: String?
    public var instanceId: String?
    public var instanceLifecycle: InstanceLifecycleType?
    public var instanceType: InstanceType?
    public var ipv6Address: String?
    public var kernelId: String?
    public var keyName: String?
    public var launchTime: DateTime?
    public var licenses: LicenseList?
    public var maintenanceOptions: InstanceMaintenanceOptions?
    public var metadataOptions: InstanceMetadataOptionsResponse?
    public var monitoring: Monitoring?
    public var networkInterfaces: InstanceNetworkInterfaceList?
    public var outpostArn: String?
    public var placement: Placement?
    public var platform: PlatformValues?
    public var platformDetails: String?
    public var privateDnsName: String?
    public var privateDnsNameOptions: PrivateDnsNameOptionsResponse?
    public var privateIpAddress: String?
    public var productCodes: ProductCodeList?
    public var publicDnsName: String?
    public var publicIpAddress: String?
    public var ramdiskId: String?
    public var rootDeviceName: String?
    public var rootDeviceType: DeviceType?
    public var securityGroups: GroupIdentifierList?
    public var sourceDestCheck: Boolean?
    public var spotInstanceRequestId: String?
    public var sriovNetSupport: String?
    public var state: InstanceState?
    public var stateReason: StateReason?
    public var stateTransitionReason: String?
    public var subnetId: String?
    public var tags: TagList?
    public var tpmSupport: String?
    public var usageOperation: String?
    public var usageOperationUpdateTime: MillisecondDateTime?
    public var virtualizationType: VirtualizationType?
    public var vpcId: String?

    public init(amiLaunchIndex: Integer? = nil,
                architecture: ArchitectureValues? = nil,
                blockDeviceMappings: InstanceBlockDeviceMappingList? = nil,
                bootMode: BootModeValues? = nil,
                capacityReservationId: String? = nil,
                capacityReservationSpecification: CapacityReservationSpecificationResponse? = nil,
                clientToken: String? = nil,
                cpuOptions: CpuOptions? = nil,
                ebsOptimized: Boolean? = nil,
                elasticGpuAssociations: ElasticGpuAssociationList? = nil,
                elasticInferenceAcceleratorAssociations: ElasticInferenceAcceleratorAssociationList? = nil,
                enaSupport: Boolean? = nil,
                enclaveOptions: EnclaveOptions? = nil,
                hibernationOptions: HibernationOptions? = nil,
                hypervisor: HypervisorType? = nil,
                iamInstanceProfile: IamInstanceProfile? = nil,
                imageId: String? = nil,
                instanceId: String? = nil,
                instanceLifecycle: InstanceLifecycleType? = nil,
                instanceType: InstanceType? = nil,
                ipv6Address: String? = nil,
                kernelId: String? = nil,
                keyName: String? = nil,
                launchTime: DateTime? = nil,
                licenses: LicenseList? = nil,
                maintenanceOptions: InstanceMaintenanceOptions? = nil,
                metadataOptions: InstanceMetadataOptionsResponse? = nil,
                monitoring: Monitoring? = nil,
                networkInterfaces: InstanceNetworkInterfaceList? = nil,
                outpostArn: String? = nil,
                placement: Placement? = nil,
                platform: PlatformValues? = nil,
                platformDetails: String? = nil,
                privateDnsName: String? = nil,
                privateDnsNameOptions: PrivateDnsNameOptionsResponse? = nil,
                privateIpAddress: String? = nil,
                productCodes: ProductCodeList? = nil,
                publicDnsName: String? = nil,
                publicIpAddress: String? = nil,
                ramdiskId: String? = nil,
                rootDeviceName: String? = nil,
                rootDeviceType: DeviceType? = nil,
                securityGroups: GroupIdentifierList? = nil,
                sourceDestCheck: Boolean? = nil,
                spotInstanceRequestId: String? = nil,
                sriovNetSupport: String? = nil,
                state: InstanceState? = nil,
                stateReason: StateReason? = nil,
                stateTransitionReason: String? = nil,
                subnetId: String? = nil,
                tags: TagList? = nil,
                tpmSupport: String? = nil,
                usageOperation: String? = nil,
                usageOperationUpdateTime: MillisecondDateTime? = nil,
                virtualizationType: VirtualizationType? = nil,
                vpcId: String? = nil) {
        self.amiLaunchIndex = amiLaunchIndex
        self.architecture = architecture
        self.blockDeviceMappings = blockDeviceMappings
        self.bootMode = bootMode
        self.capacityReservationId = capacityReservationId
        self.capacityReservationSpecification = capacityReservationSpecification
        self.clientToken = clientToken
        self.cpuOptions = cpuOptions
        self.ebsOptimized = ebsOptimized
        self.elasticGpuAssociations = elasticGpuAssociations
        self.elasticInferenceAcceleratorAssociations = elasticInferenceAcceleratorAssociations
        self.enaSupport = enaSupport
        self.enclaveOptions = enclaveOptions
        self.hibernationOptions = hibernationOptions
        self.hypervisor = hypervisor
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceId = instanceId
        self.instanceLifecycle = instanceLifecycle
        self.instanceType = instanceType
        self.ipv6Address = ipv6Address
        self.kernelId = kernelId
        self.keyName = keyName
        self.launchTime = launchTime
        self.licenses = licenses
        self.maintenanceOptions = maintenanceOptions
        self.metadataOptions = metadataOptions
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.outpostArn = outpostArn
        self.placement = placement
        self.platform = platform
        self.platformDetails = platformDetails
        self.privateDnsName = privateDnsName
        self.privateDnsNameOptions = privateDnsNameOptions
        self.privateIpAddress = privateIpAddress
        self.productCodes = productCodes
        self.publicDnsName = publicDnsName
        self.publicIpAddress = publicIpAddress
        self.ramdiskId = ramdiskId
        self.rootDeviceName = rootDeviceName
        self.rootDeviceType = rootDeviceType
        self.securityGroups = securityGroups
        self.sourceDestCheck = sourceDestCheck
        self.spotInstanceRequestId = spotInstanceRequestId
        self.sriovNetSupport = sriovNetSupport
        self.state = state
        self.stateReason = stateReason
        self.stateTransitionReason = stateTransitionReason
        self.subnetId = subnetId
        self.tags = tags
        self.tpmSupport = tpmSupport
        self.usageOperation = usageOperation
        self.usageOperationUpdateTime = usageOperationUpdateTime
        self.virtualizationType = virtualizationType
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case amiLaunchIndex
        case architecture
        case blockDeviceMappings = "blockDeviceMapping"
        case bootMode
        case capacityReservationId
        case capacityReservationSpecification
        case clientToken
        case cpuOptions
        case ebsOptimized
        case elasticGpuAssociations = "elasticGpuAssociationSet"
        case elasticInferenceAcceleratorAssociations = "elasticInferenceAcceleratorAssociationSet"
        case enaSupport
        case enclaveOptions
        case hibernationOptions
        case hypervisor
        case iamInstanceProfile
        case imageId
        case instanceId
        case instanceLifecycle
        case instanceType
        case ipv6Address
        case kernelId
        case keyName
        case launchTime
        case licenses = "licenseSet"
        case maintenanceOptions
        case metadataOptions
        case monitoring
        case networkInterfaces = "networkInterfaceSet"
        case outpostArn
        case placement
        case platform
        case platformDetails
        case privateDnsName
        case privateDnsNameOptions
        case privateIpAddress
        case productCodes
        case publicDnsName = "dnsName"
        case publicIpAddress = "ipAddress"
        case ramdiskId
        case rootDeviceName
        case rootDeviceType
        case securityGroups = "groupSet"
        case sourceDestCheck
        case spotInstanceRequestId
        case sriovNetSupport
        case state = "instanceState"
        case stateReason
        case stateTransitionReason = "reason"
        case subnetId
        case tags = "tagSet"
        case tpmSupport
        case usageOperation
        case usageOperationUpdateTime
        case virtualizationType
        case vpcId
    }

    public func validate() throws {
        try capacityReservationSpecification?.validate()
        try cpuOptions?.validate()
        try enclaveOptions?.validate()
        try hibernationOptions?.validate()
        try iamInstanceProfile?.validate()
        try maintenanceOptions?.validate()
        try metadataOptions?.validate()
        try monitoring?.validate()
        try placement?.validate()
        try privateDnsNameOptions?.validate()
        try state?.validate()
        try stateReason?.validate()
    }
}

public struct InstanceAttribute: Codable, Equatable {
    public var blockDeviceMappings: InstanceBlockDeviceMappingList?
    public var disableApiStop: AttributeBooleanValue?
    public var disableApiTermination: AttributeBooleanValue?
    public var ebsOptimized: AttributeBooleanValue?
    public var enaSupport: AttributeBooleanValue?
    public var enclaveOptions: EnclaveOptions?
    public var groups: GroupIdentifierList?
    public var instanceId: String?
    public var instanceInitiatedShutdownBehavior: AttributeValue?
    public var instanceType: AttributeValue?
    public var kernelId: AttributeValue?
    public var productCodes: ProductCodeList?
    public var ramdiskId: AttributeValue?
    public var rootDeviceName: AttributeValue?
    public var sourceDestCheck: AttributeBooleanValue?
    public var sriovNetSupport: AttributeValue?
    public var userData: AttributeValue?

    public init(blockDeviceMappings: InstanceBlockDeviceMappingList? = nil,
                disableApiStop: AttributeBooleanValue? = nil,
                disableApiTermination: AttributeBooleanValue? = nil,
                ebsOptimized: AttributeBooleanValue? = nil,
                enaSupport: AttributeBooleanValue? = nil,
                enclaveOptions: EnclaveOptions? = nil,
                groups: GroupIdentifierList? = nil,
                instanceId: String? = nil,
                instanceInitiatedShutdownBehavior: AttributeValue? = nil,
                instanceType: AttributeValue? = nil,
                kernelId: AttributeValue? = nil,
                productCodes: ProductCodeList? = nil,
                ramdiskId: AttributeValue? = nil,
                rootDeviceName: AttributeValue? = nil,
                sourceDestCheck: AttributeBooleanValue? = nil,
                sriovNetSupport: AttributeValue? = nil,
                userData: AttributeValue? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.disableApiStop = disableApiStop
        self.disableApiTermination = disableApiTermination
        self.ebsOptimized = ebsOptimized
        self.enaSupport = enaSupport
        self.enclaveOptions = enclaveOptions
        self.groups = groups
        self.instanceId = instanceId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.productCodes = productCodes
        self.ramdiskId = ramdiskId
        self.rootDeviceName = rootDeviceName
        self.sourceDestCheck = sourceDestCheck
        self.sriovNetSupport = sriovNetSupport
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "blockDeviceMapping"
        case disableApiStop
        case disableApiTermination
        case ebsOptimized
        case enaSupport
        case enclaveOptions
        case groups = "groupSet"
        case instanceId
        case instanceInitiatedShutdownBehavior
        case instanceType
        case kernelId = "kernel"
        case productCodes
        case ramdiskId = "ramdisk"
        case rootDeviceName
        case sourceDestCheck
        case sriovNetSupport
        case userData
    }

    public func validate() throws {
        try disableApiStop?.validate()
        try disableApiTermination?.validate()
        try ebsOptimized?.validate()
        try enaSupport?.validate()
        try enclaveOptions?.validate()
        try instanceInitiatedShutdownBehavior?.validate()
        try instanceType?.validate()
        try kernelId?.validate()
        try ramdiskId?.validate()
        try rootDeviceName?.validate()
        try sourceDestCheck?.validate()
        try sriovNetSupport?.validate()
        try userData?.validate()
    }
}

public struct InstanceBlockDeviceMapping: Codable, Equatable {
    public var deviceName: String?
    public var ebs: EbsInstanceBlockDevice?

    public init(deviceName: String? = nil,
                ebs: EbsInstanceBlockDevice? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
    }

    enum CodingKeys: String, CodingKey {
        case deviceName
        case ebs
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct InstanceBlockDeviceMappingSpecification: Codable, Equatable {
    public var deviceName: String?
    public var ebs: EbsInstanceBlockDeviceSpecification?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: EbsInstanceBlockDeviceSpecification? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct InstanceCapacity: Codable, Equatable {
    public var availableCapacity: Integer?
    public var instanceType: String?
    public var totalCapacity: Integer?

    public init(availableCapacity: Integer? = nil,
                instanceType: String? = nil,
                totalCapacity: Integer? = nil) {
        self.availableCapacity = availableCapacity
        self.instanceType = instanceType
        self.totalCapacity = totalCapacity
    }

    enum CodingKeys: String, CodingKey {
        case availableCapacity
        case instanceType
        case totalCapacity
    }

    public func validate() throws {
    }
}

public struct InstanceCount: Codable, Equatable {
    public var instanceCount: Integer?
    public var state: ListingState?

    public init(instanceCount: Integer? = nil,
                state: ListingState? = nil) {
        self.instanceCount = instanceCount
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case instanceCount
        case state
    }

    public func validate() throws {
    }
}

public struct InstanceCreditSpecification: Codable, Equatable {
    public var cpuCredits: String?
    public var instanceId: String?

    public init(cpuCredits: String? = nil,
                instanceId: String? = nil) {
        self.cpuCredits = cpuCredits
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits
        case instanceId
    }

    public func validate() throws {
    }
}

public struct InstanceCreditSpecificationRequest: Codable, Equatable {
    public var cpuCredits: String?
    public var instanceId: InstanceId?

    public init(cpuCredits: String? = nil,
                instanceId: InstanceId? = nil) {
        self.cpuCredits = cpuCredits
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits = "CpuCredits"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct InstanceEventWindow: Codable, Equatable {
    public var associationTarget: InstanceEventWindowAssociationTarget?
    public var cronExpression: InstanceEventWindowCronExpression?
    public var instanceEventWindowId: InstanceEventWindowId?
    public var name: String?
    public var state: InstanceEventWindowState?
    public var tags: TagList?
    public var timeRanges: InstanceEventWindowTimeRangeList?

    public init(associationTarget: InstanceEventWindowAssociationTarget? = nil,
                cronExpression: InstanceEventWindowCronExpression? = nil,
                instanceEventWindowId: InstanceEventWindowId? = nil,
                name: String? = nil,
                state: InstanceEventWindowState? = nil,
                tags: TagList? = nil,
                timeRanges: InstanceEventWindowTimeRangeList? = nil) {
        self.associationTarget = associationTarget
        self.cronExpression = cronExpression
        self.instanceEventWindowId = instanceEventWindowId
        self.name = name
        self.state = state
        self.tags = tags
        self.timeRanges = timeRanges
    }

    enum CodingKeys: String, CodingKey {
        case associationTarget
        case cronExpression
        case instanceEventWindowId
        case name
        case state
        case tags = "tagSet"
        case timeRanges = "timeRangeSet"
    }

    public func validate() throws {
        try associationTarget?.validate()
    }
}

public struct InstanceEventWindowAssociationRequest: Codable, Equatable {
    public var dedicatedHostIds: DedicatedHostIdList?
    public var instanceIds: InstanceIdList?
    public var instanceTags: TagList?

    public init(dedicatedHostIds: DedicatedHostIdList? = nil,
                instanceIds: InstanceIdList? = nil,
                instanceTags: TagList? = nil) {
        self.dedicatedHostIds = dedicatedHostIds
        self.instanceIds = instanceIds
        self.instanceTags = instanceTags
    }

    enum CodingKeys: String, CodingKey {
        case dedicatedHostIds = "DedicatedHostId"
        case instanceIds = "InstanceId"
        case instanceTags = "InstanceTag"
    }

    public func validate() throws {
    }
}

public struct InstanceEventWindowAssociationTarget: Codable, Equatable {
    public var dedicatedHostIds: DedicatedHostIdList?
    public var instanceIds: InstanceIdList?
    public var tags: TagList?

    public init(dedicatedHostIds: DedicatedHostIdList? = nil,
                instanceIds: InstanceIdList? = nil,
                tags: TagList? = nil) {
        self.dedicatedHostIds = dedicatedHostIds
        self.instanceIds = instanceIds
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case dedicatedHostIds = "dedicatedHostIdSet"
        case instanceIds = "instanceIdSet"
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct InstanceEventWindowDisassociationRequest: Codable, Equatable {
    public var dedicatedHostIds: DedicatedHostIdList?
    public var instanceIds: InstanceIdList?
    public var instanceTags: TagList?

    public init(dedicatedHostIds: DedicatedHostIdList? = nil,
                instanceIds: InstanceIdList? = nil,
                instanceTags: TagList? = nil) {
        self.dedicatedHostIds = dedicatedHostIds
        self.instanceIds = instanceIds
        self.instanceTags = instanceTags
    }

    enum CodingKeys: String, CodingKey {
        case dedicatedHostIds = "DedicatedHostId"
        case instanceIds = "InstanceId"
        case instanceTags = "InstanceTag"
    }

    public func validate() throws {
    }
}

public struct InstanceEventWindowStateChange: Codable, Equatable {
    public var instanceEventWindowId: InstanceEventWindowId?
    public var state: InstanceEventWindowState?

    public init(instanceEventWindowId: InstanceEventWindowId? = nil,
                state: InstanceEventWindowState? = nil) {
        self.instanceEventWindowId = instanceEventWindowId
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case instanceEventWindowId
        case state
    }

    public func validate() throws {
    }
}

public struct InstanceEventWindowTimeRange: Codable, Equatable {
    public var endHour: Hour?
    public var endWeekDay: WeekDay?
    public var startHour: Hour?
    public var startWeekDay: WeekDay?

    public init(endHour: Hour? = nil,
                endWeekDay: WeekDay? = nil,
                startHour: Hour? = nil,
                startWeekDay: WeekDay? = nil) {
        self.endHour = endHour
        self.endWeekDay = endWeekDay
        self.startHour = startHour
        self.startWeekDay = startWeekDay
    }

    enum CodingKeys: String, CodingKey {
        case endHour
        case endWeekDay
        case startHour
        case startWeekDay
    }

    public func validate() throws {
        try endHour?.validateAsHour()
        try startHour?.validateAsHour()
    }
}

public struct InstanceEventWindowTimeRangeRequest: Codable, Equatable {
    public var endHour: Hour?
    public var endWeekDay: WeekDay?
    public var startHour: Hour?
    public var startWeekDay: WeekDay?

    public init(endHour: Hour? = nil,
                endWeekDay: WeekDay? = nil,
                startHour: Hour? = nil,
                startWeekDay: WeekDay? = nil) {
        self.endHour = endHour
        self.endWeekDay = endWeekDay
        self.startHour = startHour
        self.startWeekDay = startWeekDay
    }

    enum CodingKeys: String, CodingKey {
        case endHour = "EndHour"
        case endWeekDay = "EndWeekDay"
        case startHour = "StartHour"
        case startWeekDay = "StartWeekDay"
    }

    public func validate() throws {
        try endHour?.validateAsHour()
        try startHour?.validateAsHour()
    }
}

public struct InstanceExportDetails: Codable, Equatable {
    public var instanceId: String?
    public var targetEnvironment: ExportEnvironment?

    public init(instanceId: String? = nil,
                targetEnvironment: ExportEnvironment? = nil) {
        self.instanceId = instanceId
        self.targetEnvironment = targetEnvironment
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case targetEnvironment
    }

    public func validate() throws {
    }
}

public struct InstanceFamilyCreditSpecification: Codable, Equatable {
    public var cpuCredits: String?
    public var instanceFamily: UnlimitedSupportedInstanceFamily?

    public init(cpuCredits: String? = nil,
                instanceFamily: UnlimitedSupportedInstanceFamily? = nil) {
        self.cpuCredits = cpuCredits
        self.instanceFamily = instanceFamily
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits
        case instanceFamily
    }

    public func validate() throws {
    }
}

public struct InstanceIpv4Prefix: Codable, Equatable {
    public var ipv4Prefix: String?

    public init(ipv4Prefix: String? = nil) {
        self.ipv4Prefix = ipv4Prefix
    }

    enum CodingKeys: String, CodingKey {
        case ipv4Prefix
    }

    public func validate() throws {
    }
}

public struct InstanceIpv6Address: Codable, Equatable {
    public var ipv6Address: String?

    public init(ipv6Address: String? = nil) {
        self.ipv6Address = ipv6Address
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Address
    }

    public func validate() throws {
    }
}

public struct InstanceIpv6AddressRequest: Codable, Equatable {
    public var ipv6Address: String?

    public init(ipv6Address: String? = nil) {
        self.ipv6Address = ipv6Address
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Address = "Ipv6Address"
    }

    public func validate() throws {
    }
}

public struct InstanceIpv6Prefix: Codable, Equatable {
    public var ipv6Prefix: String?

    public init(ipv6Prefix: String? = nil) {
        self.ipv6Prefix = ipv6Prefix
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Prefix
    }

    public func validate() throws {
    }
}

public struct InstanceMaintenanceOptions: Codable, Equatable {
    public var autoRecovery: InstanceAutoRecoveryState?

    public init(autoRecovery: InstanceAutoRecoveryState? = nil) {
        self.autoRecovery = autoRecovery
    }

    enum CodingKeys: String, CodingKey {
        case autoRecovery
    }

    public func validate() throws {
    }
}

public struct InstanceMaintenanceOptionsRequest: Codable, Equatable {
    public var autoRecovery: InstanceAutoRecoveryState?

    public init(autoRecovery: InstanceAutoRecoveryState? = nil) {
        self.autoRecovery = autoRecovery
    }

    enum CodingKeys: String, CodingKey {
        case autoRecovery = "AutoRecovery"
    }

    public func validate() throws {
    }
}

public struct InstanceMarketOptionsRequest: Codable, Equatable {
    public var marketType: MarketType?
    public var spotOptions: SpotMarketOptions?

    public init(marketType: MarketType? = nil,
                spotOptions: SpotMarketOptions? = nil) {
        self.marketType = marketType
        self.spotOptions = spotOptions
    }

    enum CodingKeys: String, CodingKey {
        case marketType = "MarketType"
        case spotOptions = "SpotOptions"
    }

    public func validate() throws {
        try spotOptions?.validate()
    }
}

public struct InstanceMetadataOptionsRequest: Codable, Equatable {
    public var httpEndpoint: InstanceMetadataEndpointState?
    public var httpProtocolIpv6: InstanceMetadataProtocolState?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: HttpTokensState?
    public var instanceMetadataTags: InstanceMetadataTagsState?

    public init(httpEndpoint: InstanceMetadataEndpointState? = nil,
                httpProtocolIpv6: InstanceMetadataProtocolState? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: HttpTokensState? = nil,
                instanceMetadataTags: InstanceMetadataTagsState? = nil) {
        self.httpEndpoint = httpEndpoint
        self.httpProtocolIpv6 = httpProtocolIpv6
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
        self.instanceMetadataTags = instanceMetadataTags
    }

    enum CodingKeys: String, CodingKey {
        case httpEndpoint = "HttpEndpoint"
        case httpProtocolIpv6 = "HttpProtocolIpv6"
        case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
        case httpTokens = "HttpTokens"
        case instanceMetadataTags = "InstanceMetadataTags"
    }

    public func validate() throws {
    }
}

public struct InstanceMetadataOptionsResponse: Codable, Equatable {
    public var httpEndpoint: InstanceMetadataEndpointState?
    public var httpProtocolIpv6: InstanceMetadataProtocolState?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: HttpTokensState?
    public var instanceMetadataTags: InstanceMetadataTagsState?
    public var state: InstanceMetadataOptionsState?

    public init(httpEndpoint: InstanceMetadataEndpointState? = nil,
                httpProtocolIpv6: InstanceMetadataProtocolState? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: HttpTokensState? = nil,
                instanceMetadataTags: InstanceMetadataTagsState? = nil,
                state: InstanceMetadataOptionsState? = nil) {
        self.httpEndpoint = httpEndpoint
        self.httpProtocolIpv6 = httpProtocolIpv6
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
        self.instanceMetadataTags = instanceMetadataTags
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case httpEndpoint
        case httpProtocolIpv6
        case httpPutResponseHopLimit
        case httpTokens
        case instanceMetadataTags
        case state
    }

    public func validate() throws {
    }
}

public struct InstanceMonitoring: Codable, Equatable {
    public var instanceId: String?
    public var monitoring: Monitoring?

    public init(instanceId: String? = nil,
                monitoring: Monitoring? = nil) {
        self.instanceId = instanceId
        self.monitoring = monitoring
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case monitoring
    }

    public func validate() throws {
        try monitoring?.validate()
    }
}

public struct InstanceNetworkInterface: Codable, Equatable {
    public var association: InstanceNetworkInterfaceAssociation?
    public var attachment: InstanceNetworkInterfaceAttachment?
    public var description: String?
    public var groups: GroupIdentifierList?
    public var interfaceType: String?
    public var ipv4Prefixes: InstanceIpv4PrefixList?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var ipv6Prefixes: InstanceIpv6PrefixList?
    public var macAddress: String?
    public var networkInterfaceId: String?
    public var ownerId: String?
    public var privateDnsName: String?
    public var privateIpAddress: String?
    public var privateIpAddresses: InstancePrivateIpAddressList?
    public var sourceDestCheck: Boolean?
    public var status: NetworkInterfaceStatus?
    public var subnetId: String?
    public var vpcId: String?

    public init(association: InstanceNetworkInterfaceAssociation? = nil,
                attachment: InstanceNetworkInterfaceAttachment? = nil,
                description: String? = nil,
                groups: GroupIdentifierList? = nil,
                interfaceType: String? = nil,
                ipv4Prefixes: InstanceIpv4PrefixList? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                ipv6Prefixes: InstanceIpv6PrefixList? = nil,
                macAddress: String? = nil,
                networkInterfaceId: String? = nil,
                ownerId: String? = nil,
                privateDnsName: String? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: InstancePrivateIpAddressList? = nil,
                sourceDestCheck: Boolean? = nil,
                status: NetworkInterfaceStatus? = nil,
                subnetId: String? = nil,
                vpcId: String? = nil) {
        self.association = association
        self.attachment = attachment
        self.description = description
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv4Prefixes = ipv4Prefixes
        self.ipv6Addresses = ipv6Addresses
        self.ipv6Prefixes = ipv6Prefixes
        self.macAddress = macAddress
        self.networkInterfaceId = networkInterfaceId
        self.ownerId = ownerId
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.sourceDestCheck = sourceDestCheck
        self.status = status
        self.subnetId = subnetId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case association
        case attachment
        case description
        case groups = "groupSet"
        case interfaceType
        case ipv4Prefixes = "ipv4PrefixSet"
        case ipv6Addresses = "ipv6AddressesSet"
        case ipv6Prefixes = "ipv6PrefixSet"
        case macAddress
        case networkInterfaceId
        case ownerId
        case privateDnsName
        case privateIpAddress
        case privateIpAddresses = "privateIpAddressesSet"
        case sourceDestCheck
        case status
        case subnetId
        case vpcId
    }

    public func validate() throws {
        try association?.validate()
        try attachment?.validate()
    }
}

public struct InstanceNetworkInterfaceAssociation: Codable, Equatable {
    public var carrierIp: String?
    public var customerOwnedIp: String?
    public var ipOwnerId: String?
    public var publicDnsName: String?
    public var publicIp: String?

    public init(carrierIp: String? = nil,
                customerOwnedIp: String? = nil,
                ipOwnerId: String? = nil,
                publicDnsName: String? = nil,
                publicIp: String? = nil) {
        self.carrierIp = carrierIp
        self.customerOwnedIp = customerOwnedIp
        self.ipOwnerId = ipOwnerId
        self.publicDnsName = publicDnsName
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case carrierIp
        case customerOwnedIp
        case ipOwnerId
        case publicDnsName
        case publicIp
    }

    public func validate() throws {
    }
}

public struct InstanceNetworkInterfaceAttachment: Codable, Equatable {
    public var attachTime: DateTime?
    public var attachmentId: String?
    public var deleteOnTermination: Boolean?
    public var deviceIndex: Integer?
    public var networkCardIndex: Integer?
    public var status: AttachmentStatus?

    public init(attachTime: DateTime? = nil,
                attachmentId: String? = nil,
                deleteOnTermination: Boolean? = nil,
                deviceIndex: Integer? = nil,
                networkCardIndex: Integer? = nil,
                status: AttachmentStatus? = nil) {
        self.attachTime = attachTime
        self.attachmentId = attachmentId
        self.deleteOnTermination = deleteOnTermination
        self.deviceIndex = deviceIndex
        self.networkCardIndex = networkCardIndex
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case attachTime
        case attachmentId
        case deleteOnTermination
        case deviceIndex
        case networkCardIndex
        case status
    }

    public func validate() throws {
    }
}

public struct InstanceNetworkInterfaceSpecification: Codable, Equatable {
    public var associateCarrierIpAddress: Boolean?
    public var associatePublicIpAddress: Boolean?
    public var deleteOnTermination: Boolean?
    public var description: String?
    public var deviceIndex: Integer?
    public var groups: SecurityGroupIdStringList?
    public var interfaceType: String?
    public var ipv4PrefixCount: Integer?
    public var ipv4Prefixes: Ipv4PrefixList?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var ipv6PrefixCount: Integer?
    public var ipv6Prefixes: Ipv6PrefixList?
    public var networkCardIndex: Integer?
    public var networkInterfaceId: NetworkInterfaceId?
    public var privateIpAddress: String?
    public var privateIpAddresses: PrivateIpAddressSpecificationList?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: String?

    public init(associateCarrierIpAddress: Boolean? = nil,
                associatePublicIpAddress: Boolean? = nil,
                deleteOnTermination: Boolean? = nil,
                description: String? = nil,
                deviceIndex: Integer? = nil,
                groups: SecurityGroupIdStringList? = nil,
                interfaceType: String? = nil,
                ipv4PrefixCount: Integer? = nil,
                ipv4Prefixes: Ipv4PrefixList? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                ipv6PrefixCount: Integer? = nil,
                ipv6Prefixes: Ipv6PrefixList? = nil,
                networkCardIndex: Integer? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: PrivateIpAddressSpecificationList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: String? = nil) {
        self.associateCarrierIpAddress = associateCarrierIpAddress
        self.associatePublicIpAddress = associatePublicIpAddress
        self.deleteOnTermination = deleteOnTermination
        self.description = description
        self.deviceIndex = deviceIndex
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv4PrefixCount = ipv4PrefixCount
        self.ipv4Prefixes = ipv4Prefixes
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.ipv6PrefixCount = ipv6PrefixCount
        self.ipv6Prefixes = ipv6Prefixes
        self.networkCardIndex = networkCardIndex
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associateCarrierIpAddress = "AssociateCarrierIpAddress"
        case associatePublicIpAddress
        case deleteOnTermination
        case description
        case deviceIndex
        case groups = "SecurityGroupId"
        case interfaceType = "InterfaceType"
        case ipv4PrefixCount = "Ipv4PrefixCount"
        case ipv4Prefixes = "Ipv4Prefix"
        case ipv6AddressCount
        case ipv6Addresses = "ipv6AddressesSet"
        case ipv6PrefixCount = "Ipv6PrefixCount"
        case ipv6Prefixes = "Ipv6Prefix"
        case networkCardIndex = "NetworkCardIndex"
        case networkInterfaceId
        case privateIpAddress
        case privateIpAddresses = "privateIpAddressesSet"
        case secondaryPrivateIpAddressCount
        case subnetId
    }

    public func validate() throws {
    }
}

public struct InstancePrivateIpAddress: Codable, Equatable {
    public var association: InstanceNetworkInterfaceAssociation?
    public var primary: Boolean?
    public var privateDnsName: String?
    public var privateIpAddress: String?

    public init(association: InstanceNetworkInterfaceAssociation? = nil,
                primary: Boolean? = nil,
                privateDnsName: String? = nil,
                privateIpAddress: String? = nil) {
        self.association = association
        self.primary = primary
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case association
        case primary
        case privateDnsName
        case privateIpAddress
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct InstanceRequirements: Codable, Equatable {
    public var acceleratorCount: AcceleratorCount?
    public var acceleratorManufacturers: AcceleratorManufacturerSet?
    public var acceleratorNames: AcceleratorNameSet?
    public var acceleratorTotalMemoryMiB: AcceleratorTotalMemoryMiB?
    public var acceleratorTypes: AcceleratorTypeSet?
    public var allowedInstanceTypes: AllowedInstanceTypeSet?
    public var bareMetal: BareMetal?
    public var baselineEbsBandwidthMbps: BaselineEbsBandwidthMbps?
    public var burstablePerformance: BurstablePerformance?
    public var cpuManufacturers: CpuManufacturerSet?
    public var excludedInstanceTypes: ExcludedInstanceTypeSet?
    public var instanceGenerations: InstanceGenerationSet?
    public var localStorage: LocalStorage?
    public var localStorageTypes: LocalStorageTypeSet?
    public var memoryGiBPerVCpu: MemoryGiBPerVCpu?
    public var memoryMiB: MemoryMiB?
    public var networkBandwidthGbps: NetworkBandwidthGbps?
    public var networkInterfaceCount: NetworkInterfaceCount?
    public var onDemandMaxPricePercentageOverLowestPrice: Integer?
    public var requireHibernateSupport: Boolean?
    public var spotMaxPricePercentageOverLowestPrice: Integer?
    public var totalLocalStorageGB: TotalLocalStorageGB?
    public var vCpuCount: VCpuCountRange?

    public init(acceleratorCount: AcceleratorCount? = nil,
                acceleratorManufacturers: AcceleratorManufacturerSet? = nil,
                acceleratorNames: AcceleratorNameSet? = nil,
                acceleratorTotalMemoryMiB: AcceleratorTotalMemoryMiB? = nil,
                acceleratorTypes: AcceleratorTypeSet? = nil,
                allowedInstanceTypes: AllowedInstanceTypeSet? = nil,
                bareMetal: BareMetal? = nil,
                baselineEbsBandwidthMbps: BaselineEbsBandwidthMbps? = nil,
                burstablePerformance: BurstablePerformance? = nil,
                cpuManufacturers: CpuManufacturerSet? = nil,
                excludedInstanceTypes: ExcludedInstanceTypeSet? = nil,
                instanceGenerations: InstanceGenerationSet? = nil,
                localStorage: LocalStorage? = nil,
                localStorageTypes: LocalStorageTypeSet? = nil,
                memoryGiBPerVCpu: MemoryGiBPerVCpu? = nil,
                memoryMiB: MemoryMiB? = nil,
                networkBandwidthGbps: NetworkBandwidthGbps? = nil,
                networkInterfaceCount: NetworkInterfaceCount? = nil,
                onDemandMaxPricePercentageOverLowestPrice: Integer? = nil,
                requireHibernateSupport: Boolean? = nil,
                spotMaxPricePercentageOverLowestPrice: Integer? = nil,
                totalLocalStorageGB: TotalLocalStorageGB? = nil,
                vCpuCount: VCpuCountRange? = nil) {
        self.acceleratorCount = acceleratorCount
        self.acceleratorManufacturers = acceleratorManufacturers
        self.acceleratorNames = acceleratorNames
        self.acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB
        self.acceleratorTypes = acceleratorTypes
        self.allowedInstanceTypes = allowedInstanceTypes
        self.bareMetal = bareMetal
        self.baselineEbsBandwidthMbps = baselineEbsBandwidthMbps
        self.burstablePerformance = burstablePerformance
        self.cpuManufacturers = cpuManufacturers
        self.excludedInstanceTypes = excludedInstanceTypes
        self.instanceGenerations = instanceGenerations
        self.localStorage = localStorage
        self.localStorageTypes = localStorageTypes
        self.memoryGiBPerVCpu = memoryGiBPerVCpu
        self.memoryMiB = memoryMiB
        self.networkBandwidthGbps = networkBandwidthGbps
        self.networkInterfaceCount = networkInterfaceCount
        self.onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPrice
        self.requireHibernateSupport = requireHibernateSupport
        self.spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPrice
        self.totalLocalStorageGB = totalLocalStorageGB
        self.vCpuCount = vCpuCount
    }

    enum CodingKeys: String, CodingKey {
        case acceleratorCount
        case acceleratorManufacturers = "acceleratorManufacturerSet"
        case acceleratorNames = "acceleratorNameSet"
        case acceleratorTotalMemoryMiB
        case acceleratorTypes = "acceleratorTypeSet"
        case allowedInstanceTypes = "allowedInstanceTypeSet"
        case bareMetal
        case baselineEbsBandwidthMbps
        case burstablePerformance
        case cpuManufacturers = "cpuManufacturerSet"
        case excludedInstanceTypes = "excludedInstanceTypeSet"
        case instanceGenerations = "instanceGenerationSet"
        case localStorage
        case localStorageTypes = "localStorageTypeSet"
        case memoryGiBPerVCpu
        case memoryMiB
        case networkBandwidthGbps
        case networkInterfaceCount
        case onDemandMaxPricePercentageOverLowestPrice
        case requireHibernateSupport
        case spotMaxPricePercentageOverLowestPrice
        case totalLocalStorageGB
        case vCpuCount
    }

    public func validate() throws {
        try acceleratorCount?.validate()
        try acceleratorTotalMemoryMiB?.validate()
        try allowedInstanceTypes?.validateAsAllowedInstanceTypeSet()
        try baselineEbsBandwidthMbps?.validate()
        try excludedInstanceTypes?.validateAsExcludedInstanceTypeSet()
        try memoryGiBPerVCpu?.validate()
        try memoryMiB?.validate()
        try networkBandwidthGbps?.validate()
        try networkInterfaceCount?.validate()
        try totalLocalStorageGB?.validate()
        try vCpuCount?.validate()
    }
}

public struct InstanceRequirementsRequest: Codable, Equatable {
    public var acceleratorCount: AcceleratorCountRequest?
    public var acceleratorManufacturers: AcceleratorManufacturerSet?
    public var acceleratorNames: AcceleratorNameSet?
    public var acceleratorTotalMemoryMiB: AcceleratorTotalMemoryMiBRequest?
    public var acceleratorTypes: AcceleratorTypeSet?
    public var allowedInstanceTypes: AllowedInstanceTypeSet?
    public var bareMetal: BareMetal?
    public var baselineEbsBandwidthMbps: BaselineEbsBandwidthMbpsRequest?
    public var burstablePerformance: BurstablePerformance?
    public var cpuManufacturers: CpuManufacturerSet?
    public var excludedInstanceTypes: ExcludedInstanceTypeSet?
    public var instanceGenerations: InstanceGenerationSet?
    public var localStorage: LocalStorage?
    public var localStorageTypes: LocalStorageTypeSet?
    public var memoryGiBPerVCpu: MemoryGiBPerVCpuRequest?
    public var memoryMiB: MemoryMiBRequest
    public var networkBandwidthGbps: NetworkBandwidthGbpsRequest?
    public var networkInterfaceCount: NetworkInterfaceCountRequest?
    public var onDemandMaxPricePercentageOverLowestPrice: Integer?
    public var requireHibernateSupport: Boolean?
    public var spotMaxPricePercentageOverLowestPrice: Integer?
    public var totalLocalStorageGB: TotalLocalStorageGBRequest?
    public var vCpuCount: VCpuCountRangeRequest

    public init(acceleratorCount: AcceleratorCountRequest? = nil,
                acceleratorManufacturers: AcceleratorManufacturerSet? = nil,
                acceleratorNames: AcceleratorNameSet? = nil,
                acceleratorTotalMemoryMiB: AcceleratorTotalMemoryMiBRequest? = nil,
                acceleratorTypes: AcceleratorTypeSet? = nil,
                allowedInstanceTypes: AllowedInstanceTypeSet? = nil,
                bareMetal: BareMetal? = nil,
                baselineEbsBandwidthMbps: BaselineEbsBandwidthMbpsRequest? = nil,
                burstablePerformance: BurstablePerformance? = nil,
                cpuManufacturers: CpuManufacturerSet? = nil,
                excludedInstanceTypes: ExcludedInstanceTypeSet? = nil,
                instanceGenerations: InstanceGenerationSet? = nil,
                localStorage: LocalStorage? = nil,
                localStorageTypes: LocalStorageTypeSet? = nil,
                memoryGiBPerVCpu: MemoryGiBPerVCpuRequest? = nil,
                memoryMiB: MemoryMiBRequest,
                networkBandwidthGbps: NetworkBandwidthGbpsRequest? = nil,
                networkInterfaceCount: NetworkInterfaceCountRequest? = nil,
                onDemandMaxPricePercentageOverLowestPrice: Integer? = nil,
                requireHibernateSupport: Boolean? = nil,
                spotMaxPricePercentageOverLowestPrice: Integer? = nil,
                totalLocalStorageGB: TotalLocalStorageGBRequest? = nil,
                vCpuCount: VCpuCountRangeRequest) {
        self.acceleratorCount = acceleratorCount
        self.acceleratorManufacturers = acceleratorManufacturers
        self.acceleratorNames = acceleratorNames
        self.acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB
        self.acceleratorTypes = acceleratorTypes
        self.allowedInstanceTypes = allowedInstanceTypes
        self.bareMetal = bareMetal
        self.baselineEbsBandwidthMbps = baselineEbsBandwidthMbps
        self.burstablePerformance = burstablePerformance
        self.cpuManufacturers = cpuManufacturers
        self.excludedInstanceTypes = excludedInstanceTypes
        self.instanceGenerations = instanceGenerations
        self.localStorage = localStorage
        self.localStorageTypes = localStorageTypes
        self.memoryGiBPerVCpu = memoryGiBPerVCpu
        self.memoryMiB = memoryMiB
        self.networkBandwidthGbps = networkBandwidthGbps
        self.networkInterfaceCount = networkInterfaceCount
        self.onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPrice
        self.requireHibernateSupport = requireHibernateSupport
        self.spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPrice
        self.totalLocalStorageGB = totalLocalStorageGB
        self.vCpuCount = vCpuCount
    }

    enum CodingKeys: String, CodingKey {
        case acceleratorCount = "AcceleratorCount"
        case acceleratorManufacturers = "AcceleratorManufacturer"
        case acceleratorNames = "AcceleratorName"
        case acceleratorTotalMemoryMiB = "AcceleratorTotalMemoryMiB"
        case acceleratorTypes = "AcceleratorType"
        case allowedInstanceTypes = "AllowedInstanceType"
        case bareMetal = "BareMetal"
        case baselineEbsBandwidthMbps = "BaselineEbsBandwidthMbps"
        case burstablePerformance = "BurstablePerformance"
        case cpuManufacturers = "CpuManufacturer"
        case excludedInstanceTypes = "ExcludedInstanceType"
        case instanceGenerations = "InstanceGeneration"
        case localStorage = "LocalStorage"
        case localStorageTypes = "LocalStorageType"
        case memoryGiBPerVCpu = "MemoryGiBPerVCpu"
        case memoryMiB = "MemoryMiB"
        case networkBandwidthGbps = "NetworkBandwidthGbps"
        case networkInterfaceCount = "NetworkInterfaceCount"
        case onDemandMaxPricePercentageOverLowestPrice = "OnDemandMaxPricePercentageOverLowestPrice"
        case requireHibernateSupport = "RequireHibernateSupport"
        case spotMaxPricePercentageOverLowestPrice = "SpotMaxPricePercentageOverLowestPrice"
        case totalLocalStorageGB = "TotalLocalStorageGB"
        case vCpuCount = "VCpuCount"
    }

    public func validate() throws {
        try acceleratorCount?.validate()
        try acceleratorTotalMemoryMiB?.validate()
        try allowedInstanceTypes?.validateAsAllowedInstanceTypeSet()
        try baselineEbsBandwidthMbps?.validate()
        try excludedInstanceTypes?.validateAsExcludedInstanceTypeSet()
        try memoryGiBPerVCpu?.validate()
        try memoryMiB.validate()
        try networkBandwidthGbps?.validate()
        try networkInterfaceCount?.validate()
        try totalLocalStorageGB?.validate()
        try vCpuCount.validate()
    }
}

public struct InstanceRequirementsWithMetadataRequest: Codable, Equatable {
    public var architectureTypes: ArchitectureTypeSet?
    public var instanceRequirements: InstanceRequirementsRequest?
    public var virtualizationTypes: VirtualizationTypeSet?

    public init(architectureTypes: ArchitectureTypeSet? = nil,
                instanceRequirements: InstanceRequirementsRequest? = nil,
                virtualizationTypes: VirtualizationTypeSet? = nil) {
        self.architectureTypes = architectureTypes
        self.instanceRequirements = instanceRequirements
        self.virtualizationTypes = virtualizationTypes
    }

    enum CodingKeys: String, CodingKey {
        case architectureTypes = "ArchitectureType"
        case instanceRequirements = "InstanceRequirements"
        case virtualizationTypes = "VirtualizationType"
    }

    public func validate() throws {
        try architectureTypes?.validateAsArchitectureTypeSet()
        try instanceRequirements?.validate()
        try virtualizationTypes?.validateAsVirtualizationTypeSet()
    }
}

public struct InstanceSpecification: Codable, Equatable {
    public var excludeBootVolume: Boolean?
    public var excludeDataVolumeIds: VolumeIdStringList?
    public var instanceId: InstanceId?

    public init(excludeBootVolume: Boolean? = nil,
                excludeDataVolumeIds: VolumeIdStringList? = nil,
                instanceId: InstanceId? = nil) {
        self.excludeBootVolume = excludeBootVolume
        self.excludeDataVolumeIds = excludeDataVolumeIds
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case excludeBootVolume = "ExcludeBootVolume"
        case excludeDataVolumeIds = "ExcludeDataVolumeId"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct InstanceState: Codable, Equatable {
    public var code: Integer?
    public var name: InstanceStateName?

    public init(code: Integer? = nil,
                name: InstanceStateName? = nil) {
        self.code = code
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case code
        case name
    }

    public func validate() throws {
    }
}

public struct InstanceStateChange: Codable, Equatable {
    public var currentState: InstanceState?
    public var instanceId: String?
    public var previousState: InstanceState?

    public init(currentState: InstanceState? = nil,
                instanceId: String? = nil,
                previousState: InstanceState? = nil) {
        self.currentState = currentState
        self.instanceId = instanceId
        self.previousState = previousState
    }

    enum CodingKeys: String, CodingKey {
        case currentState
        case instanceId
        case previousState
    }

    public func validate() throws {
        try currentState?.validate()
        try previousState?.validate()
    }
}

public struct InstanceStatus: Codable, Equatable {
    public var availabilityZone: String?
    public var events: InstanceStatusEventList?
    public var instanceId: String?
    public var instanceState: InstanceState?
    public var instanceStatus: InstanceStatusSummary?
    public var outpostArn: String?
    public var systemStatus: InstanceStatusSummary?

    public init(availabilityZone: String? = nil,
                events: InstanceStatusEventList? = nil,
                instanceId: String? = nil,
                instanceState: InstanceState? = nil,
                instanceStatus: InstanceStatusSummary? = nil,
                outpostArn: String? = nil,
                systemStatus: InstanceStatusSummary? = nil) {
        self.availabilityZone = availabilityZone
        self.events = events
        self.instanceId = instanceId
        self.instanceState = instanceState
        self.instanceStatus = instanceStatus
        self.outpostArn = outpostArn
        self.systemStatus = systemStatus
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case events = "eventsSet"
        case instanceId
        case instanceState
        case instanceStatus
        case outpostArn
        case systemStatus
    }

    public func validate() throws {
        try instanceState?.validate()
        try instanceStatus?.validate()
        try systemStatus?.validate()
    }
}

public struct InstanceStatusDetails: Codable, Equatable {
    public var impairedSince: DateTime?
    public var name: StatusName?
    public var status: StatusType?

    public init(impairedSince: DateTime? = nil,
                name: StatusName? = nil,
                status: StatusType? = nil) {
        self.impairedSince = impairedSince
        self.name = name
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case impairedSince
        case name
        case status
    }

    public func validate() throws {
    }
}

public struct InstanceStatusEvent: Codable, Equatable {
    public var code: EventCode?
    public var description: String?
    public var instanceEventId: InstanceEventId?
    public var notAfter: DateTime?
    public var notBefore: DateTime?
    public var notBeforeDeadline: DateTime?

    public init(code: EventCode? = nil,
                description: String? = nil,
                instanceEventId: InstanceEventId? = nil,
                notAfter: DateTime? = nil,
                notBefore: DateTime? = nil,
                notBeforeDeadline: DateTime? = nil) {
        self.code = code
        self.description = description
        self.instanceEventId = instanceEventId
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.notBeforeDeadline = notBeforeDeadline
    }

    enum CodingKeys: String, CodingKey {
        case code
        case description
        case instanceEventId
        case notAfter
        case notBefore
        case notBeforeDeadline
    }

    public func validate() throws {
    }
}

public struct InstanceStatusSummary: Codable, Equatable {
    public var details: InstanceStatusDetailsList?
    public var status: SummaryStatus?

    public init(details: InstanceStatusDetailsList? = nil,
                status: SummaryStatus? = nil) {
        self.details = details
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case details
        case status
    }

    public func validate() throws {
    }
}

public struct InstanceStorageInfo: Codable, Equatable {
    public var disks: DiskInfoList?
    public var encryptionSupport: InstanceStorageEncryptionSupport?
    public var nvmeSupport: EphemeralNvmeSupport?
    public var totalSizeInGB: DiskSize?

    public init(disks: DiskInfoList? = nil,
                encryptionSupport: InstanceStorageEncryptionSupport? = nil,
                nvmeSupport: EphemeralNvmeSupport? = nil,
                totalSizeInGB: DiskSize? = nil) {
        self.disks = disks
        self.encryptionSupport = encryptionSupport
        self.nvmeSupport = nvmeSupport
        self.totalSizeInGB = totalSizeInGB
    }

    enum CodingKeys: String, CodingKey {
        case disks
        case encryptionSupport
        case nvmeSupport
        case totalSizeInGB
    }

    public func validate() throws {
    }
}

public struct InstanceTagNotificationAttribute: Codable, Equatable {
    public var includeAllTagsOfInstance: Boolean?
    public var instanceTagKeys: InstanceTagKeySet?

    public init(includeAllTagsOfInstance: Boolean? = nil,
                instanceTagKeys: InstanceTagKeySet? = nil) {
        self.includeAllTagsOfInstance = includeAllTagsOfInstance
        self.instanceTagKeys = instanceTagKeys
    }

    enum CodingKeys: String, CodingKey {
        case includeAllTagsOfInstance
        case instanceTagKeys = "instanceTagKeySet"
    }

    public func validate() throws {
    }
}

public struct InstanceTypeInfo: Codable, Equatable {
    public var autoRecoverySupported: AutoRecoveryFlag?
    public var bareMetal: BareMetalFlag?
    public var burstablePerformanceSupported: BurstablePerformanceFlag?
    public var currentGeneration: CurrentGenerationFlag?
    public var dedicatedHostsSupported: DedicatedHostFlag?
    public var ebsInfo: EbsInfo?
    public var fpgaInfo: FpgaInfo?
    public var freeTierEligible: FreeTierEligibleFlag?
    public var gpuInfo: GpuInfo?
    public var hibernationSupported: HibernationFlag?
    public var hypervisor: InstanceTypeHypervisor?
    public var inferenceAcceleratorInfo: InferenceAcceleratorInfo?
    public var instanceStorageInfo: InstanceStorageInfo?
    public var instanceStorageSupported: InstanceStorageFlag?
    public var instanceType: InstanceType?
    public var memoryInfo: MemoryInfo?
    public var networkInfo: NetworkInfo?
    public var placementGroupInfo: PlacementGroupInfo?
    public var processorInfo: ProcessorInfo?
    public var supportedBootModes: BootModeTypeList?
    public var supportedRootDeviceTypes: RootDeviceTypeList?
    public var supportedUsageClasses: UsageClassTypeList?
    public var supportedVirtualizationTypes: VirtualizationTypeList?
    public var vCpuInfo: VCpuInfo?

    public init(autoRecoverySupported: AutoRecoveryFlag? = nil,
                bareMetal: BareMetalFlag? = nil,
                burstablePerformanceSupported: BurstablePerformanceFlag? = nil,
                currentGeneration: CurrentGenerationFlag? = nil,
                dedicatedHostsSupported: DedicatedHostFlag? = nil,
                ebsInfo: EbsInfo? = nil,
                fpgaInfo: FpgaInfo? = nil,
                freeTierEligible: FreeTierEligibleFlag? = nil,
                gpuInfo: GpuInfo? = nil,
                hibernationSupported: HibernationFlag? = nil,
                hypervisor: InstanceTypeHypervisor? = nil,
                inferenceAcceleratorInfo: InferenceAcceleratorInfo? = nil,
                instanceStorageInfo: InstanceStorageInfo? = nil,
                instanceStorageSupported: InstanceStorageFlag? = nil,
                instanceType: InstanceType? = nil,
                memoryInfo: MemoryInfo? = nil,
                networkInfo: NetworkInfo? = nil,
                placementGroupInfo: PlacementGroupInfo? = nil,
                processorInfo: ProcessorInfo? = nil,
                supportedBootModes: BootModeTypeList? = nil,
                supportedRootDeviceTypes: RootDeviceTypeList? = nil,
                supportedUsageClasses: UsageClassTypeList? = nil,
                supportedVirtualizationTypes: VirtualizationTypeList? = nil,
                vCpuInfo: VCpuInfo? = nil) {
        self.autoRecoverySupported = autoRecoverySupported
        self.bareMetal = bareMetal
        self.burstablePerformanceSupported = burstablePerformanceSupported
        self.currentGeneration = currentGeneration
        self.dedicatedHostsSupported = dedicatedHostsSupported
        self.ebsInfo = ebsInfo
        self.fpgaInfo = fpgaInfo
        self.freeTierEligible = freeTierEligible
        self.gpuInfo = gpuInfo
        self.hibernationSupported = hibernationSupported
        self.hypervisor = hypervisor
        self.inferenceAcceleratorInfo = inferenceAcceleratorInfo
        self.instanceStorageInfo = instanceStorageInfo
        self.instanceStorageSupported = instanceStorageSupported
        self.instanceType = instanceType
        self.memoryInfo = memoryInfo
        self.networkInfo = networkInfo
        self.placementGroupInfo = placementGroupInfo
        self.processorInfo = processorInfo
        self.supportedBootModes = supportedBootModes
        self.supportedRootDeviceTypes = supportedRootDeviceTypes
        self.supportedUsageClasses = supportedUsageClasses
        self.supportedVirtualizationTypes = supportedVirtualizationTypes
        self.vCpuInfo = vCpuInfo
    }

    enum CodingKeys: String, CodingKey {
        case autoRecoverySupported
        case bareMetal
        case burstablePerformanceSupported
        case currentGeneration
        case dedicatedHostsSupported
        case ebsInfo
        case fpgaInfo
        case freeTierEligible
        case gpuInfo
        case hibernationSupported
        case hypervisor
        case inferenceAcceleratorInfo
        case instanceStorageInfo
        case instanceStorageSupported
        case instanceType
        case memoryInfo
        case networkInfo
        case placementGroupInfo
        case processorInfo
        case supportedBootModes
        case supportedRootDeviceTypes
        case supportedUsageClasses
        case supportedVirtualizationTypes
        case vCpuInfo
    }

    public func validate() throws {
        try ebsInfo?.validate()
        try fpgaInfo?.validate()
        try gpuInfo?.validate()
        try inferenceAcceleratorInfo?.validate()
        try instanceStorageInfo?.validate()
        try memoryInfo?.validate()
        try networkInfo?.validate()
        try placementGroupInfo?.validate()
        try processorInfo?.validate()
        try vCpuInfo?.validate()
    }
}

public struct InstanceTypeInfoFromInstanceRequirements: Codable, Equatable {
    public var instanceType: String?

    public init(instanceType: String? = nil) {
        self.instanceType = instanceType
    }

    enum CodingKeys: String, CodingKey {
        case instanceType
    }

    public func validate() throws {
    }
}

public struct InstanceTypeOffering: Codable, Equatable {
    public var instanceType: InstanceType?
    public var location: Location?
    public var locationType: LocationType?

    public init(instanceType: InstanceType? = nil,
                location: Location? = nil,
                locationType: LocationType? = nil) {
        self.instanceType = instanceType
        self.location = location
        self.locationType = locationType
    }

    enum CodingKeys: String, CodingKey {
        case instanceType
        case location
        case locationType
    }

    public func validate() throws {
    }
}

public struct InstanceUsage: Codable, Equatable {
    public var accountId: String?
    public var usedInstanceCount: Integer?

    public init(accountId: String? = nil,
                usedInstanceCount: Integer? = nil) {
        self.accountId = accountId
        self.usedInstanceCount = usedInstanceCount
    }

    enum CodingKeys: String, CodingKey {
        case accountId
        case usedInstanceCount
    }

    public func validate() throws {
    }
}

public struct IntegrateServices: Codable, Equatable {
    public var athenaIntegrations: AthenaIntegrationsSet?

    public init(athenaIntegrations: AthenaIntegrationsSet? = nil) {
        self.athenaIntegrations = athenaIntegrations
    }

    enum CodingKeys: String, CodingKey {
        case athenaIntegrations = "AthenaIntegration"
    }

    public func validate() throws {
        try athenaIntegrations?.validateAsAthenaIntegrationsSet()
    }
}

public struct InternetGateway: Codable, Equatable {
    public var attachments: InternetGatewayAttachmentList?
    public var internetGatewayId: String?
    public var ownerId: String?
    public var tags: TagList?

    public init(attachments: InternetGatewayAttachmentList? = nil,
                internetGatewayId: String? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil) {
        self.attachments = attachments
        self.internetGatewayId = internetGatewayId
        self.ownerId = ownerId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case attachments = "attachmentSet"
        case internetGatewayId
        case ownerId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct InternetGatewayAttachment: Codable, Equatable {
    public var state: AttachmentStatus?
    public var vpcId: String?

    public init(state: AttachmentStatus? = nil,
                vpcId: String? = nil) {
        self.state = state
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case vpcId
    }

    public func validate() throws {
    }
}

public struct IpPermission: Codable, Equatable {
    public var fromPort: Integer?
    public var ipProtocol: String?
    public var ipRanges: IpRangeList?
    public var ipv6Ranges: Ipv6RangeList?
    public var prefixListIds: PrefixListIdList?
    public var toPort: Integer?
    public var userIdGroupPairs: UserIdGroupPairList?

    public init(fromPort: Integer? = nil,
                ipProtocol: String? = nil,
                ipRanges: IpRangeList? = nil,
                ipv6Ranges: Ipv6RangeList? = nil,
                prefixListIds: PrefixListIdList? = nil,
                toPort: Integer? = nil,
                userIdGroupPairs: UserIdGroupPairList? = nil) {
        self.fromPort = fromPort
        self.ipProtocol = ipProtocol
        self.ipRanges = ipRanges
        self.ipv6Ranges = ipv6Ranges
        self.prefixListIds = prefixListIds
        self.toPort = toPort
        self.userIdGroupPairs = userIdGroupPairs
    }

    enum CodingKeys: String, CodingKey {
        case fromPort
        case ipProtocol
        case ipRanges
        case ipv6Ranges
        case prefixListIds
        case toPort
        case userIdGroupPairs = "groups"
    }

    public func validate() throws {
    }
}

public struct IpRange: Codable, Equatable {
    public var cidrIp: String?
    public var description: String?

    public init(cidrIp: String? = nil,
                description: String? = nil) {
        self.cidrIp = cidrIp
        self.description = description
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp
        case description
    }

    public func validate() throws {
    }
}

public struct Ipam: Codable, Equatable {
    public var description: String?
    public var ipamArn: ResourceArn?
    public var ipamId: IpamId?
    public var ipamRegion: String?
    public var operatingRegions: IpamOperatingRegionSet?
    public var ownerId: String?
    public var privateDefaultScopeId: IpamScopeId?
    public var publicDefaultScopeId: IpamScopeId?
    public var scopeCount: Integer?
    public var state: IpamState?
    public var tags: TagList?

    public init(description: String? = nil,
                ipamArn: ResourceArn? = nil,
                ipamId: IpamId? = nil,
                ipamRegion: String? = nil,
                operatingRegions: IpamOperatingRegionSet? = nil,
                ownerId: String? = nil,
                privateDefaultScopeId: IpamScopeId? = nil,
                publicDefaultScopeId: IpamScopeId? = nil,
                scopeCount: Integer? = nil,
                state: IpamState? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.ipamArn = ipamArn
        self.ipamId = ipamId
        self.ipamRegion = ipamRegion
        self.operatingRegions = operatingRegions
        self.ownerId = ownerId
        self.privateDefaultScopeId = privateDefaultScopeId
        self.publicDefaultScopeId = publicDefaultScopeId
        self.scopeCount = scopeCount
        self.state = state
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case ipamArn
        case ipamId
        case ipamRegion
        case operatingRegions = "operatingRegionSet"
        case ownerId
        case privateDefaultScopeId
        case publicDefaultScopeId
        case scopeCount
        case state
        case tags = "tagSet"
    }

    public func validate() throws {
        try ipamArn?.validateAsResourceArn()
    }
}

public struct IpamAddressHistoryRecord: Codable, Equatable {
    public var resourceCidr: String?
    public var resourceComplianceStatus: IpamComplianceStatus?
    public var resourceId: String?
    public var resourceName: String?
    public var resourceOverlapStatus: IpamOverlapStatus?
    public var resourceOwnerId: String?
    public var resourceRegion: String?
    public var resourceType: IpamAddressHistoryResourceType?
    public var sampledEndTime: MillisecondDateTime?
    public var sampledStartTime: MillisecondDateTime?
    public var vpcId: String?

    public init(resourceCidr: String? = nil,
                resourceComplianceStatus: IpamComplianceStatus? = nil,
                resourceId: String? = nil,
                resourceName: String? = nil,
                resourceOverlapStatus: IpamOverlapStatus? = nil,
                resourceOwnerId: String? = nil,
                resourceRegion: String? = nil,
                resourceType: IpamAddressHistoryResourceType? = nil,
                sampledEndTime: MillisecondDateTime? = nil,
                sampledStartTime: MillisecondDateTime? = nil,
                vpcId: String? = nil) {
        self.resourceCidr = resourceCidr
        self.resourceComplianceStatus = resourceComplianceStatus
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceOverlapStatus = resourceOverlapStatus
        self.resourceOwnerId = resourceOwnerId
        self.resourceRegion = resourceRegion
        self.resourceType = resourceType
        self.sampledEndTime = sampledEndTime
        self.sampledStartTime = sampledStartTime
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case resourceCidr
        case resourceComplianceStatus
        case resourceId
        case resourceName
        case resourceOverlapStatus
        case resourceOwnerId
        case resourceRegion
        case resourceType
        case sampledEndTime
        case sampledStartTime
        case vpcId
    }

    public func validate() throws {
    }
}

public struct IpamCidrAuthorizationContext: Codable, Equatable {
    public var message: String?
    public var signature: String?

    public init(message: String? = nil,
                signature: String? = nil) {
        self.message = message
        self.signature = signature
    }

    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case signature = "Signature"
    }

    public func validate() throws {
    }
}

public struct IpamOperatingRegion: Codable, Equatable {
    public var regionName: String?

    public init(regionName: String? = nil) {
        self.regionName = regionName
    }

    enum CodingKeys: String, CodingKey {
        case regionName
    }

    public func validate() throws {
    }
}

public struct IpamPool: Codable, Equatable {
    public var addressFamily: AddressFamily?
    public var allocationDefaultNetmaskLength: IpamNetmaskLength?
    public var allocationMaxNetmaskLength: IpamNetmaskLength?
    public var allocationMinNetmaskLength: IpamNetmaskLength?
    public var allocationResourceTags: IpamResourceTagList?
    public var autoImport: Boolean?
    public var awsService: IpamPoolAwsService?
    public var description: String?
    public var ipamArn: ResourceArn?
    public var ipamPoolArn: ResourceArn?
    public var ipamPoolId: IpamPoolId?
    public var ipamRegion: String?
    public var ipamScopeArn: ResourceArn?
    public var ipamScopeType: IpamScopeType?
    public var locale: String?
    public var ownerId: String?
    public var poolDepth: Integer?
    public var publiclyAdvertisable: Boolean?
    public var sourceIpamPoolId: IpamPoolId?
    public var state: IpamPoolState?
    public var stateMessage: String?
    public var tags: TagList?

    public init(addressFamily: AddressFamily? = nil,
                allocationDefaultNetmaskLength: IpamNetmaskLength? = nil,
                allocationMaxNetmaskLength: IpamNetmaskLength? = nil,
                allocationMinNetmaskLength: IpamNetmaskLength? = nil,
                allocationResourceTags: IpamResourceTagList? = nil,
                autoImport: Boolean? = nil,
                awsService: IpamPoolAwsService? = nil,
                description: String? = nil,
                ipamArn: ResourceArn? = nil,
                ipamPoolArn: ResourceArn? = nil,
                ipamPoolId: IpamPoolId? = nil,
                ipamRegion: String? = nil,
                ipamScopeArn: ResourceArn? = nil,
                ipamScopeType: IpamScopeType? = nil,
                locale: String? = nil,
                ownerId: String? = nil,
                poolDepth: Integer? = nil,
                publiclyAdvertisable: Boolean? = nil,
                sourceIpamPoolId: IpamPoolId? = nil,
                state: IpamPoolState? = nil,
                stateMessage: String? = nil,
                tags: TagList? = nil) {
        self.addressFamily = addressFamily
        self.allocationDefaultNetmaskLength = allocationDefaultNetmaskLength
        self.allocationMaxNetmaskLength = allocationMaxNetmaskLength
        self.allocationMinNetmaskLength = allocationMinNetmaskLength
        self.allocationResourceTags = allocationResourceTags
        self.autoImport = autoImport
        self.awsService = awsService
        self.description = description
        self.ipamArn = ipamArn
        self.ipamPoolArn = ipamPoolArn
        self.ipamPoolId = ipamPoolId
        self.ipamRegion = ipamRegion
        self.ipamScopeArn = ipamScopeArn
        self.ipamScopeType = ipamScopeType
        self.locale = locale
        self.ownerId = ownerId
        self.poolDepth = poolDepth
        self.publiclyAdvertisable = publiclyAdvertisable
        self.sourceIpamPoolId = sourceIpamPoolId
        self.state = state
        self.stateMessage = stateMessage
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case addressFamily
        case allocationDefaultNetmaskLength
        case allocationMaxNetmaskLength
        case allocationMinNetmaskLength
        case allocationResourceTags = "allocationResourceTagSet"
        case autoImport
        case awsService
        case description
        case ipamArn
        case ipamPoolArn
        case ipamPoolId
        case ipamRegion
        case ipamScopeArn
        case ipamScopeType
        case locale
        case ownerId
        case poolDepth
        case publiclyAdvertisable
        case sourceIpamPoolId
        case state
        case stateMessage
        case tags = "tagSet"
    }

    public func validate() throws {
        try allocationDefaultNetmaskLength?.validateAsIpamNetmaskLength()
        try allocationMaxNetmaskLength?.validateAsIpamNetmaskLength()
        try allocationMinNetmaskLength?.validateAsIpamNetmaskLength()
        try ipamArn?.validateAsResourceArn()
        try ipamPoolArn?.validateAsResourceArn()
        try ipamScopeArn?.validateAsResourceArn()
    }
}

public struct IpamPoolAllocation: Codable, Equatable {
    public var cidr: String?
    public var description: String?
    public var ipamPoolAllocationId: IpamPoolAllocationId?
    public var resourceId: String?
    public var resourceOwner: String?
    public var resourceRegion: String?
    public var resourceType: IpamPoolAllocationResourceType?

    public init(cidr: String? = nil,
                description: String? = nil,
                ipamPoolAllocationId: IpamPoolAllocationId? = nil,
                resourceId: String? = nil,
                resourceOwner: String? = nil,
                resourceRegion: String? = nil,
                resourceType: IpamPoolAllocationResourceType? = nil) {
        self.cidr = cidr
        self.description = description
        self.ipamPoolAllocationId = ipamPoolAllocationId
        self.resourceId = resourceId
        self.resourceOwner = resourceOwner
        self.resourceRegion = resourceRegion
        self.resourceType = resourceType
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case description
        case ipamPoolAllocationId
        case resourceId
        case resourceOwner
        case resourceRegion
        case resourceType
    }

    public func validate() throws {
    }
}

public struct IpamPoolCidr: Codable, Equatable {
    public var cidr: String?
    public var failureReason: IpamPoolCidrFailureReason?
    public var state: IpamPoolCidrState?

    public init(cidr: String? = nil,
                failureReason: IpamPoolCidrFailureReason? = nil,
                state: IpamPoolCidrState? = nil) {
        self.cidr = cidr
        self.failureReason = failureReason
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case failureReason
        case state
    }

    public func validate() throws {
        try failureReason?.validate()
    }
}

public struct IpamPoolCidrFailureReason: Codable, Equatable {
    public var code: IpamPoolCidrFailureCode?
    public var message: String?

    public init(code: IpamPoolCidrFailureCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct IpamResourceCidr: Codable, Equatable {
    public var complianceStatus: IpamComplianceStatus?
    public var ipUsage: BoxedDouble?
    public var ipamId: IpamId?
    public var ipamPoolId: IpamPoolId?
    public var ipamScopeId: IpamScopeId?
    public var managementState: IpamManagementState?
    public var overlapStatus: IpamOverlapStatus?
    public var resourceCidr: String?
    public var resourceId: String?
    public var resourceName: String?
    public var resourceOwnerId: String?
    public var resourceRegion: String?
    public var resourceTags: IpamResourceTagList?
    public var resourceType: IpamResourceType?
    public var vpcId: String?

    public init(complianceStatus: IpamComplianceStatus? = nil,
                ipUsage: BoxedDouble? = nil,
                ipamId: IpamId? = nil,
                ipamPoolId: IpamPoolId? = nil,
                ipamScopeId: IpamScopeId? = nil,
                managementState: IpamManagementState? = nil,
                overlapStatus: IpamOverlapStatus? = nil,
                resourceCidr: String? = nil,
                resourceId: String? = nil,
                resourceName: String? = nil,
                resourceOwnerId: String? = nil,
                resourceRegion: String? = nil,
                resourceTags: IpamResourceTagList? = nil,
                resourceType: IpamResourceType? = nil,
                vpcId: String? = nil) {
        self.complianceStatus = complianceStatus
        self.ipUsage = ipUsage
        self.ipamId = ipamId
        self.ipamPoolId = ipamPoolId
        self.ipamScopeId = ipamScopeId
        self.managementState = managementState
        self.overlapStatus = overlapStatus
        self.resourceCidr = resourceCidr
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceOwnerId = resourceOwnerId
        self.resourceRegion = resourceRegion
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case complianceStatus
        case ipUsage
        case ipamId
        case ipamPoolId
        case ipamScopeId
        case managementState
        case overlapStatus
        case resourceCidr
        case resourceId
        case resourceName
        case resourceOwnerId
        case resourceRegion
        case resourceTags = "resourceTagSet"
        case resourceType
        case vpcId
    }

    public func validate() throws {
    }
}

public struct IpamResourceTag: Codable, Equatable {
    public var key: String?
    public var value: String?

    public init(key: String? = nil,
                value: String? = nil) {
        self.key = key
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func validate() throws {
    }
}

public struct IpamScope: Codable, Equatable {
    public var description: String?
    public var ipamArn: ResourceArn?
    public var ipamRegion: String?
    public var ipamScopeArn: ResourceArn?
    public var ipamScopeId: IpamScopeId?
    public var ipamScopeType: IpamScopeType?
    public var isDefault: Boolean?
    public var ownerId: String?
    public var poolCount: Integer?
    public var state: IpamScopeState?
    public var tags: TagList?

    public init(description: String? = nil,
                ipamArn: ResourceArn? = nil,
                ipamRegion: String? = nil,
                ipamScopeArn: ResourceArn? = nil,
                ipamScopeId: IpamScopeId? = nil,
                ipamScopeType: IpamScopeType? = nil,
                isDefault: Boolean? = nil,
                ownerId: String? = nil,
                poolCount: Integer? = nil,
                state: IpamScopeState? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.ipamArn = ipamArn
        self.ipamRegion = ipamRegion
        self.ipamScopeArn = ipamScopeArn
        self.ipamScopeId = ipamScopeId
        self.ipamScopeType = ipamScopeType
        self.isDefault = isDefault
        self.ownerId = ownerId
        self.poolCount = poolCount
        self.state = state
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case ipamArn
        case ipamRegion
        case ipamScopeArn
        case ipamScopeId
        case ipamScopeType
        case isDefault
        case ownerId
        case poolCount
        case state
        case tags = "tagSet"
    }

    public func validate() throws {
        try ipamArn?.validateAsResourceArn()
        try ipamScopeArn?.validateAsResourceArn()
    }
}

public struct Ipv4PrefixSpecification: Codable, Equatable {
    public var ipv4Prefix: String?

    public init(ipv4Prefix: String? = nil) {
        self.ipv4Prefix = ipv4Prefix
    }

    enum CodingKeys: String, CodingKey {
        case ipv4Prefix
    }

    public func validate() throws {
    }
}

public struct Ipv4PrefixSpecificationRequest: Codable, Equatable {
    public var ipv4Prefix: String?

    public init(ipv4Prefix: String? = nil) {
        self.ipv4Prefix = ipv4Prefix
    }

    enum CodingKeys: String, CodingKey {
        case ipv4Prefix = "Ipv4Prefix"
    }

    public func validate() throws {
    }
}

public struct Ipv4PrefixSpecificationResponse: Codable, Equatable {
    public var ipv4Prefix: String?

    public init(ipv4Prefix: String? = nil) {
        self.ipv4Prefix = ipv4Prefix
    }

    enum CodingKeys: String, CodingKey {
        case ipv4Prefix
    }

    public func validate() throws {
    }
}

public struct Ipv6CidrAssociation: Codable, Equatable {
    public var associatedResource: String?
    public var ipv6Cidr: String?

    public init(associatedResource: String? = nil,
                ipv6Cidr: String? = nil) {
        self.associatedResource = associatedResource
        self.ipv6Cidr = ipv6Cidr
    }

    enum CodingKeys: String, CodingKey {
        case associatedResource
        case ipv6Cidr
    }

    public func validate() throws {
    }
}

public struct Ipv6CidrBlock: Codable, Equatable {
    public var ipv6CidrBlock: String?

    public init(ipv6CidrBlock: String? = nil) {
        self.ipv6CidrBlock = ipv6CidrBlock
    }

    enum CodingKeys: String, CodingKey {
        case ipv6CidrBlock
    }

    public func validate() throws {
    }
}

public struct Ipv6Pool: Codable, Equatable {
    public var description: String?
    public var poolCidrBlocks: PoolCidrBlocksSet?
    public var poolId: String?
    public var tags: TagList?

    public init(description: String? = nil,
                poolCidrBlocks: PoolCidrBlocksSet? = nil,
                poolId: String? = nil,
                tags: TagList? = nil) {
        self.description = description
        self.poolCidrBlocks = poolCidrBlocks
        self.poolId = poolId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case description
        case poolCidrBlocks = "poolCidrBlockSet"
        case poolId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct Ipv6PrefixSpecification: Codable, Equatable {
    public var ipv6Prefix: String?

    public init(ipv6Prefix: String? = nil) {
        self.ipv6Prefix = ipv6Prefix
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Prefix
    }

    public func validate() throws {
    }
}

public struct Ipv6PrefixSpecificationRequest: Codable, Equatable {
    public var ipv6Prefix: String?

    public init(ipv6Prefix: String? = nil) {
        self.ipv6Prefix = ipv6Prefix
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Prefix = "Ipv6Prefix"
    }

    public func validate() throws {
    }
}

public struct Ipv6PrefixSpecificationResponse: Codable, Equatable {
    public var ipv6Prefix: String?

    public init(ipv6Prefix: String? = nil) {
        self.ipv6Prefix = ipv6Prefix
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Prefix
    }

    public func validate() throws {
    }
}

public struct Ipv6Range: Codable, Equatable {
    public var cidrIpv6: String?
    public var description: String?

    public init(cidrIpv6: String? = nil,
                description: String? = nil) {
        self.cidrIpv6 = cidrIpv6
        self.description = description
    }

    enum CodingKeys: String, CodingKey {
        case cidrIpv6
        case description
    }

    public func validate() throws {
    }
}

public struct KeyPair: Codable, Equatable {
    public var keyFingerprint: String?
    public var keyMaterial: SensitiveUserData?
    public var keyName: String?
    public var keyPairId: String?
    public var tags: TagList?

    public init(keyFingerprint: String? = nil,
                keyMaterial: SensitiveUserData? = nil,
                keyName: String? = nil,
                keyPairId: String? = nil,
                tags: TagList? = nil) {
        self.keyFingerprint = keyFingerprint
        self.keyMaterial = keyMaterial
        self.keyName = keyName
        self.keyPairId = keyPairId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case keyFingerprint
        case keyMaterial
        case keyName
        case keyPairId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct KeyPairInfo: Codable, Equatable {
    public var createTime: MillisecondDateTime?
    public var keyFingerprint: String?
    public var keyName: String?
    public var keyPairId: String?
    public var keyType: KeyType?
    public var publicKey: String?
    public var tags: TagList?

    public init(createTime: MillisecondDateTime? = nil,
                keyFingerprint: String? = nil,
                keyName: String? = nil,
                keyPairId: String? = nil,
                keyType: KeyType? = nil,
                publicKey: String? = nil,
                tags: TagList? = nil) {
        self.createTime = createTime
        self.keyFingerprint = keyFingerprint
        self.keyName = keyName
        self.keyPairId = keyPairId
        self.keyType = keyType
        self.publicKey = publicKey
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case createTime
        case keyFingerprint
        case keyName
        case keyPairId
        case keyType
        case publicKey
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct LastError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct LaunchPermission: Codable, Equatable {
    public var group: PermissionGroup?
    public var organizationArn: String?
    public var organizationalUnitArn: String?
    public var userId: String?

    public init(group: PermissionGroup? = nil,
                organizationArn: String? = nil,
                organizationalUnitArn: String? = nil,
                userId: String? = nil) {
        self.group = group
        self.organizationArn = organizationArn
        self.organizationalUnitArn = organizationalUnitArn
        self.userId = userId
    }

    enum CodingKeys: String, CodingKey {
        case group
        case organizationArn
        case organizationalUnitArn
        case userId
    }

    public func validate() throws {
    }
}

public struct LaunchPermissionModifications: Codable, Equatable {
    public var add: LaunchPermissionList?
    public var remove: LaunchPermissionList?

    public init(add: LaunchPermissionList? = nil,
                remove: LaunchPermissionList? = nil) {
        self.add = add
        self.remove = remove
    }

    enum CodingKeys: String, CodingKey {
        case add = "Add"
        case remove = "Remove"
    }

    public func validate() throws {
    }
}

public struct LaunchSpecification: Codable, Equatable {
    public var addressingType: String?
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var ebsOptimized: Boolean?
    public var iamInstanceProfile: IamInstanceProfileSpecification?
    public var imageId: String?
    public var instanceType: InstanceType?
    public var kernelId: String?
    public var keyName: String?
    public var monitoring: RunInstancesMonitoringEnabled?
    public var networkInterfaces: InstanceNetworkInterfaceSpecificationList?
    public var placement: SpotPlacement?
    public var ramdiskId: String?
    public var securityGroups: GroupIdentifierList?
    public var subnetId: String?
    public var userData: String?

    public init(addressingType: String? = nil,
                blockDeviceMappings: BlockDeviceMappingList? = nil,
                ebsOptimized: Boolean? = nil,
                iamInstanceProfile: IamInstanceProfileSpecification? = nil,
                imageId: String? = nil,
                instanceType: InstanceType? = nil,
                kernelId: String? = nil,
                keyName: String? = nil,
                monitoring: RunInstancesMonitoringEnabled? = nil,
                networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil,
                placement: SpotPlacement? = nil,
                ramdiskId: String? = nil,
                securityGroups: GroupIdentifierList? = nil,
                subnetId: String? = nil,
                userData: String? = nil) {
        self.addressingType = addressingType
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramdiskId = ramdiskId
        self.securityGroups = securityGroups
        self.subnetId = subnetId
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case addressingType
        case blockDeviceMappings = "blockDeviceMapping"
        case ebsOptimized
        case iamInstanceProfile
        case imageId
        case instanceType
        case kernelId
        case keyName
        case monitoring
        case networkInterfaces = "networkInterfaceSet"
        case placement
        case ramdiskId
        case securityGroups = "groupSet"
        case subnetId
        case userData
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct LaunchTemplate: Codable, Equatable {
    public var createTime: DateTime?
    public var createdBy: String?
    public var defaultVersionNumber: Long?
    public var latestVersionNumber: Long?
    public var launchTemplateId: String?
    public var launchTemplateName: LaunchTemplateName?
    public var tags: TagList?

    public init(createTime: DateTime? = nil,
                createdBy: String? = nil,
                defaultVersionNumber: Long? = nil,
                latestVersionNumber: Long? = nil,
                launchTemplateId: String? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                tags: TagList? = nil) {
        self.createTime = createTime
        self.createdBy = createdBy
        self.defaultVersionNumber = defaultVersionNumber
        self.latestVersionNumber = latestVersionNumber
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case createTime
        case createdBy
        case defaultVersionNumber
        case latestVersionNumber
        case launchTemplateId
        case launchTemplateName
        case tags = "tagSet"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct LaunchTemplateAndOverridesResponse: Codable, Equatable {
    public var launchTemplateSpecification: FleetLaunchTemplateSpecification?
    public var overrides: FleetLaunchTemplateOverrides?

    public init(launchTemplateSpecification: FleetLaunchTemplateSpecification? = nil,
                overrides: FleetLaunchTemplateOverrides? = nil) {
        self.launchTemplateSpecification = launchTemplateSpecification
        self.overrides = overrides
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateSpecification
        case overrides
    }

    public func validate() throws {
        try launchTemplateSpecification?.validate()
        try overrides?.validate()
    }
}

public struct LaunchTemplateBlockDeviceMapping: Codable, Equatable {
    public var deviceName: String?
    public var ebs: LaunchTemplateEbsBlockDevice?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: LaunchTemplateEbsBlockDevice? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct LaunchTemplateBlockDeviceMappingRequest: Codable, Equatable {
    public var deviceName: String?
    public var ebs: LaunchTemplateEbsBlockDeviceRequest?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: LaunchTemplateEbsBlockDeviceRequest? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName = "DeviceName"
        case ebs = "Ebs"
        case noDevice = "NoDevice"
        case virtualName = "VirtualName"
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct LaunchTemplateCapacityReservationSpecificationRequest: Codable, Equatable {
    public var capacityReservationPreference: CapacityReservationPreference?
    public var capacityReservationTarget: CapacityReservationTarget?

    public init(capacityReservationPreference: CapacityReservationPreference? = nil,
                capacityReservationTarget: CapacityReservationTarget? = nil) {
        self.capacityReservationPreference = capacityReservationPreference
        self.capacityReservationTarget = capacityReservationTarget
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationPreference = "CapacityReservationPreference"
        case capacityReservationTarget = "CapacityReservationTarget"
    }

    public func validate() throws {
        try capacityReservationTarget?.validate()
    }
}

public struct LaunchTemplateCapacityReservationSpecificationResponse: Codable, Equatable {
    public var capacityReservationPreference: CapacityReservationPreference?
    public var capacityReservationTarget: CapacityReservationTargetResponse?

    public init(capacityReservationPreference: CapacityReservationPreference? = nil,
                capacityReservationTarget: CapacityReservationTargetResponse? = nil) {
        self.capacityReservationPreference = capacityReservationPreference
        self.capacityReservationTarget = capacityReservationTarget
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationPreference
        case capacityReservationTarget
    }

    public func validate() throws {
        try capacityReservationTarget?.validate()
    }
}

public struct LaunchTemplateConfig: Codable, Equatable {
    public var launchTemplateSpecification: FleetLaunchTemplateSpecification?
    public var overrides: LaunchTemplateOverridesList?

    public init(launchTemplateSpecification: FleetLaunchTemplateSpecification? = nil,
                overrides: LaunchTemplateOverridesList? = nil) {
        self.launchTemplateSpecification = launchTemplateSpecification
        self.overrides = overrides
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateSpecification
        case overrides
    }

    public func validate() throws {
        try launchTemplateSpecification?.validate()
    }
}

public struct LaunchTemplateCpuOptions: Codable, Equatable {
    public var coreCount: Integer?
    public var threadsPerCore: Integer?

    public init(coreCount: Integer? = nil,
                threadsPerCore: Integer? = nil) {
        self.coreCount = coreCount
        self.threadsPerCore = threadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case coreCount
        case threadsPerCore
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateCpuOptionsRequest: Codable, Equatable {
    public var coreCount: Integer?
    public var threadsPerCore: Integer?

    public init(coreCount: Integer? = nil,
                threadsPerCore: Integer? = nil) {
        self.coreCount = coreCount
        self.threadsPerCore = threadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case coreCount = "CoreCount"
        case threadsPerCore = "ThreadsPerCore"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateEbsBlockDevice: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var kmsKeyId: KmsKeyId?
    public var snapshotId: SnapshotId?
    public var throughput: Integer?
    public var volumeSize: Integer?
    public var volumeType: VolumeType?

    public init(deleteOnTermination: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: KmsKeyId? = nil,
                snapshotId: SnapshotId? = nil,
                throughput: Integer? = nil,
                volumeSize: Integer? = nil,
                volumeType: VolumeType? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.snapshotId = snapshotId
        self.throughput = throughput
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination
        case encrypted
        case iops
        case kmsKeyId
        case snapshotId
        case throughput
        case volumeSize
        case volumeType
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateEbsBlockDeviceRequest: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var kmsKeyId: KmsKeyId?
    public var snapshotId: SnapshotId?
    public var throughput: Integer?
    public var volumeSize: Integer?
    public var volumeType: VolumeType?

    public init(deleteOnTermination: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: KmsKeyId? = nil,
                snapshotId: SnapshotId? = nil,
                throughput: Integer? = nil,
                volumeSize: Integer? = nil,
                volumeType: VolumeType? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.snapshotId = snapshotId
        self.throughput = throughput
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination = "DeleteOnTermination"
        case encrypted = "Encrypted"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case snapshotId = "SnapshotId"
        case throughput = "Throughput"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateElasticInferenceAccelerator: Codable, Equatable {
    public var count: LaunchTemplateElasticInferenceAcceleratorCount?
    public var type: String

    public init(count: LaunchTemplateElasticInferenceAcceleratorCount? = nil,
                type: String) {
        self.count = count
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case type = "Type"
    }

    public func validate() throws {
        try count?.validateAsLaunchTemplateElasticInferenceAcceleratorCount()
    }
}

public struct LaunchTemplateElasticInferenceAcceleratorResponse: Codable, Equatable {
    public var count: Integer?
    public var type: String?

    public init(count: Integer? = nil,
                type: String? = nil) {
        self.count = count
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case count
        case type
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateEnclaveOptions: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateEnclaveOptionsRequest: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateHibernationOptions: Codable, Equatable {
    public var configured: Boolean?

    public init(configured: Boolean? = nil) {
        self.configured = configured
    }

    enum CodingKeys: String, CodingKey {
        case configured
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateHibernationOptionsRequest: Codable, Equatable {
    public var configured: Boolean?

    public init(configured: Boolean? = nil) {
        self.configured = configured
    }

    enum CodingKeys: String, CodingKey {
        case configured = "Configured"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateIamInstanceProfileSpecification: Codable, Equatable {
    public var arn: String?
    public var name: String?

    public init(arn: String? = nil,
                name: String? = nil) {
        self.arn = arn
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case name
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateIamInstanceProfileSpecificationRequest: Codable, Equatable {
    public var arn: String?
    public var name: String?

    public init(arn: String? = nil,
                name: String? = nil) {
        self.arn = arn
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceMaintenanceOptions: Codable, Equatable {
    public var autoRecovery: LaunchTemplateAutoRecoveryState?

    public init(autoRecovery: LaunchTemplateAutoRecoveryState? = nil) {
        self.autoRecovery = autoRecovery
    }

    enum CodingKeys: String, CodingKey {
        case autoRecovery
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceMaintenanceOptionsRequest: Codable, Equatable {
    public var autoRecovery: LaunchTemplateAutoRecoveryState?

    public init(autoRecovery: LaunchTemplateAutoRecoveryState? = nil) {
        self.autoRecovery = autoRecovery
    }

    enum CodingKeys: String, CodingKey {
        case autoRecovery = "AutoRecovery"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceMarketOptions: Codable, Equatable {
    public var marketType: MarketType?
    public var spotOptions: LaunchTemplateSpotMarketOptions?

    public init(marketType: MarketType? = nil,
                spotOptions: LaunchTemplateSpotMarketOptions? = nil) {
        self.marketType = marketType
        self.spotOptions = spotOptions
    }

    enum CodingKeys: String, CodingKey {
        case marketType
        case spotOptions
    }

    public func validate() throws {
        try spotOptions?.validate()
    }
}

public struct LaunchTemplateInstanceMarketOptionsRequest: Codable, Equatable {
    public var marketType: MarketType?
    public var spotOptions: LaunchTemplateSpotMarketOptionsRequest?

    public init(marketType: MarketType? = nil,
                spotOptions: LaunchTemplateSpotMarketOptionsRequest? = nil) {
        self.marketType = marketType
        self.spotOptions = spotOptions
    }

    enum CodingKeys: String, CodingKey {
        case marketType = "MarketType"
        case spotOptions = "SpotOptions"
    }

    public func validate() throws {
        try spotOptions?.validate()
    }
}

public struct LaunchTemplateInstanceMetadataOptions: Codable, Equatable {
    public var httpEndpoint: LaunchTemplateInstanceMetadataEndpointState?
    public var httpProtocolIpv6: LaunchTemplateInstanceMetadataProtocolIpv6?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: LaunchTemplateHttpTokensState?
    public var instanceMetadataTags: LaunchTemplateInstanceMetadataTagsState?
    public var state: LaunchTemplateInstanceMetadataOptionsState?

    public init(httpEndpoint: LaunchTemplateInstanceMetadataEndpointState? = nil,
                httpProtocolIpv6: LaunchTemplateInstanceMetadataProtocolIpv6? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: LaunchTemplateHttpTokensState? = nil,
                instanceMetadataTags: LaunchTemplateInstanceMetadataTagsState? = nil,
                state: LaunchTemplateInstanceMetadataOptionsState? = nil) {
        self.httpEndpoint = httpEndpoint
        self.httpProtocolIpv6 = httpProtocolIpv6
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
        self.instanceMetadataTags = instanceMetadataTags
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case httpEndpoint
        case httpProtocolIpv6
        case httpPutResponseHopLimit
        case httpTokens
        case instanceMetadataTags
        case state
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceMetadataOptionsRequest: Codable, Equatable {
    public var httpEndpoint: LaunchTemplateInstanceMetadataEndpointState?
    public var httpProtocolIpv6: LaunchTemplateInstanceMetadataProtocolIpv6?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: LaunchTemplateHttpTokensState?
    public var instanceMetadataTags: LaunchTemplateInstanceMetadataTagsState?

    public init(httpEndpoint: LaunchTemplateInstanceMetadataEndpointState? = nil,
                httpProtocolIpv6: LaunchTemplateInstanceMetadataProtocolIpv6? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: LaunchTemplateHttpTokensState? = nil,
                instanceMetadataTags: LaunchTemplateInstanceMetadataTagsState? = nil) {
        self.httpEndpoint = httpEndpoint
        self.httpProtocolIpv6 = httpProtocolIpv6
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
        self.instanceMetadataTags = instanceMetadataTags
    }

    enum CodingKeys: String, CodingKey {
        case httpEndpoint = "HttpEndpoint"
        case httpProtocolIpv6 = "HttpProtocolIpv6"
        case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
        case httpTokens = "HttpTokens"
        case instanceMetadataTags = "InstanceMetadataTags"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceNetworkInterfaceSpecification: Codable, Equatable {
    public var associateCarrierIpAddress: Boolean?
    public var associatePublicIpAddress: Boolean?
    public var deleteOnTermination: Boolean?
    public var description: String?
    public var deviceIndex: Integer?
    public var groups: GroupIdStringList?
    public var interfaceType: String?
    public var ipv4PrefixCount: Integer?
    public var ipv4Prefixes: Ipv4PrefixListResponse?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var ipv6PrefixCount: Integer?
    public var ipv6Prefixes: Ipv6PrefixListResponse?
    public var networkCardIndex: Integer?
    public var networkInterfaceId: NetworkInterfaceId?
    public var privateIpAddress: String?
    public var privateIpAddresses: PrivateIpAddressSpecificationList?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: SubnetId?

    public init(associateCarrierIpAddress: Boolean? = nil,
                associatePublicIpAddress: Boolean? = nil,
                deleteOnTermination: Boolean? = nil,
                description: String? = nil,
                deviceIndex: Integer? = nil,
                groups: GroupIdStringList? = nil,
                interfaceType: String? = nil,
                ipv4PrefixCount: Integer? = nil,
                ipv4Prefixes: Ipv4PrefixListResponse? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                ipv6PrefixCount: Integer? = nil,
                ipv6Prefixes: Ipv6PrefixListResponse? = nil,
                networkCardIndex: Integer? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: PrivateIpAddressSpecificationList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: SubnetId? = nil) {
        self.associateCarrierIpAddress = associateCarrierIpAddress
        self.associatePublicIpAddress = associatePublicIpAddress
        self.deleteOnTermination = deleteOnTermination
        self.description = description
        self.deviceIndex = deviceIndex
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv4PrefixCount = ipv4PrefixCount
        self.ipv4Prefixes = ipv4Prefixes
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.ipv6PrefixCount = ipv6PrefixCount
        self.ipv6Prefixes = ipv6Prefixes
        self.networkCardIndex = networkCardIndex
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associateCarrierIpAddress
        case associatePublicIpAddress
        case deleteOnTermination
        case description
        case deviceIndex
        case groups = "groupSet"
        case interfaceType
        case ipv4PrefixCount
        case ipv4Prefixes = "ipv4PrefixSet"
        case ipv6AddressCount
        case ipv6Addresses = "ipv6AddressesSet"
        case ipv6PrefixCount
        case ipv6Prefixes = "ipv6PrefixSet"
        case networkCardIndex
        case networkInterfaceId
        case privateIpAddress
        case privateIpAddresses = "privateIpAddressesSet"
        case secondaryPrivateIpAddressCount
        case subnetId
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateInstanceNetworkInterfaceSpecificationRequest: Codable, Equatable {
    public var associateCarrierIpAddress: Boolean?
    public var associatePublicIpAddress: Boolean?
    public var deleteOnTermination: Boolean?
    public var description: String?
    public var deviceIndex: Integer?
    public var groups: SecurityGroupIdStringList?
    public var interfaceType: String?
    public var ipv4PrefixCount: Integer?
    public var ipv4Prefixes: Ipv4PrefixList?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressListRequest?
    public var ipv6PrefixCount: Integer?
    public var ipv6Prefixes: Ipv6PrefixList?
    public var networkCardIndex: Integer?
    public var networkInterfaceId: NetworkInterfaceId?
    public var privateIpAddress: String?
    public var privateIpAddresses: PrivateIpAddressSpecificationList?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: SubnetId?

    public init(associateCarrierIpAddress: Boolean? = nil,
                associatePublicIpAddress: Boolean? = nil,
                deleteOnTermination: Boolean? = nil,
                description: String? = nil,
                deviceIndex: Integer? = nil,
                groups: SecurityGroupIdStringList? = nil,
                interfaceType: String? = nil,
                ipv4PrefixCount: Integer? = nil,
                ipv4Prefixes: Ipv4PrefixList? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressListRequest? = nil,
                ipv6PrefixCount: Integer? = nil,
                ipv6Prefixes: Ipv6PrefixList? = nil,
                networkCardIndex: Integer? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: PrivateIpAddressSpecificationList? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: SubnetId? = nil) {
        self.associateCarrierIpAddress = associateCarrierIpAddress
        self.associatePublicIpAddress = associatePublicIpAddress
        self.deleteOnTermination = deleteOnTermination
        self.description = description
        self.deviceIndex = deviceIndex
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv4PrefixCount = ipv4PrefixCount
        self.ipv4Prefixes = ipv4Prefixes
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.ipv6PrefixCount = ipv6PrefixCount
        self.ipv6Prefixes = ipv6Prefixes
        self.networkCardIndex = networkCardIndex
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associateCarrierIpAddress = "AssociateCarrierIpAddress"
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case deleteOnTermination = "DeleteOnTermination"
        case description = "Description"
        case deviceIndex = "DeviceIndex"
        case groups = "SecurityGroupId"
        case interfaceType = "InterfaceType"
        case ipv4PrefixCount = "Ipv4PrefixCount"
        case ipv4Prefixes = "Ipv4Prefix"
        case ipv6AddressCount = "Ipv6AddressCount"
        case ipv6Addresses = "Ipv6Addresses"
        case ipv6PrefixCount = "Ipv6PrefixCount"
        case ipv6Prefixes = "Ipv6Prefix"
        case networkCardIndex = "NetworkCardIndex"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddress = "PrivateIpAddress"
        case privateIpAddresses = "PrivateIpAddresses"
        case secondaryPrivateIpAddressCount = "SecondaryPrivateIpAddressCount"
        case subnetId = "SubnetId"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateLicenseConfiguration: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateLicenseConfigurationRequest: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateOverrides: Codable, Equatable {
    public var availabilityZone: String?
    public var instanceRequirements: InstanceRequirements?
    public var instanceType: InstanceType?
    public var priority: Double?
    public var spotPrice: String?
    public var subnetId: SubnetId?
    public var weightedCapacity: Double?

    public init(availabilityZone: String? = nil,
                instanceRequirements: InstanceRequirements? = nil,
                instanceType: InstanceType? = nil,
                priority: Double? = nil,
                spotPrice: String? = nil,
                subnetId: SubnetId? = nil,
                weightedCapacity: Double? = nil) {
        self.availabilityZone = availabilityZone
        self.instanceRequirements = instanceRequirements
        self.instanceType = instanceType
        self.priority = priority
        self.spotPrice = spotPrice
        self.subnetId = subnetId
        self.weightedCapacity = weightedCapacity
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case instanceRequirements
        case instanceType
        case priority
        case spotPrice
        case subnetId
        case weightedCapacity
    }

    public func validate() throws {
        try instanceRequirements?.validate()
    }
}

public struct LaunchTemplatePlacement: Codable, Equatable {
    public var affinity: String?
    public var availabilityZone: String?
    public var groupId: PlacementGroupId?
    public var groupName: String?
    public var hostId: String?
    public var hostResourceGroupArn: String?
    public var partitionNumber: Integer?
    public var spreadDomain: String?
    public var tenancy: Tenancy?

    public init(affinity: String? = nil,
                availabilityZone: String? = nil,
                groupId: PlacementGroupId? = nil,
                groupName: String? = nil,
                hostId: String? = nil,
                hostResourceGroupArn: String? = nil,
                partitionNumber: Integer? = nil,
                spreadDomain: String? = nil,
                tenancy: Tenancy? = nil) {
        self.affinity = affinity
        self.availabilityZone = availabilityZone
        self.groupId = groupId
        self.groupName = groupName
        self.hostId = hostId
        self.hostResourceGroupArn = hostResourceGroupArn
        self.partitionNumber = partitionNumber
        self.spreadDomain = spreadDomain
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case affinity
        case availabilityZone
        case groupId
        case groupName
        case hostId
        case hostResourceGroupArn
        case partitionNumber
        case spreadDomain
        case tenancy
    }

    public func validate() throws {
    }
}

public struct LaunchTemplatePlacementRequest: Codable, Equatable {
    public var affinity: String?
    public var availabilityZone: String?
    public var groupId: PlacementGroupId?
    public var groupName: PlacementGroupName?
    public var hostId: DedicatedHostId?
    public var hostResourceGroupArn: String?
    public var partitionNumber: Integer?
    public var spreadDomain: String?
    public var tenancy: Tenancy?

    public init(affinity: String? = nil,
                availabilityZone: String? = nil,
                groupId: PlacementGroupId? = nil,
                groupName: PlacementGroupName? = nil,
                hostId: DedicatedHostId? = nil,
                hostResourceGroupArn: String? = nil,
                partitionNumber: Integer? = nil,
                spreadDomain: String? = nil,
                tenancy: Tenancy? = nil) {
        self.affinity = affinity
        self.availabilityZone = availabilityZone
        self.groupId = groupId
        self.groupName = groupName
        self.hostId = hostId
        self.hostResourceGroupArn = hostResourceGroupArn
        self.partitionNumber = partitionNumber
        self.spreadDomain = spreadDomain
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case affinity = "Affinity"
        case availabilityZone = "AvailabilityZone"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case hostId = "HostId"
        case hostResourceGroupArn = "HostResourceGroupArn"
        case partitionNumber = "PartitionNumber"
        case spreadDomain = "SpreadDomain"
        case tenancy = "Tenancy"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplatePrivateDnsNameOptions: Codable, Equatable {
    public var enableResourceNameDnsAAAARecord: Boolean?
    public var enableResourceNameDnsARecord: Boolean?
    public var hostnameType: HostnameType?

    public init(enableResourceNameDnsAAAARecord: Boolean? = nil,
                enableResourceNameDnsARecord: Boolean? = nil,
                hostnameType: HostnameType? = nil) {
        self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
        self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
        self.hostnameType = hostnameType
    }

    enum CodingKeys: String, CodingKey {
        case enableResourceNameDnsAAAARecord
        case enableResourceNameDnsARecord
        case hostnameType
    }

    public func validate() throws {
    }
}

public struct LaunchTemplatePrivateDnsNameOptionsRequest: Codable, Equatable {
    public var enableResourceNameDnsAAAARecord: Boolean?
    public var enableResourceNameDnsARecord: Boolean?
    public var hostnameType: HostnameType?

    public init(enableResourceNameDnsAAAARecord: Boolean? = nil,
                enableResourceNameDnsARecord: Boolean? = nil,
                hostnameType: HostnameType? = nil) {
        self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
        self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
        self.hostnameType = hostnameType
    }

    enum CodingKeys: String, CodingKey {
        case enableResourceNameDnsAAAARecord = "EnableResourceNameDnsAAAARecord"
        case enableResourceNameDnsARecord = "EnableResourceNameDnsARecord"
        case hostnameType = "HostnameType"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateSpecification: Codable, Equatable {
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: String?
    public var version: String?

    public init(launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: String? = nil,
                version: String? = nil) {
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case version = "Version"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateSpotMarketOptions: Codable, Equatable {
    public var blockDurationMinutes: Integer?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var maxPrice: String?
    public var spotInstanceType: SpotInstanceType?
    public var validUntil: DateTime?

    public init(blockDurationMinutes: Integer? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                maxPrice: String? = nil,
                spotInstanceType: SpotInstanceType? = nil,
                validUntil: DateTime? = nil) {
        self.blockDurationMinutes = blockDurationMinutes
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.maxPrice = maxPrice
        self.spotInstanceType = spotInstanceType
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case blockDurationMinutes
        case instanceInterruptionBehavior
        case maxPrice
        case spotInstanceType
        case validUntil
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateSpotMarketOptionsRequest: Codable, Equatable {
    public var blockDurationMinutes: Integer?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var maxPrice: String?
    public var spotInstanceType: SpotInstanceType?
    public var validUntil: DateTime?

    public init(blockDurationMinutes: Integer? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                maxPrice: String? = nil,
                spotInstanceType: SpotInstanceType? = nil,
                validUntil: DateTime? = nil) {
        self.blockDurationMinutes = blockDurationMinutes
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.maxPrice = maxPrice
        self.spotInstanceType = spotInstanceType
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case blockDurationMinutes = "BlockDurationMinutes"
        case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
        case maxPrice = "MaxPrice"
        case spotInstanceType = "SpotInstanceType"
        case validUntil = "ValidUntil"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateTagSpecification: Codable, Equatable {
    public var resourceType: ResourceType?
    public var tags: TagList?

    public init(resourceType: ResourceType? = nil,
                tags: TagList? = nil) {
        self.resourceType = resourceType
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case resourceType
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateTagSpecificationRequest: Codable, Equatable {
    public var resourceType: ResourceType?
    public var tags: TagList?

    public init(resourceType: ResourceType? = nil,
                tags: TagList? = nil) {
        self.resourceType = resourceType
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case resourceType = "ResourceType"
        case tags = "Tag"
    }

    public func validate() throws {
    }
}

public struct LaunchTemplateVersion: Codable, Equatable {
    public var createTime: DateTime?
    public var createdBy: String?
    public var defaultVersion: Boolean?
    public var launchTemplateData: ResponseLaunchTemplateData?
    public var launchTemplateId: String?
    public var launchTemplateName: LaunchTemplateName?
    public var versionDescription: VersionDescription?
    public var versionNumber: Long?

    public init(createTime: DateTime? = nil,
                createdBy: String? = nil,
                defaultVersion: Boolean? = nil,
                launchTemplateData: ResponseLaunchTemplateData? = nil,
                launchTemplateId: String? = nil,
                launchTemplateName: LaunchTemplateName? = nil,
                versionDescription: VersionDescription? = nil,
                versionNumber: Long? = nil) {
        self.createTime = createTime
        self.createdBy = createdBy
        self.defaultVersion = defaultVersion
        self.launchTemplateData = launchTemplateData
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
        self.versionDescription = versionDescription
        self.versionNumber = versionNumber
    }

    enum CodingKeys: String, CodingKey {
        case createTime
        case createdBy
        case defaultVersion
        case launchTemplateData
        case launchTemplateId
        case launchTemplateName
        case versionDescription
        case versionNumber
    }

    public func validate() throws {
        try launchTemplateData?.validate()
        try launchTemplateName?.validateAsLaunchTemplateName()
        try versionDescription?.validateAsVersionDescription()
    }
}

public struct LaunchTemplatesMonitoring: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct LaunchTemplatesMonitoringRequest: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct LicenseConfiguration: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn
    }

    public func validate() throws {
    }
}

public struct LicenseConfigurationRequest: Codable, Equatable {
    public var licenseConfigurationArn: String?

    public init(licenseConfigurationArn: String? = nil) {
        self.licenseConfigurationArn = licenseConfigurationArn
    }

    enum CodingKeys: String, CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func validate() throws {
    }
}

public struct ListImagesInRecycleBinRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var imageIds: ImageIdStringList?
    public var maxResults: ListImagesInRecycleBinMaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                imageIds: ImageIdStringList? = nil,
                maxResults: ListImagesInRecycleBinMaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case imageIds = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
        try maxResults?.validateAsListImagesInRecycleBinMaxResults()
    }
}

public struct ListImagesInRecycleBinResult: Codable, Equatable {
    public var images: ImageRecycleBinInfoList?
    public var nextToken: String?

    public init(images: ImageRecycleBinInfoList? = nil,
                nextToken: String? = nil) {
        self.images = images
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case images = "imageSet"
        case nextToken
    }

    public func validate() throws {
    }
}

public struct ListSnapshotsInRecycleBinRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var maxResults: ListSnapshotsInRecycleBinMaxResults?
    public var nextToken: String?
    public var snapshotIds: SnapshotIdStringList?

    public init(dryRun: Boolean? = nil,
                maxResults: ListSnapshotsInRecycleBinMaxResults? = nil,
                nextToken: String? = nil,
                snapshotIds: SnapshotIdStringList? = nil) {
        self.dryRun = dryRun
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.snapshotIds = snapshotIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case snapshotIds = "SnapshotId"
    }

    public func validate() throws {
        try maxResults?.validateAsListSnapshotsInRecycleBinMaxResults()
    }
}

public struct ListSnapshotsInRecycleBinResult: Codable, Equatable {
    public var nextToken: String?
    public var snapshots: SnapshotRecycleBinInfoList?

    public init(nextToken: String? = nil,
                snapshots: SnapshotRecycleBinInfoList? = nil) {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case snapshots = "snapshotSet"
    }

    public func validate() throws {
    }
}

public struct LoadBalancersConfig: Codable, Equatable {
    public var classicLoadBalancersConfig: ClassicLoadBalancersConfig?
    public var targetGroupsConfig: TargetGroupsConfig?

    public init(classicLoadBalancersConfig: ClassicLoadBalancersConfig? = nil,
                targetGroupsConfig: TargetGroupsConfig? = nil) {
        self.classicLoadBalancersConfig = classicLoadBalancersConfig
        self.targetGroupsConfig = targetGroupsConfig
    }

    enum CodingKeys: String, CodingKey {
        case classicLoadBalancersConfig
        case targetGroupsConfig
    }

    public func validate() throws {
        try classicLoadBalancersConfig?.validate()
        try targetGroupsConfig?.validate()
    }
}

public struct LoadPermission: Codable, Equatable {
    public var group: PermissionGroup?
    public var userId: String?

    public init(group: PermissionGroup? = nil,
                userId: String? = nil) {
        self.group = group
        self.userId = userId
    }

    enum CodingKeys: String, CodingKey {
        case group
        case userId
    }

    public func validate() throws {
    }
}

public struct LoadPermissionModifications: Codable, Equatable {
    public var add: LoadPermissionListRequest?
    public var remove: LoadPermissionListRequest?

    public init(add: LoadPermissionListRequest? = nil,
                remove: LoadPermissionListRequest? = nil) {
        self.add = add
        self.remove = remove
    }

    enum CodingKeys: String, CodingKey {
        case add = "Add"
        case remove = "Remove"
    }

    public func validate() throws {
    }
}

public struct LoadPermissionRequest: Codable, Equatable {
    public var group: PermissionGroup?
    public var userId: String?

    public init(group: PermissionGroup? = nil,
                userId: String? = nil) {
        self.group = group
        self.userId = userId
    }

    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case userId = "UserId"
    }

    public func validate() throws {
    }
}

public struct LocalGateway: Codable, Equatable {
    public var localGatewayId: LocalGatewayId?
    public var outpostArn: String?
    public var ownerId: String?
    public var state: String?
    public var tags: TagList?

    public init(localGatewayId: LocalGatewayId? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                state: String? = nil,
                tags: TagList? = nil) {
        self.localGatewayId = localGatewayId
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case outpostArn
        case ownerId
        case state
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct LocalGatewayRoute: Codable, Equatable {
    public var coipPoolId: CoipPoolId?
    public var destinationCidrBlock: String?
    public var localGatewayRouteTableArn: ResourceArn?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId?
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId?
    public var networkInterfaceId: NetworkInterfaceId?
    public var ownerId: String?
    public var state: LocalGatewayRouteState?
    public var subnetId: SubnetId?
    public var type: LocalGatewayRouteType?

    public init(coipPoolId: CoipPoolId? = nil,
                destinationCidrBlock: String? = nil,
                localGatewayRouteTableArn: ResourceArn? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId? = nil,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                ownerId: String? = nil,
                state: LocalGatewayRouteState? = nil,
                subnetId: SubnetId? = nil,
                type: LocalGatewayRouteType? = nil) {
        self.coipPoolId = coipPoolId
        self.destinationCidrBlock = destinationCidrBlock
        self.localGatewayRouteTableArn = localGatewayRouteTableArn
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
        self.networkInterfaceId = networkInterfaceId
        self.ownerId = ownerId
        self.state = state
        self.subnetId = subnetId
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case coipPoolId
        case destinationCidrBlock
        case localGatewayRouteTableArn
        case localGatewayRouteTableId
        case localGatewayVirtualInterfaceGroupId
        case networkInterfaceId
        case ownerId
        case state
        case subnetId
        case type
    }

    public func validate() throws {
        try localGatewayRouteTableArn?.validateAsResourceArn()
    }
}

public struct LocalGatewayRouteTable: Codable, Equatable {
    public var localGatewayId: LocalGatewayId?
    public var localGatewayRouteTableArn: ResourceArn?
    public var localGatewayRouteTableId: String?
    public var mode: LocalGatewayRouteTableMode?
    public var outpostArn: String?
    public var ownerId: String?
    public var state: String?
    public var stateReason: StateReason?
    public var tags: TagList?

    public init(localGatewayId: LocalGatewayId? = nil,
                localGatewayRouteTableArn: ResourceArn? = nil,
                localGatewayRouteTableId: String? = nil,
                mode: LocalGatewayRouteTableMode? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                state: String? = nil,
                stateReason: StateReason? = nil,
                tags: TagList? = nil) {
        self.localGatewayId = localGatewayId
        self.localGatewayRouteTableArn = localGatewayRouteTableArn
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.mode = mode
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.state = state
        self.stateReason = stateReason
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case localGatewayRouteTableArn
        case localGatewayRouteTableId
        case mode
        case outpostArn
        case ownerId
        case state
        case stateReason
        case tags = "tagSet"
    }

    public func validate() throws {
        try localGatewayRouteTableArn?.validateAsResourceArn()
        try stateReason?.validate()
    }
}

public struct LocalGatewayRouteTableVirtualInterfaceGroupAssociation: Codable, Equatable {
    public var localGatewayId: String?
    public var localGatewayRouteTableArn: ResourceArn?
    public var localGatewayRouteTableId: LocalGatewayId?
    public var localGatewayRouteTableVirtualInterfaceGroupAssociationId: LocalGatewayRouteTableVirtualInterfaceGroupAssociationId?
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId?
    public var ownerId: String?
    public var state: String?
    public var tags: TagList?

    public init(localGatewayId: String? = nil,
                localGatewayRouteTableArn: ResourceArn? = nil,
                localGatewayRouteTableId: LocalGatewayId? = nil,
                localGatewayRouteTableVirtualInterfaceGroupAssociationId: LocalGatewayRouteTableVirtualInterfaceGroupAssociationId? = nil,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId? = nil,
                ownerId: String? = nil,
                state: String? = nil,
                tags: TagList? = nil) {
        self.localGatewayId = localGatewayId
        self.localGatewayRouteTableArn = localGatewayRouteTableArn
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayRouteTableVirtualInterfaceGroupAssociationId = localGatewayRouteTableVirtualInterfaceGroupAssociationId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case localGatewayRouteTableArn
        case localGatewayRouteTableId
        case localGatewayRouteTableVirtualInterfaceGroupAssociationId
        case localGatewayVirtualInterfaceGroupId
        case ownerId
        case state
        case tags = "tagSet"
    }

    public func validate() throws {
        try localGatewayRouteTableArn?.validateAsResourceArn()
    }
}

public struct LocalGatewayRouteTableVpcAssociation: Codable, Equatable {
    public var localGatewayId: String?
    public var localGatewayRouteTableArn: ResourceArn?
    public var localGatewayRouteTableId: String?
    public var localGatewayRouteTableVpcAssociationId: LocalGatewayRouteTableVpcAssociationId?
    public var ownerId: String?
    public var state: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(localGatewayId: String? = nil,
                localGatewayRouteTableArn: ResourceArn? = nil,
                localGatewayRouteTableId: String? = nil,
                localGatewayRouteTableVpcAssociationId: LocalGatewayRouteTableVpcAssociationId? = nil,
                ownerId: String? = nil,
                state: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.localGatewayId = localGatewayId
        self.localGatewayRouteTableArn = localGatewayRouteTableArn
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayRouteTableVpcAssociationId = localGatewayRouteTableVpcAssociationId
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case localGatewayRouteTableArn
        case localGatewayRouteTableId
        case localGatewayRouteTableVpcAssociationId
        case ownerId
        case state
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
        try localGatewayRouteTableArn?.validateAsResourceArn()
    }
}

public struct LocalGatewayVirtualInterface: Codable, Equatable {
    public var localAddress: String?
    public var localBgpAsn: Integer?
    public var localGatewayId: String?
    public var localGatewayVirtualInterfaceId: LocalGatewayVirtualInterfaceId?
    public var ownerId: String?
    public var peerAddress: String?
    public var peerBgpAsn: Integer?
    public var tags: TagList?
    public var vlan: Integer?

    public init(localAddress: String? = nil,
                localBgpAsn: Integer? = nil,
                localGatewayId: String? = nil,
                localGatewayVirtualInterfaceId: LocalGatewayVirtualInterfaceId? = nil,
                ownerId: String? = nil,
                peerAddress: String? = nil,
                peerBgpAsn: Integer? = nil,
                tags: TagList? = nil,
                vlan: Integer? = nil) {
        self.localAddress = localAddress
        self.localBgpAsn = localBgpAsn
        self.localGatewayId = localGatewayId
        self.localGatewayVirtualInterfaceId = localGatewayVirtualInterfaceId
        self.ownerId = ownerId
        self.peerAddress = peerAddress
        self.peerBgpAsn = peerBgpAsn
        self.tags = tags
        self.vlan = vlan
    }

    enum CodingKeys: String, CodingKey {
        case localAddress
        case localBgpAsn
        case localGatewayId
        case localGatewayVirtualInterfaceId
        case ownerId
        case peerAddress
        case peerBgpAsn
        case tags = "tagSet"
        case vlan
    }

    public func validate() throws {
    }
}

public struct LocalGatewayVirtualInterfaceGroup: Codable, Equatable {
    public var localGatewayId: String?
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId?
    public var localGatewayVirtualInterfaceIds: LocalGatewayVirtualInterfaceIdSet?
    public var ownerId: String?
    public var tags: TagList?

    public init(localGatewayId: String? = nil,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId? = nil,
                localGatewayVirtualInterfaceIds: LocalGatewayVirtualInterfaceIdSet? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil) {
        self.localGatewayId = localGatewayId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
        self.localGatewayVirtualInterfaceIds = localGatewayVirtualInterfaceIds
        self.ownerId = ownerId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case localGatewayId
        case localGatewayVirtualInterfaceGroupId
        case localGatewayVirtualInterfaceIds = "localGatewayVirtualInterfaceIdSet"
        case ownerId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct ManagedPrefixList: Codable, Equatable {
    public var addressFamily: String?
    public var maxEntries: Integer?
    public var ownerId: String?
    public var prefixListArn: ResourceArn?
    public var prefixListId: PrefixListResourceId?
    public var prefixListName: String?
    public var state: PrefixListState?
    public var stateMessage: String?
    public var tags: TagList?
    public var version: Long?

    public init(addressFamily: String? = nil,
                maxEntries: Integer? = nil,
                ownerId: String? = nil,
                prefixListArn: ResourceArn? = nil,
                prefixListId: PrefixListResourceId? = nil,
                prefixListName: String? = nil,
                state: PrefixListState? = nil,
                stateMessage: String? = nil,
                tags: TagList? = nil,
                version: Long? = nil) {
        self.addressFamily = addressFamily
        self.maxEntries = maxEntries
        self.ownerId = ownerId
        self.prefixListArn = prefixListArn
        self.prefixListId = prefixListId
        self.prefixListName = prefixListName
        self.state = state
        self.stateMessage = stateMessage
        self.tags = tags
        self.version = version
    }

    enum CodingKeys: String, CodingKey {
        case addressFamily
        case maxEntries
        case ownerId
        case prefixListArn
        case prefixListId
        case prefixListName
        case state
        case stateMessage
        case tags = "tagSet"
        case version
    }

    public func validate() throws {
        try prefixListArn?.validateAsResourceArn()
    }
}

public struct MemoryGiBPerVCpu: Codable, Equatable {
    public var max: Double?
    public var min: Double?

    public init(max: Double? = nil,
                min: Double? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max
        case min
    }

    public func validate() throws {
    }
}

public struct MemoryGiBPerVCpuRequest: Codable, Equatable {
    public var max: Double?
    public var min: Double?

    public init(max: Double? = nil,
                min: Double? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func validate() throws {
    }
}

public struct MemoryInfo: Codable, Equatable {
    public var sizeInMiB: MemorySize?

    public init(sizeInMiB: MemorySize? = nil) {
        self.sizeInMiB = sizeInMiB
    }

    enum CodingKeys: String, CodingKey {
        case sizeInMiB
    }

    public func validate() throws {
    }
}

public struct MemoryMiB: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max
        case min
    }

    public func validate() throws {
    }
}

public struct MemoryMiBRequest: Codable, Equatable {
    public var max: Integer?
    public var min: Integer

    public init(max: Integer? = nil,
                min: Integer) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func validate() throws {
    }
}

public struct MetricPoint: Codable, Equatable {
    public var endDate: MillisecondDateTime?
    public var startDate: MillisecondDateTime?
    public var status: String?
    public var value: Float?

    public init(endDate: MillisecondDateTime? = nil,
                startDate: MillisecondDateTime? = nil,
                status: String? = nil,
                value: Float? = nil) {
        self.endDate = endDate
        self.startDate = startDate
        self.status = status
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case endDate
        case startDate
        case status
        case value
    }

    public func validate() throws {
    }
}

public struct ModifyAddressAttributeRequest: Codable, Equatable {
    public var allocationId: AllocationId
    public var domainName: String?
    public var dryRun: Boolean?

    public init(allocationId: AllocationId,
                domainName: String? = nil,
                dryRun: Boolean? = nil) {
        self.allocationId = allocationId
        self.domainName = domainName
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case domainName = "DomainName"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ModifyAddressAttributeResult: Codable, Equatable {
    public var address: AddressAttribute?

    public init(address: AddressAttribute? = nil) {
        self.address = address
    }

    enum CodingKeys: String, CodingKey {
        case address
    }

    public func validate() throws {
        try address?.validate()
    }
}

public struct ModifyAvailabilityZoneGroupRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupName: String
    public var optInStatus: ModifyAvailabilityZoneOptInStatus

    public init(dryRun: Boolean? = nil,
                groupName: String,
                optInStatus: ModifyAvailabilityZoneOptInStatus) {
        self.dryRun = dryRun
        self.groupName = groupName
        self.optInStatus = optInStatus
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupName = "GroupName"
        case optInStatus = "OptInStatus"
    }

    public func validate() throws {
    }
}

public struct ModifyAvailabilityZoneGroupResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyCapacityReservationFleetRequest: Codable, Equatable {
    public var capacityReservationFleetId: CapacityReservationFleetId
    public var dryRun: Boolean?
    public var endDate: MillisecondDateTime?
    public var removeEndDate: Boolean?
    public var totalTargetCapacity: Integer?

    public init(capacityReservationFleetId: CapacityReservationFleetId,
                dryRun: Boolean? = nil,
                endDate: MillisecondDateTime? = nil,
                removeEndDate: Boolean? = nil,
                totalTargetCapacity: Integer? = nil) {
        self.capacityReservationFleetId = capacityReservationFleetId
        self.dryRun = dryRun
        self.endDate = endDate
        self.removeEndDate = removeEndDate
        self.totalTargetCapacity = totalTargetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationFleetId = "CapacityReservationFleetId"
        case dryRun = "DryRun"
        case endDate = "EndDate"
        case removeEndDate = "RemoveEndDate"
        case totalTargetCapacity = "TotalTargetCapacity"
    }

    public func validate() throws {
    }
}

public struct ModifyCapacityReservationFleetResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyCapacityReservationRequest: Codable, Equatable {
    public var accept: Boolean?
    public var additionalInfo: String?
    public var capacityReservationId: CapacityReservationId
    public var dryRun: Boolean?
    public var endDate: DateTime?
    public var endDateType: EndDateType?
    public var instanceCount: Integer?

    public init(accept: Boolean? = nil,
                additionalInfo: String? = nil,
                capacityReservationId: CapacityReservationId,
                dryRun: Boolean? = nil,
                endDate: DateTime? = nil,
                endDateType: EndDateType? = nil,
                instanceCount: Integer? = nil) {
        self.accept = accept
        self.additionalInfo = additionalInfo
        self.capacityReservationId = capacityReservationId
        self.dryRun = dryRun
        self.endDate = endDate
        self.endDateType = endDateType
        self.instanceCount = instanceCount
    }

    enum CodingKeys: String, CodingKey {
        case accept = "Accept"
        case additionalInfo = "AdditionalInfo"
        case capacityReservationId = "CapacityReservationId"
        case dryRun = "DryRun"
        case endDate = "EndDate"
        case endDateType = "EndDateType"
        case instanceCount = "InstanceCount"
    }

    public func validate() throws {
    }
}

public struct ModifyCapacityReservationResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyClientVpnEndpointRequest: Codable, Equatable {
    public var clientConnectOptions: ClientConnectOptions?
    public var clientLoginBannerOptions: ClientLoginBannerOptions?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var connectionLogOptions: ConnectionLogOptions?
    public var description: String?
    public var dnsServers: DnsServersOptionsModifyStructure?
    public var dryRun: Boolean?
    public var securityGroupIds: ClientVpnSecurityGroupIdSet?
    public var selfServicePortal: SelfServicePortal?
    public var serverCertificateArn: String?
    public var sessionTimeoutHours: Integer?
    public var splitTunnel: Boolean?
    public var vpcId: VpcId?
    public var vpnPort: Integer?

    public init(clientConnectOptions: ClientConnectOptions? = nil,
                clientLoginBannerOptions: ClientLoginBannerOptions? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                connectionLogOptions: ConnectionLogOptions? = nil,
                description: String? = nil,
                dnsServers: DnsServersOptionsModifyStructure? = nil,
                dryRun: Boolean? = nil,
                securityGroupIds: ClientVpnSecurityGroupIdSet? = nil,
                selfServicePortal: SelfServicePortal? = nil,
                serverCertificateArn: String? = nil,
                sessionTimeoutHours: Integer? = nil,
                splitTunnel: Boolean? = nil,
                vpcId: VpcId? = nil,
                vpnPort: Integer? = nil) {
        self.clientConnectOptions = clientConnectOptions
        self.clientLoginBannerOptions = clientLoginBannerOptions
        self.clientVpnEndpointId = clientVpnEndpointId
        self.connectionLogOptions = connectionLogOptions
        self.description = description
        self.dnsServers = dnsServers
        self.dryRun = dryRun
        self.securityGroupIds = securityGroupIds
        self.selfServicePortal = selfServicePortal
        self.serverCertificateArn = serverCertificateArn
        self.sessionTimeoutHours = sessionTimeoutHours
        self.splitTunnel = splitTunnel
        self.vpcId = vpcId
        self.vpnPort = vpnPort
    }

    enum CodingKeys: String, CodingKey {
        case clientConnectOptions = "ClientConnectOptions"
        case clientLoginBannerOptions = "ClientLoginBannerOptions"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case connectionLogOptions = "ConnectionLogOptions"
        case description = "Description"
        case dnsServers = "DnsServers"
        case dryRun = "DryRun"
        case securityGroupIds = "SecurityGroupId"
        case selfServicePortal = "SelfServicePortal"
        case serverCertificateArn = "ServerCertificateArn"
        case sessionTimeoutHours = "SessionTimeoutHours"
        case splitTunnel = "SplitTunnel"
        case vpcId = "VpcId"
        case vpnPort = "VpnPort"
    }

    public func validate() throws {
        try clientConnectOptions?.validate()
        try clientLoginBannerOptions?.validate()
        try connectionLogOptions?.validate()
        try dnsServers?.validate()
    }
}

public struct ModifyClientVpnEndpointResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyDefaultCreditSpecificationRequest: Codable, Equatable {
    public var cpuCredits: String
    public var dryRun: Boolean?
    public var instanceFamily: UnlimitedSupportedInstanceFamily

    public init(cpuCredits: String,
                dryRun: Boolean? = nil,
                instanceFamily: UnlimitedSupportedInstanceFamily) {
        self.cpuCredits = cpuCredits
        self.dryRun = dryRun
        self.instanceFamily = instanceFamily
    }

    enum CodingKeys: String, CodingKey {
        case cpuCredits = "CpuCredits"
        case dryRun = "DryRun"
        case instanceFamily = "InstanceFamily"
    }

    public func validate() throws {
    }
}

public struct ModifyDefaultCreditSpecificationResult: Codable, Equatable {
    public var instanceFamilyCreditSpecification: InstanceFamilyCreditSpecification?

    public init(instanceFamilyCreditSpecification: InstanceFamilyCreditSpecification? = nil) {
        self.instanceFamilyCreditSpecification = instanceFamilyCreditSpecification
    }

    enum CodingKeys: String, CodingKey {
        case instanceFamilyCreditSpecification
    }

    public func validate() throws {
        try instanceFamilyCreditSpecification?.validate()
    }
}

public struct ModifyEbsDefaultKmsKeyIdRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var kmsKeyId: KmsKeyId

    public init(dryRun: Boolean? = nil,
                kmsKeyId: KmsKeyId) {
        self.dryRun = dryRun
        self.kmsKeyId = kmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case kmsKeyId = "KmsKeyId"
    }

    public func validate() throws {
    }
}

public struct ModifyEbsDefaultKmsKeyIdResult: Codable, Equatable {
    public var kmsKeyId: String?

    public init(kmsKeyId: String? = nil) {
        self.kmsKeyId = kmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case kmsKeyId
    }

    public func validate() throws {
    }
}

public struct ModifyFleetRequest: Codable, Equatable {
    public var context: String?
    public var dryRun: Boolean?
    public var excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy?
    public var fleetId: FleetId
    public var launchTemplateConfigs: FleetLaunchTemplateConfigListRequest?
    public var targetCapacitySpecification: TargetCapacitySpecificationRequest?

    public init(context: String? = nil,
                dryRun: Boolean? = nil,
                excessCapacityTerminationPolicy: FleetExcessCapacityTerminationPolicy? = nil,
                fleetId: FleetId,
                launchTemplateConfigs: FleetLaunchTemplateConfigListRequest? = nil,
                targetCapacitySpecification: TargetCapacitySpecificationRequest? = nil) {
        self.context = context
        self.dryRun = dryRun
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.fleetId = fleetId
        self.launchTemplateConfigs = launchTemplateConfigs
        self.targetCapacitySpecification = targetCapacitySpecification
    }

    enum CodingKeys: String, CodingKey {
        case context = "Context"
        case dryRun = "DryRun"
        case excessCapacityTerminationPolicy = "ExcessCapacityTerminationPolicy"
        case fleetId = "FleetId"
        case launchTemplateConfigs = "LaunchTemplateConfig"
        case targetCapacitySpecification = "TargetCapacitySpecification"
    }

    public func validate() throws {
        try launchTemplateConfigs?.validateAsFleetLaunchTemplateConfigListRequest()
        try targetCapacitySpecification?.validate()
    }
}

public struct ModifyFleetResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyFpgaImageAttributeRequest: Codable, Equatable {
    public var attribute: FpgaImageAttributeName?
    public var description: String?
    public var dryRun: Boolean?
    public var fpgaImageId: FpgaImageId
    public var loadPermission: LoadPermissionModifications?
    public var name: String?
    public var operationType: OperationType?
    public var productCodes: ProductCodeStringList?
    public var userGroups: UserGroupStringList?
    public var userIds: UserIdStringList?

    public init(attribute: FpgaImageAttributeName? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                fpgaImageId: FpgaImageId,
                loadPermission: LoadPermissionModifications? = nil,
                name: String? = nil,
                operationType: OperationType? = nil,
                productCodes: ProductCodeStringList? = nil,
                userGroups: UserGroupStringList? = nil,
                userIds: UserIdStringList? = nil) {
        self.attribute = attribute
        self.description = description
        self.dryRun = dryRun
        self.fpgaImageId = fpgaImageId
        self.loadPermission = loadPermission
        self.name = name
        self.operationType = operationType
        self.productCodes = productCodes
        self.userGroups = userGroups
        self.userIds = userIds
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case description = "Description"
        case dryRun = "DryRun"
        case fpgaImageId = "FpgaImageId"
        case loadPermission = "LoadPermission"
        case name = "Name"
        case operationType = "OperationType"
        case productCodes = "ProductCode"
        case userGroups = "UserGroup"
        case userIds = "UserId"
    }

    public func validate() throws {
        try loadPermission?.validate()
    }
}

public struct ModifyFpgaImageAttributeResult: Codable, Equatable {
    public var fpgaImageAttribute: FpgaImageAttribute?

    public init(fpgaImageAttribute: FpgaImageAttribute? = nil) {
        self.fpgaImageAttribute = fpgaImageAttribute
    }

    enum CodingKeys: String, CodingKey {
        case fpgaImageAttribute
    }

    public func validate() throws {
        try fpgaImageAttribute?.validate()
    }
}

public struct ModifyHostsRequest: Codable, Equatable {
    public var autoPlacement: AutoPlacement?
    public var hostIds: RequestHostIdList
    public var hostRecovery: HostRecovery?
    public var instanceFamily: String?
    public var instanceType: String?

    public init(autoPlacement: AutoPlacement? = nil,
                hostIds: RequestHostIdList,
                hostRecovery: HostRecovery? = nil,
                instanceFamily: String? = nil,
                instanceType: String? = nil) {
        self.autoPlacement = autoPlacement
        self.hostIds = hostIds
        self.hostRecovery = hostRecovery
        self.instanceFamily = instanceFamily
        self.instanceType = instanceType
    }

    enum CodingKeys: String, CodingKey {
        case autoPlacement
        case hostIds = "hostId"
        case hostRecovery = "HostRecovery"
        case instanceFamily = "InstanceFamily"
        case instanceType = "InstanceType"
    }

    public func validate() throws {
    }
}

public struct ModifyHostsResult: Codable, Equatable {
    public var successful: ResponseHostIdList?
    public var unsuccessful: UnsuccessfulItemList?

    public init(successful: ResponseHostIdList? = nil,
                unsuccessful: UnsuccessfulItemList? = nil) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case successful
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct ModifyIdFormatRequest: Codable, Equatable {
    public var resource: String
    public var useLongIds: Boolean

    public init(resource: String,
                useLongIds: Boolean) {
        self.resource = resource
        self.useLongIds = useLongIds
    }

    enum CodingKeys: String, CodingKey {
        case resource = "Resource"
        case useLongIds = "UseLongIds"
    }

    public func validate() throws {
    }
}

public struct ModifyIdentityIdFormatRequest: Codable, Equatable {
    public var principalArn: String
    public var resource: String
    public var useLongIds: Boolean

    public init(principalArn: String,
                resource: String,
                useLongIds: Boolean) {
        self.principalArn = principalArn
        self.resource = resource
        self.useLongIds = useLongIds
    }

    enum CodingKeys: String, CodingKey {
        case principalArn
        case resource
        case useLongIds
    }

    public func validate() throws {
    }
}

public struct ModifyImageAttributeRequest: Codable, Equatable {
    public var attribute: String?
    public var description: AttributeValue?
    public var dryRun: Boolean?
    public var imageId: ImageId
    public var launchPermission: LaunchPermissionModifications?
    public var operationType: OperationType?
    public var organizationArns: OrganizationArnStringList?
    public var organizationalUnitArns: OrganizationalUnitArnStringList?
    public var productCodes: ProductCodeStringList?
    public var userGroups: UserGroupStringList?
    public var userIds: UserIdStringList?
    public var value: String?

    public init(attribute: String? = nil,
                description: AttributeValue? = nil,
                dryRun: Boolean? = nil,
                imageId: ImageId,
                launchPermission: LaunchPermissionModifications? = nil,
                operationType: OperationType? = nil,
                organizationArns: OrganizationArnStringList? = nil,
                organizationalUnitArns: OrganizationalUnitArnStringList? = nil,
                productCodes: ProductCodeStringList? = nil,
                userGroups: UserGroupStringList? = nil,
                userIds: UserIdStringList? = nil,
                value: String? = nil) {
        self.attribute = attribute
        self.description = description
        self.dryRun = dryRun
        self.imageId = imageId
        self.launchPermission = launchPermission
        self.operationType = operationType
        self.organizationArns = organizationArns
        self.organizationalUnitArns = organizationalUnitArns
        self.productCodes = productCodes
        self.userGroups = userGroups
        self.userIds = userIds
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case description = "Description"
        case dryRun
        case imageId = "ImageId"
        case launchPermission = "LaunchPermission"
        case operationType = "OperationType"
        case organizationArns = "OrganizationArn"
        case organizationalUnitArns = "OrganizationalUnitArn"
        case productCodes = "ProductCode"
        case userGroups = "UserGroup"
        case userIds = "UserId"
        case value = "Value"
    }

    public func validate() throws {
        try description?.validate()
        try launchPermission?.validate()
    }
}

public struct ModifyInstanceAttributeRequest: Codable, Equatable {
    public var attribute: InstanceAttributeName?
    public var blockDeviceMappings: InstanceBlockDeviceMappingSpecificationList?
    public var disableApiStop: AttributeBooleanValue?
    public var disableApiTermination: AttributeBooleanValue?
    public var dryRun: Boolean?
    public var ebsOptimized: AttributeBooleanValue?
    public var enaSupport: AttributeBooleanValue?
    public var groups: GroupIdStringList?
    public var instanceId: InstanceId
    public var instanceInitiatedShutdownBehavior: AttributeValue?
    public var instanceType: AttributeValue?
    public var kernel: AttributeValue?
    public var ramdisk: AttributeValue?
    public var sourceDestCheck: AttributeBooleanValue?
    public var sriovNetSupport: AttributeValue?
    public var userData: BlobAttributeValue?
    public var value: String?

    public init(attribute: InstanceAttributeName? = nil,
                blockDeviceMappings: InstanceBlockDeviceMappingSpecificationList? = nil,
                disableApiStop: AttributeBooleanValue? = nil,
                disableApiTermination: AttributeBooleanValue? = nil,
                dryRun: Boolean? = nil,
                ebsOptimized: AttributeBooleanValue? = nil,
                enaSupport: AttributeBooleanValue? = nil,
                groups: GroupIdStringList? = nil,
                instanceId: InstanceId,
                instanceInitiatedShutdownBehavior: AttributeValue? = nil,
                instanceType: AttributeValue? = nil,
                kernel: AttributeValue? = nil,
                ramdisk: AttributeValue? = nil,
                sourceDestCheck: AttributeBooleanValue? = nil,
                sriovNetSupport: AttributeValue? = nil,
                userData: BlobAttributeValue? = nil,
                value: String? = nil) {
        self.attribute = attribute
        self.blockDeviceMappings = blockDeviceMappings
        self.disableApiStop = disableApiStop
        self.disableApiTermination = disableApiTermination
        self.dryRun = dryRun
        self.ebsOptimized = ebsOptimized
        self.enaSupport = enaSupport
        self.groups = groups
        self.instanceId = instanceId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceType = instanceType
        self.kernel = kernel
        self.ramdisk = ramdisk
        self.sourceDestCheck = sourceDestCheck
        self.sriovNetSupport = sriovNetSupport
        self.userData = userData
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case attribute
        case blockDeviceMappings = "blockDeviceMapping"
        case disableApiStop = "DisableApiStop"
        case disableApiTermination
        case dryRun
        case ebsOptimized
        case enaSupport
        case groups = "GroupId"
        case instanceId
        case instanceInitiatedShutdownBehavior
        case instanceType
        case kernel
        case ramdisk
        case sourceDestCheck = "SourceDestCheck"
        case sriovNetSupport
        case userData
        case value
    }

    public func validate() throws {
        try disableApiStop?.validate()
        try disableApiTermination?.validate()
        try ebsOptimized?.validate()
        try enaSupport?.validate()
        try instanceInitiatedShutdownBehavior?.validate()
        try instanceType?.validate()
        try kernel?.validate()
        try ramdisk?.validate()
        try sourceDestCheck?.validate()
        try sriovNetSupport?.validate()
        try userData?.validate()
    }
}

public struct ModifyInstanceCapacityReservationAttributesRequest: Codable, Equatable {
    public var capacityReservationSpecification: CapacityReservationSpecification
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(capacityReservationSpecification: CapacityReservationSpecification,
                dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.capacityReservationSpecification = capacityReservationSpecification
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
        try capacityReservationSpecification.validate()
    }
}

public struct ModifyInstanceCapacityReservationAttributesResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceCreditSpecificationRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var instanceCreditSpecifications: InstanceCreditSpecificationListRequest

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                instanceCreditSpecifications: InstanceCreditSpecificationListRequest) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.instanceCreditSpecifications = instanceCreditSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case instanceCreditSpecifications = "InstanceCreditSpecification"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceCreditSpecificationResult: Codable, Equatable {
    public var successfulInstanceCreditSpecifications: SuccessfulInstanceCreditSpecificationSet?
    public var unsuccessfulInstanceCreditSpecifications: UnsuccessfulInstanceCreditSpecificationSet?

    public init(successfulInstanceCreditSpecifications: SuccessfulInstanceCreditSpecificationSet? = nil,
                unsuccessfulInstanceCreditSpecifications: UnsuccessfulInstanceCreditSpecificationSet? = nil) {
        self.successfulInstanceCreditSpecifications = successfulInstanceCreditSpecifications
        self.unsuccessfulInstanceCreditSpecifications = unsuccessfulInstanceCreditSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case successfulInstanceCreditSpecifications = "successfulInstanceCreditSpecificationSet"
        case unsuccessfulInstanceCreditSpecifications = "unsuccessfulInstanceCreditSpecificationSet"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceEventStartTimeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceEventId: String
    public var instanceId: InstanceId
    public var notBefore: DateTime

    public init(dryRun: Boolean? = nil,
                instanceEventId: String,
                instanceId: InstanceId,
                notBefore: DateTime) {
        self.dryRun = dryRun
        self.instanceEventId = instanceEventId
        self.instanceId = instanceId
        self.notBefore = notBefore
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceEventId = "InstanceEventId"
        case instanceId = "InstanceId"
        case notBefore = "NotBefore"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceEventStartTimeResult: Codable, Equatable {
    public var event: InstanceStatusEvent?

    public init(event: InstanceStatusEvent? = nil) {
        self.event = event
    }

    enum CodingKeys: String, CodingKey {
        case event
    }

    public func validate() throws {
        try event?.validate()
    }
}

public struct ModifyInstanceEventWindowRequest: Codable, Equatable {
    public var cronExpression: InstanceEventWindowCronExpression?
    public var dryRun: Boolean?
    public var instanceEventWindowId: InstanceEventWindowId
    public var name: String?
    public var timeRanges: InstanceEventWindowTimeRangeRequestSet?

    public init(cronExpression: InstanceEventWindowCronExpression? = nil,
                dryRun: Boolean? = nil,
                instanceEventWindowId: InstanceEventWindowId,
                name: String? = nil,
                timeRanges: InstanceEventWindowTimeRangeRequestSet? = nil) {
        self.cronExpression = cronExpression
        self.dryRun = dryRun
        self.instanceEventWindowId = instanceEventWindowId
        self.name = name
        self.timeRanges = timeRanges
    }

    enum CodingKeys: String, CodingKey {
        case cronExpression = "CronExpression"
        case dryRun = "DryRun"
        case instanceEventWindowId = "InstanceEventWindowId"
        case name = "Name"
        case timeRanges = "TimeRange"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceEventWindowResult: Codable, Equatable {
    public var instanceEventWindow: InstanceEventWindow?

    public init(instanceEventWindow: InstanceEventWindow? = nil) {
        self.instanceEventWindow = instanceEventWindow
    }

    enum CodingKeys: String, CodingKey {
        case instanceEventWindow
    }

    public func validate() throws {
        try instanceEventWindow?.validate()
    }
}

public struct ModifyInstanceMaintenanceOptionsRequest: Codable, Equatable {
    public var autoRecovery: InstanceAutoRecoveryState?
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(autoRecovery: InstanceAutoRecoveryState? = nil,
                dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.autoRecovery = autoRecovery
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case autoRecovery = "AutoRecovery"
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceMaintenanceOptionsResult: Codable, Equatable {
    public var autoRecovery: InstanceAutoRecoveryState?
    public var instanceId: String?

    public init(autoRecovery: InstanceAutoRecoveryState? = nil,
                instanceId: String? = nil) {
        self.autoRecovery = autoRecovery
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case autoRecovery
        case instanceId
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceMetadataOptionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var httpEndpoint: InstanceMetadataEndpointState?
    public var httpProtocolIpv6: InstanceMetadataProtocolState?
    public var httpPutResponseHopLimit: Integer?
    public var httpTokens: HttpTokensState?
    public var instanceId: InstanceId
    public var instanceMetadataTags: InstanceMetadataTagsState?

    public init(dryRun: Boolean? = nil,
                httpEndpoint: InstanceMetadataEndpointState? = nil,
                httpProtocolIpv6: InstanceMetadataProtocolState? = nil,
                httpPutResponseHopLimit: Integer? = nil,
                httpTokens: HttpTokensState? = nil,
                instanceId: InstanceId,
                instanceMetadataTags: InstanceMetadataTagsState? = nil) {
        self.dryRun = dryRun
        self.httpEndpoint = httpEndpoint
        self.httpProtocolIpv6 = httpProtocolIpv6
        self.httpPutResponseHopLimit = httpPutResponseHopLimit
        self.httpTokens = httpTokens
        self.instanceId = instanceId
        self.instanceMetadataTags = instanceMetadataTags
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case httpEndpoint = "HttpEndpoint"
        case httpProtocolIpv6 = "HttpProtocolIpv6"
        case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
        case httpTokens = "HttpTokens"
        case instanceId = "InstanceId"
        case instanceMetadataTags = "InstanceMetadataTags"
    }

    public func validate() throws {
    }
}

public struct ModifyInstanceMetadataOptionsResult: Codable, Equatable {
    public var instanceId: String?
    public var instanceMetadataOptions: InstanceMetadataOptionsResponse?

    public init(instanceId: String? = nil,
                instanceMetadataOptions: InstanceMetadataOptionsResponse? = nil) {
        self.instanceId = instanceId
        self.instanceMetadataOptions = instanceMetadataOptions
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case instanceMetadataOptions
    }

    public func validate() throws {
        try instanceMetadataOptions?.validate()
    }
}

public struct ModifyInstancePlacementRequest: Codable, Equatable {
    public var affinity: Affinity?
    public var groupId: PlacementGroupId?
    public var groupName: PlacementGroupName?
    public var hostId: DedicatedHostId?
    public var hostResourceGroupArn: String?
    public var instanceId: InstanceId
    public var partitionNumber: Integer?
    public var tenancy: HostTenancy?

    public init(affinity: Affinity? = nil,
                groupId: PlacementGroupId? = nil,
                groupName: PlacementGroupName? = nil,
                hostId: DedicatedHostId? = nil,
                hostResourceGroupArn: String? = nil,
                instanceId: InstanceId,
                partitionNumber: Integer? = nil,
                tenancy: HostTenancy? = nil) {
        self.affinity = affinity
        self.groupId = groupId
        self.groupName = groupName
        self.hostId = hostId
        self.hostResourceGroupArn = hostResourceGroupArn
        self.instanceId = instanceId
        self.partitionNumber = partitionNumber
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case affinity
        case groupId = "GroupId"
        case groupName = "GroupName"
        case hostId
        case hostResourceGroupArn = "HostResourceGroupArn"
        case instanceId
        case partitionNumber = "PartitionNumber"
        case tenancy
    }

    public func validate() throws {
    }
}

public struct ModifyInstancePlacementResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyIpamPoolRequest: Codable, Equatable {
    public var addAllocationResourceTags: RequestIpamResourceTagList?
    public var allocationDefaultNetmaskLength: IpamNetmaskLength?
    public var allocationMaxNetmaskLength: IpamNetmaskLength?
    public var allocationMinNetmaskLength: IpamNetmaskLength?
    public var autoImport: Boolean?
    public var clearAllocationDefaultNetmaskLength: Boolean?
    public var description: String?
    public var dryRun: Boolean?
    public var ipamPoolId: IpamPoolId
    public var removeAllocationResourceTags: RequestIpamResourceTagList?

    public init(addAllocationResourceTags: RequestIpamResourceTagList? = nil,
                allocationDefaultNetmaskLength: IpamNetmaskLength? = nil,
                allocationMaxNetmaskLength: IpamNetmaskLength? = nil,
                allocationMinNetmaskLength: IpamNetmaskLength? = nil,
                autoImport: Boolean? = nil,
                clearAllocationDefaultNetmaskLength: Boolean? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                ipamPoolId: IpamPoolId,
                removeAllocationResourceTags: RequestIpamResourceTagList? = nil) {
        self.addAllocationResourceTags = addAllocationResourceTags
        self.allocationDefaultNetmaskLength = allocationDefaultNetmaskLength
        self.allocationMaxNetmaskLength = allocationMaxNetmaskLength
        self.allocationMinNetmaskLength = allocationMinNetmaskLength
        self.autoImport = autoImport
        self.clearAllocationDefaultNetmaskLength = clearAllocationDefaultNetmaskLength
        self.description = description
        self.dryRun = dryRun
        self.ipamPoolId = ipamPoolId
        self.removeAllocationResourceTags = removeAllocationResourceTags
    }

    enum CodingKeys: String, CodingKey {
        case addAllocationResourceTags = "AddAllocationResourceTag"
        case allocationDefaultNetmaskLength = "AllocationDefaultNetmaskLength"
        case allocationMaxNetmaskLength = "AllocationMaxNetmaskLength"
        case allocationMinNetmaskLength = "AllocationMinNetmaskLength"
        case autoImport = "AutoImport"
        case clearAllocationDefaultNetmaskLength = "ClearAllocationDefaultNetmaskLength"
        case description = "Description"
        case dryRun = "DryRun"
        case ipamPoolId = "IpamPoolId"
        case removeAllocationResourceTags = "RemoveAllocationResourceTag"
    }

    public func validate() throws {
        try allocationDefaultNetmaskLength?.validateAsIpamNetmaskLength()
        try allocationMaxNetmaskLength?.validateAsIpamNetmaskLength()
        try allocationMinNetmaskLength?.validateAsIpamNetmaskLength()
    }
}

public struct ModifyIpamPoolResult: Codable, Equatable {
    public var ipamPool: IpamPool?

    public init(ipamPool: IpamPool? = nil) {
        self.ipamPool = ipamPool
    }

    enum CodingKeys: String, CodingKey {
        case ipamPool
    }

    public func validate() throws {
        try ipamPool?.validate()
    }
}

public struct ModifyIpamRequest: Codable, Equatable {
    public var addOperatingRegions: AddIpamOperatingRegionSet?
    public var description: String?
    public var dryRun: Boolean?
    public var ipamId: IpamId
    public var removeOperatingRegions: RemoveIpamOperatingRegionSet?

    public init(addOperatingRegions: AddIpamOperatingRegionSet? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                ipamId: IpamId,
                removeOperatingRegions: RemoveIpamOperatingRegionSet? = nil) {
        self.addOperatingRegions = addOperatingRegions
        self.description = description
        self.dryRun = dryRun
        self.ipamId = ipamId
        self.removeOperatingRegions = removeOperatingRegions
    }

    enum CodingKeys: String, CodingKey {
        case addOperatingRegions = "AddOperatingRegion"
        case description = "Description"
        case dryRun = "DryRun"
        case ipamId = "IpamId"
        case removeOperatingRegions = "RemoveOperatingRegion"
    }

    public func validate() throws {
        try addOperatingRegions?.validateAsAddIpamOperatingRegionSet()
        try removeOperatingRegions?.validateAsRemoveIpamOperatingRegionSet()
    }
}

public struct ModifyIpamResourceCidrRequest: Codable, Equatable {
    public var currentIpamScopeId: IpamScopeId
    public var destinationIpamScopeId: IpamScopeId?
    public var dryRun: Boolean?
    public var monitored: Boolean
    public var resourceCidr: String
    public var resourceId: String
    public var resourceRegion: String

    public init(currentIpamScopeId: IpamScopeId,
                destinationIpamScopeId: IpamScopeId? = nil,
                dryRun: Boolean? = nil,
                monitored: Boolean,
                resourceCidr: String,
                resourceId: String,
                resourceRegion: String) {
        self.currentIpamScopeId = currentIpamScopeId
        self.destinationIpamScopeId = destinationIpamScopeId
        self.dryRun = dryRun
        self.monitored = monitored
        self.resourceCidr = resourceCidr
        self.resourceId = resourceId
        self.resourceRegion = resourceRegion
    }

    enum CodingKeys: String, CodingKey {
        case currentIpamScopeId = "CurrentIpamScopeId"
        case destinationIpamScopeId = "DestinationIpamScopeId"
        case dryRun = "DryRun"
        case monitored = "Monitored"
        case resourceCidr = "ResourceCidr"
        case resourceId = "ResourceId"
        case resourceRegion = "ResourceRegion"
    }

    public func validate() throws {
    }
}

public struct ModifyIpamResourceCidrResult: Codable, Equatable {
    public var ipamResourceCidr: IpamResourceCidr?

    public init(ipamResourceCidr: IpamResourceCidr? = nil) {
        self.ipamResourceCidr = ipamResourceCidr
    }

    enum CodingKeys: String, CodingKey {
        case ipamResourceCidr
    }

    public func validate() throws {
        try ipamResourceCidr?.validate()
    }
}

public struct ModifyIpamResult: Codable, Equatable {
    public var ipam: Ipam?

    public init(ipam: Ipam? = nil) {
        self.ipam = ipam
    }

    enum CodingKeys: String, CodingKey {
        case ipam
    }

    public func validate() throws {
        try ipam?.validate()
    }
}

public struct ModifyIpamScopeRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var ipamScopeId: IpamScopeId

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                ipamScopeId: IpamScopeId) {
        self.description = description
        self.dryRun = dryRun
        self.ipamScopeId = ipamScopeId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case ipamScopeId = "IpamScopeId"
    }

    public func validate() throws {
    }
}

public struct ModifyIpamScopeResult: Codable, Equatable {
    public var ipamScope: IpamScope?

    public init(ipamScope: IpamScope? = nil) {
        self.ipamScope = ipamScope
    }

    enum CodingKeys: String, CodingKey {
        case ipamScope
    }

    public func validate() throws {
        try ipamScope?.validate()
    }
}

public struct ModifyLaunchTemplateRequest: Codable, Equatable {
    public var clientToken: String?
    public var defaultVersion: String?
    public var dryRun: Boolean?
    public var launchTemplateId: LaunchTemplateId?
    public var launchTemplateName: LaunchTemplateName?

    public init(clientToken: String? = nil,
                defaultVersion: String? = nil,
                dryRun: Boolean? = nil,
                launchTemplateId: LaunchTemplateId? = nil,
                launchTemplateName: LaunchTemplateName? = nil) {
        self.clientToken = clientToken
        self.defaultVersion = defaultVersion
        self.dryRun = dryRun
        self.launchTemplateId = launchTemplateId
        self.launchTemplateName = launchTemplateName
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case defaultVersion = "SetDefaultVersion"
        case dryRun = "DryRun"
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
    }

    public func validate() throws {
        try launchTemplateName?.validateAsLaunchTemplateName()
    }
}

public struct ModifyLaunchTemplateResult: Codable, Equatable {
    public var launchTemplate: LaunchTemplate?

    public init(launchTemplate: LaunchTemplate? = nil) {
        self.launchTemplate = launchTemplate
    }

    enum CodingKeys: String, CodingKey {
        case launchTemplate
    }

    public func validate() throws {
        try launchTemplate?.validate()
    }
}

public struct ModifyLocalGatewayRouteRequest: Codable, Equatable {
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId
    public var localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId?
    public var networkInterfaceId: NetworkInterfaceId?

    public init(destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId,
                localGatewayVirtualInterfaceGroupId: LocalGatewayVirtualInterfaceGroupId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil) {
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.localGatewayVirtualInterfaceGroupId = localGatewayVirtualInterfaceGroupId
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
        case localGatewayVirtualInterfaceGroupId = "LocalGatewayVirtualInterfaceGroupId"
        case networkInterfaceId = "NetworkInterfaceId"
    }

    public func validate() throws {
    }
}

public struct ModifyLocalGatewayRouteResult: Codable, Equatable {
    public var route: LocalGatewayRoute?

    public init(route: LocalGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct ModifyManagedPrefixListRequest: Codable, Equatable {
    public var addEntries: AddPrefixListEntries?
    public var currentVersion: Long?
    public var dryRun: Boolean?
    public var maxEntries: Integer?
    public var prefixListId: PrefixListResourceId
    public var prefixListName: String?
    public var removeEntries: RemovePrefixListEntries?

    public init(addEntries: AddPrefixListEntries? = nil,
                currentVersion: Long? = nil,
                dryRun: Boolean? = nil,
                maxEntries: Integer? = nil,
                prefixListId: PrefixListResourceId,
                prefixListName: String? = nil,
                removeEntries: RemovePrefixListEntries? = nil) {
        self.addEntries = addEntries
        self.currentVersion = currentVersion
        self.dryRun = dryRun
        self.maxEntries = maxEntries
        self.prefixListId = prefixListId
        self.prefixListName = prefixListName
        self.removeEntries = removeEntries
    }

    enum CodingKeys: String, CodingKey {
        case addEntries = "AddEntry"
        case currentVersion = "CurrentVersion"
        case dryRun = "DryRun"
        case maxEntries = "MaxEntries"
        case prefixListId = "PrefixListId"
        case prefixListName = "PrefixListName"
        case removeEntries = "RemoveEntry"
    }

    public func validate() throws {
        try addEntries?.validateAsAddPrefixListEntries()
        try removeEntries?.validateAsRemovePrefixListEntries()
    }
}

public struct ModifyManagedPrefixListResult: Codable, Equatable {
    public var prefixList: ManagedPrefixList?

    public init(prefixList: ManagedPrefixList? = nil) {
        self.prefixList = prefixList
    }

    enum CodingKeys: String, CodingKey {
        case prefixList
    }

    public func validate() throws {
        try prefixList?.validate()
    }
}

public struct ModifyNetworkInterfaceAttributeRequest: Codable, Equatable {
    public var attachment: NetworkInterfaceAttachmentChanges?
    public var description: AttributeValue?
    public var dryRun: Boolean?
    public var enaSrdSpecification: EnaSrdSpecification?
    public var groups: SecurityGroupIdStringList?
    public var networkInterfaceId: NetworkInterfaceId
    public var sourceDestCheck: AttributeBooleanValue?

    public init(attachment: NetworkInterfaceAttachmentChanges? = nil,
                description: AttributeValue? = nil,
                dryRun: Boolean? = nil,
                enaSrdSpecification: EnaSrdSpecification? = nil,
                groups: SecurityGroupIdStringList? = nil,
                networkInterfaceId: NetworkInterfaceId,
                sourceDestCheck: AttributeBooleanValue? = nil) {
        self.attachment = attachment
        self.description = description
        self.dryRun = dryRun
        self.enaSrdSpecification = enaSrdSpecification
        self.groups = groups
        self.networkInterfaceId = networkInterfaceId
        self.sourceDestCheck = sourceDestCheck
    }

    enum CodingKeys: String, CodingKey {
        case attachment
        case description
        case dryRun
        case enaSrdSpecification = "EnaSrdSpecification"
        case groups = "SecurityGroupId"
        case networkInterfaceId
        case sourceDestCheck
    }

    public func validate() throws {
        try attachment?.validate()
        try description?.validate()
        try enaSrdSpecification?.validate()
        try sourceDestCheck?.validate()
    }
}

public struct ModifyPrivateDnsNameOptionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var enableResourceNameDnsAAAARecord: Boolean?
    public var enableResourceNameDnsARecord: Boolean?
    public var instanceId: InstanceId?
    public var privateDnsHostnameType: HostnameType?

    public init(dryRun: Boolean? = nil,
                enableResourceNameDnsAAAARecord: Boolean? = nil,
                enableResourceNameDnsARecord: Boolean? = nil,
                instanceId: InstanceId? = nil,
                privateDnsHostnameType: HostnameType? = nil) {
        self.dryRun = dryRun
        self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
        self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
        self.instanceId = instanceId
        self.privateDnsHostnameType = privateDnsHostnameType
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case enableResourceNameDnsAAAARecord = "EnableResourceNameDnsAAAARecord"
        case enableResourceNameDnsARecord = "EnableResourceNameDnsARecord"
        case instanceId = "InstanceId"
        case privateDnsHostnameType = "PrivateDnsHostnameType"
    }

    public func validate() throws {
    }
}

public struct ModifyPrivateDnsNameOptionsResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyReservedInstancesRequest: Codable, Equatable {
    public var clientToken: String?
    public var reservedInstancesIds: ReservedInstancesIdStringList
    public var targetConfigurations: ReservedInstancesConfigurationList

    public init(clientToken: String? = nil,
                reservedInstancesIds: ReservedInstancesIdStringList,
                targetConfigurations: ReservedInstancesConfigurationList) {
        self.clientToken = clientToken
        self.reservedInstancesIds = reservedInstancesIds
        self.targetConfigurations = targetConfigurations
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case reservedInstancesIds = "ReservedInstancesId"
        case targetConfigurations = "ReservedInstancesConfigurationSetItemType"
    }

    public func validate() throws {
    }
}

public struct ModifyReservedInstancesResult: Codable, Equatable {
    public var reservedInstancesModificationId: String?

    public init(reservedInstancesModificationId: String? = nil) {
        self.reservedInstancesModificationId = reservedInstancesModificationId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesModificationId
    }

    public func validate() throws {
    }
}

public struct ModifySecurityGroupRulesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupId: SecurityGroupId
    public var securityGroupRules: SecurityGroupRuleUpdateList

    public init(dryRun: Boolean? = nil,
                groupId: SecurityGroupId,
                securityGroupRules: SecurityGroupRuleUpdateList) {
        self.dryRun = dryRun
        self.groupId = groupId
        self.securityGroupRules = securityGroupRules
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupId = "GroupId"
        case securityGroupRules = "SecurityGroupRule"
    }

    public func validate() throws {
    }
}

public struct ModifySecurityGroupRulesResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifySnapshotAttributeRequest: Codable, Equatable {
    public var attribute: SnapshotAttributeName?
    public var createVolumePermission: CreateVolumePermissionModifications?
    public var dryRun: Boolean?
    public var groupNames: GroupNameStringList?
    public var operationType: OperationType?
    public var snapshotId: SnapshotId
    public var userIds: UserIdStringList?

    public init(attribute: SnapshotAttributeName? = nil,
                createVolumePermission: CreateVolumePermissionModifications? = nil,
                dryRun: Boolean? = nil,
                groupNames: GroupNameStringList? = nil,
                operationType: OperationType? = nil,
                snapshotId: SnapshotId,
                userIds: UserIdStringList? = nil) {
        self.attribute = attribute
        self.createVolumePermission = createVolumePermission
        self.dryRun = dryRun
        self.groupNames = groupNames
        self.operationType = operationType
        self.snapshotId = snapshotId
        self.userIds = userIds
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case createVolumePermission = "CreateVolumePermission"
        case dryRun
        case groupNames = "UserGroup"
        case operationType = "OperationType"
        case snapshotId = "SnapshotId"
        case userIds = "UserId"
    }

    public func validate() throws {
        try createVolumePermission?.validate()
    }
}

public struct ModifySnapshotTierRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var snapshotId: SnapshotId
    public var storageTier: TargetStorageTier?

    public init(dryRun: Boolean? = nil,
                snapshotId: SnapshotId,
                storageTier: TargetStorageTier? = nil) {
        self.dryRun = dryRun
        self.snapshotId = snapshotId
        self.storageTier = storageTier
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case snapshotId = "SnapshotId"
        case storageTier = "StorageTier"
    }

    public func validate() throws {
    }
}

public struct ModifySnapshotTierResult: Codable, Equatable {
    public var snapshotId: String?
    public var tieringStartTime: MillisecondDateTime?

    public init(snapshotId: String? = nil,
                tieringStartTime: MillisecondDateTime? = nil) {
        self.snapshotId = snapshotId
        self.tieringStartTime = tieringStartTime
    }

    enum CodingKeys: String, CodingKey {
        case snapshotId
        case tieringStartTime
    }

    public func validate() throws {
    }
}

public struct ModifySpotFleetRequestRequest: Codable, Equatable {
    public var context: String?
    public var excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy?
    public var launchTemplateConfigs: LaunchTemplateConfigList?
    public var onDemandTargetCapacity: Integer?
    public var spotFleetRequestId: SpotFleetRequestId
    public var targetCapacity: Integer?

    public init(context: String? = nil,
                excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy? = nil,
                launchTemplateConfigs: LaunchTemplateConfigList? = nil,
                onDemandTargetCapacity: Integer? = nil,
                spotFleetRequestId: SpotFleetRequestId,
                targetCapacity: Integer? = nil) {
        self.context = context
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.launchTemplateConfigs = launchTemplateConfigs
        self.onDemandTargetCapacity = onDemandTargetCapacity
        self.spotFleetRequestId = spotFleetRequestId
        self.targetCapacity = targetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case context = "Context"
        case excessCapacityTerminationPolicy
        case launchTemplateConfigs = "LaunchTemplateConfig"
        case onDemandTargetCapacity = "OnDemandTargetCapacity"
        case spotFleetRequestId
        case targetCapacity
    }

    public func validate() throws {
    }
}

public struct ModifySpotFleetRequestResponse: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifySubnetAttributeRequest: Codable, Equatable {
    public var assignIpv6AddressOnCreation: AttributeBooleanValue?
    public var customerOwnedIpv4Pool: CoipPoolId?
    public var disableLniAtDeviceIndex: AttributeBooleanValue?
    public var enableDns64: AttributeBooleanValue?
    public var enableLniAtDeviceIndex: Integer?
    public var enableResourceNameDnsAAAARecordOnLaunch: AttributeBooleanValue?
    public var enableResourceNameDnsARecordOnLaunch: AttributeBooleanValue?
    public var mapCustomerOwnedIpOnLaunch: AttributeBooleanValue?
    public var mapPublicIpOnLaunch: AttributeBooleanValue?
    public var privateDnsHostnameTypeOnLaunch: HostnameType?
    public var subnetId: SubnetId

    public init(assignIpv6AddressOnCreation: AttributeBooleanValue? = nil,
                customerOwnedIpv4Pool: CoipPoolId? = nil,
                disableLniAtDeviceIndex: AttributeBooleanValue? = nil,
                enableDns64: AttributeBooleanValue? = nil,
                enableLniAtDeviceIndex: Integer? = nil,
                enableResourceNameDnsAAAARecordOnLaunch: AttributeBooleanValue? = nil,
                enableResourceNameDnsARecordOnLaunch: AttributeBooleanValue? = nil,
                mapCustomerOwnedIpOnLaunch: AttributeBooleanValue? = nil,
                mapPublicIpOnLaunch: AttributeBooleanValue? = nil,
                privateDnsHostnameTypeOnLaunch: HostnameType? = nil,
                subnetId: SubnetId) {
        self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.disableLniAtDeviceIndex = disableLniAtDeviceIndex
        self.enableDns64 = enableDns64
        self.enableLniAtDeviceIndex = enableLniAtDeviceIndex
        self.enableResourceNameDnsAAAARecordOnLaunch = enableResourceNameDnsAAAARecordOnLaunch
        self.enableResourceNameDnsARecordOnLaunch = enableResourceNameDnsARecordOnLaunch
        self.mapCustomerOwnedIpOnLaunch = mapCustomerOwnedIpOnLaunch
        self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
        self.privateDnsHostnameTypeOnLaunch = privateDnsHostnameTypeOnLaunch
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case assignIpv6AddressOnCreation = "AssignIpv6AddressOnCreation"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case disableLniAtDeviceIndex = "DisableLniAtDeviceIndex"
        case enableDns64 = "EnableDns64"
        case enableLniAtDeviceIndex = "EnableLniAtDeviceIndex"
        case enableResourceNameDnsAAAARecordOnLaunch = "EnableResourceNameDnsAAAARecordOnLaunch"
        case enableResourceNameDnsARecordOnLaunch = "EnableResourceNameDnsARecordOnLaunch"
        case mapCustomerOwnedIpOnLaunch = "MapCustomerOwnedIpOnLaunch"
        case mapPublicIpOnLaunch = "MapPublicIpOnLaunch"
        case privateDnsHostnameTypeOnLaunch = "PrivateDnsHostnameTypeOnLaunch"
        case subnetId
    }

    public func validate() throws {
        try assignIpv6AddressOnCreation?.validate()
        try disableLniAtDeviceIndex?.validate()
        try enableDns64?.validate()
        try enableResourceNameDnsAAAARecordOnLaunch?.validate()
        try enableResourceNameDnsARecordOnLaunch?.validate()
        try mapCustomerOwnedIpOnLaunch?.validate()
        try mapPublicIpOnLaunch?.validate()
    }
}

public struct ModifyTrafficMirrorFilterNetworkServicesRequest: Codable, Equatable {
    public var addNetworkServices: TrafficMirrorNetworkServiceList?
    public var dryRun: Boolean?
    public var removeNetworkServices: TrafficMirrorNetworkServiceList?
    public var trafficMirrorFilterId: TrafficMirrorFilterId

    public init(addNetworkServices: TrafficMirrorNetworkServiceList? = nil,
                dryRun: Boolean? = nil,
                removeNetworkServices: TrafficMirrorNetworkServiceList? = nil,
                trafficMirrorFilterId: TrafficMirrorFilterId) {
        self.addNetworkServices = addNetworkServices
        self.dryRun = dryRun
        self.removeNetworkServices = removeNetworkServices
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case addNetworkServices = "AddNetworkService"
        case dryRun = "DryRun"
        case removeNetworkServices = "RemoveNetworkService"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
    }

    public func validate() throws {
    }
}

public struct ModifyTrafficMirrorFilterNetworkServicesResult: Codable, Equatable {
    public var trafficMirrorFilter: TrafficMirrorFilter?

    public init(trafficMirrorFilter: TrafficMirrorFilter? = nil) {
        self.trafficMirrorFilter = trafficMirrorFilter
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorFilter
    }

    public func validate() throws {
        try trafficMirrorFilter?.validate()
    }
}

public struct ModifyTrafficMirrorFilterRuleRequest: Codable, Equatable {
    public var description: String?
    public var destinationCidrBlock: String?
    public var destinationPortRange: TrafficMirrorPortRangeRequest?
    public var dryRun: Boolean?
    public var `protocol`: Integer?
    public var removeFields: TrafficMirrorFilterRuleFieldList?
    public var ruleAction: TrafficMirrorRuleAction?
    public var ruleNumber: Integer?
    public var sourceCidrBlock: String?
    public var sourcePortRange: TrafficMirrorPortRangeRequest?
    public var trafficDirection: TrafficDirection?
    public var trafficMirrorFilterRuleId: TrafficMirrorFilterRuleId

    public init(description: String? = nil,
                destinationCidrBlock: String? = nil,
                destinationPortRange: TrafficMirrorPortRangeRequest? = nil,
                dryRun: Boolean? = nil,
                `protocol`: Integer? = nil,
                removeFields: TrafficMirrorFilterRuleFieldList? = nil,
                ruleAction: TrafficMirrorRuleAction? = nil,
                ruleNumber: Integer? = nil,
                sourceCidrBlock: String? = nil,
                sourcePortRange: TrafficMirrorPortRangeRequest? = nil,
                trafficDirection: TrafficDirection? = nil,
                trafficMirrorFilterRuleId: TrafficMirrorFilterRuleId) {
        self.description = description
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationPortRange = destinationPortRange
        self.dryRun = dryRun
        self.`protocol` = `protocol`
        self.removeFields = removeFields
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
        self.sourceCidrBlock = sourceCidrBlock
        self.sourcePortRange = sourcePortRange
        self.trafficDirection = trafficDirection
        self.trafficMirrorFilterRuleId = trafficMirrorFilterRuleId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationPortRange = "DestinationPortRange"
        case dryRun = "DryRun"
        case `protocol` = "Protocol"
        case removeFields = "RemoveField"
        case ruleAction = "RuleAction"
        case ruleNumber = "RuleNumber"
        case sourceCidrBlock = "SourceCidrBlock"
        case sourcePortRange = "SourcePortRange"
        case trafficDirection = "TrafficDirection"
        case trafficMirrorFilterRuleId = "TrafficMirrorFilterRuleId"
    }

    public func validate() throws {
        try destinationPortRange?.validate()
        try sourcePortRange?.validate()
    }
}

public struct ModifyTrafficMirrorFilterRuleResult: Codable, Equatable {
    public var trafficMirrorFilterRule: TrafficMirrorFilterRule?

    public init(trafficMirrorFilterRule: TrafficMirrorFilterRule? = nil) {
        self.trafficMirrorFilterRule = trafficMirrorFilterRule
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorFilterRule
    }

    public func validate() throws {
        try trafficMirrorFilterRule?.validate()
    }
}

public struct ModifyTrafficMirrorSessionRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var packetLength: Integer?
    public var removeFields: TrafficMirrorSessionFieldList?
    public var sessionNumber: Integer?
    public var trafficMirrorFilterId: TrafficMirrorFilterId?
    public var trafficMirrorSessionId: TrafficMirrorSessionId
    public var trafficMirrorTargetId: TrafficMirrorTargetId?
    public var virtualNetworkId: Integer?

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                packetLength: Integer? = nil,
                removeFields: TrafficMirrorSessionFieldList? = nil,
                sessionNumber: Integer? = nil,
                trafficMirrorFilterId: TrafficMirrorFilterId? = nil,
                trafficMirrorSessionId: TrafficMirrorSessionId,
                trafficMirrorTargetId: TrafficMirrorTargetId? = nil,
                virtualNetworkId: Integer? = nil) {
        self.description = description
        self.dryRun = dryRun
        self.packetLength = packetLength
        self.removeFields = removeFields
        self.sessionNumber = sessionNumber
        self.trafficMirrorFilterId = trafficMirrorFilterId
        self.trafficMirrorSessionId = trafficMirrorSessionId
        self.trafficMirrorTargetId = trafficMirrorTargetId
        self.virtualNetworkId = virtualNetworkId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case packetLength = "PacketLength"
        case removeFields = "RemoveField"
        case sessionNumber = "SessionNumber"
        case trafficMirrorFilterId = "TrafficMirrorFilterId"
        case trafficMirrorSessionId = "TrafficMirrorSessionId"
        case trafficMirrorTargetId = "TrafficMirrorTargetId"
        case virtualNetworkId = "VirtualNetworkId"
    }

    public func validate() throws {
    }
}

public struct ModifyTrafficMirrorSessionResult: Codable, Equatable {
    public var trafficMirrorSession: TrafficMirrorSession?

    public init(trafficMirrorSession: TrafficMirrorSession? = nil) {
        self.trafficMirrorSession = trafficMirrorSession
    }

    enum CodingKeys: String, CodingKey {
        case trafficMirrorSession
    }

    public func validate() throws {
        try trafficMirrorSession?.validate()
    }
}

public struct ModifyTransitGatewayOptions: Codable, Equatable {
    public var addTransitGatewayCidrBlocks: TransitGatewayCidrBlockStringList?
    public var amazonSideAsn: Long?
    public var associationDefaultRouteTableId: TransitGatewayRouteTableId?
    public var autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue?
    public var defaultRouteTableAssociation: DefaultRouteTableAssociationValue?
    public var defaultRouteTablePropagation: DefaultRouteTablePropagationValue?
    public var dnsSupport: DnsSupportValue?
    public var propagationDefaultRouteTableId: TransitGatewayRouteTableId?
    public var removeTransitGatewayCidrBlocks: TransitGatewayCidrBlockStringList?
    public var vpnEcmpSupport: VpnEcmpSupportValue?

    public init(addTransitGatewayCidrBlocks: TransitGatewayCidrBlockStringList? = nil,
                amazonSideAsn: Long? = nil,
                associationDefaultRouteTableId: TransitGatewayRouteTableId? = nil,
                autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue? = nil,
                defaultRouteTableAssociation: DefaultRouteTableAssociationValue? = nil,
                defaultRouteTablePropagation: DefaultRouteTablePropagationValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                propagationDefaultRouteTableId: TransitGatewayRouteTableId? = nil,
                removeTransitGatewayCidrBlocks: TransitGatewayCidrBlockStringList? = nil,
                vpnEcmpSupport: VpnEcmpSupportValue? = nil) {
        self.addTransitGatewayCidrBlocks = addTransitGatewayCidrBlocks
        self.amazonSideAsn = amazonSideAsn
        self.associationDefaultRouteTableId = associationDefaultRouteTableId
        self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
        self.defaultRouteTableAssociation = defaultRouteTableAssociation
        self.defaultRouteTablePropagation = defaultRouteTablePropagation
        self.dnsSupport = dnsSupport
        self.propagationDefaultRouteTableId = propagationDefaultRouteTableId
        self.removeTransitGatewayCidrBlocks = removeTransitGatewayCidrBlocks
        self.vpnEcmpSupport = vpnEcmpSupport
    }

    enum CodingKeys: String, CodingKey {
        case addTransitGatewayCidrBlocks = "AddTransitGatewayCidrBlocks"
        case amazonSideAsn = "AmazonSideAsn"
        case associationDefaultRouteTableId = "AssociationDefaultRouteTableId"
        case autoAcceptSharedAttachments = "AutoAcceptSharedAttachments"
        case defaultRouteTableAssociation = "DefaultRouteTableAssociation"
        case defaultRouteTablePropagation = "DefaultRouteTablePropagation"
        case dnsSupport = "DnsSupport"
        case propagationDefaultRouteTableId = "PropagationDefaultRouteTableId"
        case removeTransitGatewayCidrBlocks = "RemoveTransitGatewayCidrBlocks"
        case vpnEcmpSupport = "VpnEcmpSupport"
    }

    public func validate() throws {
    }
}

public struct ModifyTransitGatewayPrefixListReferenceRequest: Codable, Equatable {
    public var blackhole: Boolean?
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(blackhole: Boolean? = nil,
                dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.blackhole = blackhole
        self.dryRun = dryRun
        self.prefixListId = prefixListId
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole = "Blackhole"
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct ModifyTransitGatewayPrefixListReferenceResult: Codable, Equatable {
    public var transitGatewayPrefixListReference: TransitGatewayPrefixListReference?

    public init(transitGatewayPrefixListReference: TransitGatewayPrefixListReference? = nil) {
        self.transitGatewayPrefixListReference = transitGatewayPrefixListReference
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPrefixListReference
    }

    public func validate() throws {
        try transitGatewayPrefixListReference?.validate()
    }
}

public struct ModifyTransitGatewayRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var options: ModifyTransitGatewayOptions?
    public var transitGatewayId: TransitGatewayId

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                options: ModifyTransitGatewayOptions? = nil,
                transitGatewayId: TransitGatewayId) {
        self.description = description
        self.dryRun = dryRun
        self.options = options
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case options = "Options"
        case transitGatewayId = "TransitGatewayId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct ModifyTransitGatewayResult: Codable, Equatable {
    public var transitGateway: TransitGateway?

    public init(transitGateway: TransitGateway? = nil) {
        self.transitGateway = transitGateway
    }

    enum CodingKeys: String, CodingKey {
        case transitGateway
    }

    public func validate() throws {
        try transitGateway?.validate()
    }
}

public struct ModifyTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var addSubnetIds: TransitGatewaySubnetIdList?
    public var dryRun: Boolean?
    public var options: ModifyTransitGatewayVpcAttachmentRequestOptions?
    public var removeSubnetIds: TransitGatewaySubnetIdList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(addSubnetIds: TransitGatewaySubnetIdList? = nil,
                dryRun: Boolean? = nil,
                options: ModifyTransitGatewayVpcAttachmentRequestOptions? = nil,
                removeSubnetIds: TransitGatewaySubnetIdList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.addSubnetIds = addSubnetIds
        self.dryRun = dryRun
        self.options = options
        self.removeSubnetIds = removeSubnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case addSubnetIds = "AddSubnetIds"
        case dryRun = "DryRun"
        case options = "Options"
        case removeSubnetIds = "RemoveSubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct ModifyTransitGatewayVpcAttachmentRequestOptions: Codable, Equatable {
    public var applianceModeSupport: ApplianceModeSupportValue?
    public var dnsSupport: DnsSupportValue?
    public var ipv6Support: Ipv6SupportValue?

    public init(applianceModeSupport: ApplianceModeSupportValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                ipv6Support: Ipv6SupportValue? = nil) {
        self.applianceModeSupport = applianceModeSupport
        self.dnsSupport = dnsSupport
        self.ipv6Support = ipv6Support
    }

    enum CodingKeys: String, CodingKey {
        case applianceModeSupport = "ApplianceModeSupport"
        case dnsSupport = "DnsSupport"
        case ipv6Support = "Ipv6Support"
    }

    public func validate() throws {
    }
}

public struct ModifyTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct ModifyVerifiedAccessEndpointEniOptions: Codable, Equatable {
    public var port: VerifiedAccessEndpointPortNumber?
    public var `protocol`: VerifiedAccessEndpointProtocol?

    public init(port: VerifiedAccessEndpointPortNumber? = nil,
                `protocol`: VerifiedAccessEndpointProtocol? = nil) {
        self.port = port
        self.`protocol` = `protocol`
    }

    enum CodingKeys: String, CodingKey {
        case port = "Port"
        case `protocol` = "Protocol"
    }

    public func validate() throws {
        try port?.validateAsVerifiedAccessEndpointPortNumber()
    }
}

public struct ModifyVerifiedAccessEndpointLoadBalancerOptions: Codable, Equatable {
    public var port: VerifiedAccessEndpointPortNumber?
    public var `protocol`: VerifiedAccessEndpointProtocol?
    public var subnetIds: ModifyVerifiedAccessEndpointSubnetIdList?

    public init(port: VerifiedAccessEndpointPortNumber? = nil,
                `protocol`: VerifiedAccessEndpointProtocol? = nil,
                subnetIds: ModifyVerifiedAccessEndpointSubnetIdList? = nil) {
        self.port = port
        self.`protocol` = `protocol`
        self.subnetIds = subnetIds
    }

    enum CodingKeys: String, CodingKey {
        case port = "Port"
        case `protocol` = "Protocol"
        case subnetIds = "SubnetId"
    }

    public func validate() throws {
        try port?.validateAsVerifiedAccessEndpointPortNumber()
    }
}

public struct ModifyVerifiedAccessEndpointPolicyRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var policyDocument: String?
    public var policyEnabled: Boolean
    public var verifiedAccessEndpointId: VerifiedAccessEndpointId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                policyDocument: String? = nil,
                policyEnabled: Boolean,
                verifiedAccessEndpointId: VerifiedAccessEndpointId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.policyDocument = policyDocument
        self.policyEnabled = policyEnabled
        self.verifiedAccessEndpointId = verifiedAccessEndpointId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case policyDocument = "PolicyDocument"
        case policyEnabled = "PolicyEnabled"
        case verifiedAccessEndpointId = "VerifiedAccessEndpointId"
    }

    public func validate() throws {
    }
}

public struct ModifyVerifiedAccessEndpointPolicyResult: Codable, Equatable {
    public var policyDocument: String?
    public var policyEnabled: Boolean?

    public init(policyDocument: String? = nil,
                policyEnabled: Boolean? = nil) {
        self.policyDocument = policyDocument
        self.policyEnabled = policyEnabled
    }

    enum CodingKeys: String, CodingKey {
        case policyDocument
        case policyEnabled
    }

    public func validate() throws {
    }
}

public struct ModifyVerifiedAccessEndpointRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var loadBalancerOptions: ModifyVerifiedAccessEndpointLoadBalancerOptions?
    public var networkInterfaceOptions: ModifyVerifiedAccessEndpointEniOptions?
    public var verifiedAccessEndpointId: VerifiedAccessEndpointId
    public var verifiedAccessGroupId: VerifiedAccessGroupId?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                loadBalancerOptions: ModifyVerifiedAccessEndpointLoadBalancerOptions? = nil,
                networkInterfaceOptions: ModifyVerifiedAccessEndpointEniOptions? = nil,
                verifiedAccessEndpointId: VerifiedAccessEndpointId,
                verifiedAccessGroupId: VerifiedAccessGroupId? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.loadBalancerOptions = loadBalancerOptions
        self.networkInterfaceOptions = networkInterfaceOptions
        self.verifiedAccessEndpointId = verifiedAccessEndpointId
        self.verifiedAccessGroupId = verifiedAccessGroupId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case loadBalancerOptions = "LoadBalancerOptions"
        case networkInterfaceOptions = "NetworkInterfaceOptions"
        case verifiedAccessEndpointId = "VerifiedAccessEndpointId"
        case verifiedAccessGroupId = "VerifiedAccessGroupId"
    }

    public func validate() throws {
        try loadBalancerOptions?.validate()
        try networkInterfaceOptions?.validate()
    }
}

public struct ModifyVerifiedAccessEndpointResult: Codable, Equatable {
    public var verifiedAccessEndpoint: VerifiedAccessEndpoint?

    public init(verifiedAccessEndpoint: VerifiedAccessEndpoint? = nil) {
        self.verifiedAccessEndpoint = verifiedAccessEndpoint
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessEndpoint
    }

    public func validate() throws {
        try verifiedAccessEndpoint?.validate()
    }
}

public struct ModifyVerifiedAccessGroupPolicyRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var policyDocument: String?
    public var policyEnabled: Boolean
    public var verifiedAccessGroupId: VerifiedAccessGroupId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                policyDocument: String? = nil,
                policyEnabled: Boolean,
                verifiedAccessGroupId: VerifiedAccessGroupId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.policyDocument = policyDocument
        self.policyEnabled = policyEnabled
        self.verifiedAccessGroupId = verifiedAccessGroupId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case policyDocument = "PolicyDocument"
        case policyEnabled = "PolicyEnabled"
        case verifiedAccessGroupId = "VerifiedAccessGroupId"
    }

    public func validate() throws {
    }
}

public struct ModifyVerifiedAccessGroupPolicyResult: Codable, Equatable {
    public var policyDocument: String?
    public var policyEnabled: Boolean?

    public init(policyDocument: String? = nil,
                policyEnabled: Boolean? = nil) {
        self.policyDocument = policyDocument
        self.policyEnabled = policyEnabled
    }

    enum CodingKeys: String, CodingKey {
        case policyDocument
        case policyEnabled
    }

    public func validate() throws {
    }
}

public struct ModifyVerifiedAccessGroupRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var verifiedAccessGroupId: VerifiedAccessGroupId
    public var verifiedAccessInstanceId: VerifiedAccessInstanceId?

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                verifiedAccessGroupId: VerifiedAccessGroupId,
                verifiedAccessInstanceId: VerifiedAccessInstanceId? = nil) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.verifiedAccessGroupId = verifiedAccessGroupId
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case verifiedAccessGroupId = "VerifiedAccessGroupId"
        case verifiedAccessInstanceId = "VerifiedAccessInstanceId"
    }

    public func validate() throws {
    }
}

public struct ModifyVerifiedAccessGroupResult: Codable, Equatable {
    public var verifiedAccessGroup: VerifiedAccessGroup?

    public init(verifiedAccessGroup: VerifiedAccessGroup? = nil) {
        self.verifiedAccessGroup = verifiedAccessGroup
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessGroup
    }

    public func validate() throws {
        try verifiedAccessGroup?.validate()
    }
}

public struct ModifyVerifiedAccessInstanceLoggingConfigurationRequest: Codable, Equatable {
    public var accessLogs: VerifiedAccessLogOptions
    public var clientToken: String?
    public var dryRun: Boolean?
    public var verifiedAccessInstanceId: VerifiedAccessInstanceId

    public init(accessLogs: VerifiedAccessLogOptions,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                verifiedAccessInstanceId: VerifiedAccessInstanceId) {
        self.accessLogs = accessLogs
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case accessLogs = "AccessLogs"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case verifiedAccessInstanceId = "VerifiedAccessInstanceId"
    }

    public func validate() throws {
        try accessLogs.validate()
    }
}

public struct ModifyVerifiedAccessInstanceLoggingConfigurationResult: Codable, Equatable {
    public var loggingConfiguration: VerifiedAccessInstanceLoggingConfiguration?

    public init(loggingConfiguration: VerifiedAccessInstanceLoggingConfiguration? = nil) {
        self.loggingConfiguration = loggingConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case loggingConfiguration
    }

    public func validate() throws {
        try loggingConfiguration?.validate()
    }
}

public struct ModifyVerifiedAccessInstanceRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var verifiedAccessInstanceId: VerifiedAccessInstanceId

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                verifiedAccessInstanceId: VerifiedAccessInstanceId) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case verifiedAccessInstanceId = "VerifiedAccessInstanceId"
    }

    public func validate() throws {
    }
}

public struct ModifyVerifiedAccessInstanceResult: Codable, Equatable {
    public var verifiedAccessInstance: VerifiedAccessInstance?

    public init(verifiedAccessInstance: VerifiedAccessInstance? = nil) {
        self.verifiedAccessInstance = verifiedAccessInstance
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessInstance
    }

    public func validate() throws {
        try verifiedAccessInstance?.validate()
    }
}

public struct ModifyVerifiedAccessTrustProviderOidcOptions: Codable, Equatable {
    public var scope: String?

    public init(scope: String? = nil) {
        self.scope = scope
    }

    enum CodingKeys: String, CodingKey {
        case scope = "Scope"
    }

    public func validate() throws {
    }
}

public struct ModifyVerifiedAccessTrustProviderRequest: Codable, Equatable {
    public var clientToken: String?
    public var description: String?
    public var dryRun: Boolean?
    public var oidcOptions: ModifyVerifiedAccessTrustProviderOidcOptions?
    public var verifiedAccessTrustProviderId: VerifiedAccessTrustProviderId

    public init(clientToken: String? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                oidcOptions: ModifyVerifiedAccessTrustProviderOidcOptions? = nil,
                verifiedAccessTrustProviderId: VerifiedAccessTrustProviderId) {
        self.clientToken = clientToken
        self.description = description
        self.dryRun = dryRun
        self.oidcOptions = oidcOptions
        self.verifiedAccessTrustProviderId = verifiedAccessTrustProviderId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case dryRun = "DryRun"
        case oidcOptions = "OidcOptions"
        case verifiedAccessTrustProviderId = "VerifiedAccessTrustProviderId"
    }

    public func validate() throws {
        try oidcOptions?.validate()
    }
}

public struct ModifyVerifiedAccessTrustProviderResult: Codable, Equatable {
    public var verifiedAccessTrustProvider: VerifiedAccessTrustProvider?

    public init(verifiedAccessTrustProvider: VerifiedAccessTrustProvider? = nil) {
        self.verifiedAccessTrustProvider = verifiedAccessTrustProvider
    }

    enum CodingKeys: String, CodingKey {
        case verifiedAccessTrustProvider
    }

    public func validate() throws {
        try verifiedAccessTrustProvider?.validate()
    }
}

public struct ModifyVolumeAttributeRequest: Codable, Equatable {
    public var autoEnableIO: AttributeBooleanValue?
    public var dryRun: Boolean?
    public var volumeId: VolumeId

    public init(autoEnableIO: AttributeBooleanValue? = nil,
                dryRun: Boolean? = nil,
                volumeId: VolumeId) {
        self.autoEnableIO = autoEnableIO
        self.dryRun = dryRun
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case autoEnableIO = "AutoEnableIO"
        case dryRun
        case volumeId = "VolumeId"
    }

    public func validate() throws {
        try autoEnableIO?.validate()
    }
}

public struct ModifyVolumeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var iops: Integer?
    public var multiAttachEnabled: Boolean?
    public var size: Integer?
    public var throughput: Integer?
    public var volumeId: VolumeId
    public var volumeType: VolumeType?

    public init(dryRun: Boolean? = nil,
                iops: Integer? = nil,
                multiAttachEnabled: Boolean? = nil,
                size: Integer? = nil,
                throughput: Integer? = nil,
                volumeId: VolumeId,
                volumeType: VolumeType? = nil) {
        self.dryRun = dryRun
        self.iops = iops
        self.multiAttachEnabled = multiAttachEnabled
        self.size = size
        self.throughput = throughput
        self.volumeId = volumeId
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case iops = "Iops"
        case multiAttachEnabled = "MultiAttachEnabled"
        case size = "Size"
        case throughput = "Throughput"
        case volumeId = "VolumeId"
        case volumeType = "VolumeType"
    }

    public func validate() throws {
    }
}

public struct ModifyVolumeResult: Codable, Equatable {
    public var volumeModification: VolumeModification?

    public init(volumeModification: VolumeModification? = nil) {
        self.volumeModification = volumeModification
    }

    enum CodingKeys: String, CodingKey {
        case volumeModification
    }

    public func validate() throws {
        try volumeModification?.validate()
    }
}

public struct ModifyVpcAttributeRequest: Codable, Equatable {
    public var enableDnsHostnames: AttributeBooleanValue?
    public var enableDnsSupport: AttributeBooleanValue?
    public var enableNetworkAddressUsageMetrics: AttributeBooleanValue?
    public var vpcId: VpcId

    public init(enableDnsHostnames: AttributeBooleanValue? = nil,
                enableDnsSupport: AttributeBooleanValue? = nil,
                enableNetworkAddressUsageMetrics: AttributeBooleanValue? = nil,
                vpcId: VpcId) {
        self.enableDnsHostnames = enableDnsHostnames
        self.enableDnsSupport = enableDnsSupport
        self.enableNetworkAddressUsageMetrics = enableNetworkAddressUsageMetrics
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case enableDnsHostnames = "EnableDnsHostnames"
        case enableDnsSupport = "EnableDnsSupport"
        case enableNetworkAddressUsageMetrics = "EnableNetworkAddressUsageMetrics"
        case vpcId
    }

    public func validate() throws {
        try enableDnsHostnames?.validate()
        try enableDnsSupport?.validate()
        try enableNetworkAddressUsageMetrics?.validate()
    }
}

public struct ModifyVpcEndpointConnectionNotificationRequest: Codable, Equatable {
    public var connectionEvents: ValueStringList?
    public var connectionNotificationArn: String?
    public var connectionNotificationId: ConnectionNotificationId
    public var dryRun: Boolean?

    public init(connectionEvents: ValueStringList? = nil,
                connectionNotificationArn: String? = nil,
                connectionNotificationId: ConnectionNotificationId,
                dryRun: Boolean? = nil) {
        self.connectionEvents = connectionEvents
        self.connectionNotificationArn = connectionNotificationArn
        self.connectionNotificationId = connectionNotificationId
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case connectionEvents = "ConnectionEvents"
        case connectionNotificationArn = "ConnectionNotificationArn"
        case connectionNotificationId = "ConnectionNotificationId"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointConnectionNotificationResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointRequest: Codable, Equatable {
    public var addRouteTableIds: VpcEndpointRouteTableIdList?
    public var addSecurityGroupIds: VpcEndpointSecurityGroupIdList?
    public var addSubnetIds: VpcEndpointSubnetIdList?
    public var dnsOptions: DnsOptionsSpecification?
    public var dryRun: Boolean?
    public var ipAddressType: IpAddressType?
    public var policyDocument: String?
    public var privateDnsEnabled: Boolean?
    public var removeRouteTableIds: VpcEndpointRouteTableIdList?
    public var removeSecurityGroupIds: VpcEndpointSecurityGroupIdList?
    public var removeSubnetIds: VpcEndpointSubnetIdList?
    public var resetPolicy: Boolean?
    public var vpcEndpointId: VpcEndpointId

    public init(addRouteTableIds: VpcEndpointRouteTableIdList? = nil,
                addSecurityGroupIds: VpcEndpointSecurityGroupIdList? = nil,
                addSubnetIds: VpcEndpointSubnetIdList? = nil,
                dnsOptions: DnsOptionsSpecification? = nil,
                dryRun: Boolean? = nil,
                ipAddressType: IpAddressType? = nil,
                policyDocument: String? = nil,
                privateDnsEnabled: Boolean? = nil,
                removeRouteTableIds: VpcEndpointRouteTableIdList? = nil,
                removeSecurityGroupIds: VpcEndpointSecurityGroupIdList? = nil,
                removeSubnetIds: VpcEndpointSubnetIdList? = nil,
                resetPolicy: Boolean? = nil,
                vpcEndpointId: VpcEndpointId) {
        self.addRouteTableIds = addRouteTableIds
        self.addSecurityGroupIds = addSecurityGroupIds
        self.addSubnetIds = addSubnetIds
        self.dnsOptions = dnsOptions
        self.dryRun = dryRun
        self.ipAddressType = ipAddressType
        self.policyDocument = policyDocument
        self.privateDnsEnabled = privateDnsEnabled
        self.removeRouteTableIds = removeRouteTableIds
        self.removeSecurityGroupIds = removeSecurityGroupIds
        self.removeSubnetIds = removeSubnetIds
        self.resetPolicy = resetPolicy
        self.vpcEndpointId = vpcEndpointId
    }

    enum CodingKeys: String, CodingKey {
        case addRouteTableIds = "AddRouteTableId"
        case addSecurityGroupIds = "AddSecurityGroupId"
        case addSubnetIds = "AddSubnetId"
        case dnsOptions = "DnsOptions"
        case dryRun = "DryRun"
        case ipAddressType = "IpAddressType"
        case policyDocument = "PolicyDocument"
        case privateDnsEnabled = "PrivateDnsEnabled"
        case removeRouteTableIds = "RemoveRouteTableId"
        case removeSecurityGroupIds = "RemoveSecurityGroupId"
        case removeSubnetIds = "RemoveSubnetId"
        case resetPolicy = "ResetPolicy"
        case vpcEndpointId = "VpcEndpointId"
    }

    public func validate() throws {
        try dnsOptions?.validate()
    }
}

public struct ModifyVpcEndpointResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServiceConfigurationRequest: Codable, Equatable {
    public var acceptanceRequired: Boolean?
    public var addGatewayLoadBalancerArns: ValueStringList?
    public var addNetworkLoadBalancerArns: ValueStringList?
    public var addSupportedIpAddressTypes: ValueStringList?
    public var dryRun: Boolean?
    public var privateDnsName: String?
    public var removeGatewayLoadBalancerArns: ValueStringList?
    public var removeNetworkLoadBalancerArns: ValueStringList?
    public var removePrivateDnsName: Boolean?
    public var removeSupportedIpAddressTypes: ValueStringList?
    public var serviceId: VpcEndpointServiceId

    public init(acceptanceRequired: Boolean? = nil,
                addGatewayLoadBalancerArns: ValueStringList? = nil,
                addNetworkLoadBalancerArns: ValueStringList? = nil,
                addSupportedIpAddressTypes: ValueStringList? = nil,
                dryRun: Boolean? = nil,
                privateDnsName: String? = nil,
                removeGatewayLoadBalancerArns: ValueStringList? = nil,
                removeNetworkLoadBalancerArns: ValueStringList? = nil,
                removePrivateDnsName: Boolean? = nil,
                removeSupportedIpAddressTypes: ValueStringList? = nil,
                serviceId: VpcEndpointServiceId) {
        self.acceptanceRequired = acceptanceRequired
        self.addGatewayLoadBalancerArns = addGatewayLoadBalancerArns
        self.addNetworkLoadBalancerArns = addNetworkLoadBalancerArns
        self.addSupportedIpAddressTypes = addSupportedIpAddressTypes
        self.dryRun = dryRun
        self.privateDnsName = privateDnsName
        self.removeGatewayLoadBalancerArns = removeGatewayLoadBalancerArns
        self.removeNetworkLoadBalancerArns = removeNetworkLoadBalancerArns
        self.removePrivateDnsName = removePrivateDnsName
        self.removeSupportedIpAddressTypes = removeSupportedIpAddressTypes
        self.serviceId = serviceId
    }

    enum CodingKeys: String, CodingKey {
        case acceptanceRequired = "AcceptanceRequired"
        case addGatewayLoadBalancerArns = "AddGatewayLoadBalancerArn"
        case addNetworkLoadBalancerArns = "AddNetworkLoadBalancerArn"
        case addSupportedIpAddressTypes = "AddSupportedIpAddressType"
        case dryRun = "DryRun"
        case privateDnsName = "PrivateDnsName"
        case removeGatewayLoadBalancerArns = "RemoveGatewayLoadBalancerArn"
        case removeNetworkLoadBalancerArns = "RemoveNetworkLoadBalancerArn"
        case removePrivateDnsName = "RemovePrivateDnsName"
        case removeSupportedIpAddressTypes = "RemoveSupportedIpAddressType"
        case serviceId = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServiceConfigurationResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServicePayerResponsibilityRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var payerResponsibility: PayerResponsibility
    public var serviceId: VpcEndpointServiceId

    public init(dryRun: Boolean? = nil,
                payerResponsibility: PayerResponsibility,
                serviceId: VpcEndpointServiceId) {
        self.dryRun = dryRun
        self.payerResponsibility = payerResponsibility
        self.serviceId = serviceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case payerResponsibility = "PayerResponsibility"
        case serviceId = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServicePayerResponsibilityResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServicePermissionsRequest: Codable, Equatable {
    public var addAllowedPrincipals: ValueStringList?
    public var dryRun: Boolean?
    public var removeAllowedPrincipals: ValueStringList?
    public var serviceId: VpcEndpointServiceId

    public init(addAllowedPrincipals: ValueStringList? = nil,
                dryRun: Boolean? = nil,
                removeAllowedPrincipals: ValueStringList? = nil,
                serviceId: VpcEndpointServiceId) {
        self.addAllowedPrincipals = addAllowedPrincipals
        self.dryRun = dryRun
        self.removeAllowedPrincipals = removeAllowedPrincipals
        self.serviceId = serviceId
    }

    enum CodingKeys: String, CodingKey {
        case addAllowedPrincipals = "AddAllowedPrincipals"
        case dryRun = "DryRun"
        case removeAllowedPrincipals = "RemoveAllowedPrincipals"
        case serviceId = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcEndpointServicePermissionsResult: Codable, Equatable {
    public var addedPrincipals: AddedPrincipalSet?
    public var returnValue: Boolean?

    public init(addedPrincipals: AddedPrincipalSet? = nil,
                returnValue: Boolean? = nil) {
        self.addedPrincipals = addedPrincipals
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case addedPrincipals = "addedPrincipalSet"
        case returnValue = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcPeeringConnectionOptionsRequest: Codable, Equatable {
    public var accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest?
    public var dryRun: Boolean?
    public var requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId

    public init(accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil,
                dryRun: Boolean? = nil,
                requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId) {
        self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
        self.dryRun = dryRun
        self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case accepterPeeringConnectionOptions = "AccepterPeeringConnectionOptions"
        case dryRun = "DryRun"
        case requesterPeeringConnectionOptions = "RequesterPeeringConnectionOptions"
        case vpcPeeringConnectionId = "VpcPeeringConnectionId"
    }

    public func validate() throws {
        try accepterPeeringConnectionOptions?.validate()
        try requesterPeeringConnectionOptions?.validate()
    }
}

public struct ModifyVpcPeeringConnectionOptionsResult: Codable, Equatable {
    public var accepterPeeringConnectionOptions: PeeringConnectionOptions?
    public var requesterPeeringConnectionOptions: PeeringConnectionOptions?

    public init(accepterPeeringConnectionOptions: PeeringConnectionOptions? = nil,
                requesterPeeringConnectionOptions: PeeringConnectionOptions? = nil) {
        self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
        self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
    }

    enum CodingKeys: String, CodingKey {
        case accepterPeeringConnectionOptions
        case requesterPeeringConnectionOptions
    }

    public func validate() throws {
        try accepterPeeringConnectionOptions?.validate()
        try requesterPeeringConnectionOptions?.validate()
    }
}

public struct ModifyVpcTenancyRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceTenancy: VpcTenancy
    public var vpcId: VpcId

    public init(dryRun: Boolean? = nil,
                instanceTenancy: VpcTenancy,
                vpcId: VpcId) {
        self.dryRun = dryRun
        self.instanceTenancy = instanceTenancy
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceTenancy = "InstanceTenancy"
        case vpcId = "VpcId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpcTenancyResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue = "return"
    }

    public func validate() throws {
    }
}

public struct ModifyVpnConnectionOptionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var localIpv4NetworkCidr: String?
    public var localIpv6NetworkCidr: String?
    public var remoteIpv4NetworkCidr: String?
    public var remoteIpv6NetworkCidr: String?
    public var vpnConnectionId: VpnConnectionId

    public init(dryRun: Boolean? = nil,
                localIpv4NetworkCidr: String? = nil,
                localIpv6NetworkCidr: String? = nil,
                remoteIpv4NetworkCidr: String? = nil,
                remoteIpv6NetworkCidr: String? = nil,
                vpnConnectionId: VpnConnectionId) {
        self.dryRun = dryRun
        self.localIpv4NetworkCidr = localIpv4NetworkCidr
        self.localIpv6NetworkCidr = localIpv6NetworkCidr
        self.remoteIpv4NetworkCidr = remoteIpv4NetworkCidr
        self.remoteIpv6NetworkCidr = remoteIpv6NetworkCidr
        self.vpnConnectionId = vpnConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case localIpv4NetworkCidr = "LocalIpv4NetworkCidr"
        case localIpv6NetworkCidr = "LocalIpv6NetworkCidr"
        case remoteIpv4NetworkCidr = "RemoteIpv4NetworkCidr"
        case remoteIpv6NetworkCidr = "RemoteIpv6NetworkCidr"
        case vpnConnectionId = "VpnConnectionId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpnConnectionOptionsResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct ModifyVpnConnectionRequest: Codable, Equatable {
    public var customerGatewayId: CustomerGatewayId?
    public var dryRun: Boolean?
    public var transitGatewayId: TransitGatewayId?
    public var vpnConnectionId: VpnConnectionId
    public var vpnGatewayId: VpnGatewayId?

    public init(customerGatewayId: CustomerGatewayId? = nil,
                dryRun: Boolean? = nil,
                transitGatewayId: TransitGatewayId? = nil,
                vpnConnectionId: VpnConnectionId,
                vpnGatewayId: VpnGatewayId? = nil) {
        self.customerGatewayId = customerGatewayId
        self.dryRun = dryRun
        self.transitGatewayId = transitGatewayId
        self.vpnConnectionId = vpnConnectionId
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case customerGatewayId = "CustomerGatewayId"
        case dryRun = "DryRun"
        case transitGatewayId = "TransitGatewayId"
        case vpnConnectionId = "VpnConnectionId"
        case vpnGatewayId = "VpnGatewayId"
    }

    public func validate() throws {
    }
}

public struct ModifyVpnConnectionResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct ModifyVpnTunnelCertificateRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpnConnectionId: VpnConnectionId
    public var vpnTunnelOutsideIpAddress: String

    public init(dryRun: Boolean? = nil,
                vpnConnectionId: VpnConnectionId,
                vpnTunnelOutsideIpAddress: String) {
        self.dryRun = dryRun
        self.vpnConnectionId = vpnConnectionId
        self.vpnTunnelOutsideIpAddress = vpnTunnelOutsideIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case vpnConnectionId = "VpnConnectionId"
        case vpnTunnelOutsideIpAddress = "VpnTunnelOutsideIpAddress"
    }

    public func validate() throws {
    }
}

public struct ModifyVpnTunnelCertificateResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct ModifyVpnTunnelOptionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var tunnelOptions: ModifyVpnTunnelOptionsSpecification
    public var vpnConnectionId: VpnConnectionId
    public var vpnTunnelOutsideIpAddress: String

    public init(dryRun: Boolean? = nil,
                tunnelOptions: ModifyVpnTunnelOptionsSpecification,
                vpnConnectionId: VpnConnectionId,
                vpnTunnelOutsideIpAddress: String) {
        self.dryRun = dryRun
        self.tunnelOptions = tunnelOptions
        self.vpnConnectionId = vpnConnectionId
        self.vpnTunnelOutsideIpAddress = vpnTunnelOutsideIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case tunnelOptions = "TunnelOptions"
        case vpnConnectionId = "VpnConnectionId"
        case vpnTunnelOutsideIpAddress = "VpnTunnelOutsideIpAddress"
    }

    public func validate() throws {
        try tunnelOptions.validate()
    }
}

public struct ModifyVpnTunnelOptionsResult: Codable, Equatable {
    public var vpnConnection: VpnConnection?

    public init(vpnConnection: VpnConnection? = nil) {
        self.vpnConnection = vpnConnection
    }

    enum CodingKeys: String, CodingKey {
        case vpnConnection
    }

    public func validate() throws {
        try vpnConnection?.validate()
    }
}

public struct ModifyVpnTunnelOptionsSpecification: Codable, Equatable {
    public var dPDTimeoutAction: String?
    public var dPDTimeoutSeconds: Integer?
    public var iKEVersions: IKEVersionsRequestList?
    public var logOptions: VpnTunnelLogOptionsSpecification?
    public var phase1DHGroupNumbers: Phase1DHGroupNumbersRequestList?
    public var phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsRequestList?
    public var phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsRequestList?
    public var phase1LifetimeSeconds: Integer?
    public var phase2DHGroupNumbers: Phase2DHGroupNumbersRequestList?
    public var phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsRequestList?
    public var phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsRequestList?
    public var phase2LifetimeSeconds: Integer?
    public var preSharedKey: String?
    public var rekeyFuzzPercentage: Integer?
    public var rekeyMarginTimeSeconds: Integer?
    public var replayWindowSize: Integer?
    public var startupAction: String?
    public var tunnelInsideCidr: String?
    public var tunnelInsideIpv6Cidr: String?

    public init(dPDTimeoutAction: String? = nil,
                dPDTimeoutSeconds: Integer? = nil,
                iKEVersions: IKEVersionsRequestList? = nil,
                logOptions: VpnTunnelLogOptionsSpecification? = nil,
                phase1DHGroupNumbers: Phase1DHGroupNumbersRequestList? = nil,
                phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsRequestList? = nil,
                phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsRequestList? = nil,
                phase1LifetimeSeconds: Integer? = nil,
                phase2DHGroupNumbers: Phase2DHGroupNumbersRequestList? = nil,
                phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsRequestList? = nil,
                phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsRequestList? = nil,
                phase2LifetimeSeconds: Integer? = nil,
                preSharedKey: String? = nil,
                rekeyFuzzPercentage: Integer? = nil,
                rekeyMarginTimeSeconds: Integer? = nil,
                replayWindowSize: Integer? = nil,
                startupAction: String? = nil,
                tunnelInsideCidr: String? = nil,
                tunnelInsideIpv6Cidr: String? = nil) {
        self.dPDTimeoutAction = dPDTimeoutAction
        self.dPDTimeoutSeconds = dPDTimeoutSeconds
        self.iKEVersions = iKEVersions
        self.logOptions = logOptions
        self.phase1DHGroupNumbers = phase1DHGroupNumbers
        self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
        self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
        self.phase1LifetimeSeconds = phase1LifetimeSeconds
        self.phase2DHGroupNumbers = phase2DHGroupNumbers
        self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
        self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
        self.phase2LifetimeSeconds = phase2LifetimeSeconds
        self.preSharedKey = preSharedKey
        self.rekeyFuzzPercentage = rekeyFuzzPercentage
        self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
        self.replayWindowSize = replayWindowSize
        self.startupAction = startupAction
        self.tunnelInsideCidr = tunnelInsideCidr
        self.tunnelInsideIpv6Cidr = tunnelInsideIpv6Cidr
    }

    enum CodingKeys: String, CodingKey {
        case dPDTimeoutAction = "DPDTimeoutAction"
        case dPDTimeoutSeconds = "DPDTimeoutSeconds"
        case iKEVersions = "IKEVersion"
        case logOptions = "LogOptions"
        case phase1DHGroupNumbers = "Phase1DHGroupNumber"
        case phase1EncryptionAlgorithms = "Phase1EncryptionAlgorithm"
        case phase1IntegrityAlgorithms = "Phase1IntegrityAlgorithm"
        case phase1LifetimeSeconds = "Phase1LifetimeSeconds"
        case phase2DHGroupNumbers = "Phase2DHGroupNumber"
        case phase2EncryptionAlgorithms = "Phase2EncryptionAlgorithm"
        case phase2IntegrityAlgorithms = "Phase2IntegrityAlgorithm"
        case phase2LifetimeSeconds = "Phase2LifetimeSeconds"
        case preSharedKey = "PreSharedKey"
        case rekeyFuzzPercentage = "RekeyFuzzPercentage"
        case rekeyMarginTimeSeconds = "RekeyMarginTimeSeconds"
        case replayWindowSize = "ReplayWindowSize"
        case startupAction = "StartupAction"
        case tunnelInsideCidr = "TunnelInsideCidr"
        case tunnelInsideIpv6Cidr = "TunnelInsideIpv6Cidr"
    }

    public func validate() throws {
        try logOptions?.validate()
    }
}

public struct MonitorInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct MonitorInstancesResult: Codable, Equatable {
    public var instanceMonitorings: InstanceMonitoringList?

    public init(instanceMonitorings: InstanceMonitoringList? = nil) {
        self.instanceMonitorings = instanceMonitorings
    }

    enum CodingKeys: String, CodingKey {
        case instanceMonitorings = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct Monitoring: Codable, Equatable {
    public var state: MonitoringState?

    public init(state: MonitoringState? = nil) {
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case state
    }

    public func validate() throws {
    }
}

public struct MoveAddressToVpcRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var publicIp: String

    public init(dryRun: Boolean? = nil,
                publicIp: String) {
        self.dryRun = dryRun
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case publicIp
    }

    public func validate() throws {
    }
}

public struct MoveAddressToVpcResult: Codable, Equatable {
    public var allocationId: String?
    public var status: Status?

    public init(allocationId: String? = nil,
                status: Status? = nil) {
        self.allocationId = allocationId
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case status
    }

    public func validate() throws {
    }
}

public struct MoveByoipCidrToIpamRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?
    public var ipamPoolId: IpamPoolId
    public var ipamPoolOwner: String

    public init(cidr: String,
                dryRun: Boolean? = nil,
                ipamPoolId: IpamPoolId,
                ipamPoolOwner: String) {
        self.cidr = cidr
        self.dryRun = dryRun
        self.ipamPoolId = ipamPoolId
        self.ipamPoolOwner = ipamPoolOwner
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
        case ipamPoolId = "IpamPoolId"
        case ipamPoolOwner = "IpamPoolOwner"
    }

    public func validate() throws {
    }
}

public struct MoveByoipCidrToIpamResult: Codable, Equatable {
    public var byoipCidr: ByoipCidr?

    public init(byoipCidr: ByoipCidr? = nil) {
        self.byoipCidr = byoipCidr
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidr
    }

    public func validate() throws {
        try byoipCidr?.validate()
    }
}

public struct MovingAddressStatus: Codable, Equatable {
    public var moveStatus: MoveStatus?
    public var publicIp: String?

    public init(moveStatus: MoveStatus? = nil,
                publicIp: String? = nil) {
        self.moveStatus = moveStatus
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case moveStatus
        case publicIp
    }

    public func validate() throws {
    }
}

public struct NatGateway: Codable, Equatable {
    public var connectivityType: ConnectivityType?
    public var createTime: DateTime?
    public var deleteTime: DateTime?
    public var failureCode: String?
    public var failureMessage: String?
    public var natGatewayAddresses: NatGatewayAddressList?
    public var natGatewayId: String?
    public var provisionedBandwidth: ProvisionedBandwidth?
    public var state: NatGatewayState?
    public var subnetId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(connectivityType: ConnectivityType? = nil,
                createTime: DateTime? = nil,
                deleteTime: DateTime? = nil,
                failureCode: String? = nil,
                failureMessage: String? = nil,
                natGatewayAddresses: NatGatewayAddressList? = nil,
                natGatewayId: String? = nil,
                provisionedBandwidth: ProvisionedBandwidth? = nil,
                state: NatGatewayState? = nil,
                subnetId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.connectivityType = connectivityType
        self.createTime = createTime
        self.deleteTime = deleteTime
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.natGatewayAddresses = natGatewayAddresses
        self.natGatewayId = natGatewayId
        self.provisionedBandwidth = provisionedBandwidth
        self.state = state
        self.subnetId = subnetId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case connectivityType
        case createTime
        case deleteTime
        case failureCode
        case failureMessage
        case natGatewayAddresses = "natGatewayAddressSet"
        case natGatewayId
        case provisionedBandwidth
        case state
        case subnetId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
        try provisionedBandwidth?.validate()
    }
}

public struct NatGatewayAddress: Codable, Equatable {
    public var allocationId: String?
    public var networkInterfaceId: String?
    public var privateIp: String?
    public var publicIp: String?

    public init(allocationId: String? = nil,
                networkInterfaceId: String? = nil,
                privateIp: String? = nil,
                publicIp: String? = nil) {
        self.allocationId = allocationId
        self.networkInterfaceId = networkInterfaceId
        self.privateIp = privateIp
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case networkInterfaceId
        case privateIp
        case publicIp
    }

    public func validate() throws {
    }
}

public struct NetworkAcl: Codable, Equatable {
    public var associations: NetworkAclAssociationList?
    public var entries: NetworkAclEntryList?
    public var isDefault: Boolean?
    public var networkAclId: String?
    public var ownerId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(associations: NetworkAclAssociationList? = nil,
                entries: NetworkAclEntryList? = nil,
                isDefault: Boolean? = nil,
                networkAclId: String? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.associations = associations
        self.entries = entries
        self.isDefault = isDefault
        self.networkAclId = networkAclId
        self.ownerId = ownerId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case associations = "associationSet"
        case entries = "entrySet"
        case isDefault = "default"
        case networkAclId
        case ownerId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct NetworkAclAssociation: Codable, Equatable {
    public var networkAclAssociationId: String?
    public var networkAclId: String?
    public var subnetId: String?

    public init(networkAclAssociationId: String? = nil,
                networkAclId: String? = nil,
                subnetId: String? = nil) {
        self.networkAclAssociationId = networkAclAssociationId
        self.networkAclId = networkAclId
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case networkAclAssociationId
        case networkAclId
        case subnetId
    }

    public func validate() throws {
    }
}

public struct NetworkAclEntry: Codable, Equatable {
    public var cidrBlock: String?
    public var egress: Boolean?
    public var icmpTypeCode: IcmpTypeCode?
    public var ipv6CidrBlock: String?
    public var portRange: PortRange?
    public var `protocol`: String?
    public var ruleAction: RuleAction?
    public var ruleNumber: Integer?

    public init(cidrBlock: String? = nil,
                egress: Boolean? = nil,
                icmpTypeCode: IcmpTypeCode? = nil,
                ipv6CidrBlock: String? = nil,
                portRange: PortRange? = nil,
                `protocol`: String? = nil,
                ruleAction: RuleAction? = nil,
                ruleNumber: Integer? = nil) {
        self.cidrBlock = cidrBlock
        self.egress = egress
        self.icmpTypeCode = icmpTypeCode
        self.ipv6CidrBlock = ipv6CidrBlock
        self.portRange = portRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case egress
        case icmpTypeCode
        case ipv6CidrBlock
        case portRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
    }

    public func validate() throws {
        try icmpTypeCode?.validate()
        try portRange?.validate()
    }
}

public struct NetworkBandwidthGbps: Codable, Equatable {
    public var max: Double?
    public var min: Double?

    public init(max: Double? = nil,
                min: Double? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max
        case min
    }

    public func validate() throws {
    }
}

public struct NetworkBandwidthGbpsRequest: Codable, Equatable {
    public var max: Double?
    public var min: Double?

    public init(max: Double? = nil,
                min: Double? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func validate() throws {
    }
}

public struct NetworkCardInfo: Codable, Equatable {
    public var maximumNetworkInterfaces: MaxNetworkInterfaces?
    public var networkCardIndex: NetworkCardIndex?
    public var networkPerformance: NetworkPerformance?

    public init(maximumNetworkInterfaces: MaxNetworkInterfaces? = nil,
                networkCardIndex: NetworkCardIndex? = nil,
                networkPerformance: NetworkPerformance? = nil) {
        self.maximumNetworkInterfaces = maximumNetworkInterfaces
        self.networkCardIndex = networkCardIndex
        self.networkPerformance = networkPerformance
    }

    enum CodingKeys: String, CodingKey {
        case maximumNetworkInterfaces
        case networkCardIndex
        case networkPerformance
    }

    public func validate() throws {
    }
}

public struct NetworkInfo: Codable, Equatable {
    public var defaultNetworkCardIndex: DefaultNetworkCardIndex?
    public var efaInfo: EfaInfo?
    public var efaSupported: EfaSupportedFlag?
    public var enaSrdSupported: EnaSrdSupported?
    public var enaSupport: EnaSupport?
    public var encryptionInTransitSupported: EncryptionInTransitSupported?
    public var ipv4AddressesPerInterface: MaxIpv4AddrPerInterface?
    public var ipv6AddressesPerInterface: MaxIpv6AddrPerInterface?
    public var ipv6Supported: Ipv6Flag?
    public var maximumNetworkCards: MaximumNetworkCards?
    public var maximumNetworkInterfaces: MaxNetworkInterfaces?
    public var networkCards: NetworkCardInfoList?
    public var networkPerformance: NetworkPerformance?

    public init(defaultNetworkCardIndex: DefaultNetworkCardIndex? = nil,
                efaInfo: EfaInfo? = nil,
                efaSupported: EfaSupportedFlag? = nil,
                enaSrdSupported: EnaSrdSupported? = nil,
                enaSupport: EnaSupport? = nil,
                encryptionInTransitSupported: EncryptionInTransitSupported? = nil,
                ipv4AddressesPerInterface: MaxIpv4AddrPerInterface? = nil,
                ipv6AddressesPerInterface: MaxIpv6AddrPerInterface? = nil,
                ipv6Supported: Ipv6Flag? = nil,
                maximumNetworkCards: MaximumNetworkCards? = nil,
                maximumNetworkInterfaces: MaxNetworkInterfaces? = nil,
                networkCards: NetworkCardInfoList? = nil,
                networkPerformance: NetworkPerformance? = nil) {
        self.defaultNetworkCardIndex = defaultNetworkCardIndex
        self.efaInfo = efaInfo
        self.efaSupported = efaSupported
        self.enaSrdSupported = enaSrdSupported
        self.enaSupport = enaSupport
        self.encryptionInTransitSupported = encryptionInTransitSupported
        self.ipv4AddressesPerInterface = ipv4AddressesPerInterface
        self.ipv6AddressesPerInterface = ipv6AddressesPerInterface
        self.ipv6Supported = ipv6Supported
        self.maximumNetworkCards = maximumNetworkCards
        self.maximumNetworkInterfaces = maximumNetworkInterfaces
        self.networkCards = networkCards
        self.networkPerformance = networkPerformance
    }

    enum CodingKeys: String, CodingKey {
        case defaultNetworkCardIndex
        case efaInfo
        case efaSupported
        case enaSrdSupported
        case enaSupport
        case encryptionInTransitSupported
        case ipv4AddressesPerInterface
        case ipv6AddressesPerInterface
        case ipv6Supported
        case maximumNetworkCards
        case maximumNetworkInterfaces
        case networkCards
        case networkPerformance
    }

    public func validate() throws {
        try efaInfo?.validate()
    }
}

public struct NetworkInsightsAccessScope: Codable, Equatable {
    public var createdDate: MillisecondDateTime?
    public var networkInsightsAccessScopeArn: ResourceArn?
    public var networkInsightsAccessScopeId: NetworkInsightsAccessScopeId?
    public var tags: TagList?
    public var updatedDate: MillisecondDateTime?

    public init(createdDate: MillisecondDateTime? = nil,
                networkInsightsAccessScopeArn: ResourceArn? = nil,
                networkInsightsAccessScopeId: NetworkInsightsAccessScopeId? = nil,
                tags: TagList? = nil,
                updatedDate: MillisecondDateTime? = nil) {
        self.createdDate = createdDate
        self.networkInsightsAccessScopeArn = networkInsightsAccessScopeArn
        self.networkInsightsAccessScopeId = networkInsightsAccessScopeId
        self.tags = tags
        self.updatedDate = updatedDate
    }

    enum CodingKeys: String, CodingKey {
        case createdDate
        case networkInsightsAccessScopeArn
        case networkInsightsAccessScopeId
        case tags = "tagSet"
        case updatedDate
    }

    public func validate() throws {
        try networkInsightsAccessScopeArn?.validateAsResourceArn()
    }
}

public struct NetworkInsightsAccessScopeAnalysis: Codable, Equatable {
    public var analyzedEniCount: Integer?
    public var endDate: MillisecondDateTime?
    public var findingsFound: FindingsFound?
    public var networkInsightsAccessScopeAnalysisArn: ResourceArn?
    public var networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId?
    public var networkInsightsAccessScopeId: NetworkInsightsAccessScopeId?
    public var startDate: MillisecondDateTime?
    public var status: AnalysisStatus?
    public var statusMessage: String?
    public var tags: TagList?
    public var warningMessage: String?

    public init(analyzedEniCount: Integer? = nil,
                endDate: MillisecondDateTime? = nil,
                findingsFound: FindingsFound? = nil,
                networkInsightsAccessScopeAnalysisArn: ResourceArn? = nil,
                networkInsightsAccessScopeAnalysisId: NetworkInsightsAccessScopeAnalysisId? = nil,
                networkInsightsAccessScopeId: NetworkInsightsAccessScopeId? = nil,
                startDate: MillisecondDateTime? = nil,
                status: AnalysisStatus? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil,
                warningMessage: String? = nil) {
        self.analyzedEniCount = analyzedEniCount
        self.endDate = endDate
        self.findingsFound = findingsFound
        self.networkInsightsAccessScopeAnalysisArn = networkInsightsAccessScopeAnalysisArn
        self.networkInsightsAccessScopeAnalysisId = networkInsightsAccessScopeAnalysisId
        self.networkInsightsAccessScopeId = networkInsightsAccessScopeId
        self.startDate = startDate
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.warningMessage = warningMessage
    }

    enum CodingKeys: String, CodingKey {
        case analyzedEniCount
        case endDate
        case findingsFound
        case networkInsightsAccessScopeAnalysisArn
        case networkInsightsAccessScopeAnalysisId
        case networkInsightsAccessScopeId
        case startDate
        case status
        case statusMessage
        case tags = "tagSet"
        case warningMessage
    }

    public func validate() throws {
        try networkInsightsAccessScopeAnalysisArn?.validateAsResourceArn()
    }
}

public struct NetworkInsightsAccessScopeContent: Codable, Equatable {
    public var excludePaths: AccessScopePathList?
    public var matchPaths: AccessScopePathList?
    public var networkInsightsAccessScopeId: NetworkInsightsAccessScopeId?

    public init(excludePaths: AccessScopePathList? = nil,
                matchPaths: AccessScopePathList? = nil,
                networkInsightsAccessScopeId: NetworkInsightsAccessScopeId? = nil) {
        self.excludePaths = excludePaths
        self.matchPaths = matchPaths
        self.networkInsightsAccessScopeId = networkInsightsAccessScopeId
    }

    enum CodingKeys: String, CodingKey {
        case excludePaths = "excludePathSet"
        case matchPaths = "matchPathSet"
        case networkInsightsAccessScopeId
    }

    public func validate() throws {
    }
}

public struct NetworkInsightsAnalysis: Codable, Equatable {
    public var additionalAccounts: ValueStringList?
    public var alternatePathHints: AlternatePathHintList?
    public var explanations: ExplanationList?
    public var filterInArns: ArnList?
    public var forwardPathComponents: PathComponentList?
    public var networkInsightsAnalysisArn: ResourceArn?
    public var networkInsightsAnalysisId: NetworkInsightsAnalysisId?
    public var networkInsightsPathId: NetworkInsightsPathId?
    public var networkPathFound: Boolean?
    public var returnPathComponents: PathComponentList?
    public var startDate: MillisecondDateTime?
    public var status: AnalysisStatus?
    public var statusMessage: String?
    public var suggestedAccounts: ValueStringList?
    public var tags: TagList?
    public var warningMessage: String?

    public init(additionalAccounts: ValueStringList? = nil,
                alternatePathHints: AlternatePathHintList? = nil,
                explanations: ExplanationList? = nil,
                filterInArns: ArnList? = nil,
                forwardPathComponents: PathComponentList? = nil,
                networkInsightsAnalysisArn: ResourceArn? = nil,
                networkInsightsAnalysisId: NetworkInsightsAnalysisId? = nil,
                networkInsightsPathId: NetworkInsightsPathId? = nil,
                networkPathFound: Boolean? = nil,
                returnPathComponents: PathComponentList? = nil,
                startDate: MillisecondDateTime? = nil,
                status: AnalysisStatus? = nil,
                statusMessage: String? = nil,
                suggestedAccounts: ValueStringList? = nil,
                tags: TagList? = nil,
                warningMessage: String? = nil) {
        self.additionalAccounts = additionalAccounts
        self.alternatePathHints = alternatePathHints
        self.explanations = explanations
        self.filterInArns = filterInArns
        self.forwardPathComponents = forwardPathComponents
        self.networkInsightsAnalysisArn = networkInsightsAnalysisArn
        self.networkInsightsAnalysisId = networkInsightsAnalysisId
        self.networkInsightsPathId = networkInsightsPathId
        self.networkPathFound = networkPathFound
        self.returnPathComponents = returnPathComponents
        self.startDate = startDate
        self.status = status
        self.statusMessage = statusMessage
        self.suggestedAccounts = suggestedAccounts
        self.tags = tags
        self.warningMessage = warningMessage
    }

    enum CodingKeys: String, CodingKey {
        case additionalAccounts = "additionalAccountSet"
        case alternatePathHints = "alternatePathHintSet"
        case explanations = "explanationSet"
        case filterInArns = "filterInArnSet"
        case forwardPathComponents = "forwardPathComponentSet"
        case networkInsightsAnalysisArn
        case networkInsightsAnalysisId
        case networkInsightsPathId
        case networkPathFound
        case returnPathComponents = "returnPathComponentSet"
        case startDate
        case status
        case statusMessage
        case suggestedAccounts = "suggestedAccountSet"
        case tags = "tagSet"
        case warningMessage
    }

    public func validate() throws {
        try networkInsightsAnalysisArn?.validateAsResourceArn()
    }
}

public struct NetworkInsightsPath: Codable, Equatable {
    public var createdDate: MillisecondDateTime?
    public var destination: String?
    public var destinationArn: ResourceArn?
    public var destinationIp: IpAddress?
    public var destinationPort: Integer?
    public var networkInsightsPathArn: ResourceArn?
    public var networkInsightsPathId: NetworkInsightsPathId?
    public var `protocol`: Protocol?
    public var source: String?
    public var sourceArn: ResourceArn?
    public var sourceIp: IpAddress?
    public var tags: TagList?

    public init(createdDate: MillisecondDateTime? = nil,
                destination: String? = nil,
                destinationArn: ResourceArn? = nil,
                destinationIp: IpAddress? = nil,
                destinationPort: Integer? = nil,
                networkInsightsPathArn: ResourceArn? = nil,
                networkInsightsPathId: NetworkInsightsPathId? = nil,
                `protocol`: Protocol? = nil,
                source: String? = nil,
                sourceArn: ResourceArn? = nil,
                sourceIp: IpAddress? = nil,
                tags: TagList? = nil) {
        self.createdDate = createdDate
        self.destination = destination
        self.destinationArn = destinationArn
        self.destinationIp = destinationIp
        self.destinationPort = destinationPort
        self.networkInsightsPathArn = networkInsightsPathArn
        self.networkInsightsPathId = networkInsightsPathId
        self.`protocol` = `protocol`
        self.source = source
        self.sourceArn = sourceArn
        self.sourceIp = sourceIp
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case createdDate
        case destination
        case destinationArn
        case destinationIp
        case destinationPort
        case networkInsightsPathArn
        case networkInsightsPathId
        case `protocol` = "protocol"
        case source
        case sourceArn
        case sourceIp
        case tags = "tagSet"
    }

    public func validate() throws {
        try destinationArn?.validateAsResourceArn()
        try destinationIp?.validateAsIpAddress()
        try networkInsightsPathArn?.validateAsResourceArn()
        try sourceArn?.validateAsResourceArn()
        try sourceIp?.validateAsIpAddress()
    }
}

public struct NetworkInterface: Codable, Equatable {
    public var association: NetworkInterfaceAssociation?
    public var attachment: NetworkInterfaceAttachment?
    public var availabilityZone: String?
    public var denyAllIgwTraffic: Boolean?
    public var description: String?
    public var groups: GroupIdentifierList?
    public var interfaceType: NetworkInterfaceType?
    public var ipv4Prefixes: Ipv4PrefixesList?
    public var ipv6Address: String?
    public var ipv6Addresses: NetworkInterfaceIpv6AddressesList?
    public var ipv6Native: Boolean?
    public var ipv6Prefixes: Ipv6PrefixesList?
    public var macAddress: String?
    public var networkInterfaceId: String?
    public var outpostArn: String?
    public var ownerId: String?
    public var privateDnsName: String?
    public var privateIpAddress: String?
    public var privateIpAddresses: NetworkInterfacePrivateIpAddressList?
    public var requesterId: String?
    public var requesterManaged: Boolean?
    public var sourceDestCheck: Boolean?
    public var status: NetworkInterfaceStatus?
    public var subnetId: String?
    public var tagSet: TagList?
    public var vpcId: String?

    public init(association: NetworkInterfaceAssociation? = nil,
                attachment: NetworkInterfaceAttachment? = nil,
                availabilityZone: String? = nil,
                denyAllIgwTraffic: Boolean? = nil,
                description: String? = nil,
                groups: GroupIdentifierList? = nil,
                interfaceType: NetworkInterfaceType? = nil,
                ipv4Prefixes: Ipv4PrefixesList? = nil,
                ipv6Address: String? = nil,
                ipv6Addresses: NetworkInterfaceIpv6AddressesList? = nil,
                ipv6Native: Boolean? = nil,
                ipv6Prefixes: Ipv6PrefixesList? = nil,
                macAddress: String? = nil,
                networkInterfaceId: String? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                privateDnsName: String? = nil,
                privateIpAddress: String? = nil,
                privateIpAddresses: NetworkInterfacePrivateIpAddressList? = nil,
                requesterId: String? = nil,
                requesterManaged: Boolean? = nil,
                sourceDestCheck: Boolean? = nil,
                status: NetworkInterfaceStatus? = nil,
                subnetId: String? = nil,
                tagSet: TagList? = nil,
                vpcId: String? = nil) {
        self.association = association
        self.attachment = attachment
        self.availabilityZone = availabilityZone
        self.denyAllIgwTraffic = denyAllIgwTraffic
        self.description = description
        self.groups = groups
        self.interfaceType = interfaceType
        self.ipv4Prefixes = ipv4Prefixes
        self.ipv6Address = ipv6Address
        self.ipv6Addresses = ipv6Addresses
        self.ipv6Native = ipv6Native
        self.ipv6Prefixes = ipv6Prefixes
        self.macAddress = macAddress
        self.networkInterfaceId = networkInterfaceId
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.requesterId = requesterId
        self.requesterManaged = requesterManaged
        self.sourceDestCheck = sourceDestCheck
        self.status = status
        self.subnetId = subnetId
        self.tagSet = tagSet
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case association
        case attachment
        case availabilityZone
        case denyAllIgwTraffic
        case description
        case groups = "groupSet"
        case interfaceType
        case ipv4Prefixes = "ipv4PrefixSet"
        case ipv6Address
        case ipv6Addresses = "ipv6AddressesSet"
        case ipv6Native
        case ipv6Prefixes = "ipv6PrefixSet"
        case macAddress
        case networkInterfaceId
        case outpostArn
        case ownerId
        case privateDnsName
        case privateIpAddress
        case privateIpAddresses = "privateIpAddressesSet"
        case requesterId
        case requesterManaged
        case sourceDestCheck
        case status
        case subnetId
        case tagSet
        case vpcId
    }

    public func validate() throws {
        try association?.validate()
        try attachment?.validate()
    }
}

public struct NetworkInterfaceAssociation: Codable, Equatable {
    public var allocationId: String?
    public var associationId: String?
    public var carrierIp: String?
    public var customerOwnedIp: String?
    public var ipOwnerId: String?
    public var publicDnsName: String?
    public var publicIp: String?

    public init(allocationId: String? = nil,
                associationId: String? = nil,
                carrierIp: String? = nil,
                customerOwnedIp: String? = nil,
                ipOwnerId: String? = nil,
                publicDnsName: String? = nil,
                publicIp: String? = nil) {
        self.allocationId = allocationId
        self.associationId = associationId
        self.carrierIp = carrierIp
        self.customerOwnedIp = customerOwnedIp
        self.ipOwnerId = ipOwnerId
        self.publicDnsName = publicDnsName
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId
        case associationId
        case carrierIp
        case customerOwnedIp
        case ipOwnerId
        case publicDnsName
        case publicIp
    }

    public func validate() throws {
    }
}

public struct NetworkInterfaceAttachment: Codable, Equatable {
    public var attachTime: DateTime?
    public var attachmentId: String?
    public var deleteOnTermination: Boolean?
    public var deviceIndex: Integer?
    public var enaSrdSpecification: AttachmentEnaSrdSpecification?
    public var instanceId: String?
    public var instanceOwnerId: String?
    public var networkCardIndex: Integer?
    public var status: AttachmentStatus?

    public init(attachTime: DateTime? = nil,
                attachmentId: String? = nil,
                deleteOnTermination: Boolean? = nil,
                deviceIndex: Integer? = nil,
                enaSrdSpecification: AttachmentEnaSrdSpecification? = nil,
                instanceId: String? = nil,
                instanceOwnerId: String? = nil,
                networkCardIndex: Integer? = nil,
                status: AttachmentStatus? = nil) {
        self.attachTime = attachTime
        self.attachmentId = attachmentId
        self.deleteOnTermination = deleteOnTermination
        self.deviceIndex = deviceIndex
        self.enaSrdSpecification = enaSrdSpecification
        self.instanceId = instanceId
        self.instanceOwnerId = instanceOwnerId
        self.networkCardIndex = networkCardIndex
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case attachTime
        case attachmentId
        case deleteOnTermination
        case deviceIndex
        case enaSrdSpecification
        case instanceId
        case instanceOwnerId
        case networkCardIndex
        case status
    }

    public func validate() throws {
        try enaSrdSpecification?.validate()
    }
}

public struct NetworkInterfaceAttachmentChanges: Codable, Equatable {
    public var attachmentId: NetworkInterfaceAttachmentId?
    public var deleteOnTermination: Boolean?

    public init(attachmentId: NetworkInterfaceAttachmentId? = nil,
                deleteOnTermination: Boolean? = nil) {
        self.attachmentId = attachmentId
        self.deleteOnTermination = deleteOnTermination
    }

    enum CodingKeys: String, CodingKey {
        case attachmentId
        case deleteOnTermination
    }

    public func validate() throws {
    }
}

public struct NetworkInterfaceCount: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max
        case min
    }

    public func validate() throws {
    }
}

public struct NetworkInterfaceCountRequest: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func validate() throws {
    }
}

public struct NetworkInterfaceIpv6Address: Codable, Equatable {
    public var ipv6Address: String?

    public init(ipv6Address: String? = nil) {
        self.ipv6Address = ipv6Address
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Address
    }

    public func validate() throws {
    }
}

public struct NetworkInterfacePermission: Codable, Equatable {
    public var awsAccountId: String?
    public var awsService: String?
    public var networkInterfaceId: String?
    public var networkInterfacePermissionId: String?
    public var permission: InterfacePermissionType?
    public var permissionState: NetworkInterfacePermissionState?

    public init(awsAccountId: String? = nil,
                awsService: String? = nil,
                networkInterfaceId: String? = nil,
                networkInterfacePermissionId: String? = nil,
                permission: InterfacePermissionType? = nil,
                permissionState: NetworkInterfacePermissionState? = nil) {
        self.awsAccountId = awsAccountId
        self.awsService = awsService
        self.networkInterfaceId = networkInterfaceId
        self.networkInterfacePermissionId = networkInterfacePermissionId
        self.permission = permission
        self.permissionState = permissionState
    }

    enum CodingKeys: String, CodingKey {
        case awsAccountId
        case awsService
        case networkInterfaceId
        case networkInterfacePermissionId
        case permission
        case permissionState
    }

    public func validate() throws {
        try permissionState?.validate()
    }
}

public struct NetworkInterfacePermissionState: Codable, Equatable {
    public var state: NetworkInterfacePermissionStateCode?
    public var statusMessage: String?

    public init(state: NetworkInterfacePermissionStateCode? = nil,
                statusMessage: String? = nil) {
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct NetworkInterfacePrivateIpAddress: Codable, Equatable {
    public var association: NetworkInterfaceAssociation?
    public var primary: Boolean?
    public var privateDnsName: String?
    public var privateIpAddress: String?

    public init(association: NetworkInterfaceAssociation? = nil,
                primary: Boolean? = nil,
                privateDnsName: String? = nil,
                privateIpAddress: String? = nil) {
        self.association = association
        self.primary = primary
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case association
        case primary
        case privateDnsName
        case privateIpAddress
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct NewDhcpConfiguration: Codable, Equatable {
    public var key: String?
    public var values: ValueStringList?

    public init(key: String? = nil,
                values: ValueStringList? = nil) {
        self.key = key
        self.values = values
    }

    enum CodingKeys: String, CodingKey {
        case key
        case values = "Value"
    }

    public func validate() throws {
    }
}

public struct OidcOptions: Codable, Equatable {
    public var authorizationEndpoint: String?
    public var clientId: String?
    public var clientSecret: String?
    public var issuer: String?
    public var scope: String?
    public var tokenEndpoint: String?
    public var userInfoEndpoint: String?

    public init(authorizationEndpoint: String? = nil,
                clientId: String? = nil,
                clientSecret: String? = nil,
                issuer: String? = nil,
                scope: String? = nil,
                tokenEndpoint: String? = nil,
                userInfoEndpoint: String? = nil) {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.issuer = issuer
        self.scope = scope
        self.tokenEndpoint = tokenEndpoint
        self.userInfoEndpoint = userInfoEndpoint
    }

    enum CodingKeys: String, CodingKey {
        case authorizationEndpoint
        case clientId
        case clientSecret
        case issuer
        case scope
        case tokenEndpoint
        case userInfoEndpoint
    }

    public func validate() throws {
    }
}

public struct OnDemandOptions: Codable, Equatable {
    public var allocationStrategy: FleetOnDemandAllocationStrategy?
    public var capacityReservationOptions: CapacityReservationOptions?
    public var maxTotalPrice: String?
    public var minTargetCapacity: Integer?
    public var singleAvailabilityZone: Boolean?
    public var singleInstanceType: Boolean?

    public init(allocationStrategy: FleetOnDemandAllocationStrategy? = nil,
                capacityReservationOptions: CapacityReservationOptions? = nil,
                maxTotalPrice: String? = nil,
                minTargetCapacity: Integer? = nil,
                singleAvailabilityZone: Boolean? = nil,
                singleInstanceType: Boolean? = nil) {
        self.allocationStrategy = allocationStrategy
        self.capacityReservationOptions = capacityReservationOptions
        self.maxTotalPrice = maxTotalPrice
        self.minTargetCapacity = minTargetCapacity
        self.singleAvailabilityZone = singleAvailabilityZone
        self.singleInstanceType = singleInstanceType
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy
        case capacityReservationOptions
        case maxTotalPrice
        case minTargetCapacity
        case singleAvailabilityZone
        case singleInstanceType
    }

    public func validate() throws {
        try capacityReservationOptions?.validate()
    }
}

public struct OnDemandOptionsRequest: Codable, Equatable {
    public var allocationStrategy: FleetOnDemandAllocationStrategy?
    public var capacityReservationOptions: CapacityReservationOptionsRequest?
    public var maxTotalPrice: String?
    public var minTargetCapacity: Integer?
    public var singleAvailabilityZone: Boolean?
    public var singleInstanceType: Boolean?

    public init(allocationStrategy: FleetOnDemandAllocationStrategy? = nil,
                capacityReservationOptions: CapacityReservationOptionsRequest? = nil,
                maxTotalPrice: String? = nil,
                minTargetCapacity: Integer? = nil,
                singleAvailabilityZone: Boolean? = nil,
                singleInstanceType: Boolean? = nil) {
        self.allocationStrategy = allocationStrategy
        self.capacityReservationOptions = capacityReservationOptions
        self.maxTotalPrice = maxTotalPrice
        self.minTargetCapacity = minTargetCapacity
        self.singleAvailabilityZone = singleAvailabilityZone
        self.singleInstanceType = singleInstanceType
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy = "AllocationStrategy"
        case capacityReservationOptions = "CapacityReservationOptions"
        case maxTotalPrice = "MaxTotalPrice"
        case minTargetCapacity = "MinTargetCapacity"
        case singleAvailabilityZone = "SingleAvailabilityZone"
        case singleInstanceType = "SingleInstanceType"
    }

    public func validate() throws {
        try capacityReservationOptions?.validate()
    }
}

public struct PacketHeaderStatement: Codable, Equatable {
    public var destinationAddresses: ValueStringList?
    public var destinationPorts: ValueStringList?
    public var destinationPrefixLists: ValueStringList?
    public var protocols: ProtocolList?
    public var sourceAddresses: ValueStringList?
    public var sourcePorts: ValueStringList?
    public var sourcePrefixLists: ValueStringList?

    public init(destinationAddresses: ValueStringList? = nil,
                destinationPorts: ValueStringList? = nil,
                destinationPrefixLists: ValueStringList? = nil,
                protocols: ProtocolList? = nil,
                sourceAddresses: ValueStringList? = nil,
                sourcePorts: ValueStringList? = nil,
                sourcePrefixLists: ValueStringList? = nil) {
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.destinationPrefixLists = destinationPrefixLists
        self.protocols = protocols
        self.sourceAddresses = sourceAddresses
        self.sourcePorts = sourcePorts
        self.sourcePrefixLists = sourcePrefixLists
    }

    enum CodingKeys: String, CodingKey {
        case destinationAddresses = "destinationAddressSet"
        case destinationPorts = "destinationPortSet"
        case destinationPrefixLists = "destinationPrefixListSet"
        case protocols = "protocolSet"
        case sourceAddresses = "sourceAddressSet"
        case sourcePorts = "sourcePortSet"
        case sourcePrefixLists = "sourcePrefixListSet"
    }

    public func validate() throws {
    }
}

public struct PacketHeaderStatementRequest: Codable, Equatable {
    public var destinationAddresses: ValueStringList?
    public var destinationPorts: ValueStringList?
    public var destinationPrefixLists: ValueStringList?
    public var protocols: ProtocolList?
    public var sourceAddresses: ValueStringList?
    public var sourcePorts: ValueStringList?
    public var sourcePrefixLists: ValueStringList?

    public init(destinationAddresses: ValueStringList? = nil,
                destinationPorts: ValueStringList? = nil,
                destinationPrefixLists: ValueStringList? = nil,
                protocols: ProtocolList? = nil,
                sourceAddresses: ValueStringList? = nil,
                sourcePorts: ValueStringList? = nil,
                sourcePrefixLists: ValueStringList? = nil) {
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.destinationPrefixLists = destinationPrefixLists
        self.protocols = protocols
        self.sourceAddresses = sourceAddresses
        self.sourcePorts = sourcePorts
        self.sourcePrefixLists = sourcePrefixLists
    }

    enum CodingKeys: String, CodingKey {
        case destinationAddresses = "DestinationAddress"
        case destinationPorts = "DestinationPort"
        case destinationPrefixLists = "DestinationPrefixList"
        case protocols = "Protocol"
        case sourceAddresses = "SourceAddress"
        case sourcePorts = "SourcePort"
        case sourcePrefixLists = "SourcePrefixList"
    }

    public func validate() throws {
    }
}

public struct PathComponent: Codable, Equatable {
    public var aclRule: AnalysisAclRule?
    public var additionalDetails: AdditionalDetailList?
    public var attachedTo: AnalysisComponent?
    public var component: AnalysisComponent?
    public var destinationVpc: AnalysisComponent?
    public var elasticLoadBalancerListener: AnalysisComponent?
    public var explanations: ExplanationList?
    public var inboundHeader: AnalysisPacketHeader?
    public var outboundHeader: AnalysisPacketHeader?
    public var routeTableRoute: AnalysisRouteTableRoute?
    public var securityGroupRule: AnalysisSecurityGroupRule?
    public var sequenceNumber: Integer?
    public var sourceVpc: AnalysisComponent?
    public var subnet: AnalysisComponent?
    public var transitGateway: AnalysisComponent?
    public var transitGatewayRouteTableRoute: TransitGatewayRouteTableRoute?
    public var vpc: AnalysisComponent?

    public init(aclRule: AnalysisAclRule? = nil,
                additionalDetails: AdditionalDetailList? = nil,
                attachedTo: AnalysisComponent? = nil,
                component: AnalysisComponent? = nil,
                destinationVpc: AnalysisComponent? = nil,
                elasticLoadBalancerListener: AnalysisComponent? = nil,
                explanations: ExplanationList? = nil,
                inboundHeader: AnalysisPacketHeader? = nil,
                outboundHeader: AnalysisPacketHeader? = nil,
                routeTableRoute: AnalysisRouteTableRoute? = nil,
                securityGroupRule: AnalysisSecurityGroupRule? = nil,
                sequenceNumber: Integer? = nil,
                sourceVpc: AnalysisComponent? = nil,
                subnet: AnalysisComponent? = nil,
                transitGateway: AnalysisComponent? = nil,
                transitGatewayRouteTableRoute: TransitGatewayRouteTableRoute? = nil,
                vpc: AnalysisComponent? = nil) {
        self.aclRule = aclRule
        self.additionalDetails = additionalDetails
        self.attachedTo = attachedTo
        self.component = component
        self.destinationVpc = destinationVpc
        self.elasticLoadBalancerListener = elasticLoadBalancerListener
        self.explanations = explanations
        self.inboundHeader = inboundHeader
        self.outboundHeader = outboundHeader
        self.routeTableRoute = routeTableRoute
        self.securityGroupRule = securityGroupRule
        self.sequenceNumber = sequenceNumber
        self.sourceVpc = sourceVpc
        self.subnet = subnet
        self.transitGateway = transitGateway
        self.transitGatewayRouteTableRoute = transitGatewayRouteTableRoute
        self.vpc = vpc
    }

    enum CodingKeys: String, CodingKey {
        case aclRule
        case additionalDetails = "additionalDetailSet"
        case attachedTo
        case component
        case destinationVpc
        case elasticLoadBalancerListener
        case explanations = "explanationSet"
        case inboundHeader
        case outboundHeader
        case routeTableRoute
        case securityGroupRule
        case sequenceNumber
        case sourceVpc
        case subnet
        case transitGateway
        case transitGatewayRouteTableRoute
        case vpc
    }

    public func validate() throws {
        try aclRule?.validate()
        try attachedTo?.validate()
        try component?.validate()
        try destinationVpc?.validate()
        try elasticLoadBalancerListener?.validate()
        try inboundHeader?.validate()
        try outboundHeader?.validate()
        try routeTableRoute?.validate()
        try securityGroupRule?.validate()
        try sourceVpc?.validate()
        try subnet?.validate()
        try transitGateway?.validate()
        try transitGatewayRouteTableRoute?.validate()
        try vpc?.validate()
    }
}

public struct PathStatement: Codable, Equatable {
    public var packetHeaderStatement: PacketHeaderStatement?
    public var resourceStatement: ResourceStatement?

    public init(packetHeaderStatement: PacketHeaderStatement? = nil,
                resourceStatement: ResourceStatement? = nil) {
        self.packetHeaderStatement = packetHeaderStatement
        self.resourceStatement = resourceStatement
    }

    enum CodingKeys: String, CodingKey {
        case packetHeaderStatement
        case resourceStatement
    }

    public func validate() throws {
        try packetHeaderStatement?.validate()
        try resourceStatement?.validate()
    }
}

public struct PathStatementRequest: Codable, Equatable {
    public var packetHeaderStatement: PacketHeaderStatementRequest?
    public var resourceStatement: ResourceStatementRequest?

    public init(packetHeaderStatement: PacketHeaderStatementRequest? = nil,
                resourceStatement: ResourceStatementRequest? = nil) {
        self.packetHeaderStatement = packetHeaderStatement
        self.resourceStatement = resourceStatement
    }

    enum CodingKeys: String, CodingKey {
        case packetHeaderStatement = "PacketHeaderStatement"
        case resourceStatement = "ResourceStatement"
    }

    public func validate() throws {
        try packetHeaderStatement?.validate()
        try resourceStatement?.validate()
    }
}

public struct PciId: Codable, Equatable {
    public var deviceId: String?
    public var subsystemId: String?
    public var subsystemVendorId: String?
    public var vendorId: String?

    public init(deviceId: String? = nil,
                subsystemId: String? = nil,
                subsystemVendorId: String? = nil,
                vendorId: String? = nil) {
        self.deviceId = deviceId
        self.subsystemId = subsystemId
        self.subsystemVendorId = subsystemVendorId
        self.vendorId = vendorId
    }

    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case subsystemId = "SubsystemId"
        case subsystemVendorId = "SubsystemVendorId"
        case vendorId = "VendorId"
    }

    public func validate() throws {
    }
}

public struct PeeringAttachmentStatus: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct PeeringConnectionOptions: Codable, Equatable {
    public var allowDnsResolutionFromRemoteVpc: Boolean?
    public var allowEgressFromLocalClassicLinkToRemoteVpc: Boolean?
    public var allowEgressFromLocalVpcToRemoteClassicLink: Boolean?

    public init(allowDnsResolutionFromRemoteVpc: Boolean? = nil,
                allowEgressFromLocalClassicLinkToRemoteVpc: Boolean? = nil,
                allowEgressFromLocalVpcToRemoteClassicLink: Boolean? = nil) {
        self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
        self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
    }

    enum CodingKeys: String, CodingKey {
        case allowDnsResolutionFromRemoteVpc
        case allowEgressFromLocalClassicLinkToRemoteVpc
        case allowEgressFromLocalVpcToRemoteClassicLink
    }

    public func validate() throws {
    }
}

public struct PeeringConnectionOptionsRequest: Codable, Equatable {
    public var allowDnsResolutionFromRemoteVpc: Boolean?
    public var allowEgressFromLocalClassicLinkToRemoteVpc: Boolean?
    public var allowEgressFromLocalVpcToRemoteClassicLink: Boolean?

    public init(allowDnsResolutionFromRemoteVpc: Boolean? = nil,
                allowEgressFromLocalClassicLinkToRemoteVpc: Boolean? = nil,
                allowEgressFromLocalVpcToRemoteClassicLink: Boolean? = nil) {
        self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
        self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
    }

    enum CodingKeys: String, CodingKey {
        case allowDnsResolutionFromRemoteVpc = "AllowDnsResolutionFromRemoteVpc"
        case allowEgressFromLocalClassicLinkToRemoteVpc = "AllowEgressFromLocalClassicLinkToRemoteVpc"
        case allowEgressFromLocalVpcToRemoteClassicLink = "AllowEgressFromLocalVpcToRemoteClassicLink"
    }

    public func validate() throws {
    }
}

public struct PeeringTgwInfo: Codable, Equatable {
    public var coreNetworkId: String?
    public var ownerId: String?
    public var region: String?
    public var transitGatewayId: String?

    public init(coreNetworkId: String? = nil,
                ownerId: String? = nil,
                region: String? = nil,
                transitGatewayId: String? = nil) {
        self.coreNetworkId = coreNetworkId
        self.ownerId = ownerId
        self.region = region
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case coreNetworkId
        case ownerId
        case region
        case transitGatewayId
    }

    public func validate() throws {
    }
}

public struct Phase1DHGroupNumbersListValue: Codable, Equatable {
    public var value: Integer?

    public init(value: Integer? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase1DHGroupNumbersRequestListValue: Codable, Equatable {
    public var value: Integer?

    public init(value: Integer? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase1EncryptionAlgorithmsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase1EncryptionAlgorithmsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase1IntegrityAlgorithmsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase1IntegrityAlgorithmsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase2DHGroupNumbersListValue: Codable, Equatable {
    public var value: Integer?

    public init(value: Integer? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase2DHGroupNumbersRequestListValue: Codable, Equatable {
    public var value: Integer?

    public init(value: Integer? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase2EncryptionAlgorithmsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase2EncryptionAlgorithmsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Phase2IntegrityAlgorithmsListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value
    }

    public func validate() throws {
    }
}

public struct Phase2IntegrityAlgorithmsRequestListValue: Codable, Equatable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct Placement: Codable, Equatable {
    public var affinity: String?
    public var availabilityZone: String?
    public var groupId: PlacementGroupId?
    public var groupName: PlacementGroupName?
    public var hostId: String?
    public var hostResourceGroupArn: String?
    public var partitionNumber: Integer?
    public var spreadDomain: String?
    public var tenancy: Tenancy?

    public init(affinity: String? = nil,
                availabilityZone: String? = nil,
                groupId: PlacementGroupId? = nil,
                groupName: PlacementGroupName? = nil,
                hostId: String? = nil,
                hostResourceGroupArn: String? = nil,
                partitionNumber: Integer? = nil,
                spreadDomain: String? = nil,
                tenancy: Tenancy? = nil) {
        self.affinity = affinity
        self.availabilityZone = availabilityZone
        self.groupId = groupId
        self.groupName = groupName
        self.hostId = hostId
        self.hostResourceGroupArn = hostResourceGroupArn
        self.partitionNumber = partitionNumber
        self.spreadDomain = spreadDomain
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case affinity
        case availabilityZone
        case groupId
        case groupName
        case hostId
        case hostResourceGroupArn
        case partitionNumber
        case spreadDomain
        case tenancy
    }

    public func validate() throws {
    }
}

public struct PlacementGroup: Codable, Equatable {
    public var groupArn: String?
    public var groupId: String?
    public var groupName: String?
    public var partitionCount: Integer?
    public var spreadLevel: SpreadLevel?
    public var state: PlacementGroupState?
    public var strategy: PlacementStrategy?
    public var tags: TagList?

    public init(groupArn: String? = nil,
                groupId: String? = nil,
                groupName: String? = nil,
                partitionCount: Integer? = nil,
                spreadLevel: SpreadLevel? = nil,
                state: PlacementGroupState? = nil,
                strategy: PlacementStrategy? = nil,
                tags: TagList? = nil) {
        self.groupArn = groupArn
        self.groupId = groupId
        self.groupName = groupName
        self.partitionCount = partitionCount
        self.spreadLevel = spreadLevel
        self.state = state
        self.strategy = strategy
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case groupArn
        case groupId
        case groupName
        case partitionCount
        case spreadLevel
        case state
        case strategy
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct PlacementGroupInfo: Codable, Equatable {
    public var supportedStrategies: PlacementGroupStrategyList?

    public init(supportedStrategies: PlacementGroupStrategyList? = nil) {
        self.supportedStrategies = supportedStrategies
    }

    enum CodingKeys: String, CodingKey {
        case supportedStrategies
    }

    public func validate() throws {
    }
}

public struct PlacementResponse: Codable, Equatable {
    public var groupName: PlacementGroupName?

    public init(groupName: PlacementGroupName? = nil) {
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case groupName
    }

    public func validate() throws {
    }
}

public struct PoolCidrBlock: Codable, Equatable {
    public var cidr: String?

    public init(cidr: String? = nil) {
        self.cidr = cidr
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "poolCidrBlock"
    }

    public func validate() throws {
    }
}

public struct PortRange: Codable, Equatable {
    public var from: Integer?
    public var to: Integer?

    public init(from: Integer? = nil,
                to: Integer? = nil) {
        self.from = from
        self.to = to
    }

    enum CodingKeys: String, CodingKey {
        case from
        case to
    }

    public func validate() throws {
    }
}

public struct PrefixList: Codable, Equatable {
    public var cidrs: ValueStringList?
    public var prefixListId: String?
    public var prefixListName: String?

    public init(cidrs: ValueStringList? = nil,
                prefixListId: String? = nil,
                prefixListName: String? = nil) {
        self.cidrs = cidrs
        self.prefixListId = prefixListId
        self.prefixListName = prefixListName
    }

    enum CodingKeys: String, CodingKey {
        case cidrs = "cidrSet"
        case prefixListId
        case prefixListName
    }

    public func validate() throws {
    }
}

public struct PrefixListAssociation: Codable, Equatable {
    public var resourceId: String?
    public var resourceOwner: String?

    public init(resourceId: String? = nil,
                resourceOwner: String? = nil) {
        self.resourceId = resourceId
        self.resourceOwner = resourceOwner
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceOwner
    }

    public func validate() throws {
    }
}

public struct PrefixListEntry: Codable, Equatable {
    public var cidr: String?
    public var description: String?

    public init(cidr: String? = nil,
                description: String? = nil) {
        self.cidr = cidr
        self.description = description
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case description
    }

    public func validate() throws {
    }
}

public struct PrefixListId: Codable, Equatable {
    public var description: String?
    public var prefixListId: String?

    public init(description: String? = nil,
                prefixListId: String? = nil) {
        self.description = description
        self.prefixListId = prefixListId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case prefixListId
    }

    public func validate() throws {
    }
}

public struct PriceSchedule: Codable, Equatable {
    public var active: Boolean?
    public var currencyCode: CurrencyCodeValues?
    public var price: Double?
    public var term: Long?

    public init(active: Boolean? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                price: Double? = nil,
                term: Long? = nil) {
        self.active = active
        self.currencyCode = currencyCode
        self.price = price
        self.term = term
    }

    enum CodingKeys: String, CodingKey {
        case active
        case currencyCode
        case price
        case term
    }

    public func validate() throws {
    }
}

public struct PriceScheduleSpecification: Codable, Equatable {
    public var currencyCode: CurrencyCodeValues?
    public var price: Double?
    public var term: Long?

    public init(currencyCode: CurrencyCodeValues? = nil,
                price: Double? = nil,
                term: Long? = nil) {
        self.currencyCode = currencyCode
        self.price = price
        self.term = term
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case price
        case term
    }

    public func validate() throws {
    }
}

public struct PricingDetail: Codable, Equatable {
    public var count: Integer?
    public var price: Double?

    public init(count: Integer? = nil,
                price: Double? = nil) {
        self.count = count
        self.price = price
    }

    enum CodingKeys: String, CodingKey {
        case count
        case price
    }

    public func validate() throws {
    }
}

public struct PrincipalIdFormat: Codable, Equatable {
    public var arn: String?
    public var statuses: IdFormatList?

    public init(arn: String? = nil,
                statuses: IdFormatList? = nil) {
        self.arn = arn
        self.statuses = statuses
    }

    enum CodingKeys: String, CodingKey {
        case arn
        case statuses = "statusSet"
    }

    public func validate() throws {
    }
}

public struct PrivateDnsDetails: Codable, Equatable {
    public var privateDnsName: String?

    public init(privateDnsName: String? = nil) {
        self.privateDnsName = privateDnsName
    }

    enum CodingKeys: String, CodingKey {
        case privateDnsName
    }

    public func validate() throws {
    }
}

public struct PrivateDnsNameConfiguration: Codable, Equatable {
    public var name: String?
    public var state: DnsNameState?
    public var type: String?
    public var value: String?

    public init(name: String? = nil,
                state: DnsNameState? = nil,
                type: String? = nil,
                value: String? = nil) {
        self.name = name
        self.state = state
        self.type = type
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case name
        case state
        case type
        case value
    }

    public func validate() throws {
    }
}

public struct PrivateDnsNameOptionsOnLaunch: Codable, Equatable {
    public var enableResourceNameDnsAAAARecord: Boolean?
    public var enableResourceNameDnsARecord: Boolean?
    public var hostnameType: HostnameType?

    public init(enableResourceNameDnsAAAARecord: Boolean? = nil,
                enableResourceNameDnsARecord: Boolean? = nil,
                hostnameType: HostnameType? = nil) {
        self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
        self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
        self.hostnameType = hostnameType
    }

    enum CodingKeys: String, CodingKey {
        case enableResourceNameDnsAAAARecord
        case enableResourceNameDnsARecord
        case hostnameType
    }

    public func validate() throws {
    }
}

public struct PrivateDnsNameOptionsRequest: Codable, Equatable {
    public var enableResourceNameDnsAAAARecord: Boolean?
    public var enableResourceNameDnsARecord: Boolean?
    public var hostnameType: HostnameType?

    public init(enableResourceNameDnsAAAARecord: Boolean? = nil,
                enableResourceNameDnsARecord: Boolean? = nil,
                hostnameType: HostnameType? = nil) {
        self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
        self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
        self.hostnameType = hostnameType
    }

    enum CodingKeys: String, CodingKey {
        case enableResourceNameDnsAAAARecord = "EnableResourceNameDnsAAAARecord"
        case enableResourceNameDnsARecord = "EnableResourceNameDnsARecord"
        case hostnameType = "HostnameType"
    }

    public func validate() throws {
    }
}

public struct PrivateDnsNameOptionsResponse: Codable, Equatable {
    public var enableResourceNameDnsAAAARecord: Boolean?
    public var enableResourceNameDnsARecord: Boolean?
    public var hostnameType: HostnameType?

    public init(enableResourceNameDnsAAAARecord: Boolean? = nil,
                enableResourceNameDnsARecord: Boolean? = nil,
                hostnameType: HostnameType? = nil) {
        self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
        self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
        self.hostnameType = hostnameType
    }

    enum CodingKeys: String, CodingKey {
        case enableResourceNameDnsAAAARecord
        case enableResourceNameDnsARecord
        case hostnameType
    }

    public func validate() throws {
    }
}

public struct PrivateIpAddressSpecification: Codable, Equatable {
    public var primary: Boolean?
    public var privateIpAddress: String?

    public init(primary: Boolean? = nil,
                privateIpAddress: String? = nil) {
        self.primary = primary
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case primary
        case privateIpAddress
    }

    public func validate() throws {
    }
}

public struct ProcessorInfo: Codable, Equatable {
    public var supportedArchitectures: ArchitectureTypeList?
    public var sustainedClockSpeedInGhz: ProcessorSustainedClockSpeed?

    public init(supportedArchitectures: ArchitectureTypeList? = nil,
                sustainedClockSpeedInGhz: ProcessorSustainedClockSpeed? = nil) {
        self.supportedArchitectures = supportedArchitectures
        self.sustainedClockSpeedInGhz = sustainedClockSpeedInGhz
    }

    enum CodingKeys: String, CodingKey {
        case supportedArchitectures
        case sustainedClockSpeedInGhz
    }

    public func validate() throws {
    }
}

public struct ProductCode: Codable, Equatable {
    public var productCodeId: String?
    public var productCodeType: ProductCodeValues?

    public init(productCodeId: String? = nil,
                productCodeType: ProductCodeValues? = nil) {
        self.productCodeId = productCodeId
        self.productCodeType = productCodeType
    }

    enum CodingKeys: String, CodingKey {
        case productCodeId = "productCode"
        case productCodeType = "type"
    }

    public func validate() throws {
    }
}

public struct PropagatingVgw: Codable, Equatable {
    public var gatewayId: String?

    public init(gatewayId: String? = nil) {
        self.gatewayId = gatewayId
    }

    enum CodingKeys: String, CodingKey {
        case gatewayId
    }

    public func validate() throws {
    }
}

public struct ProvisionByoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var cidrAuthorizationContext: CidrAuthorizationContext?
    public var description: String?
    public var dryRun: Boolean?
    public var multiRegion: Boolean?
    public var poolTagSpecifications: TagSpecificationList?
    public var publiclyAdvertisable: Boolean?

    public init(cidr: String,
                cidrAuthorizationContext: CidrAuthorizationContext? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                multiRegion: Boolean? = nil,
                poolTagSpecifications: TagSpecificationList? = nil,
                publiclyAdvertisable: Boolean? = nil) {
        self.cidr = cidr
        self.cidrAuthorizationContext = cidrAuthorizationContext
        self.description = description
        self.dryRun = dryRun
        self.multiRegion = multiRegion
        self.poolTagSpecifications = poolTagSpecifications
        self.publiclyAdvertisable = publiclyAdvertisable
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
        case description = "Description"
        case dryRun = "DryRun"
        case multiRegion = "MultiRegion"
        case poolTagSpecifications = "PoolTagSpecification"
        case publiclyAdvertisable = "PubliclyAdvertisable"
    }

    public func validate() throws {
        try cidrAuthorizationContext?.validate()
    }
}

public struct ProvisionByoipCidrResult: Codable, Equatable {
    public var byoipCidr: ByoipCidr?

    public init(byoipCidr: ByoipCidr? = nil) {
        self.byoipCidr = byoipCidr
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidr
    }

    public func validate() throws {
        try byoipCidr?.validate()
    }
}

public struct ProvisionIpamPoolCidrRequest: Codable, Equatable {
    public var cidr: String?
    public var cidrAuthorizationContext: IpamCidrAuthorizationContext?
    public var dryRun: Boolean?
    public var ipamPoolId: IpamPoolId

    public init(cidr: String? = nil,
                cidrAuthorizationContext: IpamCidrAuthorizationContext? = nil,
                dryRun: Boolean? = nil,
                ipamPoolId: IpamPoolId) {
        self.cidr = cidr
        self.cidrAuthorizationContext = cidrAuthorizationContext
        self.dryRun = dryRun
        self.ipamPoolId = ipamPoolId
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
        case dryRun = "DryRun"
        case ipamPoolId = "IpamPoolId"
    }

    public func validate() throws {
        try cidrAuthorizationContext?.validate()
    }
}

public struct ProvisionIpamPoolCidrResult: Codable, Equatable {
    public var ipamPoolCidr: IpamPoolCidr?

    public init(ipamPoolCidr: IpamPoolCidr? = nil) {
        self.ipamPoolCidr = ipamPoolCidr
    }

    enum CodingKeys: String, CodingKey {
        case ipamPoolCidr
    }

    public func validate() throws {
        try ipamPoolCidr?.validate()
    }
}

public struct ProvisionPublicIpv4PoolCidrRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var ipamPoolId: IpamPoolId
    public var netmaskLength: Integer
    public var poolId: Ipv4PoolEc2Id

    public init(dryRun: Boolean? = nil,
                ipamPoolId: IpamPoolId,
                netmaskLength: Integer,
                poolId: Ipv4PoolEc2Id) {
        self.dryRun = dryRun
        self.ipamPoolId = ipamPoolId
        self.netmaskLength = netmaskLength
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case ipamPoolId = "IpamPoolId"
        case netmaskLength = "NetmaskLength"
        case poolId = "PoolId"
    }

    public func validate() throws {
    }
}

public struct ProvisionPublicIpv4PoolCidrResult: Codable, Equatable {
    public var poolAddressRange: PublicIpv4PoolRange?
    public var poolId: Ipv4PoolEc2Id?

    public init(poolAddressRange: PublicIpv4PoolRange? = nil,
                poolId: Ipv4PoolEc2Id? = nil) {
        self.poolAddressRange = poolAddressRange
        self.poolId = poolId
    }

    enum CodingKeys: String, CodingKey {
        case poolAddressRange
        case poolId
    }

    public func validate() throws {
        try poolAddressRange?.validate()
    }
}

public struct ProvisionedBandwidth: Codable, Equatable {
    public var provisionTime: DateTime?
    public var provisioned: String?
    public var requestTime: DateTime?
    public var requested: String?
    public var status: String?

    public init(provisionTime: DateTime? = nil,
                provisioned: String? = nil,
                requestTime: DateTime? = nil,
                requested: String? = nil,
                status: String? = nil) {
        self.provisionTime = provisionTime
        self.provisioned = provisioned
        self.requestTime = requestTime
        self.requested = requested
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case provisionTime
        case provisioned
        case requestTime
        case requested
        case status
    }

    public func validate() throws {
    }
}

public struct PtrUpdateStatus: Codable, Equatable {
    public var reason: String?
    public var status: String?
    public var value: String?

    public init(reason: String? = nil,
                status: String? = nil,
                value: String? = nil) {
        self.reason = reason
        self.status = status
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case reason
        case status
        case value
    }

    public func validate() throws {
    }
}

public struct PublicIpv4Pool: Codable, Equatable {
    public var description: String?
    public var networkBorderGroup: String?
    public var poolAddressRanges: PublicIpv4PoolRangeSet?
    public var poolId: String?
    public var tags: TagList?
    public var totalAddressCount: Integer?
    public var totalAvailableAddressCount: Integer?

    public init(description: String? = nil,
                networkBorderGroup: String? = nil,
                poolAddressRanges: PublicIpv4PoolRangeSet? = nil,
                poolId: String? = nil,
                tags: TagList? = nil,
                totalAddressCount: Integer? = nil,
                totalAvailableAddressCount: Integer? = nil) {
        self.description = description
        self.networkBorderGroup = networkBorderGroup
        self.poolAddressRanges = poolAddressRanges
        self.poolId = poolId
        self.tags = tags
        self.totalAddressCount = totalAddressCount
        self.totalAvailableAddressCount = totalAvailableAddressCount
    }

    enum CodingKeys: String, CodingKey {
        case description
        case networkBorderGroup
        case poolAddressRanges = "poolAddressRangeSet"
        case poolId
        case tags = "tagSet"
        case totalAddressCount
        case totalAvailableAddressCount
    }

    public func validate() throws {
    }
}

public struct PublicIpv4PoolRange: Codable, Equatable {
    public var addressCount: Integer?
    public var availableAddressCount: Integer?
    public var firstAddress: String?
    public var lastAddress: String?

    public init(addressCount: Integer? = nil,
                availableAddressCount: Integer? = nil,
                firstAddress: String? = nil,
                lastAddress: String? = nil) {
        self.addressCount = addressCount
        self.availableAddressCount = availableAddressCount
        self.firstAddress = firstAddress
        self.lastAddress = lastAddress
    }

    enum CodingKeys: String, CodingKey {
        case addressCount
        case availableAddressCount
        case firstAddress
        case lastAddress
    }

    public func validate() throws {
    }
}

public struct Purchase: Codable, Equatable {
    public var currencyCode: CurrencyCodeValues?
    public var duration: Integer?
    public var hostIdSet: ResponseHostIdSet?
    public var hostReservationId: HostReservationId?
    public var hourlyPrice: String?
    public var instanceFamily: String?
    public var paymentOption: PaymentOption?
    public var upfrontPrice: String?

    public init(currencyCode: CurrencyCodeValues? = nil,
                duration: Integer? = nil,
                hostIdSet: ResponseHostIdSet? = nil,
                hostReservationId: HostReservationId? = nil,
                hourlyPrice: String? = nil,
                instanceFamily: String? = nil,
                paymentOption: PaymentOption? = nil,
                upfrontPrice: String? = nil) {
        self.currencyCode = currencyCode
        self.duration = duration
        self.hostIdSet = hostIdSet
        self.hostReservationId = hostReservationId
        self.hourlyPrice = hourlyPrice
        self.instanceFamily = instanceFamily
        self.paymentOption = paymentOption
        self.upfrontPrice = upfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case currencyCode
        case duration
        case hostIdSet
        case hostReservationId
        case hourlyPrice
        case instanceFamily
        case paymentOption
        case upfrontPrice
    }

    public func validate() throws {
    }
}

public struct PurchaseHostReservationRequest: Codable, Equatable {
    public var clientToken: String?
    public var currencyCode: CurrencyCodeValues?
    public var hostIdSet: RequestHostIdSet
    public var limitPrice: String?
    public var offeringId: OfferingId
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                hostIdSet: RequestHostIdSet,
                limitPrice: String? = nil,
                offeringId: OfferingId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.currencyCode = currencyCode
        self.hostIdSet = hostIdSet
        self.limitPrice = limitPrice
        self.offeringId = offeringId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case currencyCode = "CurrencyCode"
        case hostIdSet = "HostIdSet"
        case limitPrice = "LimitPrice"
        case offeringId = "OfferingId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct PurchaseHostReservationResult: Codable, Equatable {
    public var clientToken: String?
    public var currencyCode: CurrencyCodeValues?
    public var purchase: PurchaseSet?
    public var totalHourlyPrice: String?
    public var totalUpfrontPrice: String?

    public init(clientToken: String? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                purchase: PurchaseSet? = nil,
                totalHourlyPrice: String? = nil,
                totalUpfrontPrice: String? = nil) {
        self.clientToken = clientToken
        self.currencyCode = currencyCode
        self.purchase = purchase
        self.totalHourlyPrice = totalHourlyPrice
        self.totalUpfrontPrice = totalUpfrontPrice
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case currencyCode
        case purchase
        case totalHourlyPrice
        case totalUpfrontPrice
    }

    public func validate() throws {
    }
}

public struct PurchaseRequest: Codable, Equatable {
    public var instanceCount: Integer
    public var purchaseToken: String

    public init(instanceCount: Integer,
                purchaseToken: String) {
        self.instanceCount = instanceCount
        self.purchaseToken = purchaseToken
    }

    enum CodingKeys: String, CodingKey {
        case instanceCount = "InstanceCount"
        case purchaseToken = "PurchaseToken"
    }

    public func validate() throws {
    }
}

public struct PurchaseReservedInstancesOfferingRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceCount: Integer
    public var limitPrice: ReservedInstanceLimitPrice?
    public var purchaseTime: DateTime?
    public var reservedInstancesOfferingId: ReservedInstancesOfferingId

    public init(dryRun: Boolean? = nil,
                instanceCount: Integer,
                limitPrice: ReservedInstanceLimitPrice? = nil,
                purchaseTime: DateTime? = nil,
                reservedInstancesOfferingId: ReservedInstancesOfferingId) {
        self.dryRun = dryRun
        self.instanceCount = instanceCount
        self.limitPrice = limitPrice
        self.purchaseTime = purchaseTime
        self.reservedInstancesOfferingId = reservedInstancesOfferingId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceCount = "InstanceCount"
        case limitPrice
        case purchaseTime = "PurchaseTime"
        case reservedInstancesOfferingId = "ReservedInstancesOfferingId"
    }

    public func validate() throws {
        try limitPrice?.validate()
    }
}

public struct PurchaseReservedInstancesOfferingResult: Codable, Equatable {
    public var reservedInstancesId: String?

    public init(reservedInstancesId: String? = nil) {
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesId
    }

    public func validate() throws {
    }
}

public struct PurchaseScheduledInstancesRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var purchaseRequests: PurchaseRequestSet

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                purchaseRequests: PurchaseRequestSet) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.purchaseRequests = purchaseRequests
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case purchaseRequests = "PurchaseRequest"
    }

    public func validate() throws {
        try purchaseRequests.validateAsPurchaseRequestSet()
    }
}

public struct PurchaseScheduledInstancesResult: Codable, Equatable {
    public var scheduledInstanceSet: PurchasedScheduledInstanceSet?

    public init(scheduledInstanceSet: PurchasedScheduledInstanceSet? = nil) {
        self.scheduledInstanceSet = scheduledInstanceSet
    }

    enum CodingKeys: String, CodingKey {
        case scheduledInstanceSet
    }

    public func validate() throws {
    }
}

public struct RebootInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct RecurringCharge: Codable, Equatable {
    public var amount: Double?
    public var frequency: RecurringChargeFrequency?

    public init(amount: Double? = nil,
                frequency: RecurringChargeFrequency? = nil) {
        self.amount = amount
        self.frequency = frequency
    }

    enum CodingKeys: String, CodingKey {
        case amount
        case frequency
    }

    public func validate() throws {
    }
}

public struct ReferencedSecurityGroup: Codable, Equatable {
    public var groupId: String?
    public var peeringStatus: String?
    public var userId: String?
    public var vpcId: String?
    public var vpcPeeringConnectionId: String?

    public init(groupId: String? = nil,
                peeringStatus: String? = nil,
                userId: String? = nil,
                vpcId: String? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.groupId = groupId
        self.peeringStatus = peeringStatus
        self.userId = userId
        self.vpcId = vpcId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case peeringStatus
        case userId
        case vpcId
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct Region: Codable, Equatable {
    public var endpoint: String?
    public var optInStatus: String?
    public var regionName: String?

    public init(endpoint: String? = nil,
                optInStatus: String? = nil,
                regionName: String? = nil) {
        self.endpoint = endpoint
        self.optInStatus = optInStatus
        self.regionName = regionName
    }

    enum CodingKeys: String, CodingKey {
        case endpoint = "regionEndpoint"
        case optInStatus
        case regionName
    }

    public func validate() throws {
    }
}

public struct RegisterImageRequest: Codable, Equatable {
    public var architecture: ArchitectureValues?
    public var billingProducts: BillingProductList?
    public var blockDeviceMappings: BlockDeviceMappingRequestList?
    public var bootMode: BootModeValues?
    public var description: String?
    public var dryRun: Boolean?
    public var enaSupport: Boolean?
    public var imageLocation: String?
    public var imdsSupport: ImdsSupportValues?
    public var kernelId: KernelId?
    public var name: String
    public var ramdiskId: RamdiskId?
    public var rootDeviceName: String?
    public var sriovNetSupport: String?
    public var tpmSupport: TpmSupportValues?
    public var uefiData: StringType?
    public var virtualizationType: String?

    public init(architecture: ArchitectureValues? = nil,
                billingProducts: BillingProductList? = nil,
                blockDeviceMappings: BlockDeviceMappingRequestList? = nil,
                bootMode: BootModeValues? = nil,
                description: String? = nil,
                dryRun: Boolean? = nil,
                enaSupport: Boolean? = nil,
                imageLocation: String? = nil,
                imdsSupport: ImdsSupportValues? = nil,
                kernelId: KernelId? = nil,
                name: String,
                ramdiskId: RamdiskId? = nil,
                rootDeviceName: String? = nil,
                sriovNetSupport: String? = nil,
                tpmSupport: TpmSupportValues? = nil,
                uefiData: StringType? = nil,
                virtualizationType: String? = nil) {
        self.architecture = architecture
        self.billingProducts = billingProducts
        self.blockDeviceMappings = blockDeviceMappings
        self.bootMode = bootMode
        self.description = description
        self.dryRun = dryRun
        self.enaSupport = enaSupport
        self.imageLocation = imageLocation
        self.imdsSupport = imdsSupport
        self.kernelId = kernelId
        self.name = name
        self.ramdiskId = ramdiskId
        self.rootDeviceName = rootDeviceName
        self.sriovNetSupport = sriovNetSupport
        self.tpmSupport = tpmSupport
        self.uefiData = uefiData
        self.virtualizationType = virtualizationType
    }

    enum CodingKeys: String, CodingKey {
        case architecture
        case billingProducts = "BillingProduct"
        case blockDeviceMappings = "BlockDeviceMapping"
        case bootMode = "BootMode"
        case description
        case dryRun
        case enaSupport
        case imageLocation = "ImageLocation"
        case imdsSupport = "ImdsSupport"
        case kernelId
        case name
        case ramdiskId
        case rootDeviceName
        case sriovNetSupport
        case tpmSupport = "TpmSupport"
        case uefiData = "UefiData"
        case virtualizationType
    }

    public func validate() throws {
        try uefiData?.validateAsStringType()
    }
}

public struct RegisterImageResult: Codable, Equatable {
    public var imageId: String?

    public init(imageId: String? = nil) {
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case imageId
    }

    public func validate() throws {
    }
}

public struct RegisterInstanceEventNotificationAttributesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceTagAttribute: RegisterInstanceTagAttributeRequest?

    public init(dryRun: Boolean? = nil,
                instanceTagAttribute: RegisterInstanceTagAttributeRequest? = nil) {
        self.dryRun = dryRun
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceTagAttribute = "InstanceTagAttribute"
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct RegisterInstanceEventNotificationAttributesResult: Codable, Equatable {
    public var instanceTagAttribute: InstanceTagNotificationAttribute?

    public init(instanceTagAttribute: InstanceTagNotificationAttribute? = nil) {
        self.instanceTagAttribute = instanceTagAttribute
    }

    enum CodingKeys: String, CodingKey {
        case instanceTagAttribute
    }

    public func validate() throws {
        try instanceTagAttribute?.validate()
    }
}

public struct RegisterInstanceTagAttributeRequest: Codable, Equatable {
    public var includeAllTagsOfInstance: Boolean?
    public var instanceTagKeys: InstanceTagKeySet?

    public init(includeAllTagsOfInstance: Boolean? = nil,
                instanceTagKeys: InstanceTagKeySet? = nil) {
        self.includeAllTagsOfInstance = includeAllTagsOfInstance
        self.instanceTagKeys = instanceTagKeys
    }

    enum CodingKeys: String, CodingKey {
        case includeAllTagsOfInstance = "IncludeAllTagsOfInstance"
        case instanceTagKeys = "InstanceTagKey"
    }

    public func validate() throws {
    }
}

public struct RegisterTransitGatewayMulticastGroupMembersRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupIpAddress: String?
    public var networkInterfaceIds: TransitGatewayNetworkInterfaceIdList?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                groupIpAddress: String? = nil,
                networkInterfaceIds: TransitGatewayNetworkInterfaceIdList? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.groupIpAddress = groupIpAddress
        self.networkInterfaceIds = networkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupIpAddress = "GroupIpAddress"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct RegisterTransitGatewayMulticastGroupMembersResult: Codable, Equatable {
    public var registeredMulticastGroupMembers: TransitGatewayMulticastRegisteredGroupMembers?

    public init(registeredMulticastGroupMembers: TransitGatewayMulticastRegisteredGroupMembers? = nil) {
        self.registeredMulticastGroupMembers = registeredMulticastGroupMembers
    }

    enum CodingKeys: String, CodingKey {
        case registeredMulticastGroupMembers
    }

    public func validate() throws {
        try registeredMulticastGroupMembers?.validate()
    }
}

public struct RegisterTransitGatewayMulticastGroupSourcesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupIpAddress: String?
    public var networkInterfaceIds: TransitGatewayNetworkInterfaceIdList?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                groupIpAddress: String? = nil,
                networkInterfaceIds: TransitGatewayNetworkInterfaceIdList? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.groupIpAddress = groupIpAddress
        self.networkInterfaceIds = networkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupIpAddress = "GroupIpAddress"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct RegisterTransitGatewayMulticastGroupSourcesResult: Codable, Equatable {
    public var registeredMulticastGroupSources: TransitGatewayMulticastRegisteredGroupSources?

    public init(registeredMulticastGroupSources: TransitGatewayMulticastRegisteredGroupSources? = nil) {
        self.registeredMulticastGroupSources = registeredMulticastGroupSources
    }

    enum CodingKeys: String, CodingKey {
        case registeredMulticastGroupSources
    }

    public func validate() throws {
        try registeredMulticastGroupSources?.validate()
    }
}

public struct RejectTransitGatewayMulticastDomainAssociationsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var subnetIds: ValueStringList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                subnetIds: ValueStringList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.subnetIds = subnetIds
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case subnetIds = "SubnetIds"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
    }
}

public struct RejectTransitGatewayMulticastDomainAssociationsResult: Codable, Equatable {
    public var associations: TransitGatewayMulticastDomainAssociations?

    public init(associations: TransitGatewayMulticastDomainAssociations? = nil) {
        self.associations = associations
    }

    enum CodingKeys: String, CodingKey {
        case associations
    }

    public func validate() throws {
        try associations?.validate()
    }
}

public struct RejectTransitGatewayPeeringAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct RejectTransitGatewayPeeringAttachmentResult: Codable, Equatable {
    public var transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment?

    public init(transitGatewayPeeringAttachment: TransitGatewayPeeringAttachment? = nil) {
        self.transitGatewayPeeringAttachment = transitGatewayPeeringAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayPeeringAttachment
    }

    public func validate() throws {
        try transitGatewayPeeringAttachment?.validate()
    }
}

public struct RejectTransitGatewayVpcAttachmentRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId

    public init(dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId) {
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
    }

    public func validate() throws {
    }
}

public struct RejectTransitGatewayVpcAttachmentResult: Codable, Equatable {
    public var transitGatewayVpcAttachment: TransitGatewayVpcAttachment?

    public init(transitGatewayVpcAttachment: TransitGatewayVpcAttachment? = nil) {
        self.transitGatewayVpcAttachment = transitGatewayVpcAttachment
    }

    enum CodingKeys: String, CodingKey {
        case transitGatewayVpcAttachment
    }

    public func validate() throws {
        try transitGatewayVpcAttachment?.validate()
    }
}

public struct RejectVpcEndpointConnectionsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var serviceId: VpcEndpointServiceId
    public var vpcEndpointIds: VpcEndpointIdList

    public init(dryRun: Boolean? = nil,
                serviceId: VpcEndpointServiceId,
                vpcEndpointIds: VpcEndpointIdList) {
        self.dryRun = dryRun
        self.serviceId = serviceId
        self.vpcEndpointIds = vpcEndpointIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case serviceId = "ServiceId"
        case vpcEndpointIds = "VpcEndpointId"
    }

    public func validate() throws {
    }
}

public struct RejectVpcEndpointConnectionsResult: Codable, Equatable {
    public var unsuccessful: UnsuccessfulItemSet?

    public init(unsuccessful: UnsuccessfulItemSet? = nil) {
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct RejectVpcPeeringConnectionRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId

    public init(dryRun: Boolean? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId) {
        self.dryRun = dryRun
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct RejectVpcPeeringConnectionResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ReleaseAddressRequest: Codable, Equatable {
    public var allocationId: AllocationId?
    public var dryRun: Boolean?
    public var networkBorderGroup: String?
    public var publicIp: String?

    public init(allocationId: AllocationId? = nil,
                dryRun: Boolean? = nil,
                networkBorderGroup: String? = nil,
                publicIp: String? = nil) {
        self.allocationId = allocationId
        self.dryRun = dryRun
        self.networkBorderGroup = networkBorderGroup
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case dryRun
        case networkBorderGroup = "NetworkBorderGroup"
        case publicIp = "PublicIp"
    }

    public func validate() throws {
    }
}

public struct ReleaseHostsRequest: Codable, Equatable {
    public var hostIds: RequestHostIdList

    public init(hostIds: RequestHostIdList) {
        self.hostIds = hostIds
    }

    enum CodingKeys: String, CodingKey {
        case hostIds = "hostId"
    }

    public func validate() throws {
    }
}

public struct ReleaseHostsResult: Codable, Equatable {
    public var successful: ResponseHostIdList?
    public var unsuccessful: UnsuccessfulItemList?

    public init(successful: ResponseHostIdList? = nil,
                unsuccessful: UnsuccessfulItemList? = nil) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }

    enum CodingKeys: String, CodingKey {
        case successful
        case unsuccessful
    }

    public func validate() throws {
    }
}

public struct ReleaseIpamPoolAllocationRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?
    public var ipamPoolAllocationId: IpamPoolAllocationId
    public var ipamPoolId: IpamPoolId

    public init(cidr: String,
                dryRun: Boolean? = nil,
                ipamPoolAllocationId: IpamPoolAllocationId,
                ipamPoolId: IpamPoolId) {
        self.cidr = cidr
        self.dryRun = dryRun
        self.ipamPoolAllocationId = ipamPoolAllocationId
        self.ipamPoolId = ipamPoolId
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
        case ipamPoolAllocationId = "IpamPoolAllocationId"
        case ipamPoolId = "IpamPoolId"
    }

    public func validate() throws {
    }
}

public struct ReleaseIpamPoolAllocationResult: Codable, Equatable {
    public var success: Boolean?

    public init(success: Boolean? = nil) {
        self.success = success
    }

    enum CodingKeys: String, CodingKey {
        case success
    }

    public func validate() throws {
    }
}

public struct RemoveIpamOperatingRegion: Codable, Equatable {
    public var regionName: String?

    public init(regionName: String? = nil) {
        self.regionName = regionName
    }

    enum CodingKeys: String, CodingKey {
        case regionName = "RegionName"
    }

    public func validate() throws {
    }
}

public struct RemovePrefixListEntry: Codable, Equatable {
    public var cidr: String

    public init(cidr: String) {
        self.cidr = cidr
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
    }

    public func validate() throws {
    }
}

public struct ReplaceIamInstanceProfileAssociationRequest: Codable, Equatable {
    public var associationId: IamInstanceProfileAssociationId
    public var iamInstanceProfile: IamInstanceProfileSpecification

    public init(associationId: IamInstanceProfileAssociationId,
                iamInstanceProfile: IamInstanceProfileSpecification) {
        self.associationId = associationId
        self.iamInstanceProfile = iamInstanceProfile
    }

    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case iamInstanceProfile = "IamInstanceProfile"
    }

    public func validate() throws {
        try iamInstanceProfile.validate()
    }
}

public struct ReplaceIamInstanceProfileAssociationResult: Codable, Equatable {
    public var iamInstanceProfileAssociation: IamInstanceProfileAssociation?

    public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
        self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
    }

    enum CodingKeys: String, CodingKey {
        case iamInstanceProfileAssociation
    }

    public func validate() throws {
        try iamInstanceProfileAssociation?.validate()
    }
}

public struct ReplaceNetworkAclAssociationRequest: Codable, Equatable {
    public var associationId: NetworkAclAssociationId
    public var dryRun: Boolean?
    public var networkAclId: NetworkAclId

    public init(associationId: NetworkAclAssociationId,
                dryRun: Boolean? = nil,
                networkAclId: NetworkAclId) {
        self.associationId = associationId
        self.dryRun = dryRun
        self.networkAclId = networkAclId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case dryRun
        case networkAclId
    }

    public func validate() throws {
    }
}

public struct ReplaceNetworkAclAssociationResult: Codable, Equatable {
    public var newAssociationId: String?

    public init(newAssociationId: String? = nil) {
        self.newAssociationId = newAssociationId
    }

    enum CodingKeys: String, CodingKey {
        case newAssociationId
    }

    public func validate() throws {
    }
}

public struct ReplaceNetworkAclEntryRequest: Codable, Equatable {
    public var cidrBlock: String?
    public var dryRun: Boolean?
    public var egress: Boolean
    public var icmpTypeCode: IcmpTypeCode?
    public var ipv6CidrBlock: String?
    public var networkAclId: NetworkAclId
    public var portRange: PortRange?
    public var `protocol`: String
    public var ruleAction: RuleAction
    public var ruleNumber: Integer

    public init(cidrBlock: String? = nil,
                dryRun: Boolean? = nil,
                egress: Boolean,
                icmpTypeCode: IcmpTypeCode? = nil,
                ipv6CidrBlock: String? = nil,
                networkAclId: NetworkAclId,
                portRange: PortRange? = nil,
                `protocol`: String,
                ruleAction: RuleAction,
                ruleNumber: Integer) {
        self.cidrBlock = cidrBlock
        self.dryRun = dryRun
        self.egress = egress
        self.icmpTypeCode = icmpTypeCode
        self.ipv6CidrBlock = ipv6CidrBlock
        self.networkAclId = networkAclId
        self.portRange = portRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case dryRun
        case egress
        case icmpTypeCode = "Icmp"
        case ipv6CidrBlock
        case networkAclId
        case portRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
    }

    public func validate() throws {
        try icmpTypeCode?.validate()
        try portRange?.validate()
    }
}

public struct ReplaceRootVolumeTask: Codable, Equatable {
    public var completeTime: String?
    public var deleteReplacedRootVolume: Boolean?
    public var imageId: ImageId?
    public var instanceId: String?
    public var replaceRootVolumeTaskId: ReplaceRootVolumeTaskId?
    public var snapshotId: SnapshotId?
    public var startTime: String?
    public var tags: TagList?
    public var taskState: ReplaceRootVolumeTaskState?

    public init(completeTime: String? = nil,
                deleteReplacedRootVolume: Boolean? = nil,
                imageId: ImageId? = nil,
                instanceId: String? = nil,
                replaceRootVolumeTaskId: ReplaceRootVolumeTaskId? = nil,
                snapshotId: SnapshotId? = nil,
                startTime: String? = nil,
                tags: TagList? = nil,
                taskState: ReplaceRootVolumeTaskState? = nil) {
        self.completeTime = completeTime
        self.deleteReplacedRootVolume = deleteReplacedRootVolume
        self.imageId = imageId
        self.instanceId = instanceId
        self.replaceRootVolumeTaskId = replaceRootVolumeTaskId
        self.snapshotId = snapshotId
        self.startTime = startTime
        self.tags = tags
        self.taskState = taskState
    }

    enum CodingKeys: String, CodingKey {
        case completeTime
        case deleteReplacedRootVolume
        case imageId
        case instanceId
        case replaceRootVolumeTaskId
        case snapshotId
        case startTime
        case tags = "tagSet"
        case taskState
    }

    public func validate() throws {
    }
}

public struct ReplaceRouteRequest: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId?
    public var coreNetworkArn: CoreNetworkArn?
    public var destinationCidrBlock: String?
    public var destinationIpv6CidrBlock: String?
    public var destinationPrefixListId: PrefixListResourceId?
    public var dryRun: Boolean?
    public var egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId?
    public var gatewayId: RouteGatewayId?
    public var instanceId: InstanceId?
    public var localGatewayId: LocalGatewayId?
    public var localTarget: Boolean?
    public var natGatewayId: NatGatewayId?
    public var networkInterfaceId: NetworkInterfaceId?
    public var routeTableId: RouteTableId
    public var transitGatewayId: TransitGatewayId?
    public var vpcEndpointId: VpcEndpointId?
    public var vpcPeeringConnectionId: VpcPeeringConnectionId?

    public init(carrierGatewayId: CarrierGatewayId? = nil,
                coreNetworkArn: CoreNetworkArn? = nil,
                destinationCidrBlock: String? = nil,
                destinationIpv6CidrBlock: String? = nil,
                destinationPrefixListId: PrefixListResourceId? = nil,
                dryRun: Boolean? = nil,
                egressOnlyInternetGatewayId: EgressOnlyInternetGatewayId? = nil,
                gatewayId: RouteGatewayId? = nil,
                instanceId: InstanceId? = nil,
                localGatewayId: LocalGatewayId? = nil,
                localTarget: Boolean? = nil,
                natGatewayId: NatGatewayId? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                routeTableId: RouteTableId,
                transitGatewayId: TransitGatewayId? = nil,
                vpcEndpointId: VpcEndpointId? = nil,
                vpcPeeringConnectionId: VpcPeeringConnectionId? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.coreNetworkArn = coreNetworkArn
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        self.destinationPrefixListId = destinationPrefixListId
        self.dryRun = dryRun
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.gatewayId = gatewayId
        self.instanceId = instanceId
        self.localGatewayId = localGatewayId
        self.localTarget = localTarget
        self.natGatewayId = natGatewayId
        self.networkInterfaceId = networkInterfaceId
        self.routeTableId = routeTableId
        self.transitGatewayId = transitGatewayId
        self.vpcEndpointId = vpcEndpointId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId = "CarrierGatewayId"
        case coreNetworkArn = "CoreNetworkArn"
        case destinationCidrBlock
        case destinationIpv6CidrBlock
        case destinationPrefixListId = "DestinationPrefixListId"
        case dryRun
        case egressOnlyInternetGatewayId
        case gatewayId
        case instanceId
        case localGatewayId = "LocalGatewayId"
        case localTarget = "LocalTarget"
        case natGatewayId
        case networkInterfaceId
        case routeTableId
        case transitGatewayId = "TransitGatewayId"
        case vpcEndpointId = "VpcEndpointId"
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct ReplaceRouteTableAssociationRequest: Codable, Equatable {
    public var associationId: RouteTableAssociationId
    public var dryRun: Boolean?
    public var routeTableId: RouteTableId

    public init(associationId: RouteTableAssociationId,
                dryRun: Boolean? = nil,
                routeTableId: RouteTableId) {
        self.associationId = associationId
        self.dryRun = dryRun
        self.routeTableId = routeTableId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case dryRun
        case routeTableId
    }

    public func validate() throws {
    }
}

public struct ReplaceRouteTableAssociationResult: Codable, Equatable {
    public var associationState: RouteTableAssociationState?
    public var newAssociationId: String?

    public init(associationState: RouteTableAssociationState? = nil,
                newAssociationId: String? = nil) {
        self.associationState = associationState
        self.newAssociationId = newAssociationId
    }

    enum CodingKeys: String, CodingKey {
        case associationState
        case newAssociationId
    }

    public func validate() throws {
        try associationState?.validate()
    }
}

public struct ReplaceTransitGatewayRouteRequest: Codable, Equatable {
    public var blackhole: Boolean?
    public var destinationCidrBlock: String
    public var dryRun: Boolean?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(blackhole: Boolean? = nil,
                destinationCidrBlock: String,
                dryRun: Boolean? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.blackhole = blackhole
        self.destinationCidrBlock = destinationCidrBlock
        self.dryRun = dryRun
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole = "Blackhole"
        case destinationCidrBlock = "DestinationCidrBlock"
        case dryRun = "DryRun"
        case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
    }
}

public struct ReplaceTransitGatewayRouteResult: Codable, Equatable {
    public var route: TransitGatewayRoute?

    public init(route: TransitGatewayRoute? = nil) {
        self.route = route
    }

    enum CodingKeys: String, CodingKey {
        case route
    }

    public func validate() throws {
        try route?.validate()
    }
}

public struct ReportInstanceStatusRequest: Codable, Equatable {
    public var description: String?
    public var dryRun: Boolean?
    public var endTime: DateTime?
    public var instances: InstanceIdStringList
    public var reasonCodes: ReasonCodesList
    public var startTime: DateTime?
    public var status: ReportStatusType

    public init(description: String? = nil,
                dryRun: Boolean? = nil,
                endTime: DateTime? = nil,
                instances: InstanceIdStringList,
                reasonCodes: ReasonCodesList,
                startTime: DateTime? = nil,
                status: ReportStatusType) {
        self.description = description
        self.dryRun = dryRun
        self.endTime = endTime
        self.instances = instances
        self.reasonCodes = reasonCodes
        self.startTime = startTime
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case description
        case dryRun
        case endTime
        case instances = "instanceId"
        case reasonCodes = "reasonCode"
        case startTime
        case status
    }

    public func validate() throws {
    }
}

public struct RequestIpamResourceTag: Codable, Equatable {
    public var key: String?
    public var value: String?

    public init(key: String? = nil,
                value: String? = nil) {
        self.key = key
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct RequestLaunchTemplateData: Codable, Equatable {
    public var blockDeviceMappings: LaunchTemplateBlockDeviceMappingRequestList?
    public var capacityReservationSpecification: LaunchTemplateCapacityReservationSpecificationRequest?
    public var cpuOptions: LaunchTemplateCpuOptionsRequest?
    public var creditSpecification: CreditSpecificationRequest?
    public var disableApiStop: Boolean?
    public var disableApiTermination: Boolean?
    public var ebsOptimized: Boolean?
    public var elasticGpuSpecifications: ElasticGpuSpecificationList?
    public var elasticInferenceAccelerators: LaunchTemplateElasticInferenceAcceleratorList?
    public var enclaveOptions: LaunchTemplateEnclaveOptionsRequest?
    public var hibernationOptions: LaunchTemplateHibernationOptionsRequest?
    public var iamInstanceProfile: LaunchTemplateIamInstanceProfileSpecificationRequest?
    public var imageId: ImageId?
    public var instanceInitiatedShutdownBehavior: ShutdownBehavior?
    public var instanceMarketOptions: LaunchTemplateInstanceMarketOptionsRequest?
    public var instanceRequirements: InstanceRequirementsRequest?
    public var instanceType: InstanceType?
    public var kernelId: KernelId?
    public var keyName: KeyPairName?
    public var licenseSpecifications: LaunchTemplateLicenseSpecificationListRequest?
    public var maintenanceOptions: LaunchTemplateInstanceMaintenanceOptionsRequest?
    public var metadataOptions: LaunchTemplateInstanceMetadataOptionsRequest?
    public var monitoring: LaunchTemplatesMonitoringRequest?
    public var networkInterfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList?
    public var placement: LaunchTemplatePlacementRequest?
    public var privateDnsNameOptions: LaunchTemplatePrivateDnsNameOptionsRequest?
    public var ramDiskId: RamdiskId?
    public var securityGroupIds: SecurityGroupIdStringList?
    public var securityGroups: SecurityGroupStringList?
    public var tagSpecifications: LaunchTemplateTagSpecificationRequestList?
    public var userData: String?

    public init(blockDeviceMappings: LaunchTemplateBlockDeviceMappingRequestList? = nil,
                capacityReservationSpecification: LaunchTemplateCapacityReservationSpecificationRequest? = nil,
                cpuOptions: LaunchTemplateCpuOptionsRequest? = nil,
                creditSpecification: CreditSpecificationRequest? = nil,
                disableApiStop: Boolean? = nil,
                disableApiTermination: Boolean? = nil,
                ebsOptimized: Boolean? = nil,
                elasticGpuSpecifications: ElasticGpuSpecificationList? = nil,
                elasticInferenceAccelerators: LaunchTemplateElasticInferenceAcceleratorList? = nil,
                enclaveOptions: LaunchTemplateEnclaveOptionsRequest? = nil,
                hibernationOptions: LaunchTemplateHibernationOptionsRequest? = nil,
                iamInstanceProfile: LaunchTemplateIamInstanceProfileSpecificationRequest? = nil,
                imageId: ImageId? = nil,
                instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil,
                instanceMarketOptions: LaunchTemplateInstanceMarketOptionsRequest? = nil,
                instanceRequirements: InstanceRequirementsRequest? = nil,
                instanceType: InstanceType? = nil,
                kernelId: KernelId? = nil,
                keyName: KeyPairName? = nil,
                licenseSpecifications: LaunchTemplateLicenseSpecificationListRequest? = nil,
                maintenanceOptions: LaunchTemplateInstanceMaintenanceOptionsRequest? = nil,
                metadataOptions: LaunchTemplateInstanceMetadataOptionsRequest? = nil,
                monitoring: LaunchTemplatesMonitoringRequest? = nil,
                networkInterfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList? = nil,
                placement: LaunchTemplatePlacementRequest? = nil,
                privateDnsNameOptions: LaunchTemplatePrivateDnsNameOptionsRequest? = nil,
                ramDiskId: RamdiskId? = nil,
                securityGroupIds: SecurityGroupIdStringList? = nil,
                securityGroups: SecurityGroupStringList? = nil,
                tagSpecifications: LaunchTemplateTagSpecificationRequestList? = nil,
                userData: String? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.capacityReservationSpecification = capacityReservationSpecification
        self.cpuOptions = cpuOptions
        self.creditSpecification = creditSpecification
        self.disableApiStop = disableApiStop
        self.disableApiTermination = disableApiTermination
        self.ebsOptimized = ebsOptimized
        self.elasticGpuSpecifications = elasticGpuSpecifications
        self.elasticInferenceAccelerators = elasticInferenceAccelerators
        self.enclaveOptions = enclaveOptions
        self.hibernationOptions = hibernationOptions
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceMarketOptions = instanceMarketOptions
        self.instanceRequirements = instanceRequirements
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.licenseSpecifications = licenseSpecifications
        self.maintenanceOptions = maintenanceOptions
        self.metadataOptions = metadataOptions
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.privateDnsNameOptions = privateDnsNameOptions
        self.ramDiskId = ramDiskId
        self.securityGroupIds = securityGroupIds
        self.securityGroups = securityGroups
        self.tagSpecifications = tagSpecifications
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "BlockDeviceMapping"
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case cpuOptions = "CpuOptions"
        case creditSpecification = "CreditSpecification"
        case disableApiStop = "DisableApiStop"
        case disableApiTermination = "DisableApiTermination"
        case ebsOptimized = "EbsOptimized"
        case elasticGpuSpecifications = "ElasticGpuSpecification"
        case elasticInferenceAccelerators = "ElasticInferenceAccelerator"
        case enclaveOptions = "EnclaveOptions"
        case hibernationOptions = "HibernationOptions"
        case iamInstanceProfile = "IamInstanceProfile"
        case imageId = "ImageId"
        case instanceInitiatedShutdownBehavior = "InstanceInitiatedShutdownBehavior"
        case instanceMarketOptions = "InstanceMarketOptions"
        case instanceRequirements = "InstanceRequirements"
        case instanceType = "InstanceType"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case licenseSpecifications = "LicenseSpecification"
        case maintenanceOptions = "MaintenanceOptions"
        case metadataOptions = "MetadataOptions"
        case monitoring = "Monitoring"
        case networkInterfaces = "NetworkInterface"
        case placement = "Placement"
        case privateDnsNameOptions = "PrivateDnsNameOptions"
        case ramDiskId = "RamDiskId"
        case securityGroupIds = "SecurityGroupId"
        case securityGroups = "SecurityGroup"
        case tagSpecifications = "TagSpecification"
        case userData = "UserData"
    }

    public func validate() throws {
        try capacityReservationSpecification?.validate()
        try cpuOptions?.validate()
        try creditSpecification?.validate()
        try enclaveOptions?.validate()
        try hibernationOptions?.validate()
        try iamInstanceProfile?.validate()
        try instanceMarketOptions?.validate()
        try instanceRequirements?.validate()
        try maintenanceOptions?.validate()
        try metadataOptions?.validate()
        try monitoring?.validate()
        try placement?.validate()
        try privateDnsNameOptions?.validate()
    }
}

public struct RequestSpotFleetRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var spotFleetRequestConfig: SpotFleetRequestConfigData

    public init(dryRun: Boolean? = nil,
                spotFleetRequestConfig: SpotFleetRequestConfigData) {
        self.dryRun = dryRun
        self.spotFleetRequestConfig = spotFleetRequestConfig
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case spotFleetRequestConfig
    }

    public func validate() throws {
        try spotFleetRequestConfig.validate()
    }
}

public struct RequestSpotFleetResponse: Codable, Equatable {
    public var spotFleetRequestId: String?

    public init(spotFleetRequestId: String? = nil) {
        self.spotFleetRequestId = spotFleetRequestId
    }

    enum CodingKeys: String, CodingKey {
        case spotFleetRequestId
    }

    public func validate() throws {
    }
}

public struct RequestSpotInstancesRequest: Codable, Equatable {
    public var availabilityZoneGroup: String?
    public var blockDurationMinutes: Integer?
    public var clientToken: String?
    public var dryRun: Boolean?
    public var instanceCount: Integer?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var launchGroup: String?
    public var launchSpecification: RequestSpotLaunchSpecification?
    public var spotPrice: String?
    public var tagSpecifications: TagSpecificationList?
    public var type: SpotInstanceType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(availabilityZoneGroup: String? = nil,
                blockDurationMinutes: Integer? = nil,
                clientToken: String? = nil,
                dryRun: Boolean? = nil,
                instanceCount: Integer? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                launchGroup: String? = nil,
                launchSpecification: RequestSpotLaunchSpecification? = nil,
                spotPrice: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                type: SpotInstanceType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.availabilityZoneGroup = availabilityZoneGroup
        self.blockDurationMinutes = blockDurationMinutes
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.instanceCount = instanceCount
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.launchGroup = launchGroup
        self.launchSpecification = launchSpecification
        self.spotPrice = spotPrice
        self.tagSpecifications = tagSpecifications
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZoneGroup
        case blockDurationMinutes
        case clientToken
        case dryRun
        case instanceCount
        case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
        case launchGroup
        case launchSpecification = "LaunchSpecification"
        case spotPrice
        case tagSpecifications = "TagSpecification"
        case type
        case validFrom
        case validUntil
    }

    public func validate() throws {
        try launchSpecification?.validate()
    }
}

public struct RequestSpotInstancesResult: Codable, Equatable {
    public var spotInstanceRequests: SpotInstanceRequestList?

    public init(spotInstanceRequests: SpotInstanceRequestList? = nil) {
        self.spotInstanceRequests = spotInstanceRequests
    }

    enum CodingKeys: String, CodingKey {
        case spotInstanceRequests = "spotInstanceRequestSet"
    }

    public func validate() throws {
    }
}

public struct RequestSpotLaunchSpecification: Codable, Equatable {
    public var addressingType: String?
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var ebsOptimized: Boolean?
    public var iamInstanceProfile: IamInstanceProfileSpecification?
    public var imageId: ImageId?
    public var instanceType: InstanceType?
    public var kernelId: KernelId?
    public var keyName: KeyPairName?
    public var monitoring: RunInstancesMonitoringEnabled?
    public var networkInterfaces: InstanceNetworkInterfaceSpecificationList?
    public var placement: SpotPlacement?
    public var ramdiskId: RamdiskId?
    public var securityGroupIds: RequestSpotLaunchSpecificationSecurityGroupIdList?
    public var securityGroups: RequestSpotLaunchSpecificationSecurityGroupList?
    public var subnetId: SubnetId?
    public var userData: String?

    public init(addressingType: String? = nil,
                blockDeviceMappings: BlockDeviceMappingList? = nil,
                ebsOptimized: Boolean? = nil,
                iamInstanceProfile: IamInstanceProfileSpecification? = nil,
                imageId: ImageId? = nil,
                instanceType: InstanceType? = nil,
                kernelId: KernelId? = nil,
                keyName: KeyPairName? = nil,
                monitoring: RunInstancesMonitoringEnabled? = nil,
                networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil,
                placement: SpotPlacement? = nil,
                ramdiskId: RamdiskId? = nil,
                securityGroupIds: RequestSpotLaunchSpecificationSecurityGroupIdList? = nil,
                securityGroups: RequestSpotLaunchSpecificationSecurityGroupList? = nil,
                subnetId: SubnetId? = nil,
                userData: String? = nil) {
        self.addressingType = addressingType
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramdiskId = ramdiskId
        self.securityGroupIds = securityGroupIds
        self.securityGroups = securityGroups
        self.subnetId = subnetId
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case addressingType
        case blockDeviceMappings = "blockDeviceMapping"
        case ebsOptimized
        case iamInstanceProfile
        case imageId
        case instanceType
        case kernelId
        case keyName
        case monitoring
        case networkInterfaces = "NetworkInterface"
        case placement
        case ramdiskId
        case securityGroupIds = "SecurityGroupId"
        case securityGroups = "SecurityGroup"
        case subnetId
        case userData
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct Reservation: Codable, Equatable {
    public var groups: GroupIdentifierList?
    public var instances: InstanceList?
    public var ownerId: String?
    public var requesterId: String?
    public var reservationId: String?

    public init(groups: GroupIdentifierList? = nil,
                instances: InstanceList? = nil,
                ownerId: String? = nil,
                requesterId: String? = nil,
                reservationId: String? = nil) {
        self.groups = groups
        self.instances = instances
        self.ownerId = ownerId
        self.requesterId = requesterId
        self.reservationId = reservationId
    }

    enum CodingKeys: String, CodingKey {
        case groups = "groupSet"
        case instances = "instancesSet"
        case ownerId
        case requesterId
        case reservationId
    }

    public func validate() throws {
    }
}

public struct ReservationFleetInstanceSpecification: Codable, Equatable {
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var ebsOptimized: Boolean?
    public var instancePlatform: CapacityReservationInstancePlatform?
    public var instanceType: InstanceType?
    public var priority: IntegerWithConstraints?
    public var weight: DoubleWithConstraints?

    public init(availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                ebsOptimized: Boolean? = nil,
                instancePlatform: CapacityReservationInstancePlatform? = nil,
                instanceType: InstanceType? = nil,
                priority: IntegerWithConstraints? = nil,
                weight: DoubleWithConstraints? = nil) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.ebsOptimized = ebsOptimized
        self.instancePlatform = instancePlatform
        self.instanceType = instanceType
        self.priority = priority
        self.weight = weight
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case ebsOptimized = "EbsOptimized"
        case instancePlatform = "InstancePlatform"
        case instanceType = "InstanceType"
        case priority = "Priority"
        case weight = "Weight"
    }

    public func validate() throws {
        try priority?.validateAsIntegerWithConstraints()
        try weight?.validateAsDoubleWithConstraints()
    }
}

public struct ReservationValue: Codable, Equatable {
    public var hourlyPrice: String?
    public var remainingTotalValue: String?
    public var remainingUpfrontValue: String?

    public init(hourlyPrice: String? = nil,
                remainingTotalValue: String? = nil,
                remainingUpfrontValue: String? = nil) {
        self.hourlyPrice = hourlyPrice
        self.remainingTotalValue = remainingTotalValue
        self.remainingUpfrontValue = remainingUpfrontValue
    }

    enum CodingKeys: String, CodingKey {
        case hourlyPrice
        case remainingTotalValue
        case remainingUpfrontValue
    }

    public func validate() throws {
    }
}

public struct ReservedInstanceLimitPrice: Codable, Equatable {
    public var amount: Double?
    public var currencyCode: CurrencyCodeValues?

    public init(amount: Double? = nil,
                currencyCode: CurrencyCodeValues? = nil) {
        self.amount = amount
        self.currencyCode = currencyCode
    }

    enum CodingKeys: String, CodingKey {
        case amount
        case currencyCode
    }

    public func validate() throws {
    }
}

public struct ReservedInstanceReservationValue: Codable, Equatable {
    public var reservationValue: ReservationValue?
    public var reservedInstanceId: String?

    public init(reservationValue: ReservationValue? = nil,
                reservedInstanceId: String? = nil) {
        self.reservationValue = reservationValue
        self.reservedInstanceId = reservedInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case reservationValue
        case reservedInstanceId
    }

    public func validate() throws {
        try reservationValue?.validate()
    }
}

public struct ReservedInstances: Codable, Equatable {
    public var availabilityZone: String?
    public var currencyCode: CurrencyCodeValues?
    public var duration: Long?
    public var end: DateTime?
    public var fixedPrice: Float?
    public var instanceCount: Integer?
    public var instanceTenancy: Tenancy?
    public var instanceType: InstanceType?
    public var offeringClass: OfferingClassType?
    public var offeringType: OfferingTypeValues?
    public var productDescription: RIProductDescription?
    public var recurringCharges: RecurringChargesList?
    public var reservedInstancesId: String?
    public var scope: Scope?
    public var start: DateTime?
    public var state: ReservedInstanceState?
    public var tags: TagList?
    public var usagePrice: Float?

    public init(availabilityZone: String? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                duration: Long? = nil,
                end: DateTime? = nil,
                fixedPrice: Float? = nil,
                instanceCount: Integer? = nil,
                instanceTenancy: Tenancy? = nil,
                instanceType: InstanceType? = nil,
                offeringClass: OfferingClassType? = nil,
                offeringType: OfferingTypeValues? = nil,
                productDescription: RIProductDescription? = nil,
                recurringCharges: RecurringChargesList? = nil,
                reservedInstancesId: String? = nil,
                scope: Scope? = nil,
                start: DateTime? = nil,
                state: ReservedInstanceState? = nil,
                tags: TagList? = nil,
                usagePrice: Float? = nil) {
        self.availabilityZone = availabilityZone
        self.currencyCode = currencyCode
        self.duration = duration
        self.end = end
        self.fixedPrice = fixedPrice
        self.instanceCount = instanceCount
        self.instanceTenancy = instanceTenancy
        self.instanceType = instanceType
        self.offeringClass = offeringClass
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.recurringCharges = recurringCharges
        self.reservedInstancesId = reservedInstancesId
        self.scope = scope
        self.start = start
        self.state = state
        self.tags = tags
        self.usagePrice = usagePrice
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case currencyCode
        case duration
        case end
        case fixedPrice
        case instanceCount
        case instanceTenancy
        case instanceType
        case offeringClass
        case offeringType
        case productDescription
        case recurringCharges
        case reservedInstancesId
        case scope
        case start
        case state
        case tags = "tagSet"
        case usagePrice
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesConfiguration: Codable, Equatable {
    public var availabilityZone: String?
    public var instanceCount: Integer?
    public var instanceType: InstanceType?
    public var platform: String?
    public var scope: Scope?

    public init(availabilityZone: String? = nil,
                instanceCount: Integer? = nil,
                instanceType: InstanceType? = nil,
                platform: String? = nil,
                scope: Scope? = nil) {
        self.availabilityZone = availabilityZone
        self.instanceCount = instanceCount
        self.instanceType = instanceType
        self.platform = platform
        self.scope = scope
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case instanceCount
        case instanceType
        case platform
        case scope
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesId: Codable, Equatable {
    public var reservedInstancesId: String?

    public init(reservedInstancesId: String? = nil) {
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesId
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesListing: Codable, Equatable {
    public var clientToken: String?
    public var createDate: DateTime?
    public var instanceCounts: InstanceCountList?
    public var priceSchedules: PriceScheduleList?
    public var reservedInstancesId: String?
    public var reservedInstancesListingId: String?
    public var status: ListingStatus?
    public var statusMessage: String?
    public var tags: TagList?
    public var updateDate: DateTime?

    public init(clientToken: String? = nil,
                createDate: DateTime? = nil,
                instanceCounts: InstanceCountList? = nil,
                priceSchedules: PriceScheduleList? = nil,
                reservedInstancesId: String? = nil,
                reservedInstancesListingId: String? = nil,
                status: ListingStatus? = nil,
                statusMessage: String? = nil,
                tags: TagList? = nil,
                updateDate: DateTime? = nil) {
        self.clientToken = clientToken
        self.createDate = createDate
        self.instanceCounts = instanceCounts
        self.priceSchedules = priceSchedules
        self.reservedInstancesId = reservedInstancesId
        self.reservedInstancesListingId = reservedInstancesListingId
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.updateDate = updateDate
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case createDate
        case instanceCounts
        case priceSchedules
        case reservedInstancesId
        case reservedInstancesListingId
        case status
        case statusMessage
        case tags = "tagSet"
        case updateDate
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesModification: Codable, Equatable {
    public var clientToken: String?
    public var createDate: DateTime?
    public var effectiveDate: DateTime?
    public var modificationResults: ReservedInstancesModificationResultList?
    public var reservedInstancesIds: ReservedIntancesIds?
    public var reservedInstancesModificationId: String?
    public var status: String?
    public var statusMessage: String?
    public var updateDate: DateTime?

    public init(clientToken: String? = nil,
                createDate: DateTime? = nil,
                effectiveDate: DateTime? = nil,
                modificationResults: ReservedInstancesModificationResultList? = nil,
                reservedInstancesIds: ReservedIntancesIds? = nil,
                reservedInstancesModificationId: String? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                updateDate: DateTime? = nil) {
        self.clientToken = clientToken
        self.createDate = createDate
        self.effectiveDate = effectiveDate
        self.modificationResults = modificationResults
        self.reservedInstancesIds = reservedInstancesIds
        self.reservedInstancesModificationId = reservedInstancesModificationId
        self.status = status
        self.statusMessage = statusMessage
        self.updateDate = updateDate
    }

    enum CodingKeys: String, CodingKey {
        case clientToken
        case createDate
        case effectiveDate
        case modificationResults = "modificationResultSet"
        case reservedInstancesIds = "reservedInstancesSet"
        case reservedInstancesModificationId
        case status
        case statusMessage
        case updateDate
    }

    public func validate() throws {
    }
}

public struct ReservedInstancesModificationResult: Codable, Equatable {
    public var reservedInstancesId: String?
    public var targetConfiguration: ReservedInstancesConfiguration?

    public init(reservedInstancesId: String? = nil,
                targetConfiguration: ReservedInstancesConfiguration? = nil) {
        self.reservedInstancesId = reservedInstancesId
        self.targetConfiguration = targetConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesId
        case targetConfiguration
    }

    public func validate() throws {
        try targetConfiguration?.validate()
    }
}

public struct ReservedInstancesOffering: Codable, Equatable {
    public var availabilityZone: String?
    public var currencyCode: CurrencyCodeValues?
    public var duration: Long?
    public var fixedPrice: Float?
    public var instanceTenancy: Tenancy?
    public var instanceType: InstanceType?
    public var marketplace: Boolean?
    public var offeringClass: OfferingClassType?
    public var offeringType: OfferingTypeValues?
    public var pricingDetails: PricingDetailsList?
    public var productDescription: RIProductDescription?
    public var recurringCharges: RecurringChargesList?
    public var reservedInstancesOfferingId: String?
    public var scope: Scope?
    public var usagePrice: Float?

    public init(availabilityZone: String? = nil,
                currencyCode: CurrencyCodeValues? = nil,
                duration: Long? = nil,
                fixedPrice: Float? = nil,
                instanceTenancy: Tenancy? = nil,
                instanceType: InstanceType? = nil,
                marketplace: Boolean? = nil,
                offeringClass: OfferingClassType? = nil,
                offeringType: OfferingTypeValues? = nil,
                pricingDetails: PricingDetailsList? = nil,
                productDescription: RIProductDescription? = nil,
                recurringCharges: RecurringChargesList? = nil,
                reservedInstancesOfferingId: String? = nil,
                scope: Scope? = nil,
                usagePrice: Float? = nil) {
        self.availabilityZone = availabilityZone
        self.currencyCode = currencyCode
        self.duration = duration
        self.fixedPrice = fixedPrice
        self.instanceTenancy = instanceTenancy
        self.instanceType = instanceType
        self.marketplace = marketplace
        self.offeringClass = offeringClass
        self.offeringType = offeringType
        self.pricingDetails = pricingDetails
        self.productDescription = productDescription
        self.recurringCharges = recurringCharges
        self.reservedInstancesOfferingId = reservedInstancesOfferingId
        self.scope = scope
        self.usagePrice = usagePrice
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case currencyCode
        case duration
        case fixedPrice
        case instanceTenancy
        case instanceType
        case marketplace
        case offeringClass
        case offeringType
        case pricingDetails = "pricingDetailsSet"
        case productDescription
        case recurringCharges
        case reservedInstancesOfferingId
        case scope
        case usagePrice
    }

    public func validate() throws {
    }
}

public struct ResetAddressAttributeRequest: Codable, Equatable {
    public var allocationId: AllocationId
    public var attribute: AddressAttributeName
    public var dryRun: Boolean?

    public init(allocationId: AllocationId,
                attribute: AddressAttributeName,
                dryRun: Boolean? = nil) {
        self.allocationId = allocationId
        self.attribute = attribute
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case attribute = "Attribute"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ResetAddressAttributeResult: Codable, Equatable {
    public var address: AddressAttribute?

    public init(address: AddressAttribute? = nil) {
        self.address = address
    }

    enum CodingKeys: String, CodingKey {
        case address
    }

    public func validate() throws {
        try address?.validate()
    }
}

public struct ResetEbsDefaultKmsKeyIdRequest: Codable, Equatable {
    public var dryRun: Boolean?

    public init(dryRun: Boolean? = nil) {
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct ResetEbsDefaultKmsKeyIdResult: Codable, Equatable {
    public var kmsKeyId: String?

    public init(kmsKeyId: String? = nil) {
        self.kmsKeyId = kmsKeyId
    }

    enum CodingKeys: String, CodingKey {
        case kmsKeyId
    }

    public func validate() throws {
    }
}

public struct ResetFpgaImageAttributeRequest: Codable, Equatable {
    public var attribute: ResetFpgaImageAttributeName?
    public var dryRun: Boolean?
    public var fpgaImageId: FpgaImageId

    public init(attribute: ResetFpgaImageAttributeName? = nil,
                dryRun: Boolean? = nil,
                fpgaImageId: FpgaImageId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.fpgaImageId = fpgaImageId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun = "DryRun"
        case fpgaImageId = "FpgaImageId"
    }

    public func validate() throws {
    }
}

public struct ResetFpgaImageAttributeResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct ResetImageAttributeRequest: Codable, Equatable {
    public var attribute: ResetImageAttributeName
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(attribute: ResetImageAttributeName,
                dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct ResetInstanceAttributeRequest: Codable, Equatable {
    public var attribute: InstanceAttributeName
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(attribute: InstanceAttributeName,
                dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case attribute
        case dryRun
        case instanceId
    }

    public func validate() throws {
    }
}

public struct ResetNetworkInterfaceAttributeRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var networkInterfaceId: NetworkInterfaceId
    public var sourceDestCheck: String?

    public init(dryRun: Boolean? = nil,
                networkInterfaceId: NetworkInterfaceId,
                sourceDestCheck: String? = nil) {
        self.dryRun = dryRun
        self.networkInterfaceId = networkInterfaceId
        self.sourceDestCheck = sourceDestCheck
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case networkInterfaceId
        case sourceDestCheck
    }

    public func validate() throws {
    }
}

public struct ResetSnapshotAttributeRequest: Codable, Equatable {
    public var attribute: SnapshotAttributeName
    public var dryRun: Boolean?
    public var snapshotId: SnapshotId

    public init(attribute: SnapshotAttributeName,
                dryRun: Boolean? = nil,
                snapshotId: SnapshotId) {
        self.attribute = attribute
        self.dryRun = dryRun
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case dryRun
        case snapshotId = "SnapshotId"
    }

    public func validate() throws {
    }
}

public struct ResourceStatement: Codable, Equatable {
    public var resourceTypes: ValueStringList?
    public var resources: ValueStringList?

    public init(resourceTypes: ValueStringList? = nil,
                resources: ValueStringList? = nil) {
        self.resourceTypes = resourceTypes
        self.resources = resources
    }

    enum CodingKeys: String, CodingKey {
        case resourceTypes = "resourceTypeSet"
        case resources = "resourceSet"
    }

    public func validate() throws {
    }
}

public struct ResourceStatementRequest: Codable, Equatable {
    public var resourceTypes: ValueStringList?
    public var resources: ValueStringList?

    public init(resourceTypes: ValueStringList? = nil,
                resources: ValueStringList? = nil) {
        self.resourceTypes = resourceTypes
        self.resources = resources
    }

    enum CodingKeys: String, CodingKey {
        case resourceTypes = "ResourceType"
        case resources = "Resource"
    }

    public func validate() throws {
    }
}

public struct ResponseError: Codable, Equatable {
    public var code: LaunchTemplateErrorCode?
    public var message: String?

    public init(code: LaunchTemplateErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ResponseLaunchTemplateData: Codable, Equatable {
    public var blockDeviceMappings: LaunchTemplateBlockDeviceMappingList?
    public var capacityReservationSpecification: LaunchTemplateCapacityReservationSpecificationResponse?
    public var cpuOptions: LaunchTemplateCpuOptions?
    public var creditSpecification: CreditSpecification?
    public var disableApiStop: Boolean?
    public var disableApiTermination: Boolean?
    public var ebsOptimized: Boolean?
    public var elasticGpuSpecifications: ElasticGpuSpecificationResponseList?
    public var elasticInferenceAccelerators: LaunchTemplateElasticInferenceAcceleratorResponseList?
    public var enclaveOptions: LaunchTemplateEnclaveOptions?
    public var hibernationOptions: LaunchTemplateHibernationOptions?
    public var iamInstanceProfile: LaunchTemplateIamInstanceProfileSpecification?
    public var imageId: String?
    public var instanceInitiatedShutdownBehavior: ShutdownBehavior?
    public var instanceMarketOptions: LaunchTemplateInstanceMarketOptions?
    public var instanceRequirements: InstanceRequirements?
    public var instanceType: InstanceType?
    public var kernelId: String?
    public var keyName: String?
    public var licenseSpecifications: LaunchTemplateLicenseList?
    public var maintenanceOptions: LaunchTemplateInstanceMaintenanceOptions?
    public var metadataOptions: LaunchTemplateInstanceMetadataOptions?
    public var monitoring: LaunchTemplatesMonitoring?
    public var networkInterfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationList?
    public var placement: LaunchTemplatePlacement?
    public var privateDnsNameOptions: LaunchTemplatePrivateDnsNameOptions?
    public var ramDiskId: String?
    public var securityGroupIds: ValueStringList?
    public var securityGroups: ValueStringList?
    public var tagSpecifications: LaunchTemplateTagSpecificationList?
    public var userData: String?

    public init(blockDeviceMappings: LaunchTemplateBlockDeviceMappingList? = nil,
                capacityReservationSpecification: LaunchTemplateCapacityReservationSpecificationResponse? = nil,
                cpuOptions: LaunchTemplateCpuOptions? = nil,
                creditSpecification: CreditSpecification? = nil,
                disableApiStop: Boolean? = nil,
                disableApiTermination: Boolean? = nil,
                ebsOptimized: Boolean? = nil,
                elasticGpuSpecifications: ElasticGpuSpecificationResponseList? = nil,
                elasticInferenceAccelerators: LaunchTemplateElasticInferenceAcceleratorResponseList? = nil,
                enclaveOptions: LaunchTemplateEnclaveOptions? = nil,
                hibernationOptions: LaunchTemplateHibernationOptions? = nil,
                iamInstanceProfile: LaunchTemplateIamInstanceProfileSpecification? = nil,
                imageId: String? = nil,
                instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil,
                instanceMarketOptions: LaunchTemplateInstanceMarketOptions? = nil,
                instanceRequirements: InstanceRequirements? = nil,
                instanceType: InstanceType? = nil,
                kernelId: String? = nil,
                keyName: String? = nil,
                licenseSpecifications: LaunchTemplateLicenseList? = nil,
                maintenanceOptions: LaunchTemplateInstanceMaintenanceOptions? = nil,
                metadataOptions: LaunchTemplateInstanceMetadataOptions? = nil,
                monitoring: LaunchTemplatesMonitoring? = nil,
                networkInterfaces: LaunchTemplateInstanceNetworkInterfaceSpecificationList? = nil,
                placement: LaunchTemplatePlacement? = nil,
                privateDnsNameOptions: LaunchTemplatePrivateDnsNameOptions? = nil,
                ramDiskId: String? = nil,
                securityGroupIds: ValueStringList? = nil,
                securityGroups: ValueStringList? = nil,
                tagSpecifications: LaunchTemplateTagSpecificationList? = nil,
                userData: String? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.capacityReservationSpecification = capacityReservationSpecification
        self.cpuOptions = cpuOptions
        self.creditSpecification = creditSpecification
        self.disableApiStop = disableApiStop
        self.disableApiTermination = disableApiTermination
        self.ebsOptimized = ebsOptimized
        self.elasticGpuSpecifications = elasticGpuSpecifications
        self.elasticInferenceAccelerators = elasticInferenceAccelerators
        self.enclaveOptions = enclaveOptions
        self.hibernationOptions = hibernationOptions
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceMarketOptions = instanceMarketOptions
        self.instanceRequirements = instanceRequirements
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.licenseSpecifications = licenseSpecifications
        self.maintenanceOptions = maintenanceOptions
        self.metadataOptions = metadataOptions
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.privateDnsNameOptions = privateDnsNameOptions
        self.ramDiskId = ramDiskId
        self.securityGroupIds = securityGroupIds
        self.securityGroups = securityGroups
        self.tagSpecifications = tagSpecifications
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "blockDeviceMappingSet"
        case capacityReservationSpecification
        case cpuOptions
        case creditSpecification
        case disableApiStop
        case disableApiTermination
        case ebsOptimized
        case elasticGpuSpecifications = "elasticGpuSpecificationSet"
        case elasticInferenceAccelerators = "elasticInferenceAcceleratorSet"
        case enclaveOptions
        case hibernationOptions
        case iamInstanceProfile
        case imageId
        case instanceInitiatedShutdownBehavior
        case instanceMarketOptions
        case instanceRequirements
        case instanceType
        case kernelId
        case keyName
        case licenseSpecifications = "licenseSet"
        case maintenanceOptions
        case metadataOptions
        case monitoring
        case networkInterfaces = "networkInterfaceSet"
        case placement
        case privateDnsNameOptions
        case ramDiskId
        case securityGroupIds = "securityGroupIdSet"
        case securityGroups = "securityGroupSet"
        case tagSpecifications = "tagSpecificationSet"
        case userData
    }

    public func validate() throws {
        try capacityReservationSpecification?.validate()
        try cpuOptions?.validate()
        try creditSpecification?.validate()
        try enclaveOptions?.validate()
        try hibernationOptions?.validate()
        try iamInstanceProfile?.validate()
        try instanceMarketOptions?.validate()
        try instanceRequirements?.validate()
        try maintenanceOptions?.validate()
        try metadataOptions?.validate()
        try monitoring?.validate()
        try placement?.validate()
        try privateDnsNameOptions?.validate()
    }
}

public struct RestoreAddressToClassicRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var publicIp: String

    public init(dryRun: Boolean? = nil,
                publicIp: String) {
        self.dryRun = dryRun
        self.publicIp = publicIp
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case publicIp
    }

    public func validate() throws {
    }
}

public struct RestoreAddressToClassicResult: Codable, Equatable {
    public var publicIp: String?
    public var status: Status?

    public init(publicIp: String? = nil,
                status: Status? = nil) {
        self.publicIp = publicIp
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case publicIp
        case status
    }

    public func validate() throws {
    }
}

public struct RestoreImageFromRecycleBinRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var imageId: ImageId

    public init(dryRun: Boolean? = nil,
                imageId: ImageId) {
        self.dryRun = dryRun
        self.imageId = imageId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case imageId = "ImageId"
    }

    public func validate() throws {
    }
}

public struct RestoreImageFromRecycleBinResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct RestoreManagedPrefixListVersionRequest: Codable, Equatable {
    public var currentVersion: Long
    public var dryRun: Boolean?
    public var prefixListId: PrefixListResourceId
    public var previousVersion: Long

    public init(currentVersion: Long,
                dryRun: Boolean? = nil,
                prefixListId: PrefixListResourceId,
                previousVersion: Long) {
        self.currentVersion = currentVersion
        self.dryRun = dryRun
        self.prefixListId = prefixListId
        self.previousVersion = previousVersion
    }

    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case dryRun = "DryRun"
        case prefixListId = "PrefixListId"
        case previousVersion = "PreviousVersion"
    }

    public func validate() throws {
    }
}

public struct RestoreManagedPrefixListVersionResult: Codable, Equatable {
    public var prefixList: ManagedPrefixList?

    public init(prefixList: ManagedPrefixList? = nil) {
        self.prefixList = prefixList
    }

    enum CodingKeys: String, CodingKey {
        case prefixList
    }

    public func validate() throws {
        try prefixList?.validate()
    }
}

public struct RestoreSnapshotFromRecycleBinRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var snapshotId: SnapshotId

    public init(dryRun: Boolean? = nil,
                snapshotId: SnapshotId) {
        self.dryRun = dryRun
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case snapshotId = "SnapshotId"
    }

    public func validate() throws {
    }
}

public struct RestoreSnapshotFromRecycleBinResult: Codable, Equatable {
    public var description: String?
    public var encrypted: Boolean?
    public var outpostArn: String?
    public var ownerId: String?
    public var progress: String?
    public var snapshotId: String?
    public var startTime: MillisecondDateTime?
    public var state: SnapshotState?
    public var volumeId: String?
    public var volumeSize: Integer?

    public init(description: String? = nil,
                encrypted: Boolean? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                progress: String? = nil,
                snapshotId: String? = nil,
                startTime: MillisecondDateTime? = nil,
                state: SnapshotState? = nil,
                volumeId: String? = nil,
                volumeSize: Integer? = nil) {
        self.description = description
        self.encrypted = encrypted
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.progress = progress
        self.snapshotId = snapshotId
        self.startTime = startTime
        self.state = state
        self.volumeId = volumeId
        self.volumeSize = volumeSize
    }

    enum CodingKeys: String, CodingKey {
        case description
        case encrypted
        case outpostArn
        case ownerId
        case progress
        case snapshotId
        case startTime
        case state = "status"
        case volumeId
        case volumeSize
    }

    public func validate() throws {
    }
}

public struct RestoreSnapshotTierRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var permanentRestore: Boolean?
    public var snapshotId: SnapshotId
    public var temporaryRestoreDays: RestoreSnapshotTierRequestTemporaryRestoreDays?

    public init(dryRun: Boolean? = nil,
                permanentRestore: Boolean? = nil,
                snapshotId: SnapshotId,
                temporaryRestoreDays: RestoreSnapshotTierRequestTemporaryRestoreDays? = nil) {
        self.dryRun = dryRun
        self.permanentRestore = permanentRestore
        self.snapshotId = snapshotId
        self.temporaryRestoreDays = temporaryRestoreDays
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case permanentRestore = "PermanentRestore"
        case snapshotId = "SnapshotId"
        case temporaryRestoreDays = "TemporaryRestoreDays"
    }

    public func validate() throws {
    }
}

public struct RestoreSnapshotTierResult: Codable, Equatable {
    public var isPermanentRestore: Boolean?
    public var restoreDuration: Integer?
    public var restoreStartTime: MillisecondDateTime?
    public var snapshotId: String?

    public init(isPermanentRestore: Boolean? = nil,
                restoreDuration: Integer? = nil,
                restoreStartTime: MillisecondDateTime? = nil,
                snapshotId: String? = nil) {
        self.isPermanentRestore = isPermanentRestore
        self.restoreDuration = restoreDuration
        self.restoreStartTime = restoreStartTime
        self.snapshotId = snapshotId
    }

    enum CodingKeys: String, CodingKey {
        case isPermanentRestore
        case restoreDuration
        case restoreStartTime
        case snapshotId
    }

    public func validate() throws {
    }
}

public struct RevokeClientVpnIngressRequest: Codable, Equatable {
    public var accessGroupId: String?
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var dryRun: Boolean?
    public var revokeAllGroups: Boolean?
    public var targetNetworkCidr: String

    public init(accessGroupId: String? = nil,
                clientVpnEndpointId: ClientVpnEndpointId,
                dryRun: Boolean? = nil,
                revokeAllGroups: Boolean? = nil,
                targetNetworkCidr: String) {
        self.accessGroupId = accessGroupId
        self.clientVpnEndpointId = clientVpnEndpointId
        self.dryRun = dryRun
        self.revokeAllGroups = revokeAllGroups
        self.targetNetworkCidr = targetNetworkCidr
    }

    enum CodingKeys: String, CodingKey {
        case accessGroupId = "AccessGroupId"
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case dryRun = "DryRun"
        case revokeAllGroups = "RevokeAllGroups"
        case targetNetworkCidr = "TargetNetworkCidr"
    }

    public func validate() throws {
    }
}

public struct RevokeClientVpnIngressResult: Codable, Equatable {
    public var status: ClientVpnAuthorizationRuleStatus?

    public init(status: ClientVpnAuthorizationRuleStatus? = nil) {
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case status
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct RevokeSecurityGroupEgressRequest: Codable, Equatable {
    public var cidrIp: String?
    public var dryRun: Boolean?
    public var fromPort: Integer?
    public var groupId: SecurityGroupId
    public var ipPermissions: IpPermissionList?
    public var ipProtocol: String?
    public var securityGroupRuleIds: SecurityGroupRuleIdList?
    public var sourceSecurityGroupName: String?
    public var sourceSecurityGroupOwnerId: String?
    public var toPort: Integer?

    public init(cidrIp: String? = nil,
                dryRun: Boolean? = nil,
                fromPort: Integer? = nil,
                groupId: SecurityGroupId,
                ipPermissions: IpPermissionList? = nil,
                ipProtocol: String? = nil,
                securityGroupRuleIds: SecurityGroupRuleIdList? = nil,
                sourceSecurityGroupName: String? = nil,
                sourceSecurityGroupOwnerId: String? = nil,
                toPort: Integer? = nil) {
        self.cidrIp = cidrIp
        self.dryRun = dryRun
        self.fromPort = fromPort
        self.groupId = groupId
        self.ipPermissions = ipPermissions
        self.ipProtocol = ipProtocol
        self.securityGroupRuleIds = securityGroupRuleIds
        self.sourceSecurityGroupName = sourceSecurityGroupName
        self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp
        case dryRun
        case fromPort
        case groupId
        case ipPermissions
        case ipProtocol
        case securityGroupRuleIds = "SecurityGroupRuleId"
        case sourceSecurityGroupName
        case sourceSecurityGroupOwnerId
        case toPort
    }

    public func validate() throws {
    }
}

public struct RevokeSecurityGroupEgressResult: Codable, Equatable {
    public var `return`: Boolean?
    public var unknownIpPermissions: IpPermissionList?

    public init(`return`: Boolean? = nil,
                unknownIpPermissions: IpPermissionList? = nil) {
        self.`return` = `return`
        self.unknownIpPermissions = unknownIpPermissions
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
        case unknownIpPermissions = "unknownIpPermissionSet"
    }

    public func validate() throws {
    }
}

public struct RevokeSecurityGroupIngressRequest: Codable, Equatable {
    public var cidrIp: String?
    public var dryRun: Boolean?
    public var fromPort: Integer?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?
    public var ipPermissions: IpPermissionList?
    public var ipProtocol: String?
    public var securityGroupRuleIds: SecurityGroupRuleIdList?
    public var sourceSecurityGroupName: String?
    public var sourceSecurityGroupOwnerId: String?
    public var toPort: Integer?

    public init(cidrIp: String? = nil,
                dryRun: Boolean? = nil,
                fromPort: Integer? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil,
                ipPermissions: IpPermissionList? = nil,
                ipProtocol: String? = nil,
                securityGroupRuleIds: SecurityGroupRuleIdList? = nil,
                sourceSecurityGroupName: String? = nil,
                sourceSecurityGroupOwnerId: String? = nil,
                toPort: Integer? = nil) {
        self.cidrIp = cidrIp
        self.dryRun = dryRun
        self.fromPort = fromPort
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
        self.ipProtocol = ipProtocol
        self.securityGroupRuleIds = securityGroupRuleIds
        self.sourceSecurityGroupName = sourceSecurityGroupName
        self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIp = "CidrIp"
        case dryRun
        case fromPort = "FromPort"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
        case ipProtocol = "IpProtocol"
        case securityGroupRuleIds = "SecurityGroupRuleId"
        case sourceSecurityGroupName = "SourceSecurityGroupName"
        case sourceSecurityGroupOwnerId = "SourceSecurityGroupOwnerId"
        case toPort = "ToPort"
    }

    public func validate() throws {
    }
}

public struct RevokeSecurityGroupIngressResult: Codable, Equatable {
    public var `return`: Boolean?
    public var unknownIpPermissions: IpPermissionList?

    public init(`return`: Boolean? = nil,
                unknownIpPermissions: IpPermissionList? = nil) {
        self.`return` = `return`
        self.unknownIpPermissions = unknownIpPermissions
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
        case unknownIpPermissions = "unknownIpPermissionSet"
    }

    public func validate() throws {
    }
}

public struct Route: Codable, Equatable {
    public var carrierGatewayId: CarrierGatewayId?
    public var coreNetworkArn: CoreNetworkArn?
    public var destinationCidrBlock: String?
    public var destinationIpv6CidrBlock: String?
    public var destinationPrefixListId: String?
    public var egressOnlyInternetGatewayId: String?
    public var gatewayId: String?
    public var instanceId: String?
    public var instanceOwnerId: String?
    public var localGatewayId: String?
    public var natGatewayId: String?
    public var networkInterfaceId: String?
    public var origin: RouteOrigin?
    public var state: RouteState?
    public var transitGatewayId: String?
    public var vpcPeeringConnectionId: String?

    public init(carrierGatewayId: CarrierGatewayId? = nil,
                coreNetworkArn: CoreNetworkArn? = nil,
                destinationCidrBlock: String? = nil,
                destinationIpv6CidrBlock: String? = nil,
                destinationPrefixListId: String? = nil,
                egressOnlyInternetGatewayId: String? = nil,
                gatewayId: String? = nil,
                instanceId: String? = nil,
                instanceOwnerId: String? = nil,
                localGatewayId: String? = nil,
                natGatewayId: String? = nil,
                networkInterfaceId: String? = nil,
                origin: RouteOrigin? = nil,
                state: RouteState? = nil,
                transitGatewayId: String? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.carrierGatewayId = carrierGatewayId
        self.coreNetworkArn = coreNetworkArn
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        self.destinationPrefixListId = destinationPrefixListId
        self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
        self.gatewayId = gatewayId
        self.instanceId = instanceId
        self.instanceOwnerId = instanceOwnerId
        self.localGatewayId = localGatewayId
        self.natGatewayId = natGatewayId
        self.networkInterfaceId = networkInterfaceId
        self.origin = origin
        self.state = state
        self.transitGatewayId = transitGatewayId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case carrierGatewayId
        case coreNetworkArn
        case destinationCidrBlock
        case destinationIpv6CidrBlock
        case destinationPrefixListId
        case egressOnlyInternetGatewayId
        case gatewayId
        case instanceId
        case instanceOwnerId
        case localGatewayId
        case natGatewayId
        case networkInterfaceId
        case origin
        case state
        case transitGatewayId
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct RouteTable: Codable, Equatable {
    public var associations: RouteTableAssociationList?
    public var ownerId: String?
    public var propagatingVgws: PropagatingVgwList?
    public var routeTableId: String?
    public var routes: RouteList?
    public var tags: TagList?
    public var vpcId: String?

    public init(associations: RouteTableAssociationList? = nil,
                ownerId: String? = nil,
                propagatingVgws: PropagatingVgwList? = nil,
                routeTableId: String? = nil,
                routes: RouteList? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.associations = associations
        self.ownerId = ownerId
        self.propagatingVgws = propagatingVgws
        self.routeTableId = routeTableId
        self.routes = routes
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case associations = "associationSet"
        case ownerId
        case propagatingVgws = "propagatingVgwSet"
        case routeTableId
        case routes = "routeSet"
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct RouteTableAssociation: Codable, Equatable {
    public var associationState: RouteTableAssociationState?
    public var gatewayId: String?
    public var main: Boolean?
    public var routeTableAssociationId: String?
    public var routeTableId: String?
    public var subnetId: String?

    public init(associationState: RouteTableAssociationState? = nil,
                gatewayId: String? = nil,
                main: Boolean? = nil,
                routeTableAssociationId: String? = nil,
                routeTableId: String? = nil,
                subnetId: String? = nil) {
        self.associationState = associationState
        self.gatewayId = gatewayId
        self.main = main
        self.routeTableAssociationId = routeTableAssociationId
        self.routeTableId = routeTableId
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associationState
        case gatewayId
        case main
        case routeTableAssociationId
        case routeTableId
        case subnetId
    }

    public func validate() throws {
        try associationState?.validate()
    }
}

public struct RouteTableAssociationState: Codable, Equatable {
    public var state: RouteTableAssociationStateCode?
    public var statusMessage: String?

    public init(state: RouteTableAssociationStateCode? = nil,
                statusMessage: String? = nil) {
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct RunInstancesMonitoringEnabled: Codable, Equatable {
    public var enabled: Boolean

    public init(enabled: Boolean) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct RunInstancesRequest: Codable, Equatable {
    public var additionalInfo: String?
    public var blockDeviceMappings: BlockDeviceMappingRequestList?
    public var capacityReservationSpecification: CapacityReservationSpecification?
    public var clientToken: String?
    public var cpuOptions: CpuOptionsRequest?
    public var creditSpecification: CreditSpecificationRequest?
    public var disableApiStop: Boolean?
    public var disableApiTermination: Boolean?
    public var dryRun: Boolean?
    public var ebsOptimized: Boolean?
    public var elasticGpuSpecification: ElasticGpuSpecifications?
    public var elasticInferenceAccelerators: ElasticInferenceAccelerators?
    public var enclaveOptions: EnclaveOptionsRequest?
    public var hibernationOptions: HibernationOptionsRequest?
    public var iamInstanceProfile: IamInstanceProfileSpecification?
    public var imageId: ImageId?
    public var instanceInitiatedShutdownBehavior: ShutdownBehavior?
    public var instanceMarketOptions: InstanceMarketOptionsRequest?
    public var instanceType: InstanceType?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: InstanceIpv6AddressList?
    public var kernelId: KernelId?
    public var keyName: KeyPairName?
    public var launchTemplate: LaunchTemplateSpecification?
    public var licenseSpecifications: LicenseSpecificationListRequest?
    public var maintenanceOptions: InstanceMaintenanceOptionsRequest?
    public var maxCount: Integer
    public var metadataOptions: InstanceMetadataOptionsRequest?
    public var minCount: Integer
    public var monitoring: RunInstancesMonitoringEnabled?
    public var networkInterfaces: InstanceNetworkInterfaceSpecificationList?
    public var placement: Placement?
    public var privateDnsNameOptions: PrivateDnsNameOptionsRequest?
    public var privateIpAddress: String?
    public var ramdiskId: RamdiskId?
    public var securityGroupIds: SecurityGroupIdStringList?
    public var securityGroups: SecurityGroupStringList?
    public var subnetId: SubnetId?
    public var tagSpecifications: TagSpecificationList?
    public var userData: RunInstancesUserData?

    public init(additionalInfo: String? = nil,
                blockDeviceMappings: BlockDeviceMappingRequestList? = nil,
                capacityReservationSpecification: CapacityReservationSpecification? = nil,
                clientToken: String? = nil,
                cpuOptions: CpuOptionsRequest? = nil,
                creditSpecification: CreditSpecificationRequest? = nil,
                disableApiStop: Boolean? = nil,
                disableApiTermination: Boolean? = nil,
                dryRun: Boolean? = nil,
                ebsOptimized: Boolean? = nil,
                elasticGpuSpecification: ElasticGpuSpecifications? = nil,
                elasticInferenceAccelerators: ElasticInferenceAccelerators? = nil,
                enclaveOptions: EnclaveOptionsRequest? = nil,
                hibernationOptions: HibernationOptionsRequest? = nil,
                iamInstanceProfile: IamInstanceProfileSpecification? = nil,
                imageId: ImageId? = nil,
                instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil,
                instanceMarketOptions: InstanceMarketOptionsRequest? = nil,
                instanceType: InstanceType? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: InstanceIpv6AddressList? = nil,
                kernelId: KernelId? = nil,
                keyName: KeyPairName? = nil,
                launchTemplate: LaunchTemplateSpecification? = nil,
                licenseSpecifications: LicenseSpecificationListRequest? = nil,
                maintenanceOptions: InstanceMaintenanceOptionsRequest? = nil,
                maxCount: Integer,
                metadataOptions: InstanceMetadataOptionsRequest? = nil,
                minCount: Integer,
                monitoring: RunInstancesMonitoringEnabled? = nil,
                networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil,
                placement: Placement? = nil,
                privateDnsNameOptions: PrivateDnsNameOptionsRequest? = nil,
                privateIpAddress: String? = nil,
                ramdiskId: RamdiskId? = nil,
                securityGroupIds: SecurityGroupIdStringList? = nil,
                securityGroups: SecurityGroupStringList? = nil,
                subnetId: SubnetId? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                userData: RunInstancesUserData? = nil) {
        self.additionalInfo = additionalInfo
        self.blockDeviceMappings = blockDeviceMappings
        self.capacityReservationSpecification = capacityReservationSpecification
        self.clientToken = clientToken
        self.cpuOptions = cpuOptions
        self.creditSpecification = creditSpecification
        self.disableApiStop = disableApiStop
        self.disableApiTermination = disableApiTermination
        self.dryRun = dryRun
        self.ebsOptimized = ebsOptimized
        self.elasticGpuSpecification = elasticGpuSpecification
        self.elasticInferenceAccelerators = elasticInferenceAccelerators
        self.enclaveOptions = enclaveOptions
        self.hibernationOptions = hibernationOptions
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
        self.instanceMarketOptions = instanceMarketOptions
        self.instanceType = instanceType
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.kernelId = kernelId
        self.keyName = keyName
        self.launchTemplate = launchTemplate
        self.licenseSpecifications = licenseSpecifications
        self.maintenanceOptions = maintenanceOptions
        self.maxCount = maxCount
        self.metadataOptions = metadataOptions
        self.minCount = minCount
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.privateDnsNameOptions = privateDnsNameOptions
        self.privateIpAddress = privateIpAddress
        self.ramdiskId = ramdiskId
        self.securityGroupIds = securityGroupIds
        self.securityGroups = securityGroups
        self.subnetId = subnetId
        self.tagSpecifications = tagSpecifications
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case additionalInfo
        case blockDeviceMappings = "BlockDeviceMapping"
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case clientToken
        case cpuOptions = "CpuOptions"
        case creditSpecification = "CreditSpecification"
        case disableApiStop = "DisableApiStop"
        case disableApiTermination
        case dryRun
        case ebsOptimized
        case elasticGpuSpecification = "ElasticGpuSpecification"
        case elasticInferenceAccelerators = "ElasticInferenceAccelerator"
        case enclaveOptions = "EnclaveOptions"
        case hibernationOptions = "HibernationOptions"
        case iamInstanceProfile
        case imageId = "ImageId"
        case instanceInitiatedShutdownBehavior
        case instanceMarketOptions = "InstanceMarketOptions"
        case instanceType = "InstanceType"
        case ipv6AddressCount = "Ipv6AddressCount"
        case ipv6Addresses = "Ipv6Address"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case launchTemplate = "LaunchTemplate"
        case licenseSpecifications = "LicenseSpecification"
        case maintenanceOptions = "MaintenanceOptions"
        case maxCount = "MaxCount"
        case metadataOptions = "MetadataOptions"
        case minCount = "MinCount"
        case monitoring = "Monitoring"
        case networkInterfaces = "networkInterface"
        case placement = "Placement"
        case privateDnsNameOptions = "PrivateDnsNameOptions"
        case privateIpAddress
        case ramdiskId = "RamdiskId"
        case securityGroupIds = "SecurityGroupId"
        case securityGroups = "SecurityGroup"
        case subnetId = "SubnetId"
        case tagSpecifications = "TagSpecification"
        case userData = "UserData"
    }

    public func validate() throws {
        try capacityReservationSpecification?.validate()
        try cpuOptions?.validate()
        try creditSpecification?.validate()
        try enclaveOptions?.validate()
        try hibernationOptions?.validate()
        try iamInstanceProfile?.validate()
        try instanceMarketOptions?.validate()
        try launchTemplate?.validate()
        try maintenanceOptions?.validate()
        try metadataOptions?.validate()
        try monitoring?.validate()
        try placement?.validate()
        try privateDnsNameOptions?.validate()
    }
}

public struct RunScheduledInstancesRequest: Codable, Equatable {
    public var clientToken: String?
    public var dryRun: Boolean?
    public var instanceCount: Integer?
    public var launchSpecification: ScheduledInstancesLaunchSpecification
    public var scheduledInstanceId: ScheduledInstanceId

    public init(clientToken: String? = nil,
                dryRun: Boolean? = nil,
                instanceCount: Integer? = nil,
                launchSpecification: ScheduledInstancesLaunchSpecification,
                scheduledInstanceId: ScheduledInstanceId) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.instanceCount = instanceCount
        self.launchSpecification = launchSpecification
        self.scheduledInstanceId = scheduledInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case instanceCount = "InstanceCount"
        case launchSpecification = "LaunchSpecification"
        case scheduledInstanceId = "ScheduledInstanceId"
    }

    public func validate() throws {
        try launchSpecification.validate()
    }
}

public struct RunScheduledInstancesResult: Codable, Equatable {
    public var instanceIdSet: InstanceIdSet?

    public init(instanceIdSet: InstanceIdSet? = nil) {
        self.instanceIdSet = instanceIdSet
    }

    enum CodingKeys: String, CodingKey {
        case instanceIdSet
    }

    public func validate() throws {
    }
}

public struct S3ObjectTag: Codable, Equatable {
    public var key: String?
    public var value: String?

    public init(key: String? = nil,
                value: String? = nil) {
        self.key = key
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func validate() throws {
    }
}

public struct S3Storage: Codable, Equatable {
    public var aWSAccessKeyId: String?
    public var bucket: String?
    public var prefix: String?
    public var uploadPolicy: Blob?
    public var uploadPolicySignature: String?

    public init(aWSAccessKeyId: String? = nil,
                bucket: String? = nil,
                prefix: String? = nil,
                uploadPolicy: Blob? = nil,
                uploadPolicySignature: String? = nil) {
        self.aWSAccessKeyId = aWSAccessKeyId
        self.bucket = bucket
        self.prefix = prefix
        self.uploadPolicy = uploadPolicy
        self.uploadPolicySignature = uploadPolicySignature
    }

    enum CodingKeys: String, CodingKey {
        case aWSAccessKeyId = "AWSAccessKeyId"
        case bucket
        case prefix
        case uploadPolicy
        case uploadPolicySignature
    }

    public func validate() throws {
    }
}

public struct ScheduledInstance: Codable, Equatable {
    public var availabilityZone: String?
    public var createDate: DateTime?
    public var hourlyPrice: String?
    public var instanceCount: Integer?
    public var instanceType: String?
    public var networkPlatform: String?
    public var nextSlotStartTime: DateTime?
    public var platform: String?
    public var previousSlotEndTime: DateTime?
    public var recurrence: ScheduledInstanceRecurrence?
    public var scheduledInstanceId: String?
    public var slotDurationInHours: Integer?
    public var termEndDate: DateTime?
    public var termStartDate: DateTime?
    public var totalScheduledInstanceHours: Integer?

    public init(availabilityZone: String? = nil,
                createDate: DateTime? = nil,
                hourlyPrice: String? = nil,
                instanceCount: Integer? = nil,
                instanceType: String? = nil,
                networkPlatform: String? = nil,
                nextSlotStartTime: DateTime? = nil,
                platform: String? = nil,
                previousSlotEndTime: DateTime? = nil,
                recurrence: ScheduledInstanceRecurrence? = nil,
                scheduledInstanceId: String? = nil,
                slotDurationInHours: Integer? = nil,
                termEndDate: DateTime? = nil,
                termStartDate: DateTime? = nil,
                totalScheduledInstanceHours: Integer? = nil) {
        self.availabilityZone = availabilityZone
        self.createDate = createDate
        self.hourlyPrice = hourlyPrice
        self.instanceCount = instanceCount
        self.instanceType = instanceType
        self.networkPlatform = networkPlatform
        self.nextSlotStartTime = nextSlotStartTime
        self.platform = platform
        self.previousSlotEndTime = previousSlotEndTime
        self.recurrence = recurrence
        self.scheduledInstanceId = scheduledInstanceId
        self.slotDurationInHours = slotDurationInHours
        self.termEndDate = termEndDate
        self.termStartDate = termStartDate
        self.totalScheduledInstanceHours = totalScheduledInstanceHours
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case createDate
        case hourlyPrice
        case instanceCount
        case instanceType
        case networkPlatform
        case nextSlotStartTime
        case platform
        case previousSlotEndTime
        case recurrence
        case scheduledInstanceId
        case slotDurationInHours
        case termEndDate
        case termStartDate
        case totalScheduledInstanceHours
    }

    public func validate() throws {
        try recurrence?.validate()
    }
}

public struct ScheduledInstanceAvailability: Codable, Equatable {
    public var availabilityZone: String?
    public var availableInstanceCount: Integer?
    public var firstSlotStartTime: DateTime?
    public var hourlyPrice: String?
    public var instanceType: String?
    public var maxTermDurationInDays: Integer?
    public var minTermDurationInDays: Integer?
    public var networkPlatform: String?
    public var platform: String?
    public var purchaseToken: String?
    public var recurrence: ScheduledInstanceRecurrence?
    public var slotDurationInHours: Integer?
    public var totalScheduledInstanceHours: Integer?

    public init(availabilityZone: String? = nil,
                availableInstanceCount: Integer? = nil,
                firstSlotStartTime: DateTime? = nil,
                hourlyPrice: String? = nil,
                instanceType: String? = nil,
                maxTermDurationInDays: Integer? = nil,
                minTermDurationInDays: Integer? = nil,
                networkPlatform: String? = nil,
                platform: String? = nil,
                purchaseToken: String? = nil,
                recurrence: ScheduledInstanceRecurrence? = nil,
                slotDurationInHours: Integer? = nil,
                totalScheduledInstanceHours: Integer? = nil) {
        self.availabilityZone = availabilityZone
        self.availableInstanceCount = availableInstanceCount
        self.firstSlotStartTime = firstSlotStartTime
        self.hourlyPrice = hourlyPrice
        self.instanceType = instanceType
        self.maxTermDurationInDays = maxTermDurationInDays
        self.minTermDurationInDays = minTermDurationInDays
        self.networkPlatform = networkPlatform
        self.platform = platform
        self.purchaseToken = purchaseToken
        self.recurrence = recurrence
        self.slotDurationInHours = slotDurationInHours
        self.totalScheduledInstanceHours = totalScheduledInstanceHours
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case availableInstanceCount
        case firstSlotStartTime
        case hourlyPrice
        case instanceType
        case maxTermDurationInDays
        case minTermDurationInDays
        case networkPlatform
        case platform
        case purchaseToken
        case recurrence
        case slotDurationInHours
        case totalScheduledInstanceHours
    }

    public func validate() throws {
        try recurrence?.validate()
    }
}

public struct ScheduledInstanceRecurrence: Codable, Equatable {
    public var frequency: String?
    public var interval: Integer?
    public var occurrenceDaySet: OccurrenceDaySet?
    public var occurrenceRelativeToEnd: Boolean?
    public var occurrenceUnit: String?

    public init(frequency: String? = nil,
                interval: Integer? = nil,
                occurrenceDaySet: OccurrenceDaySet? = nil,
                occurrenceRelativeToEnd: Boolean? = nil,
                occurrenceUnit: String? = nil) {
        self.frequency = frequency
        self.interval = interval
        self.occurrenceDaySet = occurrenceDaySet
        self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
        self.occurrenceUnit = occurrenceUnit
    }

    enum CodingKeys: String, CodingKey {
        case frequency
        case interval
        case occurrenceDaySet
        case occurrenceRelativeToEnd
        case occurrenceUnit
    }

    public func validate() throws {
    }
}

public struct ScheduledInstanceRecurrenceRequest: Codable, Equatable {
    public var frequency: String?
    public var interval: Integer?
    public var occurrenceDays: OccurrenceDayRequestSet?
    public var occurrenceRelativeToEnd: Boolean?
    public var occurrenceUnit: String?

    public init(frequency: String? = nil,
                interval: Integer? = nil,
                occurrenceDays: OccurrenceDayRequestSet? = nil,
                occurrenceRelativeToEnd: Boolean? = nil,
                occurrenceUnit: String? = nil) {
        self.frequency = frequency
        self.interval = interval
        self.occurrenceDays = occurrenceDays
        self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
        self.occurrenceUnit = occurrenceUnit
    }

    enum CodingKeys: String, CodingKey {
        case frequency = "Frequency"
        case interval = "Interval"
        case occurrenceDays = "OccurrenceDay"
        case occurrenceRelativeToEnd = "OccurrenceRelativeToEnd"
        case occurrenceUnit = "OccurrenceUnit"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesBlockDeviceMapping: Codable, Equatable {
    public var deviceName: String?
    public var ebs: ScheduledInstancesEbs?
    public var noDevice: String?
    public var virtualName: String?

    public init(deviceName: String? = nil,
                ebs: ScheduledInstancesEbs? = nil,
                noDevice: String? = nil,
                virtualName: String? = nil) {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }

    enum CodingKeys: String, CodingKey {
        case deviceName = "DeviceName"
        case ebs = "Ebs"
        case noDevice = "NoDevice"
        case virtualName = "VirtualName"
    }

    public func validate() throws {
        try ebs?.validate()
    }
}

public struct ScheduledInstancesEbs: Codable, Equatable {
    public var deleteOnTermination: Boolean?
    public var encrypted: Boolean?
    public var iops: Integer?
    public var snapshotId: SnapshotId?
    public var volumeSize: Integer?
    public var volumeType: String?

    public init(deleteOnTermination: Boolean? = nil,
                encrypted: Boolean? = nil,
                iops: Integer? = nil,
                snapshotId: SnapshotId? = nil,
                volumeSize: Integer? = nil,
                volumeType: String? = nil) {
        self.deleteOnTermination = deleteOnTermination
        self.encrypted = encrypted
        self.iops = iops
        self.snapshotId = snapshotId
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case deleteOnTermination = "DeleteOnTermination"
        case encrypted = "Encrypted"
        case iops = "Iops"
        case snapshotId = "SnapshotId"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesIamInstanceProfile: Codable, Equatable {
    public var arn: String?
    public var name: String?

    public init(arn: String? = nil,
                name: String? = nil) {
        self.arn = arn
        self.name = name
    }

    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesIpv6Address: Codable, Equatable {
    public var ipv6Address: Ipv6Address?

    public init(ipv6Address: Ipv6Address? = nil) {
        self.ipv6Address = ipv6Address
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Address = "Ipv6Address"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesLaunchSpecification: Codable, Equatable {
    public var blockDeviceMappings: ScheduledInstancesBlockDeviceMappingSet?
    public var ebsOptimized: Boolean?
    public var iamInstanceProfile: ScheduledInstancesIamInstanceProfile?
    public var imageId: ImageId
    public var instanceType: String?
    public var kernelId: KernelId?
    public var keyName: KeyPairName?
    public var monitoring: ScheduledInstancesMonitoring?
    public var networkInterfaces: ScheduledInstancesNetworkInterfaceSet?
    public var placement: ScheduledInstancesPlacement?
    public var ramdiskId: RamdiskId?
    public var securityGroupIds: ScheduledInstancesSecurityGroupIdSet?
    public var subnetId: SubnetId?
    public var userData: String?

    public init(blockDeviceMappings: ScheduledInstancesBlockDeviceMappingSet? = nil,
                ebsOptimized: Boolean? = nil,
                iamInstanceProfile: ScheduledInstancesIamInstanceProfile? = nil,
                imageId: ImageId,
                instanceType: String? = nil,
                kernelId: KernelId? = nil,
                keyName: KeyPairName? = nil,
                monitoring: ScheduledInstancesMonitoring? = nil,
                networkInterfaces: ScheduledInstancesNetworkInterfaceSet? = nil,
                placement: ScheduledInstancesPlacement? = nil,
                ramdiskId: RamdiskId? = nil,
                securityGroupIds: ScheduledInstancesSecurityGroupIdSet? = nil,
                subnetId: SubnetId? = nil,
                userData: String? = nil) {
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramdiskId = ramdiskId
        self.securityGroupIds = securityGroupIds
        self.subnetId = subnetId
        self.userData = userData
    }

    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings = "BlockDeviceMapping"
        case ebsOptimized = "EbsOptimized"
        case iamInstanceProfile = "IamInstanceProfile"
        case imageId = "ImageId"
        case instanceType = "InstanceType"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case monitoring = "Monitoring"
        case networkInterfaces = "NetworkInterface"
        case placement = "Placement"
        case ramdiskId = "RamdiskId"
        case securityGroupIds = "SecurityGroupId"
        case subnetId = "SubnetId"
        case userData = "UserData"
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct ScheduledInstancesMonitoring: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesNetworkInterface: Codable, Equatable {
    public var associatePublicIpAddress: Boolean?
    public var deleteOnTermination: Boolean?
    public var description: String?
    public var deviceIndex: Integer?
    public var groups: ScheduledInstancesSecurityGroupIdSet?
    public var ipv6AddressCount: Integer?
    public var ipv6Addresses: ScheduledInstancesIpv6AddressList?
    public var networkInterfaceId: NetworkInterfaceId?
    public var privateIpAddress: String?
    public var privateIpAddressConfigs: PrivateIpAddressConfigSet?
    public var secondaryPrivateIpAddressCount: Integer?
    public var subnetId: SubnetId?

    public init(associatePublicIpAddress: Boolean? = nil,
                deleteOnTermination: Boolean? = nil,
                description: String? = nil,
                deviceIndex: Integer? = nil,
                groups: ScheduledInstancesSecurityGroupIdSet? = nil,
                ipv6AddressCount: Integer? = nil,
                ipv6Addresses: ScheduledInstancesIpv6AddressList? = nil,
                networkInterfaceId: NetworkInterfaceId? = nil,
                privateIpAddress: String? = nil,
                privateIpAddressConfigs: PrivateIpAddressConfigSet? = nil,
                secondaryPrivateIpAddressCount: Integer? = nil,
                subnetId: SubnetId? = nil) {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.deleteOnTermination = deleteOnTermination
        self.description = description
        self.deviceIndex = deviceIndex
        self.groups = groups
        self.ipv6AddressCount = ipv6AddressCount
        self.ipv6Addresses = ipv6Addresses
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddress = privateIpAddress
        self.privateIpAddressConfigs = privateIpAddressConfigs
        self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case deleteOnTermination = "DeleteOnTermination"
        case description = "Description"
        case deviceIndex = "DeviceIndex"
        case groups = "Group"
        case ipv6AddressCount = "Ipv6AddressCount"
        case ipv6Addresses = "Ipv6Address"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddress = "PrivateIpAddress"
        case privateIpAddressConfigs = "PrivateIpAddressConfig"
        case secondaryPrivateIpAddressCount = "SecondaryPrivateIpAddressCount"
        case subnetId = "SubnetId"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesPlacement: Codable, Equatable {
    public var availabilityZone: String?
    public var groupName: PlacementGroupName?

    public init(availabilityZone: String? = nil,
                groupName: PlacementGroupName? = nil) {
        self.availabilityZone = availabilityZone
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case groupName = "GroupName"
    }

    public func validate() throws {
    }
}

public struct ScheduledInstancesPrivateIpAddressConfig: Codable, Equatable {
    public var primary: Boolean?
    public var privateIpAddress: String?

    public init(primary: Boolean? = nil,
                privateIpAddress: String? = nil) {
        self.primary = primary
        self.privateIpAddress = privateIpAddress
    }

    enum CodingKeys: String, CodingKey {
        case primary = "Primary"
        case privateIpAddress = "PrivateIpAddress"
    }

    public func validate() throws {
    }
}

public struct SearchLocalGatewayRoutesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var localGatewayRouteTableId: LocalGatewayRoutetableId
    public var maxResults: MaxResults?
    public var nextToken: String?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                localGatewayRouteTableId: LocalGatewayRoutetableId,
                maxResults: MaxResults? = nil,
                nextToken: String? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.localGatewayRouteTableId = localGatewayRouteTableId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case localGatewayRouteTableId = "LocalGatewayRouteTableId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func validate() throws {
    }
}

public struct SearchLocalGatewayRoutesResult: Codable, Equatable {
    public var nextToken: String?
    public var routes: LocalGatewayRouteList?

    public init(nextToken: String? = nil,
                routes: LocalGatewayRouteList? = nil) {
        self.nextToken = nextToken
        self.routes = routes
    }

    enum CodingKeys: String, CodingKey {
        case nextToken
        case routes = "routeSet"
    }

    public func validate() throws {
    }
}

public struct SearchTransitGatewayMulticastGroupsRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList?
    public var maxResults: TransitGatewayMaxResults?
    public var nextToken: String?
    public var transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId?

    public init(dryRun: Boolean? = nil,
                filters: FilterList? = nil,
                maxResults: TransitGatewayMaxResults? = nil,
                nextToken: String? = nil,
                transitGatewayMulticastDomainId: TransitGatewayMulticastDomainId? = nil) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case transitGatewayMulticastDomainId = "TransitGatewayMulticastDomainId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct SearchTransitGatewayMulticastGroupsResult: Codable, Equatable {
    public var multicastGroups: TransitGatewayMulticastGroupList?
    public var nextToken: String?

    public init(multicastGroups: TransitGatewayMulticastGroupList? = nil,
                nextToken: String? = nil) {
        self.multicastGroups = multicastGroups
        self.nextToken = nextToken
    }

    enum CodingKeys: String, CodingKey {
        case multicastGroups
        case nextToken
    }

    public func validate() throws {
    }
}

public struct SearchTransitGatewayRoutesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var filters: FilterList
    public var maxResults: TransitGatewayMaxResults?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId

    public init(dryRun: Boolean? = nil,
                filters: FilterList,
                maxResults: TransitGatewayMaxResults? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId) {
        self.dryRun = dryRun
        self.filters = filters
        self.maxResults = maxResults
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case filters = "Filter"
        case maxResults = "MaxResults"
        case transitGatewayRouteTableId = "TransitGatewayRouteTableId"
    }

    public func validate() throws {
        try maxResults?.validateAsTransitGatewayMaxResults()
    }
}

public struct SearchTransitGatewayRoutesResult: Codable, Equatable {
    public var additionalRoutesAvailable: Boolean?
    public var routes: TransitGatewayRouteList?

    public init(additionalRoutesAvailable: Boolean? = nil,
                routes: TransitGatewayRouteList? = nil) {
        self.additionalRoutesAvailable = additionalRoutesAvailable
        self.routes = routes
    }

    enum CodingKeys: String, CodingKey {
        case additionalRoutesAvailable
        case routes = "routeSet"
    }

    public func validate() throws {
    }
}

public struct SecurityGroup: Codable, Equatable {
    public var description: String?
    public var groupId: String?
    public var groupName: String?
    public var ipPermissions: IpPermissionList?
    public var ipPermissionsEgress: IpPermissionList?
    public var ownerId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(description: String? = nil,
                groupId: String? = nil,
                groupName: String? = nil,
                ipPermissions: IpPermissionList? = nil,
                ipPermissionsEgress: IpPermissionList? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.description = description
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
        self.ipPermissionsEgress = ipPermissionsEgress
        self.ownerId = ownerId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case description = "groupDescription"
        case groupId
        case groupName
        case ipPermissions
        case ipPermissionsEgress
        case ownerId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct SecurityGroupIdentifier: Codable, Equatable {
    public var groupId: String?
    public var groupName: String?

    public init(groupId: String? = nil,
                groupName: String? = nil) {
        self.groupId = groupId
        self.groupName = groupName
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case groupName
    }

    public func validate() throws {
    }
}

public struct SecurityGroupReference: Codable, Equatable {
    public var groupId: String?
    public var referencingVpcId: String?
    public var vpcPeeringConnectionId: String?

    public init(groupId: String? = nil,
                referencingVpcId: String? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.groupId = groupId
        self.referencingVpcId = referencingVpcId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case groupId
        case referencingVpcId
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct SecurityGroupRule: Codable, Equatable {
    public var cidrIpv4: String?
    public var cidrIpv6: String?
    public var description: String?
    public var fromPort: Integer?
    public var groupId: SecurityGroupId?
    public var groupOwnerId: String?
    public var ipProtocol: String?
    public var isEgress: Boolean?
    public var prefixListId: PrefixListResourceId?
    public var referencedGroupInfo: ReferencedSecurityGroup?
    public var securityGroupRuleId: SecurityGroupRuleId?
    public var tags: TagList?
    public var toPort: Integer?

    public init(cidrIpv4: String? = nil,
                cidrIpv6: String? = nil,
                description: String? = nil,
                fromPort: Integer? = nil,
                groupId: SecurityGroupId? = nil,
                groupOwnerId: String? = nil,
                ipProtocol: String? = nil,
                isEgress: Boolean? = nil,
                prefixListId: PrefixListResourceId? = nil,
                referencedGroupInfo: ReferencedSecurityGroup? = nil,
                securityGroupRuleId: SecurityGroupRuleId? = nil,
                tags: TagList? = nil,
                toPort: Integer? = nil) {
        self.cidrIpv4 = cidrIpv4
        self.cidrIpv6 = cidrIpv6
        self.description = description
        self.fromPort = fromPort
        self.groupId = groupId
        self.groupOwnerId = groupOwnerId
        self.ipProtocol = ipProtocol
        self.isEgress = isEgress
        self.prefixListId = prefixListId
        self.referencedGroupInfo = referencedGroupInfo
        self.securityGroupRuleId = securityGroupRuleId
        self.tags = tags
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIpv4
        case cidrIpv6
        case description
        case fromPort
        case groupId
        case groupOwnerId
        case ipProtocol
        case isEgress
        case prefixListId
        case referencedGroupInfo
        case securityGroupRuleId
        case tags = "tagSet"
        case toPort
    }

    public func validate() throws {
        try referencedGroupInfo?.validate()
    }
}

public struct SecurityGroupRuleDescription: Codable, Equatable {
    public var description: String?
    public var securityGroupRuleId: String?

    public init(description: String? = nil,
                securityGroupRuleId: String? = nil) {
        self.description = description
        self.securityGroupRuleId = securityGroupRuleId
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case securityGroupRuleId = "SecurityGroupRuleId"
    }

    public func validate() throws {
    }
}

public struct SecurityGroupRuleRequest: Codable, Equatable {
    public var cidrIpv4: String?
    public var cidrIpv6: String?
    public var description: String?
    public var fromPort: Integer?
    public var ipProtocol: String?
    public var prefixListId: PrefixListResourceId?
    public var referencedGroupId: SecurityGroupId?
    public var toPort: Integer?

    public init(cidrIpv4: String? = nil,
                cidrIpv6: String? = nil,
                description: String? = nil,
                fromPort: Integer? = nil,
                ipProtocol: String? = nil,
                prefixListId: PrefixListResourceId? = nil,
                referencedGroupId: SecurityGroupId? = nil,
                toPort: Integer? = nil) {
        self.cidrIpv4 = cidrIpv4
        self.cidrIpv6 = cidrIpv6
        self.description = description
        self.fromPort = fromPort
        self.ipProtocol = ipProtocol
        self.prefixListId = prefixListId
        self.referencedGroupId = referencedGroupId
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case cidrIpv4 = "CidrIpv4"
        case cidrIpv6 = "CidrIpv6"
        case description = "Description"
        case fromPort = "FromPort"
        case ipProtocol = "IpProtocol"
        case prefixListId = "PrefixListId"
        case referencedGroupId = "ReferencedGroupId"
        case toPort = "ToPort"
    }

    public func validate() throws {
    }
}

public struct SecurityGroupRuleUpdate: Codable, Equatable {
    public var securityGroupRule: SecurityGroupRuleRequest?
    public var securityGroupRuleId: SecurityGroupRuleId?

    public init(securityGroupRule: SecurityGroupRuleRequest? = nil,
                securityGroupRuleId: SecurityGroupRuleId? = nil) {
        self.securityGroupRule = securityGroupRule
        self.securityGroupRuleId = securityGroupRuleId
    }

    enum CodingKeys: String, CodingKey {
        case securityGroupRule = "SecurityGroupRule"
        case securityGroupRuleId = "SecurityGroupRuleId"
    }

    public func validate() throws {
        try securityGroupRule?.validate()
    }
}

public struct SendDiagnosticInterruptRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceId: InstanceId

    public init(dryRun: Boolean? = nil,
                instanceId: InstanceId) {
        self.dryRun = dryRun
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case instanceId = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct ServiceConfiguration: Codable, Equatable {
    public var acceptanceRequired: Boolean?
    public var availabilityZones: ValueStringList?
    public var baseEndpointDnsNames: ValueStringList?
    public var gatewayLoadBalancerArns: ValueStringList?
    public var managesVpcEndpoints: Boolean?
    public var networkLoadBalancerArns: ValueStringList?
    public var payerResponsibility: PayerResponsibility?
    public var privateDnsName: String?
    public var privateDnsNameConfiguration: PrivateDnsNameConfiguration?
    public var serviceId: String?
    public var serviceName: String?
    public var serviceState: ServiceState?
    public var serviceType: ServiceTypeDetailSet?
    public var supportedIpAddressTypes: SupportedIpAddressTypes?
    public var tags: TagList?

    public init(acceptanceRequired: Boolean? = nil,
                availabilityZones: ValueStringList? = nil,
                baseEndpointDnsNames: ValueStringList? = nil,
                gatewayLoadBalancerArns: ValueStringList? = nil,
                managesVpcEndpoints: Boolean? = nil,
                networkLoadBalancerArns: ValueStringList? = nil,
                payerResponsibility: PayerResponsibility? = nil,
                privateDnsName: String? = nil,
                privateDnsNameConfiguration: PrivateDnsNameConfiguration? = nil,
                serviceId: String? = nil,
                serviceName: String? = nil,
                serviceState: ServiceState? = nil,
                serviceType: ServiceTypeDetailSet? = nil,
                supportedIpAddressTypes: SupportedIpAddressTypes? = nil,
                tags: TagList? = nil) {
        self.acceptanceRequired = acceptanceRequired
        self.availabilityZones = availabilityZones
        self.baseEndpointDnsNames = baseEndpointDnsNames
        self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
        self.managesVpcEndpoints = managesVpcEndpoints
        self.networkLoadBalancerArns = networkLoadBalancerArns
        self.payerResponsibility = payerResponsibility
        self.privateDnsName = privateDnsName
        self.privateDnsNameConfiguration = privateDnsNameConfiguration
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceState = serviceState
        self.serviceType = serviceType
        self.supportedIpAddressTypes = supportedIpAddressTypes
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case acceptanceRequired
        case availabilityZones = "availabilityZoneSet"
        case baseEndpointDnsNames = "baseEndpointDnsNameSet"
        case gatewayLoadBalancerArns = "gatewayLoadBalancerArnSet"
        case managesVpcEndpoints
        case networkLoadBalancerArns = "networkLoadBalancerArnSet"
        case payerResponsibility
        case privateDnsName
        case privateDnsNameConfiguration
        case serviceId
        case serviceName
        case serviceState
        case serviceType
        case supportedIpAddressTypes = "supportedIpAddressTypeSet"
        case tags = "tagSet"
    }

    public func validate() throws {
        try privateDnsNameConfiguration?.validate()
        try supportedIpAddressTypes?.validateAsSupportedIpAddressTypes()
    }
}

public struct ServiceDetail: Codable, Equatable {
    public var acceptanceRequired: Boolean?
    public var availabilityZones: ValueStringList?
    public var baseEndpointDnsNames: ValueStringList?
    public var managesVpcEndpoints: Boolean?
    public var owner: String?
    public var payerResponsibility: PayerResponsibility?
    public var privateDnsName: String?
    public var privateDnsNameVerificationState: DnsNameState?
    public var privateDnsNames: PrivateDnsDetailsSet?
    public var serviceId: String?
    public var serviceName: String?
    public var serviceType: ServiceTypeDetailSet?
    public var supportedIpAddressTypes: SupportedIpAddressTypes?
    public var tags: TagList?
    public var vpcEndpointPolicySupported: Boolean?

    public init(acceptanceRequired: Boolean? = nil,
                availabilityZones: ValueStringList? = nil,
                baseEndpointDnsNames: ValueStringList? = nil,
                managesVpcEndpoints: Boolean? = nil,
                owner: String? = nil,
                payerResponsibility: PayerResponsibility? = nil,
                privateDnsName: String? = nil,
                privateDnsNameVerificationState: DnsNameState? = nil,
                privateDnsNames: PrivateDnsDetailsSet? = nil,
                serviceId: String? = nil,
                serviceName: String? = nil,
                serviceType: ServiceTypeDetailSet? = nil,
                supportedIpAddressTypes: SupportedIpAddressTypes? = nil,
                tags: TagList? = nil,
                vpcEndpointPolicySupported: Boolean? = nil) {
        self.acceptanceRequired = acceptanceRequired
        self.availabilityZones = availabilityZones
        self.baseEndpointDnsNames = baseEndpointDnsNames
        self.managesVpcEndpoints = managesVpcEndpoints
        self.owner = owner
        self.payerResponsibility = payerResponsibility
        self.privateDnsName = privateDnsName
        self.privateDnsNameVerificationState = privateDnsNameVerificationState
        self.privateDnsNames = privateDnsNames
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceType = serviceType
        self.supportedIpAddressTypes = supportedIpAddressTypes
        self.tags = tags
        self.vpcEndpointPolicySupported = vpcEndpointPolicySupported
    }

    enum CodingKeys: String, CodingKey {
        case acceptanceRequired
        case availabilityZones = "availabilityZoneSet"
        case baseEndpointDnsNames = "baseEndpointDnsNameSet"
        case managesVpcEndpoints
        case owner
        case payerResponsibility
        case privateDnsName
        case privateDnsNameVerificationState
        case privateDnsNames = "privateDnsNameSet"
        case serviceId
        case serviceName
        case serviceType
        case supportedIpAddressTypes = "supportedIpAddressTypeSet"
        case tags = "tagSet"
        case vpcEndpointPolicySupported
    }

    public func validate() throws {
        try supportedIpAddressTypes?.validateAsSupportedIpAddressTypes()
    }
}

public struct ServiceTypeDetail: Codable, Equatable {
    public var serviceType: ServiceType?

    public init(serviceType: ServiceType? = nil) {
        self.serviceType = serviceType
    }

    enum CodingKeys: String, CodingKey {
        case serviceType
    }

    public func validate() throws {
    }
}

public struct SlotDateTimeRangeRequest: Codable, Equatable {
    public var earliestTime: DateTime
    public var latestTime: DateTime

    public init(earliestTime: DateTime,
                latestTime: DateTime) {
        self.earliestTime = earliestTime
        self.latestTime = latestTime
    }

    enum CodingKeys: String, CodingKey {
        case earliestTime = "EarliestTime"
        case latestTime = "LatestTime"
    }

    public func validate() throws {
    }
}

public struct SlotStartTimeRangeRequest: Codable, Equatable {
    public var earliestTime: DateTime?
    public var latestTime: DateTime?

    public init(earliestTime: DateTime? = nil,
                latestTime: DateTime? = nil) {
        self.earliestTime = earliestTime
        self.latestTime = latestTime
    }

    enum CodingKeys: String, CodingKey {
        case earliestTime = "EarliestTime"
        case latestTime = "LatestTime"
    }

    public func validate() throws {
    }
}

public struct Snapshot: Codable, Equatable {
    public var dataEncryptionKeyId: String?
    public var description: String?
    public var encrypted: Boolean?
    public var kmsKeyId: String?
    public var outpostArn: String?
    public var ownerAlias: String?
    public var ownerId: String?
    public var progress: String?
    public var restoreExpiryTime: MillisecondDateTime?
    public var snapshotId: String?
    public var startTime: DateTime?
    public var state: SnapshotState?
    public var stateMessage: String?
    public var storageTier: StorageTier?
    public var tags: TagList?
    public var volumeId: String?
    public var volumeSize: Integer?

    public init(dataEncryptionKeyId: String? = nil,
                description: String? = nil,
                encrypted: Boolean? = nil,
                kmsKeyId: String? = nil,
                outpostArn: String? = nil,
                ownerAlias: String? = nil,
                ownerId: String? = nil,
                progress: String? = nil,
                restoreExpiryTime: MillisecondDateTime? = nil,
                snapshotId: String? = nil,
                startTime: DateTime? = nil,
                state: SnapshotState? = nil,
                stateMessage: String? = nil,
                storageTier: StorageTier? = nil,
                tags: TagList? = nil,
                volumeId: String? = nil,
                volumeSize: Integer? = nil) {
        self.dataEncryptionKeyId = dataEncryptionKeyId
        self.description = description
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.outpostArn = outpostArn
        self.ownerAlias = ownerAlias
        self.ownerId = ownerId
        self.progress = progress
        self.restoreExpiryTime = restoreExpiryTime
        self.snapshotId = snapshotId
        self.startTime = startTime
        self.state = state
        self.stateMessage = stateMessage
        self.storageTier = storageTier
        self.tags = tags
        self.volumeId = volumeId
        self.volumeSize = volumeSize
    }

    enum CodingKeys: String, CodingKey {
        case dataEncryptionKeyId
        case description
        case encrypted
        case kmsKeyId
        case outpostArn
        case ownerAlias
        case ownerId
        case progress
        case restoreExpiryTime
        case snapshotId
        case startTime
        case state = "status"
        case stateMessage = "statusMessage"
        case storageTier
        case tags = "tagSet"
        case volumeId
        case volumeSize
    }

    public func validate() throws {
    }
}

public struct SnapshotDetail: Codable, Equatable {
    public var description: String?
    public var deviceName: String?
    public var diskImageSize: Double?
    public var format: String?
    public var progress: String?
    public var snapshotId: String?
    public var status: String?
    public var statusMessage: String?
    public var url: String?
    public var userBucket: UserBucketDetails?

    public init(description: String? = nil,
                deviceName: String? = nil,
                diskImageSize: Double? = nil,
                format: String? = nil,
                progress: String? = nil,
                snapshotId: String? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                url: String? = nil,
                userBucket: UserBucketDetails? = nil) {
        self.description = description
        self.deviceName = deviceName
        self.diskImageSize = diskImageSize
        self.format = format
        self.progress = progress
        self.snapshotId = snapshotId
        self.status = status
        self.statusMessage = statusMessage
        self.url = url
        self.userBucket = userBucket
    }

    enum CodingKeys: String, CodingKey {
        case description
        case deviceName
        case diskImageSize
        case format
        case progress
        case snapshotId
        case status
        case statusMessage
        case url
        case userBucket
    }

    public func validate() throws {
        try userBucket?.validate()
    }
}

public struct SnapshotDiskContainer: Codable, Equatable {
    public var description: String?
    public var format: String?
    public var url: String?
    public var userBucket: UserBucket?

    public init(description: String? = nil,
                format: String? = nil,
                url: String? = nil,
                userBucket: UserBucket? = nil) {
        self.description = description
        self.format = format
        self.url = url
        self.userBucket = userBucket
    }

    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case format = "Format"
        case url = "Url"
        case userBucket = "UserBucket"
    }

    public func validate() throws {
        try userBucket?.validate()
    }
}

public struct SnapshotInfo: Codable, Equatable {
    public var description: String?
    public var encrypted: Boolean?
    public var outpostArn: String?
    public var ownerId: String?
    public var progress: String?
    public var snapshotId: String?
    public var startTime: MillisecondDateTime?
    public var state: SnapshotState?
    public var tags: TagList?
    public var volumeId: String?
    public var volumeSize: Integer?

    public init(description: String? = nil,
                encrypted: Boolean? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                progress: String? = nil,
                snapshotId: String? = nil,
                startTime: MillisecondDateTime? = nil,
                state: SnapshotState? = nil,
                tags: TagList? = nil,
                volumeId: String? = nil,
                volumeSize: Integer? = nil) {
        self.description = description
        self.encrypted = encrypted
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.progress = progress
        self.snapshotId = snapshotId
        self.startTime = startTime
        self.state = state
        self.tags = tags
        self.volumeId = volumeId
        self.volumeSize = volumeSize
    }

    enum CodingKeys: String, CodingKey {
        case description
        case encrypted
        case outpostArn
        case ownerId
        case progress
        case snapshotId
        case startTime
        case state
        case tags = "tagSet"
        case volumeId
        case volumeSize
    }

    public func validate() throws {
    }
}

public struct SnapshotRecycleBinInfo: Codable, Equatable {
    public var description: String?
    public var recycleBinEnterTime: MillisecondDateTime?
    public var recycleBinExitTime: MillisecondDateTime?
    public var snapshotId: String?
    public var volumeId: String?

    public init(description: String? = nil,
                recycleBinEnterTime: MillisecondDateTime? = nil,
                recycleBinExitTime: MillisecondDateTime? = nil,
                snapshotId: String? = nil,
                volumeId: String? = nil) {
        self.description = description
        self.recycleBinEnterTime = recycleBinEnterTime
        self.recycleBinExitTime = recycleBinExitTime
        self.snapshotId = snapshotId
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case recycleBinEnterTime
        case recycleBinExitTime
        case snapshotId
        case volumeId
    }

    public func validate() throws {
    }
}

public struct SnapshotTaskDetail: Codable, Equatable {
    public var description: String?
    public var diskImageSize: Double?
    public var encrypted: Boolean?
    public var format: String?
    public var kmsKeyId: String?
    public var progress: String?
    public var snapshotId: String?
    public var status: String?
    public var statusMessage: String?
    public var url: String?
    public var userBucket: UserBucketDetails?

    public init(description: String? = nil,
                diskImageSize: Double? = nil,
                encrypted: Boolean? = nil,
                format: String? = nil,
                kmsKeyId: String? = nil,
                progress: String? = nil,
                snapshotId: String? = nil,
                status: String? = nil,
                statusMessage: String? = nil,
                url: String? = nil,
                userBucket: UserBucketDetails? = nil) {
        self.description = description
        self.diskImageSize = diskImageSize
        self.encrypted = encrypted
        self.format = format
        self.kmsKeyId = kmsKeyId
        self.progress = progress
        self.snapshotId = snapshotId
        self.status = status
        self.statusMessage = statusMessage
        self.url = url
        self.userBucket = userBucket
    }

    enum CodingKeys: String, CodingKey {
        case description
        case diskImageSize
        case encrypted
        case format
        case kmsKeyId
        case progress
        case snapshotId
        case status
        case statusMessage
        case url
        case userBucket
    }

    public func validate() throws {
        try userBucket?.validate()
    }
}

public struct SnapshotTierStatus: Codable, Equatable {
    public var archivalCompleteTime: MillisecondDateTime?
    public var lastTieringOperationStatus: TieringOperationStatus?
    public var lastTieringOperationStatusDetail: String?
    public var lastTieringProgress: Integer?
    public var lastTieringStartTime: MillisecondDateTime?
    public var ownerId: String?
    public var restoreExpiryTime: MillisecondDateTime?
    public var snapshotId: SnapshotId?
    public var status: SnapshotState?
    public var storageTier: StorageTier?
    public var tags: TagList?
    public var volumeId: VolumeId?

    public init(archivalCompleteTime: MillisecondDateTime? = nil,
                lastTieringOperationStatus: TieringOperationStatus? = nil,
                lastTieringOperationStatusDetail: String? = nil,
                lastTieringProgress: Integer? = nil,
                lastTieringStartTime: MillisecondDateTime? = nil,
                ownerId: String? = nil,
                restoreExpiryTime: MillisecondDateTime? = nil,
                snapshotId: SnapshotId? = nil,
                status: SnapshotState? = nil,
                storageTier: StorageTier? = nil,
                tags: TagList? = nil,
                volumeId: VolumeId? = nil) {
        self.archivalCompleteTime = archivalCompleteTime
        self.lastTieringOperationStatus = lastTieringOperationStatus
        self.lastTieringOperationStatusDetail = lastTieringOperationStatusDetail
        self.lastTieringProgress = lastTieringProgress
        self.lastTieringStartTime = lastTieringStartTime
        self.ownerId = ownerId
        self.restoreExpiryTime = restoreExpiryTime
        self.snapshotId = snapshotId
        self.status = status
        self.storageTier = storageTier
        self.tags = tags
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case archivalCompleteTime
        case lastTieringOperationStatus
        case lastTieringOperationStatusDetail
        case lastTieringProgress
        case lastTieringStartTime
        case ownerId
        case restoreExpiryTime
        case snapshotId
        case status
        case storageTier
        case tags = "tagSet"
        case volumeId
    }

    public func validate() throws {
    }
}

public struct SpotCapacityRebalance: Codable, Equatable {
    public var replacementStrategy: ReplacementStrategy?
    public var terminationDelay: Integer?

    public init(replacementStrategy: ReplacementStrategy? = nil,
                terminationDelay: Integer? = nil) {
        self.replacementStrategy = replacementStrategy
        self.terminationDelay = terminationDelay
    }

    enum CodingKeys: String, CodingKey {
        case replacementStrategy
        case terminationDelay
    }

    public func validate() throws {
    }
}

public struct SpotDatafeedSubscription: Codable, Equatable {
    public var bucket: String?
    public var fault: SpotInstanceStateFault?
    public var ownerId: String?
    public var prefix: String?
    public var state: DatafeedSubscriptionState?

    public init(bucket: String? = nil,
                fault: SpotInstanceStateFault? = nil,
                ownerId: String? = nil,
                prefix: String? = nil,
                state: DatafeedSubscriptionState? = nil) {
        self.bucket = bucket
        self.fault = fault
        self.ownerId = ownerId
        self.prefix = prefix
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case bucket
        case fault
        case ownerId
        case prefix
        case state
    }

    public func validate() throws {
        try fault?.validate()
    }
}

public struct SpotFleetLaunchSpecification: Codable, Equatable {
    public var addressingType: String?
    public var blockDeviceMappings: BlockDeviceMappingList?
    public var ebsOptimized: Boolean?
    public var iamInstanceProfile: IamInstanceProfileSpecification?
    public var imageId: ImageId?
    public var instanceRequirements: InstanceRequirements?
    public var instanceType: InstanceType?
    public var kernelId: String?
    public var keyName: KeyPairName?
    public var monitoring: SpotFleetMonitoring?
    public var networkInterfaces: InstanceNetworkInterfaceSpecificationList?
    public var placement: SpotPlacement?
    public var ramdiskId: String?
    public var securityGroups: GroupIdentifierList?
    public var spotPrice: String?
    public var subnetId: SubnetId?
    public var tagSpecifications: SpotFleetTagSpecificationList?
    public var userData: String?
    public var weightedCapacity: Double?

    public init(addressingType: String? = nil,
                blockDeviceMappings: BlockDeviceMappingList? = nil,
                ebsOptimized: Boolean? = nil,
                iamInstanceProfile: IamInstanceProfileSpecification? = nil,
                imageId: ImageId? = nil,
                instanceRequirements: InstanceRequirements? = nil,
                instanceType: InstanceType? = nil,
                kernelId: String? = nil,
                keyName: KeyPairName? = nil,
                monitoring: SpotFleetMonitoring? = nil,
                networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil,
                placement: SpotPlacement? = nil,
                ramdiskId: String? = nil,
                securityGroups: GroupIdentifierList? = nil,
                spotPrice: String? = nil,
                subnetId: SubnetId? = nil,
                tagSpecifications: SpotFleetTagSpecificationList? = nil,
                userData: String? = nil,
                weightedCapacity: Double? = nil) {
        self.addressingType = addressingType
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.iamInstanceProfile = iamInstanceProfile
        self.imageId = imageId
        self.instanceRequirements = instanceRequirements
        self.instanceType = instanceType
        self.kernelId = kernelId
        self.keyName = keyName
        self.monitoring = monitoring
        self.networkInterfaces = networkInterfaces
        self.placement = placement
        self.ramdiskId = ramdiskId
        self.securityGroups = securityGroups
        self.spotPrice = spotPrice
        self.subnetId = subnetId
        self.tagSpecifications = tagSpecifications
        self.userData = userData
        self.weightedCapacity = weightedCapacity
    }

    enum CodingKeys: String, CodingKey {
        case addressingType
        case blockDeviceMappings = "blockDeviceMapping"
        case ebsOptimized
        case iamInstanceProfile
        case imageId
        case instanceRequirements
        case instanceType
        case kernelId
        case keyName
        case monitoring
        case networkInterfaces = "networkInterfaceSet"
        case placement
        case ramdiskId
        case securityGroups = "groupSet"
        case spotPrice
        case subnetId
        case tagSpecifications = "tagSpecificationSet"
        case userData
        case weightedCapacity
    }

    public func validate() throws {
        try iamInstanceProfile?.validate()
        try instanceRequirements?.validate()
        try monitoring?.validate()
        try placement?.validate()
    }
}

public struct SpotFleetMonitoring: Codable, Equatable {
    public var enabled: Boolean?

    public init(enabled: Boolean? = nil) {
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case enabled
    }

    public func validate() throws {
    }
}

public struct SpotFleetRequestConfig: Codable, Equatable {
    public var activityStatus: ActivityStatus?
    public var createTime: MillisecondDateTime?
    public var spotFleetRequestConfig: SpotFleetRequestConfigData?
    public var spotFleetRequestId: String?
    public var spotFleetRequestState: BatchState?
    public var tags: TagList?

    public init(activityStatus: ActivityStatus? = nil,
                createTime: MillisecondDateTime? = nil,
                spotFleetRequestConfig: SpotFleetRequestConfigData? = nil,
                spotFleetRequestId: String? = nil,
                spotFleetRequestState: BatchState? = nil,
                tags: TagList? = nil) {
        self.activityStatus = activityStatus
        self.createTime = createTime
        self.spotFleetRequestConfig = spotFleetRequestConfig
        self.spotFleetRequestId = spotFleetRequestId
        self.spotFleetRequestState = spotFleetRequestState
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case activityStatus
        case createTime
        case spotFleetRequestConfig
        case spotFleetRequestId
        case spotFleetRequestState
        case tags = "tagSet"
    }

    public func validate() throws {
        try spotFleetRequestConfig?.validate()
    }
}

public struct SpotFleetRequestConfigData: Codable, Equatable {
    public var allocationStrategy: AllocationStrategy?
    public var clientToken: String?
    public var context: String?
    public var excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy?
    public var fulfilledCapacity: Double?
    public var iamFleetRole: String
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var instancePoolsToUseCount: Integer?
    public var launchSpecifications: LaunchSpecsList?
    public var launchTemplateConfigs: LaunchTemplateConfigList?
    public var loadBalancersConfig: LoadBalancersConfig?
    public var onDemandAllocationStrategy: OnDemandAllocationStrategy?
    public var onDemandFulfilledCapacity: Double?
    public var onDemandMaxTotalPrice: String?
    public var onDemandTargetCapacity: Integer?
    public var replaceUnhealthyInstances: Boolean?
    public var spotMaintenanceStrategies: SpotMaintenanceStrategies?
    public var spotMaxTotalPrice: String?
    public var spotPrice: String?
    public var tagSpecifications: TagSpecificationList?
    public var targetCapacity: Integer
    public var targetCapacityUnitType: TargetCapacityUnitType?
    public var terminateInstancesWithExpiration: Boolean?
    public var type: FleetType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(allocationStrategy: AllocationStrategy? = nil,
                clientToken: String? = nil,
                context: String? = nil,
                excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy? = nil,
                fulfilledCapacity: Double? = nil,
                iamFleetRole: String,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                instancePoolsToUseCount: Integer? = nil,
                launchSpecifications: LaunchSpecsList? = nil,
                launchTemplateConfigs: LaunchTemplateConfigList? = nil,
                loadBalancersConfig: LoadBalancersConfig? = nil,
                onDemandAllocationStrategy: OnDemandAllocationStrategy? = nil,
                onDemandFulfilledCapacity: Double? = nil,
                onDemandMaxTotalPrice: String? = nil,
                onDemandTargetCapacity: Integer? = nil,
                replaceUnhealthyInstances: Boolean? = nil,
                spotMaintenanceStrategies: SpotMaintenanceStrategies? = nil,
                spotMaxTotalPrice: String? = nil,
                spotPrice: String? = nil,
                tagSpecifications: TagSpecificationList? = nil,
                targetCapacity: Integer,
                targetCapacityUnitType: TargetCapacityUnitType? = nil,
                terminateInstancesWithExpiration: Boolean? = nil,
                type: FleetType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.allocationStrategy = allocationStrategy
        self.clientToken = clientToken
        self.context = context
        self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        self.fulfilledCapacity = fulfilledCapacity
        self.iamFleetRole = iamFleetRole
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.instancePoolsToUseCount = instancePoolsToUseCount
        self.launchSpecifications = launchSpecifications
        self.launchTemplateConfigs = launchTemplateConfigs
        self.loadBalancersConfig = loadBalancersConfig
        self.onDemandAllocationStrategy = onDemandAllocationStrategy
        self.onDemandFulfilledCapacity = onDemandFulfilledCapacity
        self.onDemandMaxTotalPrice = onDemandMaxTotalPrice
        self.onDemandTargetCapacity = onDemandTargetCapacity
        self.replaceUnhealthyInstances = replaceUnhealthyInstances
        self.spotMaintenanceStrategies = spotMaintenanceStrategies
        self.spotMaxTotalPrice = spotMaxTotalPrice
        self.spotPrice = spotPrice
        self.tagSpecifications = tagSpecifications
        self.targetCapacity = targetCapacity
        self.targetCapacityUnitType = targetCapacityUnitType
        self.terminateInstancesWithExpiration = terminateInstancesWithExpiration
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy
        case clientToken
        case context
        case excessCapacityTerminationPolicy
        case fulfilledCapacity
        case iamFleetRole
        case instanceInterruptionBehavior
        case instancePoolsToUseCount
        case launchSpecifications
        case launchTemplateConfigs
        case loadBalancersConfig
        case onDemandAllocationStrategy
        case onDemandFulfilledCapacity
        case onDemandMaxTotalPrice
        case onDemandTargetCapacity
        case replaceUnhealthyInstances
        case spotMaintenanceStrategies
        case spotMaxTotalPrice
        case spotPrice
        case tagSpecifications = "TagSpecification"
        case targetCapacity
        case targetCapacityUnitType
        case terminateInstancesWithExpiration
        case type
        case validFrom
        case validUntil
    }

    public func validate() throws {
        try loadBalancersConfig?.validate()
        try spotMaintenanceStrategies?.validate()
    }
}

public struct SpotFleetTagSpecification: Codable, Equatable {
    public var resourceType: ResourceType?
    public var tags: TagList?

    public init(resourceType: ResourceType? = nil,
                tags: TagList? = nil) {
        self.resourceType = resourceType
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case resourceType
        case tags = "tag"
    }

    public func validate() throws {
    }
}

public struct SpotInstanceRequest: Codable, Equatable {
    public var actualBlockHourlyPrice: String?
    public var availabilityZoneGroup: String?
    public var blockDurationMinutes: Integer?
    public var createTime: DateTime?
    public var fault: SpotInstanceStateFault?
    public var instanceId: InstanceId?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var launchGroup: String?
    public var launchSpecification: LaunchSpecification?
    public var launchedAvailabilityZone: String?
    public var productDescription: RIProductDescription?
    public var spotInstanceRequestId: String?
    public var spotPrice: String?
    public var state: SpotInstanceState?
    public var status: SpotInstanceStatus?
    public var tags: TagList?
    public var type: SpotInstanceType?
    public var validFrom: DateTime?
    public var validUntil: DateTime?

    public init(actualBlockHourlyPrice: String? = nil,
                availabilityZoneGroup: String? = nil,
                blockDurationMinutes: Integer? = nil,
                createTime: DateTime? = nil,
                fault: SpotInstanceStateFault? = nil,
                instanceId: InstanceId? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                launchGroup: String? = nil,
                launchSpecification: LaunchSpecification? = nil,
                launchedAvailabilityZone: String? = nil,
                productDescription: RIProductDescription? = nil,
                spotInstanceRequestId: String? = nil,
                spotPrice: String? = nil,
                state: SpotInstanceState? = nil,
                status: SpotInstanceStatus? = nil,
                tags: TagList? = nil,
                type: SpotInstanceType? = nil,
                validFrom: DateTime? = nil,
                validUntil: DateTime? = nil) {
        self.actualBlockHourlyPrice = actualBlockHourlyPrice
        self.availabilityZoneGroup = availabilityZoneGroup
        self.blockDurationMinutes = blockDurationMinutes
        self.createTime = createTime
        self.fault = fault
        self.instanceId = instanceId
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.launchGroup = launchGroup
        self.launchSpecification = launchSpecification
        self.launchedAvailabilityZone = launchedAvailabilityZone
        self.productDescription = productDescription
        self.spotInstanceRequestId = spotInstanceRequestId
        self.spotPrice = spotPrice
        self.state = state
        self.status = status
        self.tags = tags
        self.type = type
        self.validFrom = validFrom
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case actualBlockHourlyPrice
        case availabilityZoneGroup
        case blockDurationMinutes
        case createTime
        case fault
        case instanceId
        case instanceInterruptionBehavior
        case launchGroup
        case launchSpecification
        case launchedAvailabilityZone
        case productDescription
        case spotInstanceRequestId
        case spotPrice
        case state
        case status
        case tags = "tagSet"
        case type
        case validFrom
        case validUntil
    }

    public func validate() throws {
        try fault?.validate()
        try launchSpecification?.validate()
        try status?.validate()
    }
}

public struct SpotInstanceStateFault: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct SpotInstanceStatus: Codable, Equatable {
    public var code: String?
    public var message: String?
    public var updateTime: DateTime?

    public init(code: String? = nil,
                message: String? = nil,
                updateTime: DateTime? = nil) {
        self.code = code
        self.message = message
        self.updateTime = updateTime
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
        case updateTime
    }

    public func validate() throws {
    }
}

public struct SpotMaintenanceStrategies: Codable, Equatable {
    public var capacityRebalance: SpotCapacityRebalance?

    public init(capacityRebalance: SpotCapacityRebalance? = nil) {
        self.capacityRebalance = capacityRebalance
    }

    enum CodingKeys: String, CodingKey {
        case capacityRebalance
    }

    public func validate() throws {
        try capacityRebalance?.validate()
    }
}

public struct SpotMarketOptions: Codable, Equatable {
    public var blockDurationMinutes: Integer?
    public var instanceInterruptionBehavior: InstanceInterruptionBehavior?
    public var maxPrice: String?
    public var spotInstanceType: SpotInstanceType?
    public var validUntil: DateTime?

    public init(blockDurationMinutes: Integer? = nil,
                instanceInterruptionBehavior: InstanceInterruptionBehavior? = nil,
                maxPrice: String? = nil,
                spotInstanceType: SpotInstanceType? = nil,
                validUntil: DateTime? = nil) {
        self.blockDurationMinutes = blockDurationMinutes
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.maxPrice = maxPrice
        self.spotInstanceType = spotInstanceType
        self.validUntil = validUntil
    }

    enum CodingKeys: String, CodingKey {
        case blockDurationMinutes = "BlockDurationMinutes"
        case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
        case maxPrice = "MaxPrice"
        case spotInstanceType = "SpotInstanceType"
        case validUntil = "ValidUntil"
    }

    public func validate() throws {
    }
}

public struct SpotOptions: Codable, Equatable {
    public var allocationStrategy: SpotAllocationStrategy?
    public var instanceInterruptionBehavior: SpotInstanceInterruptionBehavior?
    public var instancePoolsToUseCount: Integer?
    public var maintenanceStrategies: FleetSpotMaintenanceStrategies?
    public var maxTotalPrice: String?
    public var minTargetCapacity: Integer?
    public var singleAvailabilityZone: Boolean?
    public var singleInstanceType: Boolean?

    public init(allocationStrategy: SpotAllocationStrategy? = nil,
                instanceInterruptionBehavior: SpotInstanceInterruptionBehavior? = nil,
                instancePoolsToUseCount: Integer? = nil,
                maintenanceStrategies: FleetSpotMaintenanceStrategies? = nil,
                maxTotalPrice: String? = nil,
                minTargetCapacity: Integer? = nil,
                singleAvailabilityZone: Boolean? = nil,
                singleInstanceType: Boolean? = nil) {
        self.allocationStrategy = allocationStrategy
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.instancePoolsToUseCount = instancePoolsToUseCount
        self.maintenanceStrategies = maintenanceStrategies
        self.maxTotalPrice = maxTotalPrice
        self.minTargetCapacity = minTargetCapacity
        self.singleAvailabilityZone = singleAvailabilityZone
        self.singleInstanceType = singleInstanceType
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy
        case instanceInterruptionBehavior
        case instancePoolsToUseCount
        case maintenanceStrategies
        case maxTotalPrice
        case minTargetCapacity
        case singleAvailabilityZone
        case singleInstanceType
    }

    public func validate() throws {
        try maintenanceStrategies?.validate()
    }
}

public struct SpotOptionsRequest: Codable, Equatable {
    public var allocationStrategy: SpotAllocationStrategy?
    public var instanceInterruptionBehavior: SpotInstanceInterruptionBehavior?
    public var instancePoolsToUseCount: Integer?
    public var maintenanceStrategies: FleetSpotMaintenanceStrategiesRequest?
    public var maxTotalPrice: String?
    public var minTargetCapacity: Integer?
    public var singleAvailabilityZone: Boolean?
    public var singleInstanceType: Boolean?

    public init(allocationStrategy: SpotAllocationStrategy? = nil,
                instanceInterruptionBehavior: SpotInstanceInterruptionBehavior? = nil,
                instancePoolsToUseCount: Integer? = nil,
                maintenanceStrategies: FleetSpotMaintenanceStrategiesRequest? = nil,
                maxTotalPrice: String? = nil,
                minTargetCapacity: Integer? = nil,
                singleAvailabilityZone: Boolean? = nil,
                singleInstanceType: Boolean? = nil) {
        self.allocationStrategy = allocationStrategy
        self.instanceInterruptionBehavior = instanceInterruptionBehavior
        self.instancePoolsToUseCount = instancePoolsToUseCount
        self.maintenanceStrategies = maintenanceStrategies
        self.maxTotalPrice = maxTotalPrice
        self.minTargetCapacity = minTargetCapacity
        self.singleAvailabilityZone = singleAvailabilityZone
        self.singleInstanceType = singleInstanceType
    }

    enum CodingKeys: String, CodingKey {
        case allocationStrategy = "AllocationStrategy"
        case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
        case instancePoolsToUseCount = "InstancePoolsToUseCount"
        case maintenanceStrategies = "MaintenanceStrategies"
        case maxTotalPrice = "MaxTotalPrice"
        case minTargetCapacity = "MinTargetCapacity"
        case singleAvailabilityZone = "SingleAvailabilityZone"
        case singleInstanceType = "SingleInstanceType"
    }

    public func validate() throws {
        try maintenanceStrategies?.validate()
    }
}

public struct SpotPlacement: Codable, Equatable {
    public var availabilityZone: String?
    public var groupName: PlacementGroupName?
    public var tenancy: Tenancy?

    public init(availabilityZone: String? = nil,
                groupName: PlacementGroupName? = nil,
                tenancy: Tenancy? = nil) {
        self.availabilityZone = availabilityZone
        self.groupName = groupName
        self.tenancy = tenancy
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case groupName
        case tenancy
    }

    public func validate() throws {
    }
}

public struct SpotPlacementScore: Codable, Equatable {
    public var availabilityZoneId: String?
    public var region: String?
    public var score: Integer?

    public init(availabilityZoneId: String? = nil,
                region: String? = nil,
                score: Integer? = nil) {
        self.availabilityZoneId = availabilityZoneId
        self.region = region
        self.score = score
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZoneId
        case region
        case score
    }

    public func validate() throws {
    }
}

public struct SpotPrice: Codable, Equatable {
    public var availabilityZone: String?
    public var instanceType: InstanceType?
    public var productDescription: RIProductDescription?
    public var spotPrice: String?
    public var timestamp: DateTime?

    public init(availabilityZone: String? = nil,
                instanceType: InstanceType? = nil,
                productDescription: RIProductDescription? = nil,
                spotPrice: String? = nil,
                timestamp: DateTime? = nil) {
        self.availabilityZone = availabilityZone
        self.instanceType = instanceType
        self.productDescription = productDescription
        self.spotPrice = spotPrice
        self.timestamp = timestamp
    }

    enum CodingKeys: String, CodingKey {
        case availabilityZone
        case instanceType
        case productDescription
        case spotPrice
        case timestamp
    }

    public func validate() throws {
    }
}

public struct StaleIpPermission: Codable, Equatable {
    public var fromPort: Integer?
    public var ipProtocol: String?
    public var ipRanges: IpRanges?
    public var prefixListIds: PrefixListIdSet?
    public var toPort: Integer?
    public var userIdGroupPairs: UserIdGroupPairSet?

    public init(fromPort: Integer? = nil,
                ipProtocol: String? = nil,
                ipRanges: IpRanges? = nil,
                prefixListIds: PrefixListIdSet? = nil,
                toPort: Integer? = nil,
                userIdGroupPairs: UserIdGroupPairSet? = nil) {
        self.fromPort = fromPort
        self.ipProtocol = ipProtocol
        self.ipRanges = ipRanges
        self.prefixListIds = prefixListIds
        self.toPort = toPort
        self.userIdGroupPairs = userIdGroupPairs
    }

    enum CodingKeys: String, CodingKey {
        case fromPort
        case ipProtocol
        case ipRanges
        case prefixListIds
        case toPort
        case userIdGroupPairs = "groups"
    }

    public func validate() throws {
    }
}

public struct StaleSecurityGroup: Codable, Equatable {
    public var description: String?
    public var groupId: String?
    public var groupName: String?
    public var staleIpPermissions: StaleIpPermissionSet?
    public var staleIpPermissionsEgress: StaleIpPermissionSet?
    public var vpcId: String?

    public init(description: String? = nil,
                groupId: String? = nil,
                groupName: String? = nil,
                staleIpPermissions: StaleIpPermissionSet? = nil,
                staleIpPermissionsEgress: StaleIpPermissionSet? = nil,
                vpcId: String? = nil) {
        self.description = description
        self.groupId = groupId
        self.groupName = groupName
        self.staleIpPermissions = staleIpPermissions
        self.staleIpPermissionsEgress = staleIpPermissionsEgress
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case groupId
        case groupName
        case staleIpPermissions
        case staleIpPermissionsEgress
        case vpcId
    }

    public func validate() throws {
    }
}

public struct StartInstancesRequest: Codable, Equatable {
    public var additionalInfo: String?
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(additionalInfo: String? = nil,
                dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.additionalInfo = additionalInfo
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case additionalInfo
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct StartInstancesResult: Codable, Equatable {
    public var startingInstances: InstanceStateChangeList?

    public init(startingInstances: InstanceStateChangeList? = nil) {
        self.startingInstances = startingInstances
    }

    enum CodingKeys: String, CodingKey {
        case startingInstances = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct StartNetworkInsightsAccessScopeAnalysisRequest: Codable, Equatable {
    public var clientToken: String
    public var dryRun: Boolean?
    public var networkInsightsAccessScopeId: NetworkInsightsAccessScopeId
    public var tagSpecifications: TagSpecificationList?

    public init(clientToken: String,
                dryRun: Boolean? = nil,
                networkInsightsAccessScopeId: NetworkInsightsAccessScopeId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.networkInsightsAccessScopeId = networkInsightsAccessScopeId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case networkInsightsAccessScopeId = "NetworkInsightsAccessScopeId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct StartNetworkInsightsAccessScopeAnalysisResult: Codable, Equatable {
    public var networkInsightsAccessScopeAnalysis: NetworkInsightsAccessScopeAnalysis?

    public init(networkInsightsAccessScopeAnalysis: NetworkInsightsAccessScopeAnalysis? = nil) {
        self.networkInsightsAccessScopeAnalysis = networkInsightsAccessScopeAnalysis
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAccessScopeAnalysis
    }

    public func validate() throws {
        try networkInsightsAccessScopeAnalysis?.validate()
    }
}

public struct StartNetworkInsightsAnalysisRequest: Codable, Equatable {
    public var additionalAccounts: ValueStringList?
    public var clientToken: String
    public var dryRun: Boolean?
    public var filterInArns: ArnList?
    public var networkInsightsPathId: NetworkInsightsPathId
    public var tagSpecifications: TagSpecificationList?

    public init(additionalAccounts: ValueStringList? = nil,
                clientToken: String,
                dryRun: Boolean? = nil,
                filterInArns: ArnList? = nil,
                networkInsightsPathId: NetworkInsightsPathId,
                tagSpecifications: TagSpecificationList? = nil) {
        self.additionalAccounts = additionalAccounts
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.filterInArns = filterInArns
        self.networkInsightsPathId = networkInsightsPathId
        self.tagSpecifications = tagSpecifications
    }

    enum CodingKeys: String, CodingKey {
        case additionalAccounts = "AdditionalAccount"
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case filterInArns = "FilterInArn"
        case networkInsightsPathId = "NetworkInsightsPathId"
        case tagSpecifications = "TagSpecification"
    }

    public func validate() throws {
    }
}

public struct StartNetworkInsightsAnalysisResult: Codable, Equatable {
    public var networkInsightsAnalysis: NetworkInsightsAnalysis?

    public init(networkInsightsAnalysis: NetworkInsightsAnalysis? = nil) {
        self.networkInsightsAnalysis = networkInsightsAnalysis
    }

    enum CodingKeys: String, CodingKey {
        case networkInsightsAnalysis
    }

    public func validate() throws {
        try networkInsightsAnalysis?.validate()
    }
}

public struct StartVpcEndpointServicePrivateDnsVerificationRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var serviceId: VpcEndpointServiceId

    public init(dryRun: Boolean? = nil,
                serviceId: VpcEndpointServiceId) {
        self.dryRun = dryRun
        self.serviceId = serviceId
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case serviceId = "ServiceId"
    }

    public func validate() throws {
    }
}

public struct StartVpcEndpointServicePrivateDnsVerificationResult: Codable, Equatable {
    public var returnValue: Boolean?

    public init(returnValue: Boolean? = nil) {
        self.returnValue = returnValue
    }

    enum CodingKeys: String, CodingKey {
        case returnValue = "return"
    }

    public func validate() throws {
    }
}

public struct StateReason: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct StopInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var force: Boolean?
    public var hibernate: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                force: Boolean? = nil,
                hibernate: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.force = force
        self.hibernate = hibernate
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case force
        case hibernate = "Hibernate"
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct StopInstancesResult: Codable, Equatable {
    public var stoppingInstances: InstanceStateChangeList?

    public init(stoppingInstances: InstanceStateChangeList? = nil) {
        self.stoppingInstances = stoppingInstances
    }

    enum CodingKeys: String, CodingKey {
        case stoppingInstances = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct Storage: Codable, Equatable {
    public var s3: S3Storage?

    public init(s3: S3Storage? = nil) {
        self.s3 = s3
    }

    enum CodingKeys: String, CodingKey {
        case s3 = "S3"
    }

    public func validate() throws {
        try s3?.validate()
    }
}

public struct StorageLocation: Codable, Equatable {
    public var bucket: String?
    public var key: String?

    public init(bucket: String? = nil,
                key: String? = nil) {
        self.bucket = bucket
        self.key = key
    }

    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func validate() throws {
    }
}

public struct StoreImageTaskResult: Codable, Equatable {
    public var amiId: String?
    public var bucket: String?
    public var progressPercentage: Integer?
    public var s3objectKey: String?
    public var storeTaskFailureReason: String?
    public var storeTaskState: String?
    public var taskStartTime: MillisecondDateTime?

    public init(amiId: String? = nil,
                bucket: String? = nil,
                progressPercentage: Integer? = nil,
                s3objectKey: String? = nil,
                storeTaskFailureReason: String? = nil,
                storeTaskState: String? = nil,
                taskStartTime: MillisecondDateTime? = nil) {
        self.amiId = amiId
        self.bucket = bucket
        self.progressPercentage = progressPercentage
        self.s3objectKey = s3objectKey
        self.storeTaskFailureReason = storeTaskFailureReason
        self.storeTaskState = storeTaskState
        self.taskStartTime = taskStartTime
    }

    enum CodingKeys: String, CodingKey {
        case amiId
        case bucket
        case progressPercentage
        case s3objectKey
        case storeTaskFailureReason
        case storeTaskState
        case taskStartTime
    }

    public func validate() throws {
    }
}

public struct Subnet: Codable, Equatable {
    public var assignIpv6AddressOnCreation: Boolean?
    public var availabilityZone: String?
    public var availabilityZoneId: String?
    public var availableIpAddressCount: Integer?
    public var cidrBlock: String?
    public var customerOwnedIpv4Pool: CoipPoolId?
    public var defaultForAz: Boolean?
    public var enableDns64: Boolean?
    public var enableLniAtDeviceIndex: Integer?
    public var ipv6CidrBlockAssociationSet: SubnetIpv6CidrBlockAssociationSet?
    public var ipv6Native: Boolean?
    public var mapCustomerOwnedIpOnLaunch: Boolean?
    public var mapPublicIpOnLaunch: Boolean?
    public var outpostArn: String?
    public var ownerId: String?
    public var privateDnsNameOptionsOnLaunch: PrivateDnsNameOptionsOnLaunch?
    public var state: SubnetState?
    public var subnetArn: String?
    public var subnetId: String?
    public var tags: TagList?
    public var vpcId: String?

    public init(assignIpv6AddressOnCreation: Boolean? = nil,
                availabilityZone: String? = nil,
                availabilityZoneId: String? = nil,
                availableIpAddressCount: Integer? = nil,
                cidrBlock: String? = nil,
                customerOwnedIpv4Pool: CoipPoolId? = nil,
                defaultForAz: Boolean? = nil,
                enableDns64: Boolean? = nil,
                enableLniAtDeviceIndex: Integer? = nil,
                ipv6CidrBlockAssociationSet: SubnetIpv6CidrBlockAssociationSet? = nil,
                ipv6Native: Boolean? = nil,
                mapCustomerOwnedIpOnLaunch: Boolean? = nil,
                mapPublicIpOnLaunch: Boolean? = nil,
                outpostArn: String? = nil,
                ownerId: String? = nil,
                privateDnsNameOptionsOnLaunch: PrivateDnsNameOptionsOnLaunch? = nil,
                state: SubnetState? = nil,
                subnetArn: String? = nil,
                subnetId: String? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.availableIpAddressCount = availableIpAddressCount
        self.cidrBlock = cidrBlock
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.defaultForAz = defaultForAz
        self.enableDns64 = enableDns64
        self.enableLniAtDeviceIndex = enableLniAtDeviceIndex
        self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
        self.ipv6Native = ipv6Native
        self.mapCustomerOwnedIpOnLaunch = mapCustomerOwnedIpOnLaunch
        self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
        self.outpostArn = outpostArn
        self.ownerId = ownerId
        self.privateDnsNameOptionsOnLaunch = privateDnsNameOptionsOnLaunch
        self.state = state
        self.subnetArn = subnetArn
        self.subnetId = subnetId
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case assignIpv6AddressOnCreation
        case availabilityZone
        case availabilityZoneId
        case availableIpAddressCount
        case cidrBlock
        case customerOwnedIpv4Pool
        case defaultForAz
        case enableDns64
        case enableLniAtDeviceIndex
        case ipv6CidrBlockAssociationSet
        case ipv6Native
        case mapCustomerOwnedIpOnLaunch
        case mapPublicIpOnLaunch
        case outpostArn
        case ownerId
        case privateDnsNameOptionsOnLaunch
        case state
        case subnetArn
        case subnetId
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
        try privateDnsNameOptionsOnLaunch?.validate()
    }
}

public struct SubnetAssociation: Codable, Equatable {
    public var state: TransitGatewayMulitcastDomainAssociationState?
    public var subnetId: String?

    public init(state: TransitGatewayMulitcastDomainAssociationState? = nil,
                subnetId: String? = nil) {
        self.state = state
        self.subnetId = subnetId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case subnetId
    }

    public func validate() throws {
    }
}

public struct SubnetCidrBlockState: Codable, Equatable {
    public var state: SubnetCidrBlockStateCode?
    public var statusMessage: String?

    public init(state: SubnetCidrBlockStateCode? = nil,
                statusMessage: String? = nil) {
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct SubnetCidrReservation: Codable, Equatable {
    public var cidr: String?
    public var description: String?
    public var ownerId: String?
    public var reservationType: SubnetCidrReservationType?
    public var subnetCidrReservationId: SubnetCidrReservationId?
    public var subnetId: SubnetId?
    public var tags: TagList?

    public init(cidr: String? = nil,
                description: String? = nil,
                ownerId: String? = nil,
                reservationType: SubnetCidrReservationType? = nil,
                subnetCidrReservationId: SubnetCidrReservationId? = nil,
                subnetId: SubnetId? = nil,
                tags: TagList? = nil) {
        self.cidr = cidr
        self.description = description
        self.ownerId = ownerId
        self.reservationType = reservationType
        self.subnetCidrReservationId = subnetCidrReservationId
        self.subnetId = subnetId
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case cidr
        case description
        case ownerId
        case reservationType
        case subnetCidrReservationId
        case subnetId
        case tags = "tagSet"
    }

    public func validate() throws {
    }
}

public struct SubnetIpv6CidrBlockAssociation: Codable, Equatable {
    public var associationId: SubnetCidrAssociationId?
    public var ipv6CidrBlock: String?
    public var ipv6CidrBlockState: SubnetCidrBlockState?

    public init(associationId: SubnetCidrAssociationId? = nil,
                ipv6CidrBlock: String? = nil,
                ipv6CidrBlockState: SubnetCidrBlockState? = nil) {
        self.associationId = associationId
        self.ipv6CidrBlock = ipv6CidrBlock
        self.ipv6CidrBlockState = ipv6CidrBlockState
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case ipv6CidrBlock
        case ipv6CidrBlockState
    }

    public func validate() throws {
        try ipv6CidrBlockState?.validate()
    }
}

public struct Subscription: Codable, Equatable {
    public var destination: String?
    public var metric: MetricType?
    public var period: PeriodType?
    public var source: String?
    public var statistic: StatisticType?

    public init(destination: String? = nil,
                metric: MetricType? = nil,
                period: PeriodType? = nil,
                source: String? = nil,
                statistic: StatisticType? = nil) {
        self.destination = destination
        self.metric = metric
        self.period = period
        self.source = source
        self.statistic = statistic
    }

    enum CodingKeys: String, CodingKey {
        case destination
        case metric
        case period
        case source
        case statistic
    }

    public func validate() throws {
    }
}

public struct SuccessfulInstanceCreditSpecificationItem: Codable, Equatable {
    public var instanceId: String?

    public init(instanceId: String? = nil) {
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
    }

    public func validate() throws {
    }
}

public struct SuccessfulQueuedPurchaseDeletion: Codable, Equatable {
    public var reservedInstancesId: String?

    public init(reservedInstancesId: String? = nil) {
        self.reservedInstancesId = reservedInstancesId
    }

    enum CodingKeys: String, CodingKey {
        case reservedInstancesId
    }

    public func validate() throws {
    }
}

public struct Tag: Codable, Equatable {
    public var key: String?
    public var value: String?

    public init(key: String? = nil,
                value: String? = nil) {
        self.key = key
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func validate() throws {
    }
}

public struct TagDescription: Codable, Equatable {
    public var key: String?
    public var resourceId: String?
    public var resourceType: ResourceType?
    public var value: String?

    public init(key: String? = nil,
                resourceId: String? = nil,
                resourceType: ResourceType? = nil,
                value: String? = nil) {
        self.key = key
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.value = value
    }

    enum CodingKeys: String, CodingKey {
        case key
        case resourceId
        case resourceType
        case value
    }

    public func validate() throws {
    }
}

public struct TagSpecification: Codable, Equatable {
    public var resourceType: ResourceType?
    public var tags: TagList?

    public init(resourceType: ResourceType? = nil,
                tags: TagList? = nil) {
        self.resourceType = resourceType
        self.tags = tags
    }

    enum CodingKeys: String, CodingKey {
        case resourceType
        case tags = "Tag"
    }

    public func validate() throws {
    }
}

public struct TargetCapacitySpecification: Codable, Equatable {
    public var defaultTargetCapacityType: DefaultTargetCapacityType?
    public var onDemandTargetCapacity: Integer?
    public var spotTargetCapacity: Integer?
    public var targetCapacityUnitType: TargetCapacityUnitType?
    public var totalTargetCapacity: Integer?

    public init(defaultTargetCapacityType: DefaultTargetCapacityType? = nil,
                onDemandTargetCapacity: Integer? = nil,
                spotTargetCapacity: Integer? = nil,
                targetCapacityUnitType: TargetCapacityUnitType? = nil,
                totalTargetCapacity: Integer? = nil) {
        self.defaultTargetCapacityType = defaultTargetCapacityType
        self.onDemandTargetCapacity = onDemandTargetCapacity
        self.spotTargetCapacity = spotTargetCapacity
        self.targetCapacityUnitType = targetCapacityUnitType
        self.totalTargetCapacity = totalTargetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case defaultTargetCapacityType
        case onDemandTargetCapacity
        case spotTargetCapacity
        case targetCapacityUnitType
        case totalTargetCapacity
    }

    public func validate() throws {
    }
}

public struct TargetCapacitySpecificationRequest: Codable, Equatable {
    public var defaultTargetCapacityType: DefaultTargetCapacityType?
    public var onDemandTargetCapacity: Integer?
    public var spotTargetCapacity: Integer?
    public var targetCapacityUnitType: TargetCapacityUnitType?
    public var totalTargetCapacity: Integer

    public init(defaultTargetCapacityType: DefaultTargetCapacityType? = nil,
                onDemandTargetCapacity: Integer? = nil,
                spotTargetCapacity: Integer? = nil,
                targetCapacityUnitType: TargetCapacityUnitType? = nil,
                totalTargetCapacity: Integer) {
        self.defaultTargetCapacityType = defaultTargetCapacityType
        self.onDemandTargetCapacity = onDemandTargetCapacity
        self.spotTargetCapacity = spotTargetCapacity
        self.targetCapacityUnitType = targetCapacityUnitType
        self.totalTargetCapacity = totalTargetCapacity
    }

    enum CodingKeys: String, CodingKey {
        case defaultTargetCapacityType = "DefaultTargetCapacityType"
        case onDemandTargetCapacity = "OnDemandTargetCapacity"
        case spotTargetCapacity = "SpotTargetCapacity"
        case targetCapacityUnitType = "TargetCapacityUnitType"
        case totalTargetCapacity = "TotalTargetCapacity"
    }

    public func validate() throws {
    }
}

public struct TargetConfiguration: Codable, Equatable {
    public var instanceCount: Integer?
    public var offeringId: String?

    public init(instanceCount: Integer? = nil,
                offeringId: String? = nil) {
        self.instanceCount = instanceCount
        self.offeringId = offeringId
    }

    enum CodingKeys: String, CodingKey {
        case instanceCount
        case offeringId
    }

    public func validate() throws {
    }
}

public struct TargetConfigurationRequest: Codable, Equatable {
    public var instanceCount: Integer?
    public var offeringId: ReservedInstancesOfferingId

    public init(instanceCount: Integer? = nil,
                offeringId: ReservedInstancesOfferingId) {
        self.instanceCount = instanceCount
        self.offeringId = offeringId
    }

    enum CodingKeys: String, CodingKey {
        case instanceCount = "InstanceCount"
        case offeringId = "OfferingId"
    }

    public func validate() throws {
    }
}

public struct TargetGroup: Codable, Equatable {
    public var arn: String?

    public init(arn: String? = nil) {
        self.arn = arn
    }

    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func validate() throws {
    }
}

public struct TargetGroupsConfig: Codable, Equatable {
    public var targetGroups: TargetGroups?

    public init(targetGroups: TargetGroups? = nil) {
        self.targetGroups = targetGroups
    }

    enum CodingKeys: String, CodingKey {
        case targetGroups
    }

    public func validate() throws {
        try targetGroups?.validateAsTargetGroups()
    }
}

public struct TargetNetwork: Codable, Equatable {
    public var associationId: String?
    public var clientVpnEndpointId: String?
    public var securityGroups: ValueStringList?
    public var status: AssociationStatus?
    public var targetNetworkId: String?
    public var vpcId: String?

    public init(associationId: String? = nil,
                clientVpnEndpointId: String? = nil,
                securityGroups: ValueStringList? = nil,
                status: AssociationStatus? = nil,
                targetNetworkId: String? = nil,
                vpcId: String? = nil) {
        self.associationId = associationId
        self.clientVpnEndpointId = clientVpnEndpointId
        self.securityGroups = securityGroups
        self.status = status
        self.targetNetworkId = targetNetworkId
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case clientVpnEndpointId
        case securityGroups
        case status
        case targetNetworkId
        case vpcId
    }

    public func validate() throws {
        try status?.validate()
    }
}

public struct TargetReservationValue: Codable, Equatable {
    public var reservationValue: ReservationValue?
    public var targetConfiguration: TargetConfiguration?

    public init(reservationValue: ReservationValue? = nil,
                targetConfiguration: TargetConfiguration? = nil) {
        self.reservationValue = reservationValue
        self.targetConfiguration = targetConfiguration
    }

    enum CodingKeys: String, CodingKey {
        case reservationValue
        case targetConfiguration
    }

    public func validate() throws {
        try reservationValue?.validate()
        try targetConfiguration?.validate()
    }
}

public struct TerminateClientVpnConnectionsRequest: Codable, Equatable {
    public var clientVpnEndpointId: ClientVpnEndpointId
    public var connectionId: VpnConnectionId?
    public var dryRun: Boolean?
    public var username: String?

    public init(clientVpnEndpointId: ClientVpnEndpointId,
                connectionId: VpnConnectionId? = nil,
                dryRun: Boolean? = nil,
                username: String? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.connectionId = connectionId
        self.dryRun = dryRun
        self.username = username
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId = "ClientVpnEndpointId"
        case connectionId = "ConnectionId"
        case dryRun = "DryRun"
        case username = "Username"
    }

    public func validate() throws {
    }
}

public struct TerminateClientVpnConnectionsResult: Codable, Equatable {
    public var clientVpnEndpointId: String?
    public var connectionStatuses: TerminateConnectionStatusSet?
    public var username: String?

    public init(clientVpnEndpointId: String? = nil,
                connectionStatuses: TerminateConnectionStatusSet? = nil,
                username: String? = nil) {
        self.clientVpnEndpointId = clientVpnEndpointId
        self.connectionStatuses = connectionStatuses
        self.username = username
    }

    enum CodingKeys: String, CodingKey {
        case clientVpnEndpointId
        case connectionStatuses
        case username
    }

    public func validate() throws {
    }
}

public struct TerminateConnectionStatus: Codable, Equatable {
    public var connectionId: String?
    public var currentStatus: ClientVpnConnectionStatus?
    public var previousStatus: ClientVpnConnectionStatus?

    public init(connectionId: String? = nil,
                currentStatus: ClientVpnConnectionStatus? = nil,
                previousStatus: ClientVpnConnectionStatus? = nil) {
        self.connectionId = connectionId
        self.currentStatus = currentStatus
        self.previousStatus = previousStatus
    }

    enum CodingKeys: String, CodingKey {
        case connectionId
        case currentStatus
        case previousStatus
    }

    public func validate() throws {
        try currentStatus?.validate()
        try previousStatus?.validate()
    }
}

public struct TerminateInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct TerminateInstancesResult: Codable, Equatable {
    public var terminatingInstances: InstanceStateChangeList?

    public init(terminatingInstances: InstanceStateChangeList? = nil) {
        self.terminatingInstances = terminatingInstances
    }

    enum CodingKeys: String, CodingKey {
        case terminatingInstances = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct ThroughResourcesStatement: Codable, Equatable {
    public var resourceStatement: ResourceStatement?

    public init(resourceStatement: ResourceStatement? = nil) {
        self.resourceStatement = resourceStatement
    }

    enum CodingKeys: String, CodingKey {
        case resourceStatement
    }

    public func validate() throws {
        try resourceStatement?.validate()
    }
}

public struct ThroughResourcesStatementRequest: Codable, Equatable {
    public var resourceStatement: ResourceStatementRequest?

    public init(resourceStatement: ResourceStatementRequest? = nil) {
        self.resourceStatement = resourceStatement
    }

    enum CodingKeys: String, CodingKey {
        case resourceStatement = "ResourceStatement"
    }

    public func validate() throws {
        try resourceStatement?.validate()
    }
}

public struct TotalLocalStorageGB: Codable, Equatable {
    public var max: Double?
    public var min: Double?

    public init(max: Double? = nil,
                min: Double? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max
        case min
    }

    public func validate() throws {
    }
}

public struct TotalLocalStorageGBRequest: Codable, Equatable {
    public var max: Double?
    public var min: Double?

    public init(max: Double? = nil,
                min: Double? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorFilter: Codable, Equatable {
    public var description: String?
    public var egressFilterRules: TrafficMirrorFilterRuleList?
    public var ingressFilterRules: TrafficMirrorFilterRuleList?
    public var networkServices: TrafficMirrorNetworkServiceList?
    public var tags: TagList?
    public var trafficMirrorFilterId: String?

    public init(description: String? = nil,
                egressFilterRules: TrafficMirrorFilterRuleList? = nil,
                ingressFilterRules: TrafficMirrorFilterRuleList? = nil,
                networkServices: TrafficMirrorNetworkServiceList? = nil,
                tags: TagList? = nil,
                trafficMirrorFilterId: String? = nil) {
        self.description = description
        self.egressFilterRules = egressFilterRules
        self.ingressFilterRules = ingressFilterRules
        self.networkServices = networkServices
        self.tags = tags
        self.trafficMirrorFilterId = trafficMirrorFilterId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case egressFilterRules = "egressFilterRuleSet"
        case ingressFilterRules = "ingressFilterRuleSet"
        case networkServices = "networkServiceSet"
        case tags = "tagSet"
        case trafficMirrorFilterId
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorFilterRule: Codable, Equatable {
    public var description: String?
    public var destinationCidrBlock: String?
    public var destinationPortRange: TrafficMirrorPortRange?
    public var `protocol`: Integer?
    public var ruleAction: TrafficMirrorRuleAction?
    public var ruleNumber: Integer?
    public var sourceCidrBlock: String?
    public var sourcePortRange: TrafficMirrorPortRange?
    public var trafficDirection: TrafficDirection?
    public var trafficMirrorFilterId: String?
    public var trafficMirrorFilterRuleId: String?

    public init(description: String? = nil,
                destinationCidrBlock: String? = nil,
                destinationPortRange: TrafficMirrorPortRange? = nil,
                `protocol`: Integer? = nil,
                ruleAction: TrafficMirrorRuleAction? = nil,
                ruleNumber: Integer? = nil,
                sourceCidrBlock: String? = nil,
                sourcePortRange: TrafficMirrorPortRange? = nil,
                trafficDirection: TrafficDirection? = nil,
                trafficMirrorFilterId: String? = nil,
                trafficMirrorFilterRuleId: String? = nil) {
        self.description = description
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationPortRange = destinationPortRange
        self.`protocol` = `protocol`
        self.ruleAction = ruleAction
        self.ruleNumber = ruleNumber
        self.sourceCidrBlock = sourceCidrBlock
        self.sourcePortRange = sourcePortRange
        self.trafficDirection = trafficDirection
        self.trafficMirrorFilterId = trafficMirrorFilterId
        self.trafficMirrorFilterRuleId = trafficMirrorFilterRuleId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case destinationCidrBlock
        case destinationPortRange
        case `protocol` = "protocol"
        case ruleAction
        case ruleNumber
        case sourceCidrBlock
        case sourcePortRange
        case trafficDirection
        case trafficMirrorFilterId
        case trafficMirrorFilterRuleId
    }

    public func validate() throws {
        try destinationPortRange?.validate()
        try sourcePortRange?.validate()
    }
}

public struct TrafficMirrorPortRange: Codable, Equatable {
    public var fromPort: Integer?
    public var toPort: Integer?

    public init(fromPort: Integer? = nil,
                toPort: Integer? = nil) {
        self.fromPort = fromPort
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case fromPort
        case toPort
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorPortRangeRequest: Codable, Equatable {
    public var fromPort: Integer?
    public var toPort: Integer?

    public init(fromPort: Integer? = nil,
                toPort: Integer? = nil) {
        self.fromPort = fromPort
        self.toPort = toPort
    }

    enum CodingKeys: String, CodingKey {
        case fromPort = "FromPort"
        case toPort = "ToPort"
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorSession: Codable, Equatable {
    public var description: String?
    public var networkInterfaceId: String?
    public var ownerId: String?
    public var packetLength: Integer?
    public var sessionNumber: Integer?
    public var tags: TagList?
    public var trafficMirrorFilterId: String?
    public var trafficMirrorSessionId: String?
    public var trafficMirrorTargetId: String?
    public var virtualNetworkId: Integer?

    public init(description: String? = nil,
                networkInterfaceId: String? = nil,
                ownerId: String? = nil,
                packetLength: Integer? = nil,
                sessionNumber: Integer? = nil,
                tags: TagList? = nil,
                trafficMirrorFilterId: String? = nil,
                trafficMirrorSessionId: String? = nil,
                trafficMirrorTargetId: String? = nil,
                virtualNetworkId: Integer? = nil) {
        self.description = description
        self.networkInterfaceId = networkInterfaceId
        self.ownerId = ownerId
        self.packetLength = packetLength
        self.sessionNumber = sessionNumber
        self.tags = tags
        self.trafficMirrorFilterId = trafficMirrorFilterId
        self.trafficMirrorSessionId = trafficMirrorSessionId
        self.trafficMirrorTargetId = trafficMirrorTargetId
        self.virtualNetworkId = virtualNetworkId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case networkInterfaceId
        case ownerId
        case packetLength
        case sessionNumber
        case tags = "tagSet"
        case trafficMirrorFilterId
        case trafficMirrorSessionId
        case trafficMirrorTargetId
        case virtualNetworkId
    }

    public func validate() throws {
    }
}

public struct TrafficMirrorTarget: Codable, Equatable {
    public var description: String?
    public var gatewayLoadBalancerEndpointId: String?
    public var networkInterfaceId: String?
    public var networkLoadBalancerArn: String?
    public var ownerId: String?
    public var tags: TagList?
    public var trafficMirrorTargetId: String?
    public var type: TrafficMirrorTargetType?

    public init(description: String? = nil,
                gatewayLoadBalancerEndpointId: String? = nil,
                networkInterfaceId: String? = nil,
                networkLoadBalancerArn: String? = nil,
                ownerId: String? = nil,
                tags: TagList? = nil,
                trafficMirrorTargetId: String? = nil,
                type: TrafficMirrorTargetType? = nil) {
        self.description = description
        self.gatewayLoadBalancerEndpointId = gatewayLoadBalancerEndpointId
        self.networkInterfaceId = networkInterfaceId
        self.networkLoadBalancerArn = networkLoadBalancerArn
        self.ownerId = ownerId
        self.tags = tags
        self.trafficMirrorTargetId = trafficMirrorTargetId
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case description
        case gatewayLoadBalancerEndpointId
        case networkInterfaceId
        case networkLoadBalancerArn
        case ownerId
        case tags = "tagSet"
        case trafficMirrorTargetId
        case type
    }

    public func validate() throws {
    }
}

public struct TransitGateway: Codable, Equatable {
    public var creationTime: DateTime?
    public var description: String?
    public var options: TransitGatewayOptions?
    public var ownerId: String?
    public var state: TransitGatewayState?
    public var tags: TagList?
    public var transitGatewayArn: String?
    public var transitGatewayId: String?

    public init(creationTime: DateTime? = nil,
                description: String? = nil,
                options: TransitGatewayOptions? = nil,
                ownerId: String? = nil,
                state: TransitGatewayState? = nil,
                tags: TagList? = nil,
                transitGatewayArn: String? = nil,
                transitGatewayId: String? = nil) {
        self.creationTime = creationTime
        self.description = description
        self.options = options
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.transitGatewayArn = transitGatewayArn
        self.transitGatewayId = transitGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case description
        case options
        case ownerId
        case state
        case tags = "tagSet"
        case transitGatewayArn
        case transitGatewayId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct TransitGatewayAssociation: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayAssociationState?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayAssociationState? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.state = state
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case state
        case transitGatewayAttachmentId
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayAttachment: Codable, Equatable {
    public var association: TransitGatewayAttachmentAssociation?
    public var creationTime: DateTime?
    public var resourceId: String?
    public var resourceOwnerId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayAttachmentState?
    public var tags: TagList?
    public var transitGatewayAttachmentId: String?
    public var transitGatewayId: String?
    public var transitGatewayOwnerId: String?

    public init(association: TransitGatewayAttachmentAssociation? = nil,
                creationTime: DateTime? = nil,
                resourceId: String? = nil,
                resourceOwnerId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayAttachmentState? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: String? = nil,
                transitGatewayId: String? = nil,
                transitGatewayOwnerId: String? = nil) {
        self.association = association
        self.creationTime = creationTime
        self.resourceId = resourceId
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
        self.state = state
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayId = transitGatewayId
        self.transitGatewayOwnerId = transitGatewayOwnerId
    }

    enum CodingKeys: String, CodingKey {
        case association
        case creationTime
        case resourceId
        case resourceOwnerId
        case resourceType
        case state
        case tags = "tagSet"
        case transitGatewayAttachmentId
        case transitGatewayId
        case transitGatewayOwnerId
    }

    public func validate() throws {
        try association?.validate()
    }
}

public struct TransitGatewayAttachmentAssociation: Codable, Equatable {
    public var state: TransitGatewayAssociationState?
    public var transitGatewayRouteTableId: String?

    public init(state: TransitGatewayAssociationState? = nil,
                transitGatewayRouteTableId: String? = nil) {
        self.state = state
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayAttachmentBgpConfiguration: Codable, Equatable {
    public var bgpStatus: BgpStatus?
    public var peerAddress: String?
    public var peerAsn: Long?
    public var transitGatewayAddress: String?
    public var transitGatewayAsn: Long?

    public init(bgpStatus: BgpStatus? = nil,
                peerAddress: String? = nil,
                peerAsn: Long? = nil,
                transitGatewayAddress: String? = nil,
                transitGatewayAsn: Long? = nil) {
        self.bgpStatus = bgpStatus
        self.peerAddress = peerAddress
        self.peerAsn = peerAsn
        self.transitGatewayAddress = transitGatewayAddress
        self.transitGatewayAsn = transitGatewayAsn
    }

    enum CodingKeys: String, CodingKey {
        case bgpStatus
        case peerAddress
        case peerAsn
        case transitGatewayAddress
        case transitGatewayAsn
    }

    public func validate() throws {
    }
}

public struct TransitGatewayAttachmentPropagation: Codable, Equatable {
    public var state: TransitGatewayPropagationState?
    public var transitGatewayRouteTableId: String?

    public init(state: TransitGatewayPropagationState? = nil,
                transitGatewayRouteTableId: String? = nil) {
        self.state = state
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayConnect: Codable, Equatable {
    public var creationTime: DateTime?
    public var options: TransitGatewayConnectOptions?
    public var state: TransitGatewayAttachmentState?
    public var tags: TagList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayId: TransitGatewayId?
    public var transportTransitGatewayAttachmentId: TransitGatewayAttachmentId?

    public init(creationTime: DateTime? = nil,
                options: TransitGatewayConnectOptions? = nil,
                state: TransitGatewayAttachmentState? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayId: TransitGatewayId? = nil,
                transportTransitGatewayAttachmentId: TransitGatewayAttachmentId? = nil) {
        self.creationTime = creationTime
        self.options = options
        self.state = state
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayId = transitGatewayId
        self.transportTransitGatewayAttachmentId = transportTransitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case options
        case state
        case tags = "tagSet"
        case transitGatewayAttachmentId
        case transitGatewayId
        case transportTransitGatewayAttachmentId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct TransitGatewayConnectOptions: Codable, Equatable {
    public var `protocol`: ProtocolValue?

    public init(`protocol`: ProtocolValue? = nil) {
        self.`protocol` = `protocol`
    }

    enum CodingKeys: String, CodingKey {
        case `protocol` = "protocol"
    }

    public func validate() throws {
    }
}

public struct TransitGatewayConnectPeer: Codable, Equatable {
    public var connectPeerConfiguration: TransitGatewayConnectPeerConfiguration?
    public var creationTime: DateTime?
    public var state: TransitGatewayConnectPeerState?
    public var tags: TagList?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayConnectPeerId: TransitGatewayConnectPeerId?

    public init(connectPeerConfiguration: TransitGatewayConnectPeerConfiguration? = nil,
                creationTime: DateTime? = nil,
                state: TransitGatewayConnectPeerState? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayConnectPeerId: TransitGatewayConnectPeerId? = nil) {
        self.connectPeerConfiguration = connectPeerConfiguration
        self.creationTime = creationTime
        self.state = state
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayConnectPeerId = transitGatewayConnectPeerId
    }

    enum CodingKeys: String, CodingKey {
        case connectPeerConfiguration
        case creationTime
        case state
        case tags = "tagSet"
        case transitGatewayAttachmentId
        case transitGatewayConnectPeerId
    }

    public func validate() throws {
        try connectPeerConfiguration?.validate()
    }
}

public struct TransitGatewayConnectPeerConfiguration: Codable, Equatable {
    public var bgpConfigurations: TransitGatewayAttachmentBgpConfigurationList?
    public var insideCidrBlocks: InsideCidrBlocksStringList?
    public var peerAddress: String?
    public var `protocol`: ProtocolValue?
    public var transitGatewayAddress: String?

    public init(bgpConfigurations: TransitGatewayAttachmentBgpConfigurationList? = nil,
                insideCidrBlocks: InsideCidrBlocksStringList? = nil,
                peerAddress: String? = nil,
                `protocol`: ProtocolValue? = nil,
                transitGatewayAddress: String? = nil) {
        self.bgpConfigurations = bgpConfigurations
        self.insideCidrBlocks = insideCidrBlocks
        self.peerAddress = peerAddress
        self.`protocol` = `protocol`
        self.transitGatewayAddress = transitGatewayAddress
    }

    enum CodingKeys: String, CodingKey {
        case bgpConfigurations
        case insideCidrBlocks
        case peerAddress
        case `protocol` = "protocol"
        case transitGatewayAddress
    }

    public func validate() throws {
    }
}

public struct TransitGatewayConnectRequestBgpOptions: Codable, Equatable {
    public var peerAsn: Long?

    public init(peerAsn: Long? = nil) {
        self.peerAsn = peerAsn
    }

    enum CodingKeys: String, CodingKey {
        case peerAsn = "PeerAsn"
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastDeregisteredGroupMembers: Codable, Equatable {
    public var deregisteredNetworkInterfaceIds: ValueStringList?
    public var groupIpAddress: String?
    public var transitGatewayMulticastDomainId: String?

    public init(deregisteredNetworkInterfaceIds: ValueStringList? = nil,
                groupIpAddress: String? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.deregisteredNetworkInterfaceIds = deregisteredNetworkInterfaceIds
        self.groupIpAddress = groupIpAddress
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case deregisteredNetworkInterfaceIds
        case groupIpAddress
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastDeregisteredGroupSources: Codable, Equatable {
    public var deregisteredNetworkInterfaceIds: ValueStringList?
    public var groupIpAddress: String?
    public var transitGatewayMulticastDomainId: String?

    public init(deregisteredNetworkInterfaceIds: ValueStringList? = nil,
                groupIpAddress: String? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.deregisteredNetworkInterfaceIds = deregisteredNetworkInterfaceIds
        self.groupIpAddress = groupIpAddress
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case deregisteredNetworkInterfaceIds
        case groupIpAddress
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastDomain: Codable, Equatable {
    public var creationTime: DateTime?
    public var options: TransitGatewayMulticastDomainOptions?
    public var ownerId: String?
    public var state: TransitGatewayMulticastDomainState?
    public var tags: TagList?
    public var transitGatewayId: String?
    public var transitGatewayMulticastDomainArn: String?
    public var transitGatewayMulticastDomainId: String?

    public init(creationTime: DateTime? = nil,
                options: TransitGatewayMulticastDomainOptions? = nil,
                ownerId: String? = nil,
                state: TransitGatewayMulticastDomainState? = nil,
                tags: TagList? = nil,
                transitGatewayId: String? = nil,
                transitGatewayMulticastDomainArn: String? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.creationTime = creationTime
        self.options = options
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
        self.transitGatewayMulticastDomainArn = transitGatewayMulticastDomainArn
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case options
        case ownerId
        case state
        case tags = "tagSet"
        case transitGatewayId
        case transitGatewayMulticastDomainArn
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct TransitGatewayMulticastDomainAssociation: Codable, Equatable {
    public var resourceId: String?
    public var resourceOwnerId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var subnet: SubnetAssociation?
    public var transitGatewayAttachmentId: String?

    public init(resourceId: String? = nil,
                resourceOwnerId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                subnet: SubnetAssociation? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.resourceId = resourceId
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
        self.subnet = subnet
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceOwnerId
        case resourceType
        case subnet
        case transitGatewayAttachmentId
    }

    public func validate() throws {
        try subnet?.validate()
    }
}

public struct TransitGatewayMulticastDomainAssociations: Codable, Equatable {
    public var resourceId: String?
    public var resourceOwnerId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var subnets: SubnetAssociationList?
    public var transitGatewayAttachmentId: String?
    public var transitGatewayMulticastDomainId: String?

    public init(resourceId: String? = nil,
                resourceOwnerId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                subnets: SubnetAssociationList? = nil,
                transitGatewayAttachmentId: String? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.resourceId = resourceId
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
        self.subnets = subnets
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceOwnerId
        case resourceType
        case subnets
        case transitGatewayAttachmentId
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastDomainOptions: Codable, Equatable {
    public var autoAcceptSharedAssociations: AutoAcceptSharedAssociationsValue?
    public var igmpv2Support: Igmpv2SupportValue?
    public var staticSourcesSupport: StaticSourcesSupportValue?

    public init(autoAcceptSharedAssociations: AutoAcceptSharedAssociationsValue? = nil,
                igmpv2Support: Igmpv2SupportValue? = nil,
                staticSourcesSupport: StaticSourcesSupportValue? = nil) {
        self.autoAcceptSharedAssociations = autoAcceptSharedAssociations
        self.igmpv2Support = igmpv2Support
        self.staticSourcesSupport = staticSourcesSupport
    }

    enum CodingKeys: String, CodingKey {
        case autoAcceptSharedAssociations
        case igmpv2Support
        case staticSourcesSupport
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastGroup: Codable, Equatable {
    public var groupIpAddress: String?
    public var groupMember: Boolean?
    public var groupSource: Boolean?
    public var memberType: MembershipType?
    public var networkInterfaceId: String?
    public var resourceId: String?
    public var resourceOwnerId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var sourceType: MembershipType?
    public var subnetId: String?
    public var transitGatewayAttachmentId: String?

    public init(groupIpAddress: String? = nil,
                groupMember: Boolean? = nil,
                groupSource: Boolean? = nil,
                memberType: MembershipType? = nil,
                networkInterfaceId: String? = nil,
                resourceId: String? = nil,
                resourceOwnerId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                sourceType: MembershipType? = nil,
                subnetId: String? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.groupIpAddress = groupIpAddress
        self.groupMember = groupMember
        self.groupSource = groupSource
        self.memberType = memberType
        self.networkInterfaceId = networkInterfaceId
        self.resourceId = resourceId
        self.resourceOwnerId = resourceOwnerId
        self.resourceType = resourceType
        self.sourceType = sourceType
        self.subnetId = subnetId
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case groupIpAddress
        case groupMember
        case groupSource
        case memberType
        case networkInterfaceId
        case resourceId
        case resourceOwnerId
        case resourceType
        case sourceType
        case subnetId
        case transitGatewayAttachmentId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastRegisteredGroupMembers: Codable, Equatable {
    public var groupIpAddress: String?
    public var registeredNetworkInterfaceIds: ValueStringList?
    public var transitGatewayMulticastDomainId: String?

    public init(groupIpAddress: String? = nil,
                registeredNetworkInterfaceIds: ValueStringList? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.groupIpAddress = groupIpAddress
        self.registeredNetworkInterfaceIds = registeredNetworkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case groupIpAddress
        case registeredNetworkInterfaceIds
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayMulticastRegisteredGroupSources: Codable, Equatable {
    public var groupIpAddress: String?
    public var registeredNetworkInterfaceIds: ValueStringList?
    public var transitGatewayMulticastDomainId: String?

    public init(groupIpAddress: String? = nil,
                registeredNetworkInterfaceIds: ValueStringList? = nil,
                transitGatewayMulticastDomainId: String? = nil) {
        self.groupIpAddress = groupIpAddress
        self.registeredNetworkInterfaceIds = registeredNetworkInterfaceIds
        self.transitGatewayMulticastDomainId = transitGatewayMulticastDomainId
    }

    enum CodingKeys: String, CodingKey {
        case groupIpAddress
        case registeredNetworkInterfaceIds
        case transitGatewayMulticastDomainId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayOptions: Codable, Equatable {
    public var amazonSideAsn: Long?
    public var associationDefaultRouteTableId: String?
    public var autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue?
    public var defaultRouteTableAssociation: DefaultRouteTableAssociationValue?
    public var defaultRouteTablePropagation: DefaultRouteTablePropagationValue?
    public var dnsSupport: DnsSupportValue?
    public var multicastSupport: MulticastSupportValue?
    public var propagationDefaultRouteTableId: String?
    public var transitGatewayCidrBlocks: ValueStringList?
    public var vpnEcmpSupport: VpnEcmpSupportValue?

    public init(amazonSideAsn: Long? = nil,
                associationDefaultRouteTableId: String? = nil,
                autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue? = nil,
                defaultRouteTableAssociation: DefaultRouteTableAssociationValue? = nil,
                defaultRouteTablePropagation: DefaultRouteTablePropagationValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                multicastSupport: MulticastSupportValue? = nil,
                propagationDefaultRouteTableId: String? = nil,
                transitGatewayCidrBlocks: ValueStringList? = nil,
                vpnEcmpSupport: VpnEcmpSupportValue? = nil) {
        self.amazonSideAsn = amazonSideAsn
        self.associationDefaultRouteTableId = associationDefaultRouteTableId
        self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
        self.defaultRouteTableAssociation = defaultRouteTableAssociation
        self.defaultRouteTablePropagation = defaultRouteTablePropagation
        self.dnsSupport = dnsSupport
        self.multicastSupport = multicastSupport
        self.propagationDefaultRouteTableId = propagationDefaultRouteTableId
        self.transitGatewayCidrBlocks = transitGatewayCidrBlocks
        self.vpnEcmpSupport = vpnEcmpSupport
    }

    enum CodingKeys: String, CodingKey {
        case amazonSideAsn
        case associationDefaultRouteTableId
        case autoAcceptSharedAttachments
        case defaultRouteTableAssociation
        case defaultRouteTablePropagation
        case dnsSupport
        case multicastSupport
        case propagationDefaultRouteTableId
        case transitGatewayCidrBlocks
        case vpnEcmpSupport
    }

    public func validate() throws {
    }
}

public struct TransitGatewayPeeringAttachment: Codable, Equatable {
    public var accepterTgwInfo: PeeringTgwInfo?
    public var accepterTransitGatewayAttachmentId: String?
    public var creationTime: DateTime?
    public var options: TransitGatewayPeeringAttachmentOptions?
    public var requesterTgwInfo: PeeringTgwInfo?
    public var state: TransitGatewayAttachmentState?
    public var status: PeeringAttachmentStatus?
    public var tags: TagList?
    public var transitGatewayAttachmentId: String?

    public init(accepterTgwInfo: PeeringTgwInfo? = nil,
                accepterTransitGatewayAttachmentId: String? = nil,
                creationTime: DateTime? = nil,
                options: TransitGatewayPeeringAttachmentOptions? = nil,
                requesterTgwInfo: PeeringTgwInfo? = nil,
                state: TransitGatewayAttachmentState? = nil,
                status: PeeringAttachmentStatus? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.accepterTgwInfo = accepterTgwInfo
        self.accepterTransitGatewayAttachmentId = accepterTransitGatewayAttachmentId
        self.creationTime = creationTime
        self.options = options
        self.requesterTgwInfo = requesterTgwInfo
        self.state = state
        self.status = status
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case accepterTgwInfo
        case accepterTransitGatewayAttachmentId
        case creationTime
        case options
        case requesterTgwInfo
        case state
        case status
        case tags = "tagSet"
        case transitGatewayAttachmentId
    }

    public func validate() throws {
        try accepterTgwInfo?.validate()
        try options?.validate()
        try requesterTgwInfo?.validate()
        try status?.validate()
    }
}

public struct TransitGatewayPeeringAttachmentOptions: Codable, Equatable {
    public var dynamicRouting: DynamicRoutingValue?

    public init(dynamicRouting: DynamicRoutingValue? = nil) {
        self.dynamicRouting = dynamicRouting
    }

    enum CodingKeys: String, CodingKey {
        case dynamicRouting
    }

    public func validate() throws {
    }
}

public struct TransitGatewayPolicyRule: Codable, Equatable {
    public var destinationCidrBlock: String?
    public var destinationPortRange: String?
    public var metaData: TransitGatewayPolicyRuleMetaData?
    public var `protocol`: String?
    public var sourceCidrBlock: String?
    public var sourcePortRange: String?

    public init(destinationCidrBlock: String? = nil,
                destinationPortRange: String? = nil,
                metaData: TransitGatewayPolicyRuleMetaData? = nil,
                `protocol`: String? = nil,
                sourceCidrBlock: String? = nil,
                sourcePortRange: String? = nil) {
        self.destinationCidrBlock = destinationCidrBlock
        self.destinationPortRange = destinationPortRange
        self.metaData = metaData
        self.`protocol` = `protocol`
        self.sourceCidrBlock = sourceCidrBlock
        self.sourcePortRange = sourcePortRange
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock
        case destinationPortRange
        case metaData
        case `protocol` = "protocol"
        case sourceCidrBlock
        case sourcePortRange
    }

    public func validate() throws {
        try metaData?.validate()
    }
}

public struct TransitGatewayPolicyRuleMetaData: Codable, Equatable {
    public var metaDataKey: String?
    public var metaDataValue: String?

    public init(metaDataKey: String? = nil,
                metaDataValue: String? = nil) {
        self.metaDataKey = metaDataKey
        self.metaDataValue = metaDataValue
    }

    enum CodingKeys: String, CodingKey {
        case metaDataKey
        case metaDataValue
    }

    public func validate() throws {
    }
}

public struct TransitGatewayPolicyTable: Codable, Equatable {
    public var creationTime: DateTime?
    public var state: TransitGatewayPolicyTableState?
    public var tags: TagList?
    public var transitGatewayId: TransitGatewayId?
    public var transitGatewayPolicyTableId: TransitGatewayPolicyTableId?

    public init(creationTime: DateTime? = nil,
                state: TransitGatewayPolicyTableState? = nil,
                tags: TagList? = nil,
                transitGatewayId: TransitGatewayId? = nil,
                transitGatewayPolicyTableId: TransitGatewayPolicyTableId? = nil) {
        self.creationTime = creationTime
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
        self.transitGatewayPolicyTableId = transitGatewayPolicyTableId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case state
        case tags = "tagSet"
        case transitGatewayId
        case transitGatewayPolicyTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayPolicyTableAssociation: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayAssociationState?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayPolicyTableId: TransitGatewayPolicyTableId?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayAssociationState? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayPolicyTableId: TransitGatewayPolicyTableId? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.state = state
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayPolicyTableId = transitGatewayPolicyTableId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case state
        case transitGatewayAttachmentId
        case transitGatewayPolicyTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayPolicyTableEntry: Codable, Equatable {
    public var policyRule: TransitGatewayPolicyRule?
    public var policyRuleNumber: String?
    public var targetRouteTableId: TransitGatewayRouteTableId?

    public init(policyRule: TransitGatewayPolicyRule? = nil,
                policyRuleNumber: String? = nil,
                targetRouteTableId: TransitGatewayRouteTableId? = nil) {
        self.policyRule = policyRule
        self.policyRuleNumber = policyRuleNumber
        self.targetRouteTableId = targetRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case policyRule
        case policyRuleNumber
        case targetRouteTableId
    }

    public func validate() throws {
        try policyRule?.validate()
    }
}

public struct TransitGatewayPrefixListAttachment: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case transitGatewayAttachmentId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayPrefixListReference: Codable, Equatable {
    public var blackhole: Boolean?
    public var prefixListId: PrefixListResourceId?
    public var prefixListOwnerId: String?
    public var state: TransitGatewayPrefixListReferenceState?
    public var transitGatewayAttachment: TransitGatewayPrefixListAttachment?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId?

    public init(blackhole: Boolean? = nil,
                prefixListId: PrefixListResourceId? = nil,
                prefixListOwnerId: String? = nil,
                state: TransitGatewayPrefixListReferenceState? = nil,
                transitGatewayAttachment: TransitGatewayPrefixListAttachment? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId? = nil) {
        self.blackhole = blackhole
        self.prefixListId = prefixListId
        self.prefixListOwnerId = prefixListOwnerId
        self.state = state
        self.transitGatewayAttachment = transitGatewayAttachment
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case blackhole
        case prefixListId
        case prefixListOwnerId
        case state
        case transitGatewayAttachment
        case transitGatewayRouteTableId
    }

    public func validate() throws {
        try transitGatewayAttachment?.validate()
    }
}

public struct TransitGatewayPropagation: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayPropagationState?
    public var transitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId?
    public var transitGatewayRouteTableId: String?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayPropagationState? = nil,
                transitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId? = nil,
                transitGatewayRouteTableId: String? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.state = state
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableAnnouncementId = transitGatewayRouteTableAnnouncementId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case state
        case transitGatewayAttachmentId
        case transitGatewayRouteTableAnnouncementId
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRequestOptions: Codable, Equatable {
    public var amazonSideAsn: Long?
    public var autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue?
    public var defaultRouteTableAssociation: DefaultRouteTableAssociationValue?
    public var defaultRouteTablePropagation: DefaultRouteTablePropagationValue?
    public var dnsSupport: DnsSupportValue?
    public var multicastSupport: MulticastSupportValue?
    public var transitGatewayCidrBlocks: TransitGatewayCidrBlockStringList?
    public var vpnEcmpSupport: VpnEcmpSupportValue?

    public init(amazonSideAsn: Long? = nil,
                autoAcceptSharedAttachments: AutoAcceptSharedAttachmentsValue? = nil,
                defaultRouteTableAssociation: DefaultRouteTableAssociationValue? = nil,
                defaultRouteTablePropagation: DefaultRouteTablePropagationValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                multicastSupport: MulticastSupportValue? = nil,
                transitGatewayCidrBlocks: TransitGatewayCidrBlockStringList? = nil,
                vpnEcmpSupport: VpnEcmpSupportValue? = nil) {
        self.amazonSideAsn = amazonSideAsn
        self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
        self.defaultRouteTableAssociation = defaultRouteTableAssociation
        self.defaultRouteTablePropagation = defaultRouteTablePropagation
        self.dnsSupport = dnsSupport
        self.multicastSupport = multicastSupport
        self.transitGatewayCidrBlocks = transitGatewayCidrBlocks
        self.vpnEcmpSupport = vpnEcmpSupport
    }

    enum CodingKeys: String, CodingKey {
        case amazonSideAsn = "AmazonSideAsn"
        case autoAcceptSharedAttachments = "AutoAcceptSharedAttachments"
        case defaultRouteTableAssociation = "DefaultRouteTableAssociation"
        case defaultRouteTablePropagation = "DefaultRouteTablePropagation"
        case dnsSupport = "DnsSupport"
        case multicastSupport = "MulticastSupport"
        case transitGatewayCidrBlocks = "TransitGatewayCidrBlocks"
        case vpnEcmpSupport = "VpnEcmpSupport"
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRoute: Codable, Equatable {
    public var destinationCidrBlock: String?
    public var prefixListId: PrefixListResourceId?
    public var state: TransitGatewayRouteState?
    public var transitGatewayAttachments: TransitGatewayRouteAttachmentList?
    public var transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId?
    public var type: TransitGatewayRouteType?

    public init(destinationCidrBlock: String? = nil,
                prefixListId: PrefixListResourceId? = nil,
                state: TransitGatewayRouteState? = nil,
                transitGatewayAttachments: TransitGatewayRouteAttachmentList? = nil,
                transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId? = nil,
                type: TransitGatewayRouteType? = nil) {
        self.destinationCidrBlock = destinationCidrBlock
        self.prefixListId = prefixListId
        self.state = state
        self.transitGatewayAttachments = transitGatewayAttachments
        self.transitGatewayRouteTableAnnouncementId = transitGatewayRouteTableAnnouncementId
        self.type = type
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock
        case prefixListId
        case state
        case transitGatewayAttachments
        case transitGatewayRouteTableAnnouncementId
        case type
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteAttachment: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var transitGatewayAttachmentId: String?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case transitGatewayAttachmentId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteTable: Codable, Equatable {
    public var creationTime: DateTime?
    public var defaultAssociationRouteTable: Boolean?
    public var defaultPropagationRouteTable: Boolean?
    public var state: TransitGatewayRouteTableState?
    public var tags: TagList?
    public var transitGatewayId: String?
    public var transitGatewayRouteTableId: String?

    public init(creationTime: DateTime? = nil,
                defaultAssociationRouteTable: Boolean? = nil,
                defaultPropagationRouteTable: Boolean? = nil,
                state: TransitGatewayRouteTableState? = nil,
                tags: TagList? = nil,
                transitGatewayId: String? = nil,
                transitGatewayRouteTableId: String? = nil) {
        self.creationTime = creationTime
        self.defaultAssociationRouteTable = defaultAssociationRouteTable
        self.defaultPropagationRouteTable = defaultPropagationRouteTable
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case defaultAssociationRouteTable
        case defaultPropagationRouteTable
        case state
        case tags = "tagSet"
        case transitGatewayId
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteTableAnnouncement: Codable, Equatable {
    public var announcementDirection: TransitGatewayRouteTableAnnouncementDirection?
    public var coreNetworkId: String?
    public var creationTime: DateTime?
    public var peerCoreNetworkId: String?
    public var peerTransitGatewayId: TransitGatewayId?
    public var peeringAttachmentId: TransitGatewayAttachmentId?
    public var state: TransitGatewayRouteTableAnnouncementState?
    public var tags: TagList?
    public var transitGatewayId: TransitGatewayId?
    public var transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId?
    public var transitGatewayRouteTableId: TransitGatewayRouteTableId?

    public init(announcementDirection: TransitGatewayRouteTableAnnouncementDirection? = nil,
                coreNetworkId: String? = nil,
                creationTime: DateTime? = nil,
                peerCoreNetworkId: String? = nil,
                peerTransitGatewayId: TransitGatewayId? = nil,
                peeringAttachmentId: TransitGatewayAttachmentId? = nil,
                state: TransitGatewayRouteTableAnnouncementState? = nil,
                tags: TagList? = nil,
                transitGatewayId: TransitGatewayId? = nil,
                transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId? = nil,
                transitGatewayRouteTableId: TransitGatewayRouteTableId? = nil) {
        self.announcementDirection = announcementDirection
        self.coreNetworkId = coreNetworkId
        self.creationTime = creationTime
        self.peerCoreNetworkId = peerCoreNetworkId
        self.peerTransitGatewayId = peerTransitGatewayId
        self.peeringAttachmentId = peeringAttachmentId
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
        self.transitGatewayRouteTableAnnouncementId = transitGatewayRouteTableAnnouncementId
        self.transitGatewayRouteTableId = transitGatewayRouteTableId
    }

    enum CodingKeys: String, CodingKey {
        case announcementDirection
        case coreNetworkId
        case creationTime
        case peerCoreNetworkId
        case peerTransitGatewayId
        case peeringAttachmentId
        case state
        case tags = "tagSet"
        case transitGatewayId
        case transitGatewayRouteTableAnnouncementId
        case transitGatewayRouteTableId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteTableAssociation: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayAssociationState?
    public var transitGatewayAttachmentId: String?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayAssociationState? = nil,
                transitGatewayAttachmentId: String? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.state = state
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case state
        case transitGatewayAttachmentId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteTablePropagation: Codable, Equatable {
    public var resourceId: String?
    public var resourceType: TransitGatewayAttachmentResourceType?
    public var state: TransitGatewayPropagationState?
    public var transitGatewayAttachmentId: String?
    public var transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId?

    public init(resourceId: String? = nil,
                resourceType: TransitGatewayAttachmentResourceType? = nil,
                state: TransitGatewayPropagationState? = nil,
                transitGatewayAttachmentId: String? = nil,
                transitGatewayRouteTableAnnouncementId: TransitGatewayRouteTableAnnouncementId? = nil) {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.state = state
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayRouteTableAnnouncementId = transitGatewayRouteTableAnnouncementId
    }

    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
        case state
        case transitGatewayAttachmentId
        case transitGatewayRouteTableAnnouncementId
    }

    public func validate() throws {
    }
}

public struct TransitGatewayRouteTableRoute: Codable, Equatable {
    public var attachmentId: String?
    public var destinationCidr: String?
    public var prefixListId: String?
    public var resourceId: String?
    public var resourceType: String?
    public var routeOrigin: String?
    public var state: String?

    public init(attachmentId: String? = nil,
                destinationCidr: String? = nil,
                prefixListId: String? = nil,
                resourceId: String? = nil,
                resourceType: String? = nil,
                routeOrigin: String? = nil,
                state: String? = nil) {
        self.attachmentId = attachmentId
        self.destinationCidr = destinationCidr
        self.prefixListId = prefixListId
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.routeOrigin = routeOrigin
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case attachmentId
        case destinationCidr
        case prefixListId
        case resourceId
        case resourceType
        case routeOrigin
        case state
    }

    public func validate() throws {
    }
}

public struct TransitGatewayVpcAttachment: Codable, Equatable {
    public var creationTime: DateTime?
    public var options: TransitGatewayVpcAttachmentOptions?
    public var state: TransitGatewayAttachmentState?
    public var subnetIds: ValueStringList?
    public var tags: TagList?
    public var transitGatewayAttachmentId: String?
    public var transitGatewayId: String?
    public var vpcId: String?
    public var vpcOwnerId: String?

    public init(creationTime: DateTime? = nil,
                options: TransitGatewayVpcAttachmentOptions? = nil,
                state: TransitGatewayAttachmentState? = nil,
                subnetIds: ValueStringList? = nil,
                tags: TagList? = nil,
                transitGatewayAttachmentId: String? = nil,
                transitGatewayId: String? = nil,
                vpcId: String? = nil,
                vpcOwnerId: String? = nil) {
        self.creationTime = creationTime
        self.options = options
        self.state = state
        self.subnetIds = subnetIds
        self.tags = tags
        self.transitGatewayAttachmentId = transitGatewayAttachmentId
        self.transitGatewayId = transitGatewayId
        self.vpcId = vpcId
        self.vpcOwnerId = vpcOwnerId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case options
        case state
        case subnetIds
        case tags = "tagSet"
        case transitGatewayAttachmentId
        case transitGatewayId
        case vpcId
        case vpcOwnerId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct TransitGatewayVpcAttachmentOptions: Codable, Equatable {
    public var applianceModeSupport: ApplianceModeSupportValue?
    public var dnsSupport: DnsSupportValue?
    public var ipv6Support: Ipv6SupportValue?

    public init(applianceModeSupport: ApplianceModeSupportValue? = nil,
                dnsSupport: DnsSupportValue? = nil,
                ipv6Support: Ipv6SupportValue? = nil) {
        self.applianceModeSupport = applianceModeSupport
        self.dnsSupport = dnsSupport
        self.ipv6Support = ipv6Support
    }

    enum CodingKeys: String, CodingKey {
        case applianceModeSupport
        case dnsSupport
        case ipv6Support
    }

    public func validate() throws {
    }
}

public struct TrunkInterfaceAssociation: Codable, Equatable {
    public var associationId: TrunkInterfaceAssociationId?
    public var branchInterfaceId: String?
    public var greKey: Integer?
    public var interfaceProtocol: InterfaceProtocolType?
    public var tags: TagList?
    public var trunkInterfaceId: String?
    public var vlanId: Integer?

    public init(associationId: TrunkInterfaceAssociationId? = nil,
                branchInterfaceId: String? = nil,
                greKey: Integer? = nil,
                interfaceProtocol: InterfaceProtocolType? = nil,
                tags: TagList? = nil,
                trunkInterfaceId: String? = nil,
                vlanId: Integer? = nil) {
        self.associationId = associationId
        self.branchInterfaceId = branchInterfaceId
        self.greKey = greKey
        self.interfaceProtocol = interfaceProtocol
        self.tags = tags
        self.trunkInterfaceId = trunkInterfaceId
        self.vlanId = vlanId
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case branchInterfaceId
        case greKey
        case interfaceProtocol
        case tags = "tagSet"
        case trunkInterfaceId
        case vlanId
    }

    public func validate() throws {
    }
}

public struct TunnelOption: Codable, Equatable {
    public var dpdTimeoutAction: String?
    public var dpdTimeoutSeconds: Integer?
    public var ikeVersions: IKEVersionsList?
    public var logOptions: VpnTunnelLogOptions?
    public var outsideIpAddress: String?
    public var phase1DHGroupNumbers: Phase1DHGroupNumbersList?
    public var phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsList?
    public var phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsList?
    public var phase1LifetimeSeconds: Integer?
    public var phase2DHGroupNumbers: Phase2DHGroupNumbersList?
    public var phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsList?
    public var phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsList?
    public var phase2LifetimeSeconds: Integer?
    public var preSharedKey: String?
    public var rekeyFuzzPercentage: Integer?
    public var rekeyMarginTimeSeconds: Integer?
    public var replayWindowSize: Integer?
    public var startupAction: String?
    public var tunnelInsideCidr: String?
    public var tunnelInsideIpv6Cidr: String?

    public init(dpdTimeoutAction: String? = nil,
                dpdTimeoutSeconds: Integer? = nil,
                ikeVersions: IKEVersionsList? = nil,
                logOptions: VpnTunnelLogOptions? = nil,
                outsideIpAddress: String? = nil,
                phase1DHGroupNumbers: Phase1DHGroupNumbersList? = nil,
                phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsList? = nil,
                phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsList? = nil,
                phase1LifetimeSeconds: Integer? = nil,
                phase2DHGroupNumbers: Phase2DHGroupNumbersList? = nil,
                phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsList? = nil,
                phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsList? = nil,
                phase2LifetimeSeconds: Integer? = nil,
                preSharedKey: String? = nil,
                rekeyFuzzPercentage: Integer? = nil,
                rekeyMarginTimeSeconds: Integer? = nil,
                replayWindowSize: Integer? = nil,
                startupAction: String? = nil,
                tunnelInsideCidr: String? = nil,
                tunnelInsideIpv6Cidr: String? = nil) {
        self.dpdTimeoutAction = dpdTimeoutAction
        self.dpdTimeoutSeconds = dpdTimeoutSeconds
        self.ikeVersions = ikeVersions
        self.logOptions = logOptions
        self.outsideIpAddress = outsideIpAddress
        self.phase1DHGroupNumbers = phase1DHGroupNumbers
        self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
        self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
        self.phase1LifetimeSeconds = phase1LifetimeSeconds
        self.phase2DHGroupNumbers = phase2DHGroupNumbers
        self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
        self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
        self.phase2LifetimeSeconds = phase2LifetimeSeconds
        self.preSharedKey = preSharedKey
        self.rekeyFuzzPercentage = rekeyFuzzPercentage
        self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
        self.replayWindowSize = replayWindowSize
        self.startupAction = startupAction
        self.tunnelInsideCidr = tunnelInsideCidr
        self.tunnelInsideIpv6Cidr = tunnelInsideIpv6Cidr
    }

    enum CodingKeys: String, CodingKey {
        case dpdTimeoutAction
        case dpdTimeoutSeconds
        case ikeVersions = "ikeVersionSet"
        case logOptions
        case outsideIpAddress
        case phase1DHGroupNumbers = "phase1DHGroupNumberSet"
        case phase1EncryptionAlgorithms = "phase1EncryptionAlgorithmSet"
        case phase1IntegrityAlgorithms = "phase1IntegrityAlgorithmSet"
        case phase1LifetimeSeconds
        case phase2DHGroupNumbers = "phase2DHGroupNumberSet"
        case phase2EncryptionAlgorithms = "phase2EncryptionAlgorithmSet"
        case phase2IntegrityAlgorithms = "phase2IntegrityAlgorithmSet"
        case phase2LifetimeSeconds
        case preSharedKey
        case rekeyFuzzPercentage
        case rekeyMarginTimeSeconds
        case replayWindowSize
        case startupAction
        case tunnelInsideCidr
        case tunnelInsideIpv6Cidr
    }

    public func validate() throws {
        try logOptions?.validate()
    }
}

public struct UnassignIpv6AddressesRequest: Codable, Equatable {
    public var ipv6Addresses: Ipv6AddressList?
    public var ipv6Prefixes: IpPrefixList?
    public var networkInterfaceId: NetworkInterfaceId

    public init(ipv6Addresses: Ipv6AddressList? = nil,
                ipv6Prefixes: IpPrefixList? = nil,
                networkInterfaceId: NetworkInterfaceId) {
        self.ipv6Addresses = ipv6Addresses
        self.ipv6Prefixes = ipv6Prefixes
        self.networkInterfaceId = networkInterfaceId
    }

    enum CodingKeys: String, CodingKey {
        case ipv6Addresses
        case ipv6Prefixes = "Ipv6Prefix"
        case networkInterfaceId
    }

    public func validate() throws {
    }
}

public struct UnassignIpv6AddressesResult: Codable, Equatable {
    public var networkInterfaceId: String?
    public var unassignedIpv6Addresses: Ipv6AddressList?
    public var unassignedIpv6Prefixes: IpPrefixList?

    public init(networkInterfaceId: String? = nil,
                unassignedIpv6Addresses: Ipv6AddressList? = nil,
                unassignedIpv6Prefixes: IpPrefixList? = nil) {
        self.networkInterfaceId = networkInterfaceId
        self.unassignedIpv6Addresses = unassignedIpv6Addresses
        self.unassignedIpv6Prefixes = unassignedIpv6Prefixes
    }

    enum CodingKeys: String, CodingKey {
        case networkInterfaceId
        case unassignedIpv6Addresses
        case unassignedIpv6Prefixes = "unassignedIpv6PrefixSet"
    }

    public func validate() throws {
    }
}

public struct UnassignPrivateIpAddressesRequest: Codable, Equatable {
    public var ipv4Prefixes: IpPrefixList?
    public var networkInterfaceId: NetworkInterfaceId
    public var privateIpAddresses: PrivateIpAddressStringList?

    public init(ipv4Prefixes: IpPrefixList? = nil,
                networkInterfaceId: NetworkInterfaceId,
                privateIpAddresses: PrivateIpAddressStringList? = nil) {
        self.ipv4Prefixes = ipv4Prefixes
        self.networkInterfaceId = networkInterfaceId
        self.privateIpAddresses = privateIpAddresses
    }

    enum CodingKeys: String, CodingKey {
        case ipv4Prefixes = "Ipv4Prefix"
        case networkInterfaceId
        case privateIpAddresses = "privateIpAddress"
    }

    public func validate() throws {
    }
}

public struct UnmonitorInstancesRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var instanceIds: InstanceIdStringList

    public init(dryRun: Boolean? = nil,
                instanceIds: InstanceIdStringList) {
        self.dryRun = dryRun
        self.instanceIds = instanceIds
    }

    enum CodingKeys: String, CodingKey {
        case dryRun
        case instanceIds = "InstanceId"
    }

    public func validate() throws {
    }
}

public struct UnmonitorInstancesResult: Codable, Equatable {
    public var instanceMonitorings: InstanceMonitoringList?

    public init(instanceMonitorings: InstanceMonitoringList? = nil) {
        self.instanceMonitorings = instanceMonitorings
    }

    enum CodingKeys: String, CodingKey {
        case instanceMonitorings = "instancesSet"
    }

    public func validate() throws {
    }
}

public struct UnsuccessfulInstanceCreditSpecificationItem: Codable, Equatable {
    public var error: UnsuccessfulInstanceCreditSpecificationItemError?
    public var instanceId: String?

    public init(error: UnsuccessfulInstanceCreditSpecificationItemError? = nil,
                instanceId: String? = nil) {
        self.error = error
        self.instanceId = instanceId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case instanceId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct UnsuccessfulInstanceCreditSpecificationItemError: Codable, Equatable {
    public var code: UnsuccessfulInstanceCreditSpecificationErrorCode?
    public var message: String?

    public init(code: UnsuccessfulInstanceCreditSpecificationErrorCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct UnsuccessfulItem: Codable, Equatable {
    public var error: UnsuccessfulItemError?
    public var resourceId: String?

    public init(error: UnsuccessfulItemError? = nil,
                resourceId: String? = nil) {
        self.error = error
        self.resourceId = resourceId
    }

    enum CodingKeys: String, CodingKey {
        case error
        case resourceId
    }

    public func validate() throws {
        try error?.validate()
    }
}

public struct UnsuccessfulItemError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct UpdateSecurityGroupRuleDescriptionsEgressRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?
    public var ipPermissions: IpPermissionList?
    public var securityGroupRuleDescriptions: SecurityGroupRuleDescriptionList?

    public init(dryRun: Boolean? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil,
                ipPermissions: IpPermissionList? = nil,
                securityGroupRuleDescriptions: SecurityGroupRuleDescriptionList? = nil) {
        self.dryRun = dryRun
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
        self.securityGroupRuleDescriptions = securityGroupRuleDescriptions
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
        case securityGroupRuleDescriptions = "SecurityGroupRuleDescription"
    }

    public func validate() throws {
    }
}

public struct UpdateSecurityGroupRuleDescriptionsEgressResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct UpdateSecurityGroupRuleDescriptionsIngressRequest: Codable, Equatable {
    public var dryRun: Boolean?
    public var groupId: SecurityGroupId?
    public var groupName: SecurityGroupName?
    public var ipPermissions: IpPermissionList?
    public var securityGroupRuleDescriptions: SecurityGroupRuleDescriptionList?

    public init(dryRun: Boolean? = nil,
                groupId: SecurityGroupId? = nil,
                groupName: SecurityGroupName? = nil,
                ipPermissions: IpPermissionList? = nil,
                securityGroupRuleDescriptions: SecurityGroupRuleDescriptionList? = nil) {
        self.dryRun = dryRun
        self.groupId = groupId
        self.groupName = groupName
        self.ipPermissions = ipPermissions
        self.securityGroupRuleDescriptions = securityGroupRuleDescriptions
    }

    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
        case securityGroupRuleDescriptions = "SecurityGroupRuleDescription"
    }

    public func validate() throws {
    }
}

public struct UpdateSecurityGroupRuleDescriptionsIngressResult: Codable, Equatable {
    public var `return`: Boolean?

    public init(`return`: Boolean? = nil) {
        self.`return` = `return`
    }

    enum CodingKeys: String, CodingKey {
        case `return` = "return"
    }

    public func validate() throws {
    }
}

public struct UserBucket: Codable, Equatable {
    public var s3Bucket: String?
    public var s3Key: String?

    public init(s3Bucket: String? = nil,
                s3Key: String? = nil) {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }

    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func validate() throws {
    }
}

public struct UserBucketDetails: Codable, Equatable {
    public var s3Bucket: String?
    public var s3Key: String?

    public init(s3Bucket: String? = nil,
                s3Key: String? = nil) {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
    }

    enum CodingKeys: String, CodingKey {
        case s3Bucket
        case s3Key
    }

    public func validate() throws {
    }
}

public struct UserData: Codable, Equatable {
    public var data: String?

    public init(data: String? = nil) {
        self.data = data
    }

    enum CodingKeys: String, CodingKey {
        case data
    }

    public func validate() throws {
    }
}

public struct UserIdGroupPair: Codable, Equatable {
    public var description: String?
    public var groupId: String?
    public var groupName: String?
    public var peeringStatus: String?
    public var userId: String?
    public var vpcId: String?
    public var vpcPeeringConnectionId: String?

    public init(description: String? = nil,
                groupId: String? = nil,
                groupName: String? = nil,
                peeringStatus: String? = nil,
                userId: String? = nil,
                vpcId: String? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.description = description
        self.groupId = groupId
        self.groupName = groupName
        self.peeringStatus = peeringStatus
        self.userId = userId
        self.vpcId = vpcId
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case groupId
        case groupName
        case peeringStatus
        case userId
        case vpcId
        case vpcPeeringConnectionId
    }

    public func validate() throws {
    }
}

public struct VCpuCountRange: Codable, Equatable {
    public var max: Integer?
    public var min: Integer?

    public init(max: Integer? = nil,
                min: Integer? = nil) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max
        case min
    }

    public func validate() throws {
    }
}

public struct VCpuCountRangeRequest: Codable, Equatable {
    public var max: Integer?
    public var min: Integer

    public init(max: Integer? = nil,
                min: Integer) {
        self.max = max
        self.min = min
    }

    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func validate() throws {
    }
}

public struct VCpuInfo: Codable, Equatable {
    public var defaultCores: CoreCount?
    public var defaultThreadsPerCore: ThreadsPerCore?
    public var defaultVCpus: VCpuCount?
    public var validCores: CoreCountList?
    public var validThreadsPerCore: ThreadsPerCoreList?

    public init(defaultCores: CoreCount? = nil,
                defaultThreadsPerCore: ThreadsPerCore? = nil,
                defaultVCpus: VCpuCount? = nil,
                validCores: CoreCountList? = nil,
                validThreadsPerCore: ThreadsPerCoreList? = nil) {
        self.defaultCores = defaultCores
        self.defaultThreadsPerCore = defaultThreadsPerCore
        self.defaultVCpus = defaultVCpus
        self.validCores = validCores
        self.validThreadsPerCore = validThreadsPerCore
    }

    enum CodingKeys: String, CodingKey {
        case defaultCores
        case defaultThreadsPerCore
        case defaultVCpus
        case validCores
        case validThreadsPerCore
    }

    public func validate() throws {
    }
}

public struct ValidationError: Codable, Equatable {
    public var code: String?
    public var message: String?

    public init(code: String? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct ValidationWarning: Codable, Equatable {
    public var errors: ErrorSet?

    public init(errors: ErrorSet? = nil) {
        self.errors = errors
    }

    enum CodingKeys: String, CodingKey {
        case errors = "errorSet"
    }

    public func validate() throws {
    }
}

public struct VerifiedAccessEndpoint: Codable, Equatable {
    public var applicationDomain: String?
    public var attachmentType: VerifiedAccessEndpointAttachmentType?
    public var creationTime: String?
    public var deletionTime: String?
    public var description: String?
    public var deviceValidationDomain: String?
    public var domainCertificateArn: String?
    public var endpointDomain: String?
    public var endpointType: VerifiedAccessEndpointType?
    public var lastUpdatedTime: String?
    public var loadBalancerOptions: VerifiedAccessEndpointLoadBalancerOptions?
    public var networkInterfaceOptions: VerifiedAccessEndpointEniOptions?
    public var securityGroupIds: SecurityGroupIdList?
    public var status: VerifiedAccessEndpointStatus?
    public var tags: TagList?
    public var verifiedAccessEndpointId: String?
    public var verifiedAccessGroupId: String?
    public var verifiedAccessInstanceId: String?

    public init(applicationDomain: String? = nil,
                attachmentType: VerifiedAccessEndpointAttachmentType? = nil,
                creationTime: String? = nil,
                deletionTime: String? = nil,
                description: String? = nil,
                deviceValidationDomain: String? = nil,
                domainCertificateArn: String? = nil,
                endpointDomain: String? = nil,
                endpointType: VerifiedAccessEndpointType? = nil,
                lastUpdatedTime: String? = nil,
                loadBalancerOptions: VerifiedAccessEndpointLoadBalancerOptions? = nil,
                networkInterfaceOptions: VerifiedAccessEndpointEniOptions? = nil,
                securityGroupIds: SecurityGroupIdList? = nil,
                status: VerifiedAccessEndpointStatus? = nil,
                tags: TagList? = nil,
                verifiedAccessEndpointId: String? = nil,
                verifiedAccessGroupId: String? = nil,
                verifiedAccessInstanceId: String? = nil) {
        self.applicationDomain = applicationDomain
        self.attachmentType = attachmentType
        self.creationTime = creationTime
        self.deletionTime = deletionTime
        self.description = description
        self.deviceValidationDomain = deviceValidationDomain
        self.domainCertificateArn = domainCertificateArn
        self.endpointDomain = endpointDomain
        self.endpointType = endpointType
        self.lastUpdatedTime = lastUpdatedTime
        self.loadBalancerOptions = loadBalancerOptions
        self.networkInterfaceOptions = networkInterfaceOptions
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.tags = tags
        self.verifiedAccessEndpointId = verifiedAccessEndpointId
        self.verifiedAccessGroupId = verifiedAccessGroupId
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case applicationDomain
        case attachmentType
        case creationTime
        case deletionTime
        case description
        case deviceValidationDomain
        case domainCertificateArn
        case endpointDomain
        case endpointType
        case lastUpdatedTime
        case loadBalancerOptions
        case networkInterfaceOptions
        case securityGroupIds = "securityGroupIdSet"
        case status
        case tags = "tagSet"
        case verifiedAccessEndpointId
        case verifiedAccessGroupId
        case verifiedAccessInstanceId
    }

    public func validate() throws {
        try loadBalancerOptions?.validate()
        try networkInterfaceOptions?.validate()
        try status?.validate()
    }
}

public struct VerifiedAccessEndpointEniOptions: Codable, Equatable {
    public var networkInterfaceId: NetworkInterfaceId?
    public var port: VerifiedAccessEndpointPortNumber?
    public var `protocol`: VerifiedAccessEndpointProtocol?

    public init(networkInterfaceId: NetworkInterfaceId? = nil,
                port: VerifiedAccessEndpointPortNumber? = nil,
                `protocol`: VerifiedAccessEndpointProtocol? = nil) {
        self.networkInterfaceId = networkInterfaceId
        self.port = port
        self.`protocol` = `protocol`
    }

    enum CodingKeys: String, CodingKey {
        case networkInterfaceId
        case port
        case `protocol` = "protocol"
    }

    public func validate() throws {
        try port?.validateAsVerifiedAccessEndpointPortNumber()
    }
}

public struct VerifiedAccessEndpointLoadBalancerOptions: Codable, Equatable {
    public var loadBalancerArn: String?
    public var port: VerifiedAccessEndpointPortNumber?
    public var `protocol`: VerifiedAccessEndpointProtocol?
    public var subnetIds: VerifiedAccessEndpointSubnetIdList?

    public init(loadBalancerArn: String? = nil,
                port: VerifiedAccessEndpointPortNumber? = nil,
                `protocol`: VerifiedAccessEndpointProtocol? = nil,
                subnetIds: VerifiedAccessEndpointSubnetIdList? = nil) {
        self.loadBalancerArn = loadBalancerArn
        self.port = port
        self.`protocol` = `protocol`
        self.subnetIds = subnetIds
    }

    enum CodingKeys: String, CodingKey {
        case loadBalancerArn
        case port
        case `protocol` = "protocol"
        case subnetIds = "subnetIdSet"
    }

    public func validate() throws {
        try port?.validateAsVerifiedAccessEndpointPortNumber()
    }
}

public struct VerifiedAccessEndpointStatus: Codable, Equatable {
    public var code: VerifiedAccessEndpointStatusCode?
    public var message: String?

    public init(code: VerifiedAccessEndpointStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct VerifiedAccessGroup: Codable, Equatable {
    public var creationTime: String?
    public var deletionTime: String?
    public var description: String?
    public var lastUpdatedTime: String?
    public var owner: String?
    public var tags: TagList?
    public var verifiedAccessGroupArn: String?
    public var verifiedAccessGroupId: String?
    public var verifiedAccessInstanceId: String?

    public init(creationTime: String? = nil,
                deletionTime: String? = nil,
                description: String? = nil,
                lastUpdatedTime: String? = nil,
                owner: String? = nil,
                tags: TagList? = nil,
                verifiedAccessGroupArn: String? = nil,
                verifiedAccessGroupId: String? = nil,
                verifiedAccessInstanceId: String? = nil) {
        self.creationTime = creationTime
        self.deletionTime = deletionTime
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.owner = owner
        self.tags = tags
        self.verifiedAccessGroupArn = verifiedAccessGroupArn
        self.verifiedAccessGroupId = verifiedAccessGroupId
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case deletionTime
        case description
        case lastUpdatedTime
        case owner
        case tags = "tagSet"
        case verifiedAccessGroupArn
        case verifiedAccessGroupId
        case verifiedAccessInstanceId
    }

    public func validate() throws {
    }
}

public struct VerifiedAccessInstance: Codable, Equatable {
    public var creationTime: String?
    public var description: String?
    public var lastUpdatedTime: String?
    public var tags: TagList?
    public var verifiedAccessInstanceId: String?
    public var verifiedAccessTrustProviders: VerifiedAccessTrustProviderCondensedList?

    public init(creationTime: String? = nil,
                description: String? = nil,
                lastUpdatedTime: String? = nil,
                tags: TagList? = nil,
                verifiedAccessInstanceId: String? = nil,
                verifiedAccessTrustProviders: VerifiedAccessTrustProviderCondensedList? = nil) {
        self.creationTime = creationTime
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.tags = tags
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
        self.verifiedAccessTrustProviders = verifiedAccessTrustProviders
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case description
        case lastUpdatedTime
        case tags = "tagSet"
        case verifiedAccessInstanceId
        case verifiedAccessTrustProviders = "verifiedAccessTrustProviderSet"
    }

    public func validate() throws {
    }
}

public struct VerifiedAccessInstanceLoggingConfiguration: Codable, Equatable {
    public var accessLogs: VerifiedAccessLogs?
    public var verifiedAccessInstanceId: String?

    public init(accessLogs: VerifiedAccessLogs? = nil,
                verifiedAccessInstanceId: String? = nil) {
        self.accessLogs = accessLogs
        self.verifiedAccessInstanceId = verifiedAccessInstanceId
    }

    enum CodingKeys: String, CodingKey {
        case accessLogs
        case verifiedAccessInstanceId
    }

    public func validate() throws {
        try accessLogs?.validate()
    }
}

public struct VerifiedAccessLogCloudWatchLogsDestination: Codable, Equatable {
    public var deliveryStatus: VerifiedAccessLogDeliveryStatus?
    public var enabled: Boolean?
    public var logGroup: String?

    public init(deliveryStatus: VerifiedAccessLogDeliveryStatus? = nil,
                enabled: Boolean? = nil,
                logGroup: String? = nil) {
        self.deliveryStatus = deliveryStatus
        self.enabled = enabled
        self.logGroup = logGroup
    }

    enum CodingKeys: String, CodingKey {
        case deliveryStatus
        case enabled
        case logGroup
    }

    public func validate() throws {
        try deliveryStatus?.validate()
    }
}

public struct VerifiedAccessLogCloudWatchLogsDestinationOptions: Codable, Equatable {
    public var enabled: Boolean
    public var logGroup: String?

    public init(enabled: Boolean,
                logGroup: String? = nil) {
        self.enabled = enabled
        self.logGroup = logGroup
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case logGroup = "LogGroup"
    }

    public func validate() throws {
    }
}

public struct VerifiedAccessLogDeliveryStatus: Codable, Equatable {
    public var code: VerifiedAccessLogDeliveryStatusCode?
    public var message: String?

    public init(code: VerifiedAccessLogDeliveryStatusCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct VerifiedAccessLogKinesisDataFirehoseDestination: Codable, Equatable {
    public var deliveryStatus: VerifiedAccessLogDeliveryStatus?
    public var deliveryStream: String?
    public var enabled: Boolean?

    public init(deliveryStatus: VerifiedAccessLogDeliveryStatus? = nil,
                deliveryStream: String? = nil,
                enabled: Boolean? = nil) {
        self.deliveryStatus = deliveryStatus
        self.deliveryStream = deliveryStream
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case deliveryStatus
        case deliveryStream
        case enabled
    }

    public func validate() throws {
        try deliveryStatus?.validate()
    }
}

public struct VerifiedAccessLogKinesisDataFirehoseDestinationOptions: Codable, Equatable {
    public var deliveryStream: String?
    public var enabled: Boolean

    public init(deliveryStream: String? = nil,
                enabled: Boolean) {
        self.deliveryStream = deliveryStream
        self.enabled = enabled
    }

    enum CodingKeys: String, CodingKey {
        case deliveryStream = "DeliveryStream"
        case enabled = "Enabled"
    }

    public func validate() throws {
    }
}

public struct VerifiedAccessLogOptions: Codable, Equatable {
    public var cloudWatchLogs: VerifiedAccessLogCloudWatchLogsDestinationOptions?
    public var kinesisDataFirehose: VerifiedAccessLogKinesisDataFirehoseDestinationOptions?
    public var s3: VerifiedAccessLogS3DestinationOptions?

    public init(cloudWatchLogs: VerifiedAccessLogCloudWatchLogsDestinationOptions? = nil,
                kinesisDataFirehose: VerifiedAccessLogKinesisDataFirehoseDestinationOptions? = nil,
                s3: VerifiedAccessLogS3DestinationOptions? = nil) {
        self.cloudWatchLogs = cloudWatchLogs
        self.kinesisDataFirehose = kinesisDataFirehose
        self.s3 = s3
    }

    enum CodingKeys: String, CodingKey {
        case cloudWatchLogs = "CloudWatchLogs"
        case kinesisDataFirehose = "KinesisDataFirehose"
        case s3 = "S3"
    }

    public func validate() throws {
        try cloudWatchLogs?.validate()
        try kinesisDataFirehose?.validate()
        try s3?.validate()
    }
}

public struct VerifiedAccessLogS3Destination: Codable, Equatable {
    public var bucketName: String?
    public var bucketOwner: String?
    public var deliveryStatus: VerifiedAccessLogDeliveryStatus?
    public var enabled: Boolean?
    public var prefix: String?

    public init(bucketName: String? = nil,
                bucketOwner: String? = nil,
                deliveryStatus: VerifiedAccessLogDeliveryStatus? = nil,
                enabled: Boolean? = nil,
                prefix: String? = nil) {
        self.bucketName = bucketName
        self.bucketOwner = bucketOwner
        self.deliveryStatus = deliveryStatus
        self.enabled = enabled
        self.prefix = prefix
    }

    enum CodingKeys: String, CodingKey {
        case bucketName
        case bucketOwner
        case deliveryStatus
        case enabled
        case prefix
    }

    public func validate() throws {
        try deliveryStatus?.validate()
    }
}

public struct VerifiedAccessLogS3DestinationOptions: Codable, Equatable {
    public var bucketName: String?
    public var bucketOwner: String?
    public var enabled: Boolean
    public var prefix: String?

    public init(bucketName: String? = nil,
                bucketOwner: String? = nil,
                enabled: Boolean,
                prefix: String? = nil) {
        self.bucketName = bucketName
        self.bucketOwner = bucketOwner
        self.enabled = enabled
        self.prefix = prefix
    }

    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case bucketOwner = "BucketOwner"
        case enabled = "Enabled"
        case prefix = "Prefix"
    }

    public func validate() throws {
    }
}

public struct VerifiedAccessLogs: Codable, Equatable {
    public var cloudWatchLogs: VerifiedAccessLogCloudWatchLogsDestination?
    public var kinesisDataFirehose: VerifiedAccessLogKinesisDataFirehoseDestination?
    public var s3: VerifiedAccessLogS3Destination?

    public init(cloudWatchLogs: VerifiedAccessLogCloudWatchLogsDestination? = nil,
                kinesisDataFirehose: VerifiedAccessLogKinesisDataFirehoseDestination? = nil,
                s3: VerifiedAccessLogS3Destination? = nil) {
        self.cloudWatchLogs = cloudWatchLogs
        self.kinesisDataFirehose = kinesisDataFirehose
        self.s3 = s3
    }

    enum CodingKeys: String, CodingKey {
        case cloudWatchLogs
        case kinesisDataFirehose
        case s3
    }

    public func validate() throws {
        try cloudWatchLogs?.validate()
        try kinesisDataFirehose?.validate()
        try s3?.validate()
    }
}

public struct VerifiedAccessTrustProvider: Codable, Equatable {
    public var creationTime: String?
    public var description: String?
    public var deviceOptions: DeviceOptions?
    public var deviceTrustProviderType: DeviceTrustProviderType?
    public var lastUpdatedTime: String?
    public var oidcOptions: OidcOptions?
    public var policyReferenceName: String?
    public var tags: TagList?
    public var trustProviderType: TrustProviderType?
    public var userTrustProviderType: UserTrustProviderType?
    public var verifiedAccessTrustProviderId: String?

    public init(creationTime: String? = nil,
                description: String? = nil,
                deviceOptions: DeviceOptions? = nil,
                deviceTrustProviderType: DeviceTrustProviderType? = nil,
                lastUpdatedTime: String? = nil,
                oidcOptions: OidcOptions? = nil,
                policyReferenceName: String? = nil,
                tags: TagList? = nil,
                trustProviderType: TrustProviderType? = nil,
                userTrustProviderType: UserTrustProviderType? = nil,
                verifiedAccessTrustProviderId: String? = nil) {
        self.creationTime = creationTime
        self.description = description
        self.deviceOptions = deviceOptions
        self.deviceTrustProviderType = deviceTrustProviderType
        self.lastUpdatedTime = lastUpdatedTime
        self.oidcOptions = oidcOptions
        self.policyReferenceName = policyReferenceName
        self.tags = tags
        self.trustProviderType = trustProviderType
        self.userTrustProviderType = userTrustProviderType
        self.verifiedAccessTrustProviderId = verifiedAccessTrustProviderId
    }

    enum CodingKeys: String, CodingKey {
        case creationTime
        case description
        case deviceOptions
        case deviceTrustProviderType
        case lastUpdatedTime
        case oidcOptions
        case policyReferenceName
        case tags = "tagSet"
        case trustProviderType
        case userTrustProviderType
        case verifiedAccessTrustProviderId
    }

    public func validate() throws {
        try deviceOptions?.validate()
        try oidcOptions?.validate()
    }
}

public struct VerifiedAccessTrustProviderCondensed: Codable, Equatable {
    public var description: String?
    public var deviceTrustProviderType: DeviceTrustProviderType?
    public var trustProviderType: TrustProviderType?
    public var userTrustProviderType: UserTrustProviderType?
    public var verifiedAccessTrustProviderId: String?

    public init(description: String? = nil,
                deviceTrustProviderType: DeviceTrustProviderType? = nil,
                trustProviderType: TrustProviderType? = nil,
                userTrustProviderType: UserTrustProviderType? = nil,
                verifiedAccessTrustProviderId: String? = nil) {
        self.description = description
        self.deviceTrustProviderType = deviceTrustProviderType
        self.trustProviderType = trustProviderType
        self.userTrustProviderType = userTrustProviderType
        self.verifiedAccessTrustProviderId = verifiedAccessTrustProviderId
    }

    enum CodingKeys: String, CodingKey {
        case description
        case deviceTrustProviderType
        case trustProviderType
        case userTrustProviderType
        case verifiedAccessTrustProviderId
    }

    public func validate() throws {
    }
}

public struct VgwTelemetry: Codable, Equatable {
    public var acceptedRouteCount: Integer?
    public var certificateArn: String?
    public var lastStatusChange: DateTime?
    public var outsideIpAddress: String?
    public var status: TelemetryStatus?
    public var statusMessage: String?

    public init(acceptedRouteCount: Integer? = nil,
                certificateArn: String? = nil,
                lastStatusChange: DateTime? = nil,
                outsideIpAddress: String? = nil,
                status: TelemetryStatus? = nil,
                statusMessage: String? = nil) {
        self.acceptedRouteCount = acceptedRouteCount
        self.certificateArn = certificateArn
        self.lastStatusChange = lastStatusChange
        self.outsideIpAddress = outsideIpAddress
        self.status = status
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case acceptedRouteCount
        case certificateArn
        case lastStatusChange
        case outsideIpAddress
        case status
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct Volume: Codable, Equatable {
    public var attachments: VolumeAttachmentList?
    public var availabilityZone: String?
    public var createTime: DateTime?
    public var encrypted: Boolean?
    public var fastRestored: Boolean?
    public var iops: Integer?
    public var kmsKeyId: String?
    public var multiAttachEnabled: Boolean?
    public var outpostArn: String?
    public var size: Integer?
    public var snapshotId: String?
    public var state: VolumeState?
    public var tags: TagList?
    public var throughput: Integer?
    public var volumeId: String?
    public var volumeType: VolumeType?

    public init(attachments: VolumeAttachmentList? = nil,
                availabilityZone: String? = nil,
                createTime: DateTime? = nil,
                encrypted: Boolean? = nil,
                fastRestored: Boolean? = nil,
                iops: Integer? = nil,
                kmsKeyId: String? = nil,
                multiAttachEnabled: Boolean? = nil,
                outpostArn: String? = nil,
                size: Integer? = nil,
                snapshotId: String? = nil,
                state: VolumeState? = nil,
                tags: TagList? = nil,
                throughput: Integer? = nil,
                volumeId: String? = nil,
                volumeType: VolumeType? = nil) {
        self.attachments = attachments
        self.availabilityZone = availabilityZone
        self.createTime = createTime
        self.encrypted = encrypted
        self.fastRestored = fastRestored
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.multiAttachEnabled = multiAttachEnabled
        self.outpostArn = outpostArn
        self.size = size
        self.snapshotId = snapshotId
        self.state = state
        self.tags = tags
        self.throughput = throughput
        self.volumeId = volumeId
        self.volumeType = volumeType
    }

    enum CodingKeys: String, CodingKey {
        case attachments = "attachmentSet"
        case availabilityZone
        case createTime
        case encrypted
        case fastRestored
        case iops
        case kmsKeyId
        case multiAttachEnabled
        case outpostArn
        case size
        case snapshotId
        case state = "status"
        case tags = "tagSet"
        case throughput
        case volumeId
        case volumeType
    }

    public func validate() throws {
    }
}

public struct VolumeAttachment: Codable, Equatable {
    public var attachTime: DateTime?
    public var deleteOnTermination: Boolean?
    public var device: String?
    public var instanceId: String?
    public var state: VolumeAttachmentState?
    public var volumeId: String?

    public init(attachTime: DateTime? = nil,
                deleteOnTermination: Boolean? = nil,
                device: String? = nil,
                instanceId: String? = nil,
                state: VolumeAttachmentState? = nil,
                volumeId: String? = nil) {
        self.attachTime = attachTime
        self.deleteOnTermination = deleteOnTermination
        self.device = device
        self.instanceId = instanceId
        self.state = state
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case attachTime
        case deleteOnTermination
        case device
        case instanceId
        case state = "status"
        case volumeId
    }

    public func validate() throws {
    }
}

public struct VolumeDetail: Codable, Equatable {
    public var size: Long

    public init(size: Long) {
        self.size = size
    }

    enum CodingKeys: String, CodingKey {
        case size
    }

    public func validate() throws {
    }
}

public struct VolumeModification: Codable, Equatable {
    public var endTime: DateTime?
    public var modificationState: VolumeModificationState?
    public var originalIops: Integer?
    public var originalMultiAttachEnabled: Boolean?
    public var originalSize: Integer?
    public var originalThroughput: Integer?
    public var originalVolumeType: VolumeType?
    public var progress: Long?
    public var startTime: DateTime?
    public var statusMessage: String?
    public var targetIops: Integer?
    public var targetMultiAttachEnabled: Boolean?
    public var targetSize: Integer?
    public var targetThroughput: Integer?
    public var targetVolumeType: VolumeType?
    public var volumeId: String?

    public init(endTime: DateTime? = nil,
                modificationState: VolumeModificationState? = nil,
                originalIops: Integer? = nil,
                originalMultiAttachEnabled: Boolean? = nil,
                originalSize: Integer? = nil,
                originalThroughput: Integer? = nil,
                originalVolumeType: VolumeType? = nil,
                progress: Long? = nil,
                startTime: DateTime? = nil,
                statusMessage: String? = nil,
                targetIops: Integer? = nil,
                targetMultiAttachEnabled: Boolean? = nil,
                targetSize: Integer? = nil,
                targetThroughput: Integer? = nil,
                targetVolumeType: VolumeType? = nil,
                volumeId: String? = nil) {
        self.endTime = endTime
        self.modificationState = modificationState
        self.originalIops = originalIops
        self.originalMultiAttachEnabled = originalMultiAttachEnabled
        self.originalSize = originalSize
        self.originalThroughput = originalThroughput
        self.originalVolumeType = originalVolumeType
        self.progress = progress
        self.startTime = startTime
        self.statusMessage = statusMessage
        self.targetIops = targetIops
        self.targetMultiAttachEnabled = targetMultiAttachEnabled
        self.targetSize = targetSize
        self.targetThroughput = targetThroughput
        self.targetVolumeType = targetVolumeType
        self.volumeId = volumeId
    }

    enum CodingKeys: String, CodingKey {
        case endTime
        case modificationState
        case originalIops
        case originalMultiAttachEnabled
        case originalSize
        case originalThroughput
        case originalVolumeType
        case progress
        case startTime
        case statusMessage
        case targetIops
        case targetMultiAttachEnabled
        case targetSize
        case targetThroughput
        case targetVolumeType
        case volumeId
    }

    public func validate() throws {
    }
}

public struct VolumeStatusAction: Codable, Equatable {
    public var code: String?
    public var description: String?
    public var eventId: String?
    public var eventType: String?

    public init(code: String? = nil,
                description: String? = nil,
                eventId: String? = nil,
                eventType: String? = nil) {
        self.code = code
        self.description = description
        self.eventId = eventId
        self.eventType = eventType
    }

    enum CodingKeys: String, CodingKey {
        case code
        case description
        case eventId
        case eventType
    }

    public func validate() throws {
    }
}

public struct VolumeStatusAttachmentStatus: Codable, Equatable {
    public var instanceId: String?
    public var ioPerformance: String?

    public init(instanceId: String? = nil,
                ioPerformance: String? = nil) {
        self.instanceId = instanceId
        self.ioPerformance = ioPerformance
    }

    enum CodingKeys: String, CodingKey {
        case instanceId
        case ioPerformance
    }

    public func validate() throws {
    }
}

public struct VolumeStatusDetails: Codable, Equatable {
    public var name: VolumeStatusName?
    public var status: String?

    public init(name: VolumeStatusName? = nil,
                status: String? = nil) {
        self.name = name
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case name
        case status
    }

    public func validate() throws {
    }
}

public struct VolumeStatusEvent: Codable, Equatable {
    public var description: String?
    public var eventId: String?
    public var eventType: String?
    public var instanceId: String?
    public var notAfter: MillisecondDateTime?
    public var notBefore: MillisecondDateTime?

    public init(description: String? = nil,
                eventId: String? = nil,
                eventType: String? = nil,
                instanceId: String? = nil,
                notAfter: MillisecondDateTime? = nil,
                notBefore: MillisecondDateTime? = nil) {
        self.description = description
        self.eventId = eventId
        self.eventType = eventType
        self.instanceId = instanceId
        self.notAfter = notAfter
        self.notBefore = notBefore
    }

    enum CodingKeys: String, CodingKey {
        case description
        case eventId
        case eventType
        case instanceId
        case notAfter
        case notBefore
    }

    public func validate() throws {
    }
}

public struct VolumeStatusInfo: Codable, Equatable {
    public var details: VolumeStatusDetailsList?
    public var status: VolumeStatusInfoStatus?

    public init(details: VolumeStatusDetailsList? = nil,
                status: VolumeStatusInfoStatus? = nil) {
        self.details = details
        self.status = status
    }

    enum CodingKeys: String, CodingKey {
        case details
        case status
    }

    public func validate() throws {
    }
}

public struct VolumeStatusItem: Codable, Equatable {
    public var actions: VolumeStatusActionsList?
    public var attachmentStatuses: VolumeStatusAttachmentStatusList?
    public var availabilityZone: String?
    public var events: VolumeStatusEventsList?
    public var outpostArn: String?
    public var volumeId: String?
    public var volumeStatus: VolumeStatusInfo?

    public init(actions: VolumeStatusActionsList? = nil,
                attachmentStatuses: VolumeStatusAttachmentStatusList? = nil,
                availabilityZone: String? = nil,
                events: VolumeStatusEventsList? = nil,
                outpostArn: String? = nil,
                volumeId: String? = nil,
                volumeStatus: VolumeStatusInfo? = nil) {
        self.actions = actions
        self.attachmentStatuses = attachmentStatuses
        self.availabilityZone = availabilityZone
        self.events = events
        self.outpostArn = outpostArn
        self.volumeId = volumeId
        self.volumeStatus = volumeStatus
    }

    enum CodingKeys: String, CodingKey {
        case actions = "actionsSet"
        case attachmentStatuses
        case availabilityZone
        case events = "eventsSet"
        case outpostArn
        case volumeId
        case volumeStatus
    }

    public func validate() throws {
        try volumeStatus?.validate()
    }
}

public struct Vpc: Codable, Equatable {
    public var cidrBlock: String?
    public var cidrBlockAssociationSet: VpcCidrBlockAssociationSet?
    public var dhcpOptionsId: String?
    public var instanceTenancy: Tenancy?
    public var ipv6CidrBlockAssociationSet: VpcIpv6CidrBlockAssociationSet?
    public var isDefault: Boolean?
    public var ownerId: String?
    public var state: VpcState?
    public var tags: TagList?
    public var vpcId: String?

    public init(cidrBlock: String? = nil,
                cidrBlockAssociationSet: VpcCidrBlockAssociationSet? = nil,
                dhcpOptionsId: String? = nil,
                instanceTenancy: Tenancy? = nil,
                ipv6CidrBlockAssociationSet: VpcIpv6CidrBlockAssociationSet? = nil,
                isDefault: Boolean? = nil,
                ownerId: String? = nil,
                state: VpcState? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.cidrBlock = cidrBlock
        self.cidrBlockAssociationSet = cidrBlockAssociationSet
        self.dhcpOptionsId = dhcpOptionsId
        self.instanceTenancy = instanceTenancy
        self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
        self.isDefault = isDefault
        self.ownerId = ownerId
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case cidrBlockAssociationSet
        case dhcpOptionsId
        case instanceTenancy
        case ipv6CidrBlockAssociationSet
        case isDefault
        case ownerId
        case state
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct VpcAttachment: Codable, Equatable {
    public var state: AttachmentStatus?
    public var vpcId: String?

    public init(state: AttachmentStatus? = nil,
                vpcId: String? = nil) {
        self.state = state
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case state
        case vpcId
    }

    public func validate() throws {
    }
}

public struct VpcCidrBlockAssociation: Codable, Equatable {
    public var associationId: String?
    public var cidrBlock: String?
    public var cidrBlockState: VpcCidrBlockState?

    public init(associationId: String? = nil,
                cidrBlock: String? = nil,
                cidrBlockState: VpcCidrBlockState? = nil) {
        self.associationId = associationId
        self.cidrBlock = cidrBlock
        self.cidrBlockState = cidrBlockState
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case cidrBlock
        case cidrBlockState
    }

    public func validate() throws {
        try cidrBlockState?.validate()
    }
}

public struct VpcCidrBlockState: Codable, Equatable {
    public var state: VpcCidrBlockStateCode?
    public var statusMessage: String?

    public init(state: VpcCidrBlockStateCode? = nil,
                statusMessage: String? = nil) {
        self.state = state
        self.statusMessage = statusMessage
    }

    enum CodingKeys: String, CodingKey {
        case state
        case statusMessage
    }

    public func validate() throws {
    }
}

public struct VpcClassicLink: Codable, Equatable {
    public var classicLinkEnabled: Boolean?
    public var tags: TagList?
    public var vpcId: String?

    public init(classicLinkEnabled: Boolean? = nil,
                tags: TagList? = nil,
                vpcId: String? = nil) {
        self.classicLinkEnabled = classicLinkEnabled
        self.tags = tags
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case classicLinkEnabled
        case tags = "tagSet"
        case vpcId
    }

    public func validate() throws {
    }
}

public struct VpcEndpoint: Codable, Equatable {
    public var creationTimestamp: MillisecondDateTime?
    public var dnsEntries: DnsEntrySet?
    public var dnsOptions: DnsOptions?
    public var groups: GroupIdentifierSet?
    public var ipAddressType: IpAddressType?
    public var lastError: LastError?
    public var networkInterfaceIds: ValueStringList?
    public var ownerId: String?
    public var policyDocument: String?
    public var privateDnsEnabled: Boolean?
    public var requesterManaged: Boolean?
    public var routeTableIds: ValueStringList?
    public var serviceName: String?
    public var state: State?
    public var subnetIds: ValueStringList?
    public var tags: TagList?
    public var vpcEndpointId: String?
    public var vpcEndpointType: VpcEndpointType?
    public var vpcId: String?

    public init(creationTimestamp: MillisecondDateTime? = nil,
                dnsEntries: DnsEntrySet? = nil,
                dnsOptions: DnsOptions? = nil,
                groups: GroupIdentifierSet? = nil,
                ipAddressType: IpAddressType? = nil,
                lastError: LastError? = nil,
                networkInterfaceIds: ValueStringList? = nil,
                ownerId: String? = nil,
                policyDocument: String? = nil,
                privateDnsEnabled: Boolean? = nil,
                requesterManaged: Boolean? = nil,
                routeTableIds: ValueStringList? = nil,
                serviceName: String? = nil,
                state: State? = nil,
                subnetIds: ValueStringList? = nil,
                tags: TagList? = nil,
                vpcEndpointId: String? = nil,
                vpcEndpointType: VpcEndpointType? = nil,
                vpcId: String? = nil) {
        self.creationTimestamp = creationTimestamp
        self.dnsEntries = dnsEntries
        self.dnsOptions = dnsOptions
        self.groups = groups
        self.ipAddressType = ipAddressType
        self.lastError = lastError
        self.networkInterfaceIds = networkInterfaceIds
        self.ownerId = ownerId
        self.policyDocument = policyDocument
        self.privateDnsEnabled = privateDnsEnabled
        self.requesterManaged = requesterManaged
        self.routeTableIds = routeTableIds
        self.serviceName = serviceName
        self.state = state
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcEndpointId = vpcEndpointId
        self.vpcEndpointType = vpcEndpointType
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case creationTimestamp
        case dnsEntries = "dnsEntrySet"
        case dnsOptions
        case groups = "groupSet"
        case ipAddressType
        case lastError
        case networkInterfaceIds = "networkInterfaceIdSet"
        case ownerId
        case policyDocument
        case privateDnsEnabled
        case requesterManaged
        case routeTableIds = "routeTableIdSet"
        case serviceName
        case state
        case subnetIds = "subnetIdSet"
        case tags = "tagSet"
        case vpcEndpointId
        case vpcEndpointType
        case vpcId
    }

    public func validate() throws {
        try dnsOptions?.validate()
        try lastError?.validate()
    }
}

public struct VpcEndpointConnection: Codable, Equatable {
    public var creationTimestamp: MillisecondDateTime?
    public var dnsEntries: DnsEntrySet?
    public var gatewayLoadBalancerArns: ValueStringList?
    public var ipAddressType: IpAddressType?
    public var networkLoadBalancerArns: ValueStringList?
    public var serviceId: String?
    public var tags: TagList?
    public var vpcEndpointConnectionId: String?
    public var vpcEndpointId: String?
    public var vpcEndpointOwner: String?
    public var vpcEndpointState: State?

    public init(creationTimestamp: MillisecondDateTime? = nil,
                dnsEntries: DnsEntrySet? = nil,
                gatewayLoadBalancerArns: ValueStringList? = nil,
                ipAddressType: IpAddressType? = nil,
                networkLoadBalancerArns: ValueStringList? = nil,
                serviceId: String? = nil,
                tags: TagList? = nil,
                vpcEndpointConnectionId: String? = nil,
                vpcEndpointId: String? = nil,
                vpcEndpointOwner: String? = nil,
                vpcEndpointState: State? = nil) {
        self.creationTimestamp = creationTimestamp
        self.dnsEntries = dnsEntries
        self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
        self.ipAddressType = ipAddressType
        self.networkLoadBalancerArns = networkLoadBalancerArns
        self.serviceId = serviceId
        self.tags = tags
        self.vpcEndpointConnectionId = vpcEndpointConnectionId
        self.vpcEndpointId = vpcEndpointId
        self.vpcEndpointOwner = vpcEndpointOwner
        self.vpcEndpointState = vpcEndpointState
    }

    enum CodingKeys: String, CodingKey {
        case creationTimestamp
        case dnsEntries = "dnsEntrySet"
        case gatewayLoadBalancerArns = "gatewayLoadBalancerArnSet"
        case ipAddressType
        case networkLoadBalancerArns = "networkLoadBalancerArnSet"
        case serviceId
        case tags = "tagSet"
        case vpcEndpointConnectionId
        case vpcEndpointId
        case vpcEndpointOwner
        case vpcEndpointState
    }

    public func validate() throws {
    }
}

public struct VpcIpv6CidrBlockAssociation: Codable, Equatable {
    public var associationId: String?
    public var ipv6CidrBlock: String?
    public var ipv6CidrBlockState: VpcCidrBlockState?
    public var ipv6Pool: String?
    public var networkBorderGroup: String?

    public init(associationId: String? = nil,
                ipv6CidrBlock: String? = nil,
                ipv6CidrBlockState: VpcCidrBlockState? = nil,
                ipv6Pool: String? = nil,
                networkBorderGroup: String? = nil) {
        self.associationId = associationId
        self.ipv6CidrBlock = ipv6CidrBlock
        self.ipv6CidrBlockState = ipv6CidrBlockState
        self.ipv6Pool = ipv6Pool
        self.networkBorderGroup = networkBorderGroup
    }

    enum CodingKeys: String, CodingKey {
        case associationId
        case ipv6CidrBlock
        case ipv6CidrBlockState
        case ipv6Pool
        case networkBorderGroup
    }

    public func validate() throws {
        try ipv6CidrBlockState?.validate()
    }
}

public struct VpcPeeringConnection: Codable, Equatable {
    public var accepterVpcInfo: VpcPeeringConnectionVpcInfo?
    public var expirationTime: DateTime?
    public var requesterVpcInfo: VpcPeeringConnectionVpcInfo?
    public var status: VpcPeeringConnectionStateReason?
    public var tags: TagList?
    public var vpcPeeringConnectionId: String?

    public init(accepterVpcInfo: VpcPeeringConnectionVpcInfo? = nil,
                expirationTime: DateTime? = nil,
                requesterVpcInfo: VpcPeeringConnectionVpcInfo? = nil,
                status: VpcPeeringConnectionStateReason? = nil,
                tags: TagList? = nil,
                vpcPeeringConnectionId: String? = nil) {
        self.accepterVpcInfo = accepterVpcInfo
        self.expirationTime = expirationTime
        self.requesterVpcInfo = requesterVpcInfo
        self.status = status
        self.tags = tags
        self.vpcPeeringConnectionId = vpcPeeringConnectionId
    }

    enum CodingKeys: String, CodingKey {
        case accepterVpcInfo
        case expirationTime
        case requesterVpcInfo
        case status
        case tags = "tagSet"
        case vpcPeeringConnectionId
    }

    public func validate() throws {
        try accepterVpcInfo?.validate()
        try requesterVpcInfo?.validate()
        try status?.validate()
    }
}

public struct VpcPeeringConnectionOptionsDescription: Codable, Equatable {
    public var allowDnsResolutionFromRemoteVpc: Boolean?
    public var allowEgressFromLocalClassicLinkToRemoteVpc: Boolean?
    public var allowEgressFromLocalVpcToRemoteClassicLink: Boolean?

    public init(allowDnsResolutionFromRemoteVpc: Boolean? = nil,
                allowEgressFromLocalClassicLinkToRemoteVpc: Boolean? = nil,
                allowEgressFromLocalVpcToRemoteClassicLink: Boolean? = nil) {
        self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
        self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
    }

    enum CodingKeys: String, CodingKey {
        case allowDnsResolutionFromRemoteVpc
        case allowEgressFromLocalClassicLinkToRemoteVpc
        case allowEgressFromLocalVpcToRemoteClassicLink
    }

    public func validate() throws {
    }
}

public struct VpcPeeringConnectionStateReason: Codable, Equatable {
    public var code: VpcPeeringConnectionStateReasonCode?
    public var message: String?

    public init(code: VpcPeeringConnectionStateReasonCode? = nil,
                message: String? = nil) {
        self.code = code
        self.message = message
    }

    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func validate() throws {
    }
}

public struct VpcPeeringConnectionVpcInfo: Codable, Equatable {
    public var cidrBlock: String?
    public var cidrBlockSet: CidrBlockSet?
    public var ipv6CidrBlockSet: Ipv6CidrBlockSet?
    public var ownerId: String?
    public var peeringOptions: VpcPeeringConnectionOptionsDescription?
    public var region: String?
    public var vpcId: String?

    public init(cidrBlock: String? = nil,
                cidrBlockSet: CidrBlockSet? = nil,
                ipv6CidrBlockSet: Ipv6CidrBlockSet? = nil,
                ownerId: String? = nil,
                peeringOptions: VpcPeeringConnectionOptionsDescription? = nil,
                region: String? = nil,
                vpcId: String? = nil) {
        self.cidrBlock = cidrBlock
        self.cidrBlockSet = cidrBlockSet
        self.ipv6CidrBlockSet = ipv6CidrBlockSet
        self.ownerId = ownerId
        self.peeringOptions = peeringOptions
        self.region = region
        self.vpcId = vpcId
    }

    enum CodingKeys: String, CodingKey {
        case cidrBlock
        case cidrBlockSet
        case ipv6CidrBlockSet
        case ownerId
        case peeringOptions
        case region
        case vpcId
    }

    public func validate() throws {
        try peeringOptions?.validate()
    }
}

public struct VpnConnection: Codable, Equatable {
    public var category: String?
    public var coreNetworkArn: String?
    public var coreNetworkAttachmentArn: String?
    public var customerGatewayConfiguration: String?
    public var customerGatewayId: String?
    public var gatewayAssociationState: GatewayAssociationState?
    public var options: VpnConnectionOptions?
    public var routes: VpnStaticRouteList?
    public var state: VpnState?
    public var tags: TagList?
    public var transitGatewayId: String?
    public var type: GatewayType?
    public var vgwTelemetry: VgwTelemetryList?
    public var vpnConnectionId: String?
    public var vpnGatewayId: String?

    public init(category: String? = nil,
                coreNetworkArn: String? = nil,
                coreNetworkAttachmentArn: String? = nil,
                customerGatewayConfiguration: String? = nil,
                customerGatewayId: String? = nil,
                gatewayAssociationState: GatewayAssociationState? = nil,
                options: VpnConnectionOptions? = nil,
                routes: VpnStaticRouteList? = nil,
                state: VpnState? = nil,
                tags: TagList? = nil,
                transitGatewayId: String? = nil,
                type: GatewayType? = nil,
                vgwTelemetry: VgwTelemetryList? = nil,
                vpnConnectionId: String? = nil,
                vpnGatewayId: String? = nil) {
        self.category = category
        self.coreNetworkArn = coreNetworkArn
        self.coreNetworkAttachmentArn = coreNetworkAttachmentArn
        self.customerGatewayConfiguration = customerGatewayConfiguration
        self.customerGatewayId = customerGatewayId
        self.gatewayAssociationState = gatewayAssociationState
        self.options = options
        self.routes = routes
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
        self.type = type
        self.vgwTelemetry = vgwTelemetry
        self.vpnConnectionId = vpnConnectionId
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case category
        case coreNetworkArn
        case coreNetworkAttachmentArn
        case customerGatewayConfiguration
        case customerGatewayId
        case gatewayAssociationState
        case options
        case routes
        case state
        case tags = "tagSet"
        case transitGatewayId
        case type
        case vgwTelemetry
        case vpnConnectionId
        case vpnGatewayId
    }

    public func validate() throws {
        try options?.validate()
    }
}

public struct VpnConnectionDeviceType: Codable, Equatable {
    public var platform: String?
    public var software: String?
    public var vendor: String?
    public var vpnConnectionDeviceTypeId: String?

    public init(platform: String? = nil,
                software: String? = nil,
                vendor: String? = nil,
                vpnConnectionDeviceTypeId: String? = nil) {
        self.platform = platform
        self.software = software
        self.vendor = vendor
        self.vpnConnectionDeviceTypeId = vpnConnectionDeviceTypeId
    }

    enum CodingKeys: String, CodingKey {
        case platform
        case software
        case vendor
        case vpnConnectionDeviceTypeId
    }

    public func validate() throws {
    }
}

public struct VpnConnectionOptions: Codable, Equatable {
    public var enableAcceleration: Boolean?
    public var localIpv4NetworkCidr: String?
    public var localIpv6NetworkCidr: String?
    public var outsideIpAddressType: String?
    public var remoteIpv4NetworkCidr: String?
    public var remoteIpv6NetworkCidr: String?
    public var staticRoutesOnly: Boolean?
    public var transportTransitGatewayAttachmentId: String?
    public var tunnelInsideIpVersion: TunnelInsideIpVersion?
    public var tunnelOptions: TunnelOptionsList?

    public init(enableAcceleration: Boolean? = nil,
                localIpv4NetworkCidr: String? = nil,
                localIpv6NetworkCidr: String? = nil,
                outsideIpAddressType: String? = nil,
                remoteIpv4NetworkCidr: String? = nil,
                remoteIpv6NetworkCidr: String? = nil,
                staticRoutesOnly: Boolean? = nil,
                transportTransitGatewayAttachmentId: String? = nil,
                tunnelInsideIpVersion: TunnelInsideIpVersion? = nil,
                tunnelOptions: TunnelOptionsList? = nil) {
        self.enableAcceleration = enableAcceleration
        self.localIpv4NetworkCidr = localIpv4NetworkCidr
        self.localIpv6NetworkCidr = localIpv6NetworkCidr
        self.outsideIpAddressType = outsideIpAddressType
        self.remoteIpv4NetworkCidr = remoteIpv4NetworkCidr
        self.remoteIpv6NetworkCidr = remoteIpv6NetworkCidr
        self.staticRoutesOnly = staticRoutesOnly
        self.transportTransitGatewayAttachmentId = transportTransitGatewayAttachmentId
        self.tunnelInsideIpVersion = tunnelInsideIpVersion
        self.tunnelOptions = tunnelOptions
    }

    enum CodingKeys: String, CodingKey {
        case enableAcceleration
        case localIpv4NetworkCidr
        case localIpv6NetworkCidr
        case outsideIpAddressType
        case remoteIpv4NetworkCidr
        case remoteIpv6NetworkCidr
        case staticRoutesOnly
        case transportTransitGatewayAttachmentId
        case tunnelInsideIpVersion
        case tunnelOptions = "tunnelOptionSet"
    }

    public func validate() throws {
    }
}

public struct VpnConnectionOptionsSpecification: Codable, Equatable {
    public var enableAcceleration: Boolean?
    public var localIpv4NetworkCidr: String?
    public var localIpv6NetworkCidr: String?
    public var outsideIpAddressType: String?
    public var remoteIpv4NetworkCidr: String?
    public var remoteIpv6NetworkCidr: String?
    public var staticRoutesOnly: Boolean?
    public var transportTransitGatewayAttachmentId: TransitGatewayAttachmentId?
    public var tunnelInsideIpVersion: TunnelInsideIpVersion?
    public var tunnelOptions: VpnTunnelOptionsSpecificationsList?

    public init(enableAcceleration: Boolean? = nil,
                localIpv4NetworkCidr: String? = nil,
                localIpv6NetworkCidr: String? = nil,
                outsideIpAddressType: String? = nil,
                remoteIpv4NetworkCidr: String? = nil,
                remoteIpv6NetworkCidr: String? = nil,
                staticRoutesOnly: Boolean? = nil,
                transportTransitGatewayAttachmentId: TransitGatewayAttachmentId? = nil,
                tunnelInsideIpVersion: TunnelInsideIpVersion? = nil,
                tunnelOptions: VpnTunnelOptionsSpecificationsList? = nil) {
        self.enableAcceleration = enableAcceleration
        self.localIpv4NetworkCidr = localIpv4NetworkCidr
        self.localIpv6NetworkCidr = localIpv6NetworkCidr
        self.outsideIpAddressType = outsideIpAddressType
        self.remoteIpv4NetworkCidr = remoteIpv4NetworkCidr
        self.remoteIpv6NetworkCidr = remoteIpv6NetworkCidr
        self.staticRoutesOnly = staticRoutesOnly
        self.transportTransitGatewayAttachmentId = transportTransitGatewayAttachmentId
        self.tunnelInsideIpVersion = tunnelInsideIpVersion
        self.tunnelOptions = tunnelOptions
    }

    enum CodingKeys: String, CodingKey {
        case enableAcceleration = "EnableAcceleration"
        case localIpv4NetworkCidr = "LocalIpv4NetworkCidr"
        case localIpv6NetworkCidr = "LocalIpv6NetworkCidr"
        case outsideIpAddressType = "OutsideIpAddressType"
        case remoteIpv4NetworkCidr = "RemoteIpv4NetworkCidr"
        case remoteIpv6NetworkCidr = "RemoteIpv6NetworkCidr"
        case staticRoutesOnly
        case transportTransitGatewayAttachmentId = "TransportTransitGatewayAttachmentId"
        case tunnelInsideIpVersion = "TunnelInsideIpVersion"
        case tunnelOptions = "TunnelOptions"
    }

    public func validate() throws {
    }
}

public struct VpnGateway: Codable, Equatable {
    public var amazonSideAsn: Long?
    public var availabilityZone: String?
    public var state: VpnState?
    public var tags: TagList?
    public var type: GatewayType?
    public var vpcAttachments: VpcAttachmentList?
    public var vpnGatewayId: String?

    public init(amazonSideAsn: Long? = nil,
                availabilityZone: String? = nil,
                state: VpnState? = nil,
                tags: TagList? = nil,
                type: GatewayType? = nil,
                vpcAttachments: VpcAttachmentList? = nil,
                vpnGatewayId: String? = nil) {
        self.amazonSideAsn = amazonSideAsn
        self.availabilityZone = availabilityZone
        self.state = state
        self.tags = tags
        self.type = type
        self.vpcAttachments = vpcAttachments
        self.vpnGatewayId = vpnGatewayId
    }

    enum CodingKeys: String, CodingKey {
        case amazonSideAsn
        case availabilityZone
        case state
        case tags = "tagSet"
        case type
        case vpcAttachments = "attachments"
        case vpnGatewayId
    }

    public func validate() throws {
    }
}

public struct VpnStaticRoute: Codable, Equatable {
    public var destinationCidrBlock: String?
    public var source: VpnStaticRouteSource?
    public var state: VpnState?

    public init(destinationCidrBlock: String? = nil,
                source: VpnStaticRouteSource? = nil,
                state: VpnState? = nil) {
        self.destinationCidrBlock = destinationCidrBlock
        self.source = source
        self.state = state
    }

    enum CodingKeys: String, CodingKey {
        case destinationCidrBlock
        case source
        case state
    }

    public func validate() throws {
    }
}

public struct VpnTunnelLogOptions: Codable, Equatable {
    public var cloudWatchLogOptions: CloudWatchLogOptions?

    public init(cloudWatchLogOptions: CloudWatchLogOptions? = nil) {
        self.cloudWatchLogOptions = cloudWatchLogOptions
    }

    enum CodingKeys: String, CodingKey {
        case cloudWatchLogOptions
    }

    public func validate() throws {
        try cloudWatchLogOptions?.validate()
    }
}

public struct VpnTunnelLogOptionsSpecification: Codable, Equatable {
    public var cloudWatchLogOptions: CloudWatchLogOptionsSpecification?

    public init(cloudWatchLogOptions: CloudWatchLogOptionsSpecification? = nil) {
        self.cloudWatchLogOptions = cloudWatchLogOptions
    }

    enum CodingKeys: String, CodingKey {
        case cloudWatchLogOptions = "CloudWatchLogOptions"
    }

    public func validate() throws {
        try cloudWatchLogOptions?.validate()
    }
}

public struct VpnTunnelOptionsSpecification: Codable, Equatable {
    public var dPDTimeoutAction: String?
    public var dPDTimeoutSeconds: Integer?
    public var iKEVersions: IKEVersionsRequestList?
    public var logOptions: VpnTunnelLogOptionsSpecification?
    public var phase1DHGroupNumbers: Phase1DHGroupNumbersRequestList?
    public var phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsRequestList?
    public var phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsRequestList?
    public var phase1LifetimeSeconds: Integer?
    public var phase2DHGroupNumbers: Phase2DHGroupNumbersRequestList?
    public var phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsRequestList?
    public var phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsRequestList?
    public var phase2LifetimeSeconds: Integer?
    public var preSharedKey: String?
    public var rekeyFuzzPercentage: Integer?
    public var rekeyMarginTimeSeconds: Integer?
    public var replayWindowSize: Integer?
    public var startupAction: String?
    public var tunnelInsideCidr: String?
    public var tunnelInsideIpv6Cidr: String?

    public init(dPDTimeoutAction: String? = nil,
                dPDTimeoutSeconds: Integer? = nil,
                iKEVersions: IKEVersionsRequestList? = nil,
                logOptions: VpnTunnelLogOptionsSpecification? = nil,
                phase1DHGroupNumbers: Phase1DHGroupNumbersRequestList? = nil,
                phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsRequestList? = nil,
                phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsRequestList? = nil,
                phase1LifetimeSeconds: Integer? = nil,
                phase2DHGroupNumbers: Phase2DHGroupNumbersRequestList? = nil,
                phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsRequestList? = nil,
                phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsRequestList? = nil,
                phase2LifetimeSeconds: Integer? = nil,
                preSharedKey: String? = nil,
                rekeyFuzzPercentage: Integer? = nil,
                rekeyMarginTimeSeconds: Integer? = nil,
                replayWindowSize: Integer? = nil,
                startupAction: String? = nil,
                tunnelInsideCidr: String? = nil,
                tunnelInsideIpv6Cidr: String? = nil) {
        self.dPDTimeoutAction = dPDTimeoutAction
        self.dPDTimeoutSeconds = dPDTimeoutSeconds
        self.iKEVersions = iKEVersions
        self.logOptions = logOptions
        self.phase1DHGroupNumbers = phase1DHGroupNumbers
        self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
        self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
        self.phase1LifetimeSeconds = phase1LifetimeSeconds
        self.phase2DHGroupNumbers = phase2DHGroupNumbers
        self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
        self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
        self.phase2LifetimeSeconds = phase2LifetimeSeconds
        self.preSharedKey = preSharedKey
        self.rekeyFuzzPercentage = rekeyFuzzPercentage
        self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
        self.replayWindowSize = replayWindowSize
        self.startupAction = startupAction
        self.tunnelInsideCidr = tunnelInsideCidr
        self.tunnelInsideIpv6Cidr = tunnelInsideIpv6Cidr
    }

    enum CodingKeys: String, CodingKey {
        case dPDTimeoutAction = "DPDTimeoutAction"
        case dPDTimeoutSeconds = "DPDTimeoutSeconds"
        case iKEVersions = "IKEVersion"
        case logOptions = "LogOptions"
        case phase1DHGroupNumbers = "Phase1DHGroupNumber"
        case phase1EncryptionAlgorithms = "Phase1EncryptionAlgorithm"
        case phase1IntegrityAlgorithms = "Phase1IntegrityAlgorithm"
        case phase1LifetimeSeconds = "Phase1LifetimeSeconds"
        case phase2DHGroupNumbers = "Phase2DHGroupNumber"
        case phase2EncryptionAlgorithms = "Phase2EncryptionAlgorithm"
        case phase2IntegrityAlgorithms = "Phase2IntegrityAlgorithm"
        case phase2LifetimeSeconds = "Phase2LifetimeSeconds"
        case preSharedKey = "PreSharedKey"
        case rekeyFuzzPercentage = "RekeyFuzzPercentage"
        case rekeyMarginTimeSeconds = "RekeyMarginTimeSeconds"
        case replayWindowSize = "ReplayWindowSize"
        case startupAction = "StartupAction"
        case tunnelInsideCidr = "TunnelInsideCidr"
        case tunnelInsideIpv6Cidr = "TunnelInsideIpv6Cidr"
    }

    public func validate() throws {
        try logOptions?.validate()
    }
}

public struct WithdrawByoipCidrRequest: Codable, Equatable {
    public var cidr: String
    public var dryRun: Boolean?

    public init(cidr: String,
                dryRun: Boolean? = nil) {
        self.cidr = cidr
        self.dryRun = dryRun
    }

    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case dryRun = "DryRun"
    }

    public func validate() throws {
    }
}

public struct WithdrawByoipCidrResult: Codable, Equatable {
    public var byoipCidr: ByoipCidr?

    public init(byoipCidr: ByoipCidr? = nil) {
        self.byoipCidr = byoipCidr
    }

    enum CodingKeys: String, CodingKey {
        case byoipCidr
    }

    public func validate() throws {
        try byoipCidr?.validate()
    }
}
